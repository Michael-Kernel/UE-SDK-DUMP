#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Brickadia

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InteractiveToolsFramework_classes.hpp"
#include "SlateCore_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Brickadia_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "InputCore_structs.hpp"
#include "DLSSBlueprint_structs.hpp"
#include "ProceduralMeshComponent_classes.hpp"
#include "Slate_structs.hpp"


namespace SDK
{

// Class Brickadia.BRPlacerComponent
// 0x0000 (0x00A8 - 0x00A8)
class UBRPlacerComponent : public UActorComponent
{
public:
	class ABRTool_Placer* GetPlacer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerComponent">();
	}
	static class UBRPlacerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerComponent>();
	}
};
static_assert(alignof(UBRPlacerComponent) == 0x000008, "Wrong alignment on UBRPlacerComponent");
static_assert(sizeof(UBRPlacerComponent) == 0x0000A8, "Wrong size on UBRPlacerComponent");

// Class Brickadia.BRSelectablePlacerMode
// 0x0028 (0x00D0 - 0x00A8)
class UBRSelectablePlacerMode : public UBRPlacerComponent
{
public:
	class FText                                   DisplayName;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRSelectablePlacerMode">();
	}
	static class UBRSelectablePlacerMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRSelectablePlacerMode>();
	}
};
static_assert(alignof(UBRSelectablePlacerMode) == 0x000008, "Wrong alignment on UBRSelectablePlacerMode");
static_assert(sizeof(UBRSelectablePlacerMode) == 0x0000D0, "Wrong size on UBRSelectablePlacerMode");
static_assert(offsetof(UBRSelectablePlacerMode, DisplayName) == 0x0000A8, "Member 'UBRSelectablePlacerMode::DisplayName' has a wrong offset!");
static_assert(offsetof(UBRSelectablePlacerMode, Description) == 0x0000B8, "Member 'UBRSelectablePlacerMode::Description' has a wrong offset!");
static_assert(offsetof(UBRSelectablePlacerMode, Icon) == 0x0000C8, "Member 'UBRSelectablePlacerMode::Icon' has a wrong offset!");

// Class Brickadia.BRPlacerAlignmentModeBase
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerAlignmentModeBase : public UBRSelectablePlacerMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerAlignmentModeBase">();
	}
	static class UBRPlacerAlignmentModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerAlignmentModeBase>();
	}
};
static_assert(alignof(UBRPlacerAlignmentModeBase) == 0x000008, "Wrong alignment on UBRPlacerAlignmentModeBase");
static_assert(sizeof(UBRPlacerAlignmentModeBase) == 0x0000D0, "Wrong size on UBRPlacerAlignmentModeBase");

// Class Brickadia.BRPlacerAlignmentMode_Super
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerAlignmentMode_Super final : public UBRPlacerAlignmentModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerAlignmentMode_Super">();
	}
	static class UBRPlacerAlignmentMode_Super* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerAlignmentMode_Super>();
	}
};
static_assert(alignof(UBRPlacerAlignmentMode_Super) == 0x000008, "Wrong alignment on UBRPlacerAlignmentMode_Super");
static_assert(sizeof(UBRPlacerAlignmentMode_Super) == 0x0000D0, "Wrong size on UBRPlacerAlignmentMode_Super");

// Class Brickadia.BehaviorBase
// 0x0038 (0x0060 - 0x0028)
class UBehaviorBase : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBHTemplate*                            Template;                                          // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBHGeneratedData*                       GeneratedData;                                     // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BehaviorBase">();
	}
	static class UBehaviorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBehaviorBase>();
	}
};
static_assert(alignof(UBehaviorBase) == 0x000008, "Wrong alignment on UBehaviorBase");
static_assert(sizeof(UBehaviorBase) == 0x000060, "Wrong size on UBehaviorBase");
static_assert(offsetof(UBehaviorBase, Template) == 0x000040, "Member 'UBehaviorBase::Template' has a wrong offset!");
static_assert(offsetof(UBehaviorBase, GeneratedData) == 0x000048, "Member 'UBehaviorBase::GeneratedData' has a wrong offset!");

// Class Brickadia.BrickBehavior
// 0x0008 (0x0068 - 0x0060)
class UBrickBehavior final : public UBehaviorBase
{
public:
	class UBrickBehaviorType*                     BehaviorType;                                      // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickBehavior">();
	}
	static class UBrickBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickBehavior>();
	}
};
static_assert(alignof(UBrickBehavior) == 0x000008, "Wrong alignment on UBrickBehavior");
static_assert(sizeof(UBrickBehavior) == 0x000068, "Wrong size on UBrickBehavior");
static_assert(offsetof(UBrickBehavior, BehaviorType) == 0x000060, "Member 'UBrickBehavior::BehaviorType' has a wrong offset!");

// Class Brickadia.BRPlaceableActor
// 0x0010 (0x02C0 - 0x02B0)
class ABRPlaceableActor : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsPreviewActor;                                   // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAttachedPlacement(class AActor* NewParentActor, class UPrimitiveComponent* NewParentComponent);
	struct FBrickPlacementPivots OverridePlacementPivots(const struct FBrickPlacementPivots& AutoPivot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlaceableActor">();
	}
	static class ABRPlaceableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlaceableActor>();
	}
};
static_assert(alignof(ABRPlaceableActor) == 0x000008, "Wrong alignment on ABRPlaceableActor");
static_assert(sizeof(ABRPlaceableActor) == 0x0002C0, "Wrong size on ABRPlaceableActor");
static_assert(offsetof(ABRPlaceableActor, bIsPreviewActor) == 0x0002B8, "Member 'ABRPlaceableActor::bIsPreviewActor' has a wrong offset!");

// Class Brickadia.BRPlaceableJointActor
// 0x0030 (0x02F0 - 0x02C0)
class ABRPlaceableJointActor : public ABRPlaceableActor
{
public:
	class ABrickGridDynamicActor*                 TempGrid;                                          // 0x02C0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UPrimitiveComponent>     BodgeParentComponent;                              // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBoxComponent*                          CollisionComponent;                                // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   VisualizeMeshComponent;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsConstraintComponent*            PhysicsConstraintComponent;                        // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPhysicsConstraintComponent*            BodgeConstraintComponent;                          // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlaceableJointActor">();
	}
	static class ABRPlaceableJointActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlaceableJointActor>();
	}
};
static_assert(alignof(ABRPlaceableJointActor) == 0x000008, "Wrong alignment on ABRPlaceableJointActor");
static_assert(sizeof(ABRPlaceableJointActor) == 0x0002F0, "Wrong size on ABRPlaceableJointActor");
static_assert(offsetof(ABRPlaceableJointActor, TempGrid) == 0x0002C0, "Member 'ABRPlaceableJointActor::TempGrid' has a wrong offset!");
static_assert(offsetof(ABRPlaceableJointActor, BodgeParentComponent) == 0x0002C8, "Member 'ABRPlaceableJointActor::BodgeParentComponent' has a wrong offset!");
static_assert(offsetof(ABRPlaceableJointActor, CollisionComponent) == 0x0002D0, "Member 'ABRPlaceableJointActor::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ABRPlaceableJointActor, VisualizeMeshComponent) == 0x0002D8, "Member 'ABRPlaceableJointActor::VisualizeMeshComponent' has a wrong offset!");
static_assert(offsetof(ABRPlaceableJointActor, PhysicsConstraintComponent) == 0x0002E0, "Member 'ABRPlaceableJointActor::PhysicsConstraintComponent' has a wrong offset!");
static_assert(offsetof(ABRPlaceableJointActor, BodgeConstraintComponent) == 0x0002E8, "Member 'ABRPlaceableJointActor::BodgeConstraintComponent' has a wrong offset!");

// Class Brickadia.BRPlaceableBearing
// 0x0000 (0x02F0 - 0x02F0)
class ABRPlaceableBearing final : public ABRPlaceableJointActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlaceableBearing">();
	}
	static class ABRPlaceableBearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlaceableBearing>();
	}
};
static_assert(alignof(ABRPlaceableBearing) == 0x000008, "Wrong alignment on ABRPlaceableBearing");
static_assert(sizeof(ABRPlaceableBearing) == 0x0002F0, "Wrong size on ABRPlaceableBearing");

// Class Brickadia.BRWorldSubsystem
// 0x0008 (0x0038 - 0x0030)
class UBRWorldSubsystem : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldSubsystem">();
	}
	static class UBRWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldSubsystem>();
	}
};
static_assert(alignof(UBRWorldSubsystem) == 0x000008, "Wrong alignment on UBRWorldSubsystem");
static_assert(sizeof(UBRWorldSubsystem) == 0x000038, "Wrong size on UBRWorldSubsystem");

// Class Brickadia.TempBehaviorDebugLoader
// 0x0050 (0x0088 - 0x0038)
class UTempBehaviorDebugLoader final : public UBRWorldSubsystem
{
public:
	TMap<class FString, class UBrickBehavior*>    BehaviorsFromFiles;                                // 0x0038(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TempBehaviorDebugLoader">();
	}
	static class UTempBehaviorDebugLoader* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTempBehaviorDebugLoader>();
	}
};
static_assert(alignof(UTempBehaviorDebugLoader) == 0x000008, "Wrong alignment on UTempBehaviorDebugLoader");
static_assert(sizeof(UTempBehaviorDebugLoader) == 0x000088, "Wrong size on UTempBehaviorDebugLoader");
static_assert(offsetof(UTempBehaviorDebugLoader, BehaviorsFromFiles) == 0x000038, "Member 'UTempBehaviorDebugLoader::BehaviorsFromFiles' has a wrong offset!");

// Class Brickadia.BRPlacerMouseTargetingModeBase
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerMouseTargetingModeBase : public UBRSelectablePlacerMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerMouseTargetingModeBase">();
	}
	static class UBRPlacerMouseTargetingModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerMouseTargetingModeBase>();
	}
};
static_assert(alignof(UBRPlacerMouseTargetingModeBase) == 0x000008, "Wrong alignment on UBRPlacerMouseTargetingModeBase");
static_assert(sizeof(UBRPlacerMouseTargetingModeBase) == 0x0000D0, "Wrong size on UBRPlacerMouseTargetingModeBase");

// Class Brickadia.BHBoxedBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBHBoxedBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool BHBoxedValueIsValid(const struct FBHBoxed& Value);
	static struct FBHBoxed BHBoxValue(int32 Value);
	static void BHUnboxValue(const struct FBHBoxed& InValue, int32* OutValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBoxedBlueprintFunctionLibrary">();
	}
	static class UBHBoxedBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBoxedBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UBHBoxedBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UBHBoxedBlueprintFunctionLibrary");
static_assert(sizeof(UBHBoxedBlueprintFunctionLibrary) == 0x000028, "Wrong size on UBHBoxedBlueprintFunctionLibrary");

// Class Brickadia.BHBlockEditorNodeWidget
// 0x0028 (0x02F8 - 0x02D0)
class UBHBlockEditorNodeWidget : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UHorizontalBox*                         HeaderElementsContainer;                           // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBHBlockEditorNodeElementWidgetBase*> ElementWidgets;                                    // 0x02E0(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UPanelWidget*                           NextNodeSlot;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleNodeChainVisual(const struct FBHResolvedTypeInfo& Type, bool bHasLastType, const struct FBHResolvedTypeInfo& LastType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorNodeWidget">();
	}
	static class UBHBlockEditorNodeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorNodeWidget>();
	}
};
static_assert(alignof(UBHBlockEditorNodeWidget) == 0x000008, "Wrong alignment on UBHBlockEditorNodeWidget");
static_assert(sizeof(UBHBlockEditorNodeWidget) == 0x0002F8, "Wrong size on UBHBlockEditorNodeWidget");
static_assert(offsetof(UBHBlockEditorNodeWidget, HeaderElementsContainer) == 0x0002D8, "Member 'UBHBlockEditorNodeWidget::HeaderElementsContainer' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorNodeWidget, ElementWidgets) == 0x0002E0, "Member 'UBHBlockEditorNodeWidget::ElementWidgets' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorNodeWidget, NextNodeSlot) == 0x0002F0, "Member 'UBHBlockEditorNodeWidget::NextNodeSlot' has a wrong offset!");

// Class Brickadia.BRPlacerPlacementModeBase
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerPlacementModeBase : public UBRSelectablePlacerMode
{
public:
	bool IsSpacingAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerPlacementModeBase">();
	}
	static class UBRPlacerPlacementModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerPlacementModeBase>();
	}
};
static_assert(alignof(UBRPlacerPlacementModeBase) == 0x000008, "Wrong alignment on UBRPlacerPlacementModeBase");
static_assert(sizeof(UBRPlacerPlacementModeBase) == 0x0000D0, "Wrong size on UBRPlacerPlacementModeBase");

// Class Brickadia.BRPlacerPlacementMode_InstanceVolume
// 0x0008 (0x00D8 - 0x00D0)
class UBRPlacerPlacementMode_InstanceVolume : public UBRPlacerPlacementModeBase
{
public:
	uint8                                         Pad_D0[0x8];                                       // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerPlacementMode_InstanceVolume">();
	}
	static class UBRPlacerPlacementMode_InstanceVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerPlacementMode_InstanceVolume>();
	}
};
static_assert(alignof(UBRPlacerPlacementMode_InstanceVolume) == 0x000008, "Wrong alignment on UBRPlacerPlacementMode_InstanceVolume");
static_assert(sizeof(UBRPlacerPlacementMode_InstanceVolume) == 0x0000D8, "Wrong size on UBRPlacerPlacementMode_InstanceVolume");

// Class Brickadia.BRPlacerPlacementMode_ResizeWithInstanceVolumeFallback
// 0x0008 (0x00E0 - 0x00D8)
class UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback final : public UBRPlacerPlacementMode_InstanceVolume
{
public:
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UProceduralBrick* GetPlacementProcBrickAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerPlacementMode_ResizeWithInstanceVolumeFallback">();
	}
	static class UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback>();
	}
};
static_assert(alignof(UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback) == 0x000008, "Wrong alignment on UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback");
static_assert(sizeof(UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback) == 0x0000E0, "Wrong size on UBRPlacerPlacementMode_ResizeWithInstanceVolumeFallback");

// Class Brickadia.BHBlockEditorLiteralNodeWidget
// 0x0010 (0x0308 - 0x02F8)
class UBHBlockEditorLiteralNodeWidget : public UBHBlockEditorNodeWidget
{
public:
	class UPanelWidget*                           LiteralValueWidgetSlot;                            // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBHBlockEditorLiteralValueWidgetBase*   LiteralValueWidgetInstance;                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleColor(const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorLiteralNodeWidget">();
	}
	static class UBHBlockEditorLiteralNodeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorLiteralNodeWidget>();
	}
};
static_assert(alignof(UBHBlockEditorLiteralNodeWidget) == 0x000008, "Wrong alignment on UBHBlockEditorLiteralNodeWidget");
static_assert(sizeof(UBHBlockEditorLiteralNodeWidget) == 0x000308, "Wrong size on UBHBlockEditorLiteralNodeWidget");
static_assert(offsetof(UBHBlockEditorLiteralNodeWidget, LiteralValueWidgetSlot) == 0x0002F8, "Member 'UBHBlockEditorLiteralNodeWidget::LiteralValueWidgetSlot' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorLiteralNodeWidget, LiteralValueWidgetInstance) == 0x000300, "Member 'UBHBlockEditorLiteralNodeWidget::LiteralValueWidgetInstance' has a wrong offset!");

// Class Brickadia.BHBlockEditorLineDecorWidget
// 0x0000 (0x02D0 - 0x02D0)
class UBHBlockEditorLineDecorWidget : public UUserWidget
{
public:
	void HandleColor(const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorLineDecorWidget">();
	}
	static class UBHBlockEditorLineDecorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorLineDecorWidget>();
	}
};
static_assert(alignof(UBHBlockEditorLineDecorWidget) == 0x000008, "Wrong alignment on UBHBlockEditorLineDecorWidget");
static_assert(sizeof(UBHBlockEditorLineDecorWidget) == 0x0002D0, "Wrong size on UBHBlockEditorLineDecorWidget");

// Class Brickadia.BRPlacerControlModeBase
// 0x0060 (0x0108 - 0x00A8)
class UBRPlacerControlModeBase : public UBRPlacerComponent
{
public:
	TArray<struct FBRToolBindHint_WithTags>       ToolBindHints;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TSet<class FName>                             DefaultVisibleToolBindTags;                        // 0x00B8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerControlModeBase">();
	}
	static class UBRPlacerControlModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerControlModeBase>();
	}
};
static_assert(alignof(UBRPlacerControlModeBase) == 0x000008, "Wrong alignment on UBRPlacerControlModeBase");
static_assert(sizeof(UBRPlacerControlModeBase) == 0x000108, "Wrong size on UBRPlacerControlModeBase");
static_assert(offsetof(UBRPlacerControlModeBase, ToolBindHints) == 0x0000A8, "Member 'UBRPlacerControlModeBase::ToolBindHints' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlModeBase, DefaultVisibleToolBindTags) == 0x0000B8, "Member 'UBRPlacerControlModeBase::DefaultVisibleToolBindTags' has a wrong offset!");

// Class Brickadia.BRPlacerControlMode_Detached
// 0x0118 (0x0220 - 0x0108)
class UBRPlacerControlMode_Detached : public UBRPlacerControlModeBase
{
public:
	class FName                                   DeletePlacerControlModeName;                       // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0xD0];                                     // 0x0110(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRGizmo_PlacerRowDragLine*             PlacingRowDragGizmos[0x3];                         // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x18];                                     // 0x01F8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRGizmo_PlacerGrid*                    GridGizmo;                                         // 0x0210(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRGizmo_PlacerReorient*                ReorientGizmo;                                     // 0x0218(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerControlMode_Detached">();
	}
	static class UBRPlacerControlMode_Detached* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerControlMode_Detached>();
	}
};
static_assert(alignof(UBRPlacerControlMode_Detached) == 0x000008, "Wrong alignment on UBRPlacerControlMode_Detached");
static_assert(sizeof(UBRPlacerControlMode_Detached) == 0x000220, "Wrong size on UBRPlacerControlMode_Detached");
static_assert(offsetof(UBRPlacerControlMode_Detached, DeletePlacerControlModeName) == 0x000108, "Member 'UBRPlacerControlMode_Detached::DeletePlacerControlModeName' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Detached, PlacingRowDragGizmos) == 0x0001E0, "Member 'UBRPlacerControlMode_Detached::PlacingRowDragGizmos' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Detached, GridGizmo) == 0x000210, "Member 'UBRPlacerControlMode_Detached::GridGizmo' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Detached, ReorientGizmo) == 0x000218, "Member 'UBRPlacerControlMode_Detached::ReorientGizmo' has a wrong offset!");

// Class Brickadia.BRPlacerControlMode_Orbit
// 0x0040 (0x0260 - 0x0220)
class UBRPlacerControlMode_Orbit final : public UBRPlacerControlMode_Detached
{
public:
	TSubclassOf<class ABROrbitCamera>             OrbitCameraClass;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraBlendTime;                                   // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CameraBlendExp;                                    // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABROrbitCamera*                         OrbitCamera;                                       // 0x0238(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x20];                                     // 0x0240(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerControlMode_Orbit">();
	}
	static class UBRPlacerControlMode_Orbit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerControlMode_Orbit>();
	}
};
static_assert(alignof(UBRPlacerControlMode_Orbit) == 0x000008, "Wrong alignment on UBRPlacerControlMode_Orbit");
static_assert(sizeof(UBRPlacerControlMode_Orbit) == 0x000260, "Wrong size on UBRPlacerControlMode_Orbit");
static_assert(offsetof(UBRPlacerControlMode_Orbit, OrbitCameraClass) == 0x000220, "Member 'UBRPlacerControlMode_Orbit::OrbitCameraClass' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Orbit, CameraBlendTime) == 0x000228, "Member 'UBRPlacerControlMode_Orbit::CameraBlendTime' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Orbit, CameraBlendExp) == 0x00022C, "Member 'UBRPlacerControlMode_Orbit::CameraBlendExp' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Orbit, OrbitCamera) == 0x000238, "Member 'UBRPlacerControlMode_Orbit::OrbitCamera' has a wrong offset!");

// Class Brickadia.BHBlockEditorLineWidget
// 0x0030 (0x0300 - 0x02D0)
class UBHBlockEditorLineWidget final : public UUserWidget
{
public:
	class UTextBlock*                             LineNumberText;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         LineNodeElements;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         MarginElements;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           SelfTopMarginElementSlot;                          // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           SelfBottomMarginElementSlot;                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           FootElements;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleAltColor(bool bIsOdd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorLineWidget">();
	}
	static class UBHBlockEditorLineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorLineWidget>();
	}
};
static_assert(alignof(UBHBlockEditorLineWidget) == 0x000008, "Wrong alignment on UBHBlockEditorLineWidget");
static_assert(sizeof(UBHBlockEditorLineWidget) == 0x000300, "Wrong size on UBHBlockEditorLineWidget");
static_assert(offsetof(UBHBlockEditorLineWidget, LineNumberText) == 0x0002D0, "Member 'UBHBlockEditorLineWidget::LineNumberText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorLineWidget, LineNodeElements) == 0x0002D8, "Member 'UBHBlockEditorLineWidget::LineNodeElements' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorLineWidget, MarginElements) == 0x0002E0, "Member 'UBHBlockEditorLineWidget::MarginElements' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorLineWidget, SelfTopMarginElementSlot) == 0x0002E8, "Member 'UBHBlockEditorLineWidget::SelfTopMarginElementSlot' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorLineWidget, SelfBottomMarginElementSlot) == 0x0002F0, "Member 'UBHBlockEditorLineWidget::SelfBottomMarginElementSlot' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorLineWidget, FootElements) == 0x0002F8, "Member 'UBHBlockEditorLineWidget::FootElements' has a wrong offset!");

// Class Brickadia.BHBlockEditorPropertyEntryWidget
// 0x0030 (0x0300 - 0x02D0)
class UBHBlockEditorPropertyEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditableText*                          EditableArgNameText;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             NonEditableArgNameText;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           FunctionArgControls;                               // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleOpened();
	void HandleType(const struct FBHResolvedTypeInfo& Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorPropertyEntryWidget">();
	}
	static class UBHBlockEditorPropertyEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorPropertyEntryWidget>();
	}
};
static_assert(alignof(UBHBlockEditorPropertyEntryWidget) == 0x000008, "Wrong alignment on UBHBlockEditorPropertyEntryWidget");
static_assert(sizeof(UBHBlockEditorPropertyEntryWidget) == 0x000300, "Wrong size on UBHBlockEditorPropertyEntryWidget");
static_assert(offsetof(UBHBlockEditorPropertyEntryWidget, EditableArgNameText) == 0x0002E8, "Member 'UBHBlockEditorPropertyEntryWidget::EditableArgNameText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorPropertyEntryWidget, NonEditableArgNameText) == 0x0002F0, "Member 'UBHBlockEditorPropertyEntryWidget::NonEditableArgNameText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorPropertyEntryWidget, FunctionArgControls) == 0x0002F8, "Member 'UBHBlockEditorPropertyEntryWidget::FunctionArgControls' has a wrong offset!");

// Class Brickadia.BRPlacerControlMode_Delete
// 0x0030 (0x0138 - 0x0108)
class UBRPlacerControlMode_Delete final : public UBRPlacerControlModeBase
{
public:
	class USoundBase*                             BreakSound;                                        // 0x0108(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_110[0x8];                                      // 0x0110(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AntiSpamTime;                                      // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x18];                                     // 0x0120(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void MulticastHammerBrick(const struct FVector& Location);
	void MulticastHammerEntity(const struct FVector& Location);
	void ServerHammerBrick(const struct FBrickHandle& BrickHandle);
	void ServerHammerEntity(class AActor* ENTITY);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerControlMode_Delete">();
	}
	static class UBRPlacerControlMode_Delete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerControlMode_Delete>();
	}
};
static_assert(alignof(UBRPlacerControlMode_Delete) == 0x000008, "Wrong alignment on UBRPlacerControlMode_Delete");
static_assert(sizeof(UBRPlacerControlMode_Delete) == 0x000138, "Wrong size on UBRPlacerControlMode_Delete");
static_assert(offsetof(UBRPlacerControlMode_Delete, BreakSound) == 0x000108, "Member 'UBRPlacerControlMode_Delete::BreakSound' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Delete, Range) == 0x000118, "Member 'UBRPlacerControlMode_Delete::Range' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Delete, AntiSpamTime) == 0x00011C, "Member 'UBRPlacerControlMode_Delete::AntiSpamTime' has a wrong offset!");

// Class Brickadia.BHBlockEditorRoutinePropertyEntryWidget
// 0x0030 (0x0300 - 0x02D0)
class UBHBlockEditorRoutinePropertyEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UEditableText*                          EditableArgNameText;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             NonEditableArgNameText;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           FunctionArgControls;                               // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleOpened();
	void HandleType(const struct FBHResolvedTypeInfo& Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorRoutinePropertyEntryWidget">();
	}
	static class UBHBlockEditorRoutinePropertyEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorRoutinePropertyEntryWidget>();
	}
};
static_assert(alignof(UBHBlockEditorRoutinePropertyEntryWidget) == 0x000008, "Wrong alignment on UBHBlockEditorRoutinePropertyEntryWidget");
static_assert(sizeof(UBHBlockEditorRoutinePropertyEntryWidget) == 0x000300, "Wrong size on UBHBlockEditorRoutinePropertyEntryWidget");
static_assert(offsetof(UBHBlockEditorRoutinePropertyEntryWidget, EditableArgNameText) == 0x0002E8, "Member 'UBHBlockEditorRoutinePropertyEntryWidget::EditableArgNameText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutinePropertyEntryWidget, NonEditableArgNameText) == 0x0002F0, "Member 'UBHBlockEditorRoutinePropertyEntryWidget::NonEditableArgNameText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutinePropertyEntryWidget, FunctionArgControls) == 0x0002F8, "Member 'UBHBlockEditorRoutinePropertyEntryWidget::FunctionArgControls' has a wrong offset!");

// Class Brickadia.BHBlockEditorReturnValueWidget
// 0x0018 (0x02E8 - 0x02D0)
class UBHBlockEditorReturnValueWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOpened();
	void HandleType(const struct FBHResolvedTypeInfo& Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorReturnValueWidget">();
	}
	static class UBHBlockEditorReturnValueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorReturnValueWidget>();
	}
};
static_assert(alignof(UBHBlockEditorReturnValueWidget) == 0x000008, "Wrong alignment on UBHBlockEditorReturnValueWidget");
static_assert(sizeof(UBHBlockEditorReturnValueWidget) == 0x0002E8, "Wrong size on UBHBlockEditorReturnValueWidget");

// Class Brickadia.BHBlockEditorRoutineEntryWidget
// 0x0020 (0x02F0 - 0x02D0)
class UBHBlockEditorRoutineEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x18];                                     // 0x02D0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextBlock*                             NameText;                                          // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleOpened();
	void HandleType(const struct FBHResolvedTypeInfo& Type, bool bIsFunction);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorRoutineEntryWidget">();
	}
	static class UBHBlockEditorRoutineEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorRoutineEntryWidget>();
	}
};
static_assert(alignof(UBHBlockEditorRoutineEntryWidget) == 0x000008, "Wrong alignment on UBHBlockEditorRoutineEntryWidget");
static_assert(sizeof(UBHBlockEditorRoutineEntryWidget) == 0x0002F0, "Wrong size on UBHBlockEditorRoutineEntryWidget");
static_assert(offsetof(UBHBlockEditorRoutineEntryWidget, NameText) == 0x0002E8, "Member 'UBHBlockEditorRoutineEntryWidget::NameText' has a wrong offset!");

// Class Brickadia.BHBlockEditorRoutineHeaderWidget
// 0x0040 (0x0310 - 0x02D0)
class UBHBlockEditorRoutineHeaderWidget final : public UUserWidget
{
public:
	class UEditableText*                          EditableRoutineNameText;                           // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             NonEditableRoutineNameText;                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         RoutineArgumentsBox;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           FunctionArgControls;                               // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           ReturnValueControls;                               // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNamedSlot*                             RoutineReturnTypeBox;                              // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorRoutinePropertyEntryWidget> ArgWidgetClass;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorReturnValueWidget> ReturnValueWidgetClass;                            // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorRoutineHeaderWidget">();
	}
	static class UBHBlockEditorRoutineHeaderWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorRoutineHeaderWidget>();
	}
};
static_assert(alignof(UBHBlockEditorRoutineHeaderWidget) == 0x000008, "Wrong alignment on UBHBlockEditorRoutineHeaderWidget");
static_assert(sizeof(UBHBlockEditorRoutineHeaderWidget) == 0x000310, "Wrong size on UBHBlockEditorRoutineHeaderWidget");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, EditableRoutineNameText) == 0x0002D0, "Member 'UBHBlockEditorRoutineHeaderWidget::EditableRoutineNameText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, NonEditableRoutineNameText) == 0x0002D8, "Member 'UBHBlockEditorRoutineHeaderWidget::NonEditableRoutineNameText' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, RoutineArgumentsBox) == 0x0002E0, "Member 'UBHBlockEditorRoutineHeaderWidget::RoutineArgumentsBox' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, FunctionArgControls) == 0x0002E8, "Member 'UBHBlockEditorRoutineHeaderWidget::FunctionArgControls' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, ReturnValueControls) == 0x0002F0, "Member 'UBHBlockEditorRoutineHeaderWidget::ReturnValueControls' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, RoutineReturnTypeBox) == 0x0002F8, "Member 'UBHBlockEditorRoutineHeaderWidget::RoutineReturnTypeBox' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, ArgWidgetClass) == 0x000300, "Member 'UBHBlockEditorRoutineHeaderWidget::ArgWidgetClass' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineHeaderWidget, ReturnValueWidgetClass) == 0x000308, "Member 'UBHBlockEditorRoutineHeaderWidget::ReturnValueWidgetClass' has a wrong offset!");

// Class Brickadia.BRInputIconFallbackPartWidget
// 0x0028 (0x02F8 - 0x02D0)
class UBRInputIconFallbackPartWidget final : public UUserWidget
{
public:
	class UBRInputKeyDisplayNames*                DisplayNames;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             KeyText;                                           // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetKey(const struct FKey& InKey);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputIconFallbackPartWidget">();
	}
	static class UBRInputIconFallbackPartWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputIconFallbackPartWidget>();
	}
};
static_assert(alignof(UBRInputIconFallbackPartWidget) == 0x000008, "Wrong alignment on UBRInputIconFallbackPartWidget");
static_assert(sizeof(UBRInputIconFallbackPartWidget) == 0x0002F8, "Wrong size on UBRInputIconFallbackPartWidget");
static_assert(offsetof(UBRInputIconFallbackPartWidget, DisplayNames) == 0x0002D0, "Member 'UBRInputIconFallbackPartWidget::DisplayNames' has a wrong offset!");
static_assert(offsetof(UBRInputIconFallbackPartWidget, Key) == 0x0002D8, "Member 'UBRInputIconFallbackPartWidget::Key' has a wrong offset!");
static_assert(offsetof(UBRInputIconFallbackPartWidget, KeyText) == 0x0002F0, "Member 'UBRInputIconFallbackPartWidget::KeyText' has a wrong offset!");

// Class Brickadia.BHBlockEditorRoutineWidget
// 0x0028 (0x02F8 - 0x02D0)
class UBHBlockEditorRoutineWidget final : public UUserWidget
{
public:
	class UVerticalBox*                           LinesBox;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBHBlockEditorLineWidget*>       Lines;                                             // 0x02D8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorRoutineHeaderWidget> HeaderWidgetClass;                                 // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorLineWidget>   LineWidgetClass;                                   // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorRoutineWidget">();
	}
	static class UBHBlockEditorRoutineWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorRoutineWidget>();
	}
};
static_assert(alignof(UBHBlockEditorRoutineWidget) == 0x000008, "Wrong alignment on UBHBlockEditorRoutineWidget");
static_assert(sizeof(UBHBlockEditorRoutineWidget) == 0x0002F8, "Wrong size on UBHBlockEditorRoutineWidget");
static_assert(offsetof(UBHBlockEditorRoutineWidget, LinesBox) == 0x0002D0, "Member 'UBHBlockEditorRoutineWidget::LinesBox' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineWidget, Lines) == 0x0002D8, "Member 'UBHBlockEditorRoutineWidget::Lines' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineWidget, HeaderWidgetClass) == 0x0002E8, "Member 'UBHBlockEditorRoutineWidget::HeaderWidgetClass' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorRoutineWidget, LineWidgetClass) == 0x0002F0, "Member 'UBHBlockEditorRoutineWidget::LineWidgetClass' has a wrong offset!");

// Class Brickadia.BRDialogBase
// 0x0010 (0x02E0 - 0x02D0)
class UBRDialogBase : public UUserWidget
{
public:
	class UBRDialogContainerBase*                 DialogContainer;                                   // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContainedInDialogRoot;                            // 0x02D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBackgroundBlur;                             // 0x02D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceHideHUD;                                     // 0x02DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DB[0x5];                                      // 0x02DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishHideDialog();
	void FinishOpenDialog();
	void HideDialog();
	void OnBackgroundMouseButtonDoubleClick(const struct FPointerEvent& MouseEvent);
	void OnBackgroundMouseButtonDown(const struct FPointerEvent& MouseEvent);
	void OnBackgroundMouseButtonUp(const struct FPointerEvent& MouseEvent);
	void OnEscapeDialog();
	void OnHideDialog();
	void OnHideDialogFinished();
	void OnOpenDialog();
	void OnOpenDialogFinished();
	void OpenDialog();
	void OpenDialog_IfNoOther();
	void OpenOrHideDialog();
	void OpenOrHideDialog_IfNoOther();

	bool BackgroundAllowsToolFreeMouse() const;
	EBRDialogState GetDialogState() const;
	class ABRHUD* GetHUD() const;
	bool IsHidden() const;
	bool IsHiddenOrHiding() const;
	bool IsOpen() const;
	bool IsOpenOrOpening() const;
	bool IsTopmost() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDialogBase">();
	}
	static class UBRDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDialogBase>();
	}
};
static_assert(alignof(UBRDialogBase) == 0x000008, "Wrong alignment on UBRDialogBase");
static_assert(sizeof(UBRDialogBase) == 0x0002E0, "Wrong size on UBRDialogBase");
static_assert(offsetof(UBRDialogBase, DialogContainer) == 0x0002D0, "Member 'UBRDialogBase::DialogContainer' has a wrong offset!");
static_assert(offsetof(UBRDialogBase, bContainedInDialogRoot) == 0x0002D8, "Member 'UBRDialogBase::bContainedInDialogRoot' has a wrong offset!");
static_assert(offsetof(UBRDialogBase, bEnableBackgroundBlur) == 0x0002D9, "Member 'UBRDialogBase::bEnableBackgroundBlur' has a wrong offset!");
static_assert(offsetof(UBRDialogBase, bForceHideHUD) == 0x0002DA, "Member 'UBRDialogBase::bForceHideHUD' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator
// 0x0028 (0x0050 - 0x0028)
class UBrickTypeGenerator : public UObject
{
public:
	struct FIntVector                             GeneratedSizeMin;                                  // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GeneratedSizeMax;                                  // 0x0034(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             GeneratedSizeStep;                                 // 0x0040(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickGeneratorAxisLockMode                   LockMode;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator">();
	}
	static class UBrickTypeGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator>();
	}
};
static_assert(alignof(UBrickTypeGenerator) == 0x000008, "Wrong alignment on UBrickTypeGenerator");
static_assert(sizeof(UBrickTypeGenerator) == 0x000050, "Wrong size on UBrickTypeGenerator");
static_assert(offsetof(UBrickTypeGenerator, GeneratedSizeMin) == 0x000028, "Member 'UBrickTypeGenerator::GeneratedSizeMin' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator, GeneratedSizeMax) == 0x000034, "Member 'UBrickTypeGenerator::GeneratedSizeMax' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator, GeneratedSizeStep) == 0x000040, "Member 'UBrickTypeGenerator::GeneratedSizeStep' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator, LockMode) == 0x00004C, "Member 'UBrickTypeGenerator::LockMode' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultWedge
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultWedge final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultWedge">();
	}
	static class UBrickTypeGenerator_DefaultWedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultWedge>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultWedge) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultWedge");
static_assert(sizeof(UBrickTypeGenerator_DefaultWedge) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultWedge");

// Class Brickadia.BHBlockEditorWidget
// 0x0050 (0x0330 - 0x02E0)
class UBHBlockEditorWidget final : public UBRDialogBase
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           RoutineDisplayArea;                                // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorRoutineWidget> RoutineWidgetClass;                                // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           EventHandlerEntriesBox;                            // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           FunctionEntriesBox;                                // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           PropertyEntriesBox;                                // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorRoutineEntryWidget> RoutineEntryWidgetClass;                           // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorPropertyEntryWidget> PropertyEntryWidgetClass;                          // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x8];                                      // 0x0328(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleBehaviorNameText(const class FText& Text);
	void Setup(class UBehaviorBase* Behavior);
	void TEMP_Test();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorWidget">();
	}
	static class UBHBlockEditorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorWidget>();
	}
};
static_assert(alignof(UBHBlockEditorWidget) == 0x000008, "Wrong alignment on UBHBlockEditorWidget");
static_assert(sizeof(UBHBlockEditorWidget) == 0x000330, "Wrong size on UBHBlockEditorWidget");
static_assert(offsetof(UBHBlockEditorWidget, RoutineDisplayArea) == 0x0002F0, "Member 'UBHBlockEditorWidget::RoutineDisplayArea' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorWidget, RoutineWidgetClass) == 0x0002F8, "Member 'UBHBlockEditorWidget::RoutineWidgetClass' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorWidget, EventHandlerEntriesBox) == 0x000300, "Member 'UBHBlockEditorWidget::EventHandlerEntriesBox' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorWidget, FunctionEntriesBox) == 0x000308, "Member 'UBHBlockEditorWidget::FunctionEntriesBox' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorWidget, PropertyEntriesBox) == 0x000310, "Member 'UBHBlockEditorWidget::PropertyEntriesBox' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorWidget, RoutineEntryWidgetClass) == 0x000318, "Member 'UBHBlockEditorWidget::RoutineEntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBHBlockEditorWidget, PropertyEntryWidgetClass) == 0x000320, "Member 'UBHBlockEditorWidget::PropertyEntryWidgetClass' has a wrong offset!");

// Class Brickadia.BHBlockEditorLiteralValueWidgetBase
// 0x0000 (0x02D0 - 0x02D0)
class UBHBlockEditorLiteralValueWidgetBase : public UUserWidget
{
public:
	void HandleChanged(const struct FBHBoxed& Value);
	void Setup(const struct FBHBoxed& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorLiteralValueWidgetBase">();
	}
	static class UBHBlockEditorLiteralValueWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorLiteralValueWidgetBase>();
	}
};
static_assert(alignof(UBHBlockEditorLiteralValueWidgetBase) == 0x000008, "Wrong alignment on UBHBlockEditorLiteralValueWidgetBase");
static_assert(sizeof(UBHBlockEditorLiteralValueWidgetBase) == 0x0002D0, "Wrong size on UBHBlockEditorLiteralValueWidgetBase");

// Class Brickadia.BRPlacerMouseTargetingMode_Regular
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerMouseTargetingMode_Regular final : public UBRPlacerMouseTargetingModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerMouseTargetingMode_Regular">();
	}
	static class UBRPlacerMouseTargetingMode_Regular* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerMouseTargetingMode_Regular>();
	}
};
static_assert(alignof(UBRPlacerMouseTargetingMode_Regular) == 0x000008, "Wrong alignment on UBRPlacerMouseTargetingMode_Regular");
static_assert(sizeof(UBRPlacerMouseTargetingMode_Regular) == 0x0000D0, "Wrong size on UBRPlacerMouseTargetingMode_Regular");

// Class Brickadia.BHBlockEditorNodeElementWidgetBase
// 0x0000 (0x02D0 - 0x02D0)
class UBHBlockEditorNodeElementWidgetBase : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorNodeElementWidgetBase">();
	}
	static class UBHBlockEditorNodeElementWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorNodeElementWidgetBase>();
	}
};
static_assert(alignof(UBHBlockEditorNodeElementWidgetBase) == 0x000008, "Wrong alignment on UBHBlockEditorNodeElementWidgetBase");
static_assert(sizeof(UBHBlockEditorNodeElementWidgetBase) == 0x0002D0, "Wrong size on UBHBlockEditorNodeElementWidgetBase");

// Class Brickadia.BHBlockEditorNodeElementWidget_Text
// 0x0008 (0x02D8 - 0x02D0)
class UBHBlockEditorNodeElementWidget_Text : public UBHBlockEditorNodeElementWidgetBase
{
public:
	class UTextBlock*                             Text;                                              // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorNodeElementWidget_Text">();
	}
	static class UBHBlockEditorNodeElementWidget_Text* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorNodeElementWidget_Text>();
	}
};
static_assert(alignof(UBHBlockEditorNodeElementWidget_Text) == 0x000008, "Wrong alignment on UBHBlockEditorNodeElementWidget_Text");
static_assert(sizeof(UBHBlockEditorNodeElementWidget_Text) == 0x0002D8, "Wrong size on UBHBlockEditorNodeElementWidget_Text");
static_assert(offsetof(UBHBlockEditorNodeElementWidget_Text, Text) == 0x0002D0, "Member 'UBHBlockEditorNodeElementWidget_Text::Text' has a wrong offset!");

// Class Brickadia.BRInputIconSet
// 0x0050 (0x0080 - 0x0030)
class UBRInputIconSet final : public UDataAsset
{
public:
	TMap<struct FKey, class UTexture2D*>          Icons;                                             // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputIconSet">();
	}
	static class UBRInputIconSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputIconSet>();
	}
};
static_assert(alignof(UBRInputIconSet) == 0x000008, "Wrong alignment on UBRInputIconSet");
static_assert(sizeof(UBRInputIconSet) == 0x000080, "Wrong size on UBRInputIconSet");
static_assert(offsetof(UBRInputIconSet, Icons) == 0x000030, "Member 'UBRInputIconSet::Icons' has a wrong offset!");

// Class Brickadia.BHBlockEditorNodeElementWidget_ArgSlot
// 0x0008 (0x02D8 - 0x02D0)
class UBHBlockEditorNodeElementWidget_ArgSlot : public UBHBlockEditorNodeElementWidgetBase
{
public:
	class UPanelWidget*                           NodeSlot;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleTypeColor(const struct FLinearColor& Color);
	void HideSlotUnderNode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorNodeElementWidget_ArgSlot">();
	}
	static class UBHBlockEditorNodeElementWidget_ArgSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorNodeElementWidget_ArgSlot>();
	}
};
static_assert(alignof(UBHBlockEditorNodeElementWidget_ArgSlot) == 0x000008, "Wrong alignment on UBHBlockEditorNodeElementWidget_ArgSlot");
static_assert(sizeof(UBHBlockEditorNodeElementWidget_ArgSlot) == 0x0002D8, "Wrong size on UBHBlockEditorNodeElementWidget_ArgSlot");
static_assert(offsetof(UBHBlockEditorNodeElementWidget_ArgSlot, NodeSlot) == 0x0002D0, "Member 'UBHBlockEditorNodeElementWidget_ArgSlot::NodeSlot' has a wrong offset!");

// Class Brickadia.BHBlockEditorNodeElementWidget_DestVarSlot
// 0x0008 (0x02D8 - 0x02D0)
class UBHBlockEditorNodeElementWidget_DestVarSlot : public UBHBlockEditorNodeElementWidgetBase
{
public:
	class UEditableText*                          VarNameText;                                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleTypeColor(const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorNodeElementWidget_DestVarSlot">();
	}
	static class UBHBlockEditorNodeElementWidget_DestVarSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorNodeElementWidget_DestVarSlot>();
	}
};
static_assert(alignof(UBHBlockEditorNodeElementWidget_DestVarSlot) == 0x000008, "Wrong alignment on UBHBlockEditorNodeElementWidget_DestVarSlot");
static_assert(sizeof(UBHBlockEditorNodeElementWidget_DestVarSlot) == 0x0002D8, "Wrong size on UBHBlockEditorNodeElementWidget_DestVarSlot");
static_assert(offsetof(UBHBlockEditorNodeElementWidget_DestVarSlot, VarNameText) == 0x0002D0, "Member 'UBHBlockEditorNodeElementWidget_DestVarSlot::VarNameText' has a wrong offset!");

// Class Brickadia.BHSettings
// 0x01B0 (0x01E8 - 0x0038)
class UBHSettings final : public UDeveloperSettings
{
public:
	TArray<TSubclassOf<class UBHBlockEditorNodeElementWidgetBase>> ElementWidgetClasses;                              // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorNodeWidget>   DefaultNodeWidgetClass;                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSubclassOf<class UBHBlockEditorNodeWidget>> CustomNodeWidgetClasses;                           // 0x0050(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorLineDecorWidget> LineMarginClass;                                   // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorLineDecorWidget> LineFootClass;                                     // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorLineDecorWidget> EmptyScopeLineFootClass;                           // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBHBlockEditorLineDecorWidget> EmptyScopeLineMarginClass;                         // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FBHConfigTypeInfo>   TypeDisplayInfo;                                   // 0x00C0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FBHConfigTypeInfoInner                 NullTypeInfo;                                      // 0x0110(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FBHConfigTypeInfoInner                 ControlFlowNullTypeInfo;                           // 0x0150(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	struct FBHConfigTypeInfoInner                 UnknownTypeInfo;                                   // 0x0190(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Config, NativeAccessSpecifierPublic)
	class UTexture2D*                             ArrayIcon;                                         // 0x01D0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             SetIcon;                                           // 0x01D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MapIcon;                                           // 0x01E0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHSettings">();
	}
	static class UBHSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHSettings>();
	}
};
static_assert(alignof(UBHSettings) == 0x000008, "Wrong alignment on UBHSettings");
static_assert(sizeof(UBHSettings) == 0x0001E8, "Wrong size on UBHSettings");
static_assert(offsetof(UBHSettings, ElementWidgetClasses) == 0x000038, "Member 'UBHSettings::ElementWidgetClasses' has a wrong offset!");
static_assert(offsetof(UBHSettings, DefaultNodeWidgetClass) == 0x000048, "Member 'UBHSettings::DefaultNodeWidgetClass' has a wrong offset!");
static_assert(offsetof(UBHSettings, CustomNodeWidgetClasses) == 0x000050, "Member 'UBHSettings::CustomNodeWidgetClasses' has a wrong offset!");
static_assert(offsetof(UBHSettings, LineMarginClass) == 0x0000A0, "Member 'UBHSettings::LineMarginClass' has a wrong offset!");
static_assert(offsetof(UBHSettings, LineFootClass) == 0x0000A8, "Member 'UBHSettings::LineFootClass' has a wrong offset!");
static_assert(offsetof(UBHSettings, EmptyScopeLineFootClass) == 0x0000B0, "Member 'UBHSettings::EmptyScopeLineFootClass' has a wrong offset!");
static_assert(offsetof(UBHSettings, EmptyScopeLineMarginClass) == 0x0000B8, "Member 'UBHSettings::EmptyScopeLineMarginClass' has a wrong offset!");
static_assert(offsetof(UBHSettings, TypeDisplayInfo) == 0x0000C0, "Member 'UBHSettings::TypeDisplayInfo' has a wrong offset!");
static_assert(offsetof(UBHSettings, NullTypeInfo) == 0x000110, "Member 'UBHSettings::NullTypeInfo' has a wrong offset!");
static_assert(offsetof(UBHSettings, ControlFlowNullTypeInfo) == 0x000150, "Member 'UBHSettings::ControlFlowNullTypeInfo' has a wrong offset!");
static_assert(offsetof(UBHSettings, UnknownTypeInfo) == 0x000190, "Member 'UBHSettings::UnknownTypeInfo' has a wrong offset!");
static_assert(offsetof(UBHSettings, ArrayIcon) == 0x0001D0, "Member 'UBHSettings::ArrayIcon' has a wrong offset!");
static_assert(offsetof(UBHSettings, SetIcon) == 0x0001D8, "Member 'UBHSettings::SetIcon' has a wrong offset!");
static_assert(offsetof(UBHSettings, MapIcon) == 0x0001E0, "Member 'UBHSettings::MapIcon' has a wrong offset!");

// Class Brickadia.BrickComponentTypeBase
// 0x01B0 (0x01D8 - 0x0028)
class UBrickComponentTypeBase : public UObject
{
public:
	class UScriptStruct*                          DataStruct;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInspectorPropertyDescriptorList> InspectorList;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPresetDescriptor*                    PresetDescriptor;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPlayerSpawnable;                                  // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentVersion;                                    // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, struct FBrickComponentWireInputDescriptor> WireInputPorts;                                    // 0x0090(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	TMap<class FName, struct FBrickComponentWirePortDescriptor> WireOutputPorts;                                   // 0x00E0(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, NativeAccessSpecifierPublic)
	bool                                          bUseInteractPressAnimation;                        // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserQuota;                                         // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInspectorPropertyDescriptorList*       InspectorListInstance;                             // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_140[0x88];                                     // 0x0140(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUpdated;                                         // 0x01C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentTypeBase">();
	}
	static class UBrickComponentTypeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentTypeBase>();
	}
};
static_assert(alignof(UBrickComponentTypeBase) == 0x000008, "Wrong alignment on UBrickComponentTypeBase");
static_assert(sizeof(UBrickComponentTypeBase) == 0x0001D8, "Wrong size on UBrickComponentTypeBase");
static_assert(offsetof(UBrickComponentTypeBase, DataStruct) == 0x000028, "Member 'UBrickComponentTypeBase::DataStruct' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, InspectorList) == 0x000038, "Member 'UBrickComponentTypeBase::InspectorList' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, PresetDescriptor) == 0x000040, "Member 'UBrickComponentTypeBase::PresetDescriptor' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, Category) == 0x000048, "Member 'UBrickComponentTypeBase::Category' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, DisplayName) == 0x000058, "Member 'UBrickComponentTypeBase::DisplayName' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, Description) == 0x000068, "Member 'UBrickComponentTypeBase::Description' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, bPlayerSpawnable) == 0x000078, "Member 'UBrickComponentTypeBase::bPlayerSpawnable' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, Icon) == 0x000080, "Member 'UBrickComponentTypeBase::Icon' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, CurrentVersion) == 0x000088, "Member 'UBrickComponentTypeBase::CurrentVersion' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, WireInputPorts) == 0x000090, "Member 'UBrickComponentTypeBase::WireInputPorts' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, WireOutputPorts) == 0x0000E0, "Member 'UBrickComponentTypeBase::WireOutputPorts' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, bUseInteractPressAnimation) == 0x000130, "Member 'UBrickComponentTypeBase::bUseInteractPressAnimation' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, UserQuota) == 0x000134, "Member 'UBrickComponentTypeBase::UserQuota' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, InspectorListInstance) == 0x000138, "Member 'UBrickComponentTypeBase::InspectorListInstance' has a wrong offset!");
static_assert(offsetof(UBrickComponentTypeBase, OnUpdated) == 0x0001C8, "Member 'UBrickComponentTypeBase::OnUpdated' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateBase
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateBase : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateBase">();
	}
	static class UBrickComponentType_GateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateBase>();
	}
};
static_assert(alignof(UBrickComponentType_GateBase) == 0x000008, "Wrong alignment on UBrickComponentType_GateBase");
static_assert(sizeof(UBrickComponentType_GateBase) == 0x0001D8, "Wrong size on UBrickComponentType_GateBase");

// Class Brickadia.BrickComponentType_GateNotInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNotInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNotInt">();
	}
	static class UBrickComponentType_GateNotInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNotInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateNotInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateNotInt");
static_assert(sizeof(UBrickComponentType_GateNotInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateNotInt");

// Class Brickadia.BHGeneratedStruct
// 0x0148 (0x0208 - 0x00C0)
class UBHGeneratedStruct final : public UScriptStruct
{
public:
	uint8                                         Pad_C0[0xC8];                                      // 0x00C0(0x00C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UInspectorPropertyDescriptorList*       DescriptorList;                                    // 0x0188(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_190[0x78];                                     // 0x0190(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHGeneratedStruct">();
	}
	static class UBHGeneratedStruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHGeneratedStruct>();
	}
};
static_assert(alignof(UBHGeneratedStruct) == 0x000008, "Wrong alignment on UBHGeneratedStruct");
static_assert(sizeof(UBHGeneratedStruct) == 0x000208, "Wrong size on UBHGeneratedStruct");
static_assert(offsetof(UBHGeneratedStruct, DescriptorList) == 0x000188, "Member 'UBHGeneratedStruct::DescriptorList' has a wrong offset!");

// Class Brickadia.BHStructTemplateNoProps
// 0x0028 (0x0050 - 0x0028)
class UBHStructTemplateNoProps : public UObject
{
public:
	uint8                                         Pad_28[0x28];                                      // 0x0028(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHStructTemplateNoProps">();
	}
	static class UBHStructTemplateNoProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHStructTemplateNoProps>();
	}
};
static_assert(alignof(UBHStructTemplateNoProps) == 0x000008, "Wrong alignment on UBHStructTemplateNoProps");
static_assert(sizeof(UBHStructTemplateNoProps) == 0x000050, "Wrong size on UBHStructTemplateNoProps");

// Class Brickadia.BRGizmoBase
// 0x0118 (0x0150 - 0x0038)
class UBRGizmoBase : public UInteractiveGizmo
{
public:
	uint8                                         Pad_38[0x108];                                     // 0x0038(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	class UGizmoElementGroup*                     GizmoElementRoot;                                  // 0x0140(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBRGizmoElementHitMultiTarget*          HitTarget;                                         // 0x0148(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoBase">();
	}
	static class UBRGizmoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmoBase>();
	}
};
static_assert(alignof(UBRGizmoBase) == 0x000008, "Wrong alignment on UBRGizmoBase");
static_assert(sizeof(UBRGizmoBase) == 0x000150, "Wrong size on UBRGizmoBase");
static_assert(offsetof(UBRGizmoBase, GizmoElementRoot) == 0x000140, "Member 'UBRGizmoBase::GizmoElementRoot' has a wrong offset!");
static_assert(offsetof(UBRGizmoBase, HitTarget) == 0x000148, "Member 'UBRGizmoBase::HitTarget' has a wrong offset!");

// Class Brickadia.BRTargetingGizmoBase
// 0x0070 (0x01C0 - 0x0150)
class alignas(0x10) UBRTargetingGizmoBase : public UBRGizmoBase
{
public:
	class UTransformProxy*                        ActiveTarget;                                      // 0x0150(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_158[0x68];                                     // 0x0158(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTargetingGizmoBase">();
	}
	static class UBRTargetingGizmoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTargetingGizmoBase>();
	}
};
static_assert(alignof(UBRTargetingGizmoBase) == 0x000010, "Wrong alignment on UBRTargetingGizmoBase");
static_assert(sizeof(UBRTargetingGizmoBase) == 0x0001C0, "Wrong size on UBRTargetingGizmoBase");
static_assert(offsetof(UBRTargetingGizmoBase, ActiveTarget) == 0x000150, "Member 'UBRTargetingGizmoBase::ActiveTarget' has a wrong offset!");

// Class Brickadia.BRDecorativeGizmoBase
// 0x0000 (0x01C0 - 0x01C0)
class UBRDecorativeGizmoBase : public UBRTargetingGizmoBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDecorativeGizmoBase">();
	}
	static class UBRDecorativeGizmoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDecorativeGizmoBase>();
	}
};
static_assert(alignof(UBRDecorativeGizmoBase) == 0x000010, "Wrong alignment on UBRDecorativeGizmoBase");
static_assert(sizeof(UBRDecorativeGizmoBase) == 0x0001C0, "Wrong size on UBRDecorativeGizmoBase");

// Class Brickadia.BRGizmo_PlacerRowDragLine
// 0x0090 (0x0250 - 0x01C0)
class UBRGizmo_PlacerRowDragLine final : public UBRDecorativeGizmoBase
{
public:
	float                                         ScreenSpaceIndicatorSize;                          // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceAxisLineThickness;                      // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABRGizmoText>               SizeTextActorClass;                                // 0x01C8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D0[0x38];                                     // 0x01D0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRGizmoElementAxisLineSegment*         AxisLineElement;                                   // 0x0208(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGizmoElementRectangle*                 OriginIndicatorElement;                            // 0x0210(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPositionedGizmoElementGroup*         OriginIndicatorElementContainer;                   // 0x0218(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGizmoElementCircle*                    StartIndicatorElement;                             // 0x0220(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPositionedGizmoElementGroup*         StartIndicatorElementContainer;                    // 0x0228(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGizmoElementCircle*                    EndIndicatorElement;                               // 0x0230(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPositionedGizmoElementGroup*         EndIndicatorElementContainer;                      // 0x0238(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRGizmoText*                           SizeTextActor;                                     // 0x0240(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248[0x8];                                      // 0x0248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmo_PlacerRowDragLine">();
	}
	static class UBRGizmo_PlacerRowDragLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmo_PlacerRowDragLine>();
	}
};
static_assert(alignof(UBRGizmo_PlacerRowDragLine) == 0x000010, "Wrong alignment on UBRGizmo_PlacerRowDragLine");
static_assert(sizeof(UBRGizmo_PlacerRowDragLine) == 0x000250, "Wrong size on UBRGizmo_PlacerRowDragLine");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, ScreenSpaceIndicatorSize) == 0x0001C0, "Member 'UBRGizmo_PlacerRowDragLine::ScreenSpaceIndicatorSize' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, ScreenSpaceAxisLineThickness) == 0x0001C4, "Member 'UBRGizmo_PlacerRowDragLine::ScreenSpaceAxisLineThickness' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, SizeTextActorClass) == 0x0001C8, "Member 'UBRGizmo_PlacerRowDragLine::SizeTextActorClass' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, AxisLineElement) == 0x000208, "Member 'UBRGizmo_PlacerRowDragLine::AxisLineElement' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, OriginIndicatorElement) == 0x000210, "Member 'UBRGizmo_PlacerRowDragLine::OriginIndicatorElement' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, OriginIndicatorElementContainer) == 0x000218, "Member 'UBRGizmo_PlacerRowDragLine::OriginIndicatorElementContainer' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, StartIndicatorElement) == 0x000220, "Member 'UBRGizmo_PlacerRowDragLine::StartIndicatorElement' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, StartIndicatorElementContainer) == 0x000228, "Member 'UBRGizmo_PlacerRowDragLine::StartIndicatorElementContainer' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, EndIndicatorElement) == 0x000230, "Member 'UBRGizmo_PlacerRowDragLine::EndIndicatorElement' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, EndIndicatorElementContainer) == 0x000238, "Member 'UBRGizmo_PlacerRowDragLine::EndIndicatorElementContainer' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerRowDragLine, SizeTextActor) == 0x000240, "Member 'UBRGizmo_PlacerRowDragLine::SizeTextActor' has a wrong offset!");

// Class Brickadia.BHStructTemplate
// 0x0020 (0x0070 - 0x0050)
class UBHStructTemplate final : public UBHStructTemplateNoProps
{
public:
	uint8                                         Pad_50[0x20];                                      // 0x0050(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHStructTemplate">();
	}
	static class UBHStructTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHStructTemplate>();
	}
};
static_assert(alignof(UBHStructTemplate) == 0x000008, "Wrong alignment on UBHStructTemplate");
static_assert(sizeof(UBHStructTemplate) == 0x000070, "Wrong size on UBHStructTemplate");

// Class Brickadia.BHGeneratedData
// 0x0198 (0x01C0 - 0x0028)
class UBHGeneratedData final : public UObject
{
public:
	TMap<EBrickNativeEvent, class UBHGeneratedRoutine*> EventHandlers;                                     // 0x0028(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UBHGeneratedRoutine*> PropertyChangeHandlers;                            // 0x0078(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UBHGeneratedRoutine*> FunctionsById;                                     // 0x00C8(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FGuid, class FName>               FunctionGuidToId;                                  // 0x0118(0x0050)(NativeAccessSpecifierPublic)
	TSet<class UBehaviorBase*>                    Dependencies;                                      // 0x0168(0x0050)(UObjectWrapper, NativeAccessSpecifierPublic)
	class UBHGeneratedStruct*                     InstanceStruct;                                    // 0x01B8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHGeneratedData">();
	}
	static class UBHGeneratedData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHGeneratedData>();
	}
};
static_assert(alignof(UBHGeneratedData) == 0x000008, "Wrong alignment on UBHGeneratedData");
static_assert(sizeof(UBHGeneratedData) == 0x0001C0, "Wrong size on UBHGeneratedData");
static_assert(offsetof(UBHGeneratedData, EventHandlers) == 0x000028, "Member 'UBHGeneratedData::EventHandlers' has a wrong offset!");
static_assert(offsetof(UBHGeneratedData, PropertyChangeHandlers) == 0x000078, "Member 'UBHGeneratedData::PropertyChangeHandlers' has a wrong offset!");
static_assert(offsetof(UBHGeneratedData, FunctionsById) == 0x0000C8, "Member 'UBHGeneratedData::FunctionsById' has a wrong offset!");
static_assert(offsetof(UBHGeneratedData, FunctionGuidToId) == 0x000118, "Member 'UBHGeneratedData::FunctionGuidToId' has a wrong offset!");
static_assert(offsetof(UBHGeneratedData, Dependencies) == 0x000168, "Member 'UBHGeneratedData::Dependencies' has a wrong offset!");
static_assert(offsetof(UBHGeneratedData, InstanceStruct) == 0x0001B8, "Member 'UBHGeneratedData::InstanceStruct' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateNandInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNandInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNandInt">();
	}
	static class UBrickComponentType_GateNandInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNandInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateNandInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateNandInt");
static_assert(sizeof(UBrickComponentType_GateNandInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateNandInt");

// Class Brickadia.BHGeneratedRoutine
// 0x0088 (0x00B0 - 0x0028)
class UBHGeneratedRoutine final : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UBHGeneratedStruct*                     StackFrameStruct;                                  // 0x0098(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHGeneratedRoutine">();
	}
	static class UBHGeneratedRoutine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHGeneratedRoutine>();
	}
};
static_assert(alignof(UBHGeneratedRoutine) == 0x000008, "Wrong alignment on UBHGeneratedRoutine");
static_assert(sizeof(UBHGeneratedRoutine) == 0x0000B0, "Wrong size on UBHGeneratedRoutine");
static_assert(offsetof(UBHGeneratedRoutine, StackFrameStruct) == 0x000098, "Member 'UBHGeneratedRoutine::StackFrameStruct' has a wrong offset!");

// Class Brickadia.BHRoutineTemplateBase
// 0x0018 (0x0040 - 0x0028)
class UBHRoutineTemplateBase : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBHStructTemplateNoProps*               StackFrameStructTemplate;                          // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHRoutineTemplateBase">();
	}
	static class UBHRoutineTemplateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHRoutineTemplateBase>();
	}
};
static_assert(alignof(UBHRoutineTemplateBase) == 0x000008, "Wrong alignment on UBHRoutineTemplateBase");
static_assert(sizeof(UBHRoutineTemplateBase) == 0x000040, "Wrong size on UBHRoutineTemplateBase");
static_assert(offsetof(UBHRoutineTemplateBase, StackFrameStructTemplate) == 0x000038, "Member 'UBHRoutineTemplateBase::StackFrameStructTemplate' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateNorBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNorBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNorBool">();
	}
	static class UBrickComponentType_GateNorBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNorBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateNorBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateNorBool");
static_assert(sizeof(UBrickComponentType_GateNorBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateNorBool");

// Class Brickadia.BHEventHandlerTemplate
// 0x0008 (0x0048 - 0x0040)
class UBHEventHandlerTemplate final : public UBHRoutineTemplateBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHEventHandlerTemplate">();
	}
	static class UBHEventHandlerTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHEventHandlerTemplate>();
	}
};
static_assert(alignof(UBHEventHandlerTemplate) == 0x000008, "Wrong alignment on UBHEventHandlerTemplate");
static_assert(sizeof(UBHEventHandlerTemplate) == 0x000048, "Wrong size on UBHEventHandlerTemplate");

// Class Brickadia.BHPropertyChangeHandlerTemplate
// 0x0008 (0x0048 - 0x0040)
class UBHPropertyChangeHandlerTemplate final : public UBHRoutineTemplateBase
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHPropertyChangeHandlerTemplate">();
	}
	static class UBHPropertyChangeHandlerTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHPropertyChangeHandlerTemplate>();
	}
};
static_assert(alignof(UBHPropertyChangeHandlerTemplate) == 0x000008, "Wrong alignment on UBHPropertyChangeHandlerTemplate");
static_assert(sizeof(UBHPropertyChangeHandlerTemplate) == 0x000048, "Wrong size on UBHPropertyChangeHandlerTemplate");

// Class Brickadia.BRGizmo_PlacerLockOrigin
// 0x0010 (0x01D0 - 0x01C0)
class UBRGizmo_PlacerLockOrigin final : public UBRDecorativeGizmoBase
{
public:
	float                                         ScreenSpaceIndicatorHalfSize;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UGizmoElementRectangle*                 OriginIndicatorElement;                            // 0x01C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmo_PlacerLockOrigin">();
	}
	static class UBRGizmo_PlacerLockOrigin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmo_PlacerLockOrigin>();
	}
};
static_assert(alignof(UBRGizmo_PlacerLockOrigin) == 0x000010, "Wrong alignment on UBRGizmo_PlacerLockOrigin");
static_assert(sizeof(UBRGizmo_PlacerLockOrigin) == 0x0001D0, "Wrong size on UBRGizmo_PlacerLockOrigin");
static_assert(offsetof(UBRGizmo_PlacerLockOrigin, ScreenSpaceIndicatorHalfSize) == 0x0001C0, "Member 'UBRGizmo_PlacerLockOrigin::ScreenSpaceIndicatorHalfSize' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerLockOrigin, OriginIndicatorElement) == 0x0001C8, "Member 'UBRGizmo_PlacerLockOrigin::OriginIndicatorElement' has a wrong offset!");

// Class Brickadia.BHFunctionTemplate
// 0x0030 (0x0070 - 0x0040)
class UBHFunctionTemplate final : public UBHRoutineTemplateBase
{
public:
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHFunctionTemplate">();
	}
	static class UBHFunctionTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHFunctionTemplate>();
	}
};
static_assert(alignof(UBHFunctionTemplate) == 0x000008, "Wrong alignment on UBHFunctionTemplate");
static_assert(sizeof(UBHFunctionTemplate) == 0x000070, "Wrong size on UBHFunctionTemplate");

// Class Brickadia.BHTemplate
// 0x0018 (0x0040 - 0x0028)
class UBHTemplate final : public UObject
{
public:
	TArray<class UBHRoutineTemplateBase*>         Routines;                                          // 0x0028(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBHStructTemplate*                      InstanceStructTemplate;                            // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHTemplate">();
	}
	static class UBHTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHTemplate>();
	}
};
static_assert(alignof(UBHTemplate) == 0x000008, "Wrong alignment on UBHTemplate");
static_assert(sizeof(UBHTemplate) == 0x000040, "Wrong size on UBHTemplate");
static_assert(offsetof(UBHTemplate, Routines) == 0x000028, "Member 'UBHTemplate::Routines' has a wrong offset!");
static_assert(offsetof(UBHTemplate, InstanceStructTemplate) == 0x000038, "Member 'UBHTemplate::InstanceStructTemplate' has a wrong offset!");

// Class Brickadia.BrickAsset
// 0x0048 (0x0070 - 0x0028)
class UBrickAsset : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableOmniport;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrickAssetDefaultComponentEntry> DefaultComponentEntries;                           // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRotator                               AddedPreviewRotation;                              // 0x0048(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UBrickAsset*                            Parent;                                            // 0x0060(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickPicksParent;                                  // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UBrickType* GetDisplayBrickType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickAsset">();
	}
	static class UBrickAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickAsset>();
	}
};
static_assert(alignof(UBrickAsset) == 0x000008, "Wrong alignment on UBrickAsset");
static_assert(sizeof(UBrickAsset) == 0x000070, "Wrong size on UBrickAsset");
static_assert(offsetof(UBrickAsset, bDisableOmniport) == 0x000030, "Member 'UBrickAsset::bDisableOmniport' has a wrong offset!");
static_assert(offsetof(UBrickAsset, DefaultComponentEntries) == 0x000038, "Member 'UBrickAsset::DefaultComponentEntries' has a wrong offset!");
static_assert(offsetof(UBrickAsset, AddedPreviewRotation) == 0x000048, "Member 'UBrickAsset::AddedPreviewRotation' has a wrong offset!");
static_assert(offsetof(UBrickAsset, Parent) == 0x000060, "Member 'UBrickAsset::Parent' has a wrong offset!");
static_assert(offsetof(UBrickAsset, bPickPicksParent) == 0x000068, "Member 'UBrickAsset::bPickPicksParent' has a wrong offset!");

// Class Brickadia.BHBlockEditorCommentNodeWidget
// 0x0008 (0x0300 - 0x02F8)
class UBHBlockEditorCommentNodeWidget : public UBHBlockEditorNodeWidget
{
public:
	class UEditableText*                          Text;                                              // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorCommentNodeWidget">();
	}
	static class UBHBlockEditorCommentNodeWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorCommentNodeWidget>();
	}
};
static_assert(alignof(UBHBlockEditorCommentNodeWidget) == 0x000008, "Wrong alignment on UBHBlockEditorCommentNodeWidget");
static_assert(sizeof(UBHBlockEditorCommentNodeWidget) == 0x000300, "Wrong size on UBHBlockEditorCommentNodeWidget");
static_assert(offsetof(UBHBlockEditorCommentNodeWidget, Text) == 0x0002F8, "Member 'UBHBlockEditorCommentNodeWidget::Text' has a wrong offset!");

// Class Brickadia.BHBlockEditorNodeElementWidget_DefineVarSlot
// 0x0000 (0x02D8 - 0x02D8)
class UBHBlockEditorNodeElementWidget_DefineVarSlot : public UBHBlockEditorNodeElementWidget_DestVarSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BHBlockEditorNodeElementWidget_DefineVarSlot">();
	}
	static class UBHBlockEditorNodeElementWidget_DefineVarSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBHBlockEditorNodeElementWidget_DefineVarSlot>();
	}
};
static_assert(alignof(UBHBlockEditorNodeElementWidget_DefineVarSlot) == 0x000008, "Wrong alignment on UBHBlockEditorNodeElementWidget_DefineVarSlot");
static_assert(sizeof(UBHBlockEditorNodeElementWidget_DefineVarSlot) == 0x0002D8, "Wrong size on UBHBlockEditorNodeElementWidget_DefineVarSlot");

// Class Brickadia.BRGuideToolHelpers
// 0x0000 (0x0028 - 0x0028)
class UBRGuideToolHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void GenerateCircle(class UInstancedStaticMeshComponent* InstancedStaticMesh, int32 Radius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGuideToolHelpers">();
	}
	static class UBRGuideToolHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGuideToolHelpers>();
	}
};
static_assert(alignof(UBRGuideToolHelpers) == 0x000008, "Wrong alignment on UBRGuideToolHelpers");
static_assert(sizeof(UBRGuideToolHelpers) == 0x000028, "Wrong size on UBRGuideToolHelpers");

// Class Brickadia.BRChangeDisplayNameAsyncAction
// 0x0030 (0x0060 - 0x0030)
class UBRChangeDisplayNameAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(const class FString& ValidatedDisplayName)> OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRChangeDisplayNameAsyncAction* AsyncChangeDisplayName(class UObject* WorldContextObject, const class FString& NewDisplayName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRChangeDisplayNameAsyncAction">();
	}
	static class UBRChangeDisplayNameAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRChangeDisplayNameAsyncAction>();
	}
};
static_assert(alignof(UBRChangeDisplayNameAsyncAction) == 0x000008, "Wrong alignment on UBRChangeDisplayNameAsyncAction");
static_assert(sizeof(UBRChangeDisplayNameAsyncAction) == 0x000060, "Wrong size on UBRChangeDisplayNameAsyncAction");
static_assert(offsetof(UBRChangeDisplayNameAsyncAction, OnSuccess) == 0x000030, "Member 'UBRChangeDisplayNameAsyncAction::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBRChangeDisplayNameAsyncAction, OnFailed) == 0x000040, "Member 'UBRChangeDisplayNameAsyncAction::OnFailed' has a wrong offset!");

// Class Brickadia.BRAnimInstance
// 0x07E0 (0x0BA0 - 0x03C0)
class UBRAnimInstance final : public UAnimInstance
{
public:
	bool                                          bIsFirstPersonHands;                               // 0x03B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinPointAtDistance;                                // 0x03BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CursorInfluenceExponent;                           // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CursorInfluenceAngleOffset;                        // 0x03C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRCharacter*                           FigureOwner;                                       // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AimOffset;                                         // 0x03D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WeaponNoAddWeight;                                 // 0x03D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CanPointWeight;                                    // 0x03DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CachedPointAtLocation;                             // 0x03E0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x7A8];                                    // 0x03F8(0x07A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsJumping();
	bool GetIsJumpingAlternate();
	struct FRotator GetLegRotatorL();
	struct FRotator GetLegRotatorR();

	float GetAimDeltaPitch() const;
	float GetAimDeltaYaw() const;
	float GetAimPitch() const;
	float GetBaseAimPitch() const;
	float GetCursorInfluenceAngle() const;
	float GetForwardSpeed() const;
	float GetForwardSpeedWithRootAngle() const;
	bool GetHasPhysicsGrabbedObject() const;
	bool GetIsCrouchingWithAimOffset() const;
	bool GetIsMoving() const;
	struct FVector GetItemAimLocation() const;
	float GetLeanPitch() const;
	float GetLeanRoll() const;
	struct FVector GetMuzzleAimOffset() const;
	float GetRootAngle() const;
	float GetSpeed() const;
	float GetStrafeSpeed() const;
	float GetStrafeSpeedWithRootAngle() const;
	bool GetUseAimOffset() const;
	bool GetUseBaseAimOffset() const;
	bool GetUseCustomAimOffset() const;
	class ABRCharacter* TryGetOwningFigure() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAnimInstance">();
	}
	static class UBRAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAnimInstance>();
	}
};
static_assert(alignof(UBRAnimInstance) == 0x000010, "Wrong alignment on UBRAnimInstance");
static_assert(sizeof(UBRAnimInstance) == 0x000BA0, "Wrong size on UBRAnimInstance");
static_assert(offsetof(UBRAnimInstance, bIsFirstPersonHands) == 0x0003B8, "Member 'UBRAnimInstance::bIsFirstPersonHands' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, MinPointAtDistance) == 0x0003BC, "Member 'UBRAnimInstance::MinPointAtDistance' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, CursorInfluenceExponent) == 0x0003C0, "Member 'UBRAnimInstance::CursorInfluenceExponent' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, CursorInfluenceAngleOffset) == 0x0003C4, "Member 'UBRAnimInstance::CursorInfluenceAngleOffset' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, FigureOwner) == 0x0003C8, "Member 'UBRAnimInstance::FigureOwner' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, AimOffset) == 0x0003D0, "Member 'UBRAnimInstance::AimOffset' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, WeaponNoAddWeight) == 0x0003D8, "Member 'UBRAnimInstance::WeaponNoAddWeight' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, CanPointWeight) == 0x0003DC, "Member 'UBRAnimInstance::CanPointWeight' has a wrong offset!");
static_assert(offsetof(UBRAnimInstance, CachedPointAtLocation) == 0x0003E0, "Member 'UBRAnimInstance::CachedPointAtLocation' has a wrong offset!");

// Class Brickadia.BRPlacerGrid
// 0x0000 (0x02B0 - 0x02B0)
class ABRPlacerGrid final : public AActor
{
public:
	void UpdateColor(const struct FLinearColor& InColor);
	void UpdateGrid(class UBrickGridComponent* BrickGrid, const struct FIntVector& InGridCellSize, const struct FIntVector& InPlacementPivotExtent, const struct FIntVector& GridLocation, EBrickDirection InDirection, int32 InExtentBeyondBrickInCells);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerGrid">();
	}
	static class ABRPlacerGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlacerGrid>();
	}
};
static_assert(alignof(ABRPlacerGrid) == 0x000008, "Wrong alignment on ABRPlacerGrid");
static_assert(sizeof(ABRPlacerGrid) == 0x0002B0, "Wrong size on ABRPlacerGrid");

// Class Brickadia.BRAnimNotifyState_MeleeActive
// 0x0000 (0x0030 - 0x0030)
class UBRAnimNotifyState_MeleeActive final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAnimNotifyState_MeleeActive">();
	}
	static class UBRAnimNotifyState_MeleeActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAnimNotifyState_MeleeActive>();
	}
};
static_assert(alignof(UBRAnimNotifyState_MeleeActive) == 0x000008, "Wrong alignment on UBRAnimNotifyState_MeleeActive");
static_assert(sizeof(UBRAnimNotifyState_MeleeActive) == 0x000030, "Wrong size on UBRAnimNotifyState_MeleeActive");

// Class Brickadia.BRAnimNotifyState_WeaponTrail
// 0x0000 (0x0058 - 0x0058)
class UBRAnimNotifyState_WeaponTrail final : public UAnimNotifyState_Trail
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAnimNotifyState_WeaponTrail">();
	}
	static class UBRAnimNotifyState_WeaponTrail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAnimNotifyState_WeaponTrail>();
	}
};
static_assert(alignof(UBRAnimNotifyState_WeaponTrail) == 0x000008, "Wrong alignment on UBRAnimNotifyState_WeaponTrail");
static_assert(sizeof(UBRAnimNotifyState_WeaponTrail) == 0x000058, "Wrong size on UBRAnimNotifyState_WeaponTrail");

// Class Brickadia.BRHUD
// 0x0138 (0x04D8 - 0x03A0)
class ABRHUD : public AHUD
{
public:
	TSubclassOf<class UBROneButtonDialogBase>     DefaultOneButtonDialogClass;                       // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRTwoButtonsDialogBase>    DefaultTwoButtonsDialogClass;                      // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRThreeButtonsDialogBase>  DefaultThreeButtonsDialogClass;                    // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UHUDWidgetBase>             HUDWidgetClass;                                    // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHUDWidgetBase*                         HUDWidget;                                         // 0x03C0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenterCursor;                                     // 0x03C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBRDialogBase*>                  OpenDialogStack;                                   // 0x03D0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class UBRDialogBase*>                    OpenDialogsInRootNotClosing;                       // 0x03E0(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<class UBRDialogBase*>                    OpenDialogsInRoot;                                 // 0x0430(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UBRDialogBase>, class UBRDialogBase*> CachedDialogInstances;                             // 0x0480(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class ABRHUD* Get(const class UObject* WorldContextObject);
	static class UHUDWidgetBase* GetHUDWidget(const class UObject* WorldContextObject);

	void ConditionalDisableBackgroundBlur();
	void HideDialogByClass(TSubclassOf<class UBRDialogBase> Class_0, bool bOnlyIfTopmost);
	class UBRDialogBase* OpenDialogByClass(TSubclassOf<class UBRDialogBase> Class_0, bool bOnlyIfNoOther, bool bCreateIfMissing);
	void SetFreeMouse(bool bFreeMouse);
	void SetHideHud(bool bHideHud);

	class UBRDialogBase* GetDialogByClass(TSubclassOf<class UBRDialogBase> Class_0) const;
	bool GetFreeMouse() const;
	bool GetHideHud() const;
	class UBRDialogBase* GetMostRecentOpenDialog() const;
	TArray<class UBRDialogBase*> GetOpenDialogs() const;
	class UBRDialogBase* GetOrCreateDialogByClass(TSubclassOf<class UBRDialogBase> Class_0) const;
	bool HasAnyOpenDialogs() const;
	bool HasAnyOpenDialogsExcept(const class UBRDialogBase* Dialog) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRHUD">();
	}
	static class ABRHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRHUD>();
	}
};
static_assert(alignof(ABRHUD) == 0x000008, "Wrong alignment on ABRHUD");
static_assert(sizeof(ABRHUD) == 0x0004D8, "Wrong size on ABRHUD");
static_assert(offsetof(ABRHUD, DefaultOneButtonDialogClass) == 0x0003A0, "Member 'ABRHUD::DefaultOneButtonDialogClass' has a wrong offset!");
static_assert(offsetof(ABRHUD, DefaultTwoButtonsDialogClass) == 0x0003A8, "Member 'ABRHUD::DefaultTwoButtonsDialogClass' has a wrong offset!");
static_assert(offsetof(ABRHUD, DefaultThreeButtonsDialogClass) == 0x0003B0, "Member 'ABRHUD::DefaultThreeButtonsDialogClass' has a wrong offset!");
static_assert(offsetof(ABRHUD, HUDWidgetClass) == 0x0003B8, "Member 'ABRHUD::HUDWidgetClass' has a wrong offset!");
static_assert(offsetof(ABRHUD, HUDWidget) == 0x0003C0, "Member 'ABRHUD::HUDWidget' has a wrong offset!");
static_assert(offsetof(ABRHUD, bCenterCursor) == 0x0003C8, "Member 'ABRHUD::bCenterCursor' has a wrong offset!");
static_assert(offsetof(ABRHUD, OpenDialogStack) == 0x0003D0, "Member 'ABRHUD::OpenDialogStack' has a wrong offset!");
static_assert(offsetof(ABRHUD, OpenDialogsInRootNotClosing) == 0x0003E0, "Member 'ABRHUD::OpenDialogsInRootNotClosing' has a wrong offset!");
static_assert(offsetof(ABRHUD, OpenDialogsInRoot) == 0x000430, "Member 'ABRHUD::OpenDialogsInRoot' has a wrong offset!");
static_assert(offsetof(ABRHUD, CachedDialogInstances) == 0x000480, "Member 'ABRHUD::CachedDialogInstances' has a wrong offset!");

// Class Brickadia.BRApplicatorComponentListEntryWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRApplicatorComponentListEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Setup(class UBrickComponentTypeBase* InComponentType);
	void TriggerSelected();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorComponentListEntryWidget">();
	}
	static class UBRApplicatorComponentListEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorComponentListEntryWidget>();
	}
};
static_assert(alignof(UBRApplicatorComponentListEntryWidget) == 0x000008, "Wrong alignment on UBRApplicatorComponentListEntryWidget");
static_assert(sizeof(UBRApplicatorComponentListEntryWidget) == 0x0002E0, "Wrong size on UBRApplicatorComponentListEntryWidget");

// Class Brickadia.BRApplicatorComponentListCategoryWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRApplicatorComponentListCategoryWidget final : public UUserWidget
{
public:
	class UTextBlock*                             CategoryNameText;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicEntryBox*                       EntriesBox;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Setup(const class FText& InCategoryName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorComponentListCategoryWidget">();
	}
	static class UBRApplicatorComponentListCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorComponentListCategoryWidget>();
	}
};
static_assert(alignof(UBRApplicatorComponentListCategoryWidget) == 0x000008, "Wrong alignment on UBRApplicatorComponentListCategoryWidget");
static_assert(sizeof(UBRApplicatorComponentListCategoryWidget) == 0x0002E0, "Wrong size on UBRApplicatorComponentListCategoryWidget");
static_assert(offsetof(UBRApplicatorComponentListCategoryWidget, CategoryNameText) == 0x0002D0, "Member 'UBRApplicatorComponentListCategoryWidget::CategoryNameText' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentListCategoryWidget, EntriesBox) == 0x0002D8, "Member 'UBRApplicatorComponentListCategoryWidget::EntriesBox' has a wrong offset!");

// Class Brickadia.BrickComponentType_BotSpawn
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_BotSpawn final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_BotSpawn">();
	}
	static class UBrickComponentType_BotSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_BotSpawn>();
	}
};
static_assert(alignof(UBrickComponentType_BotSpawn) == 0x000008, "Wrong alignment on UBrickComponentType_BotSpawn");
static_assert(sizeof(UBrickComponentType_BotSpawn) == 0x0001D8, "Wrong size on UBrickComponentType_BotSpawn");

// Class Brickadia.BRApplicatorComponentListWidget
// 0x0078 (0x0348 - 0x02D0)
class UBRApplicatorComponentListWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRApplicatorComponentListEntryWidget> EntryWidgetClass;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRApplicatorComponentListCategoryWidget> CategoryWidgetClass;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicEntryBox*                       CategoriesBox;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UBRApplicatorComponentListCategoryWidget*> CategoryWidgets;                                   // 0x02F8(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void Setup(const struct FBrickHandle& BrickHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorComponentListWidget">();
	}
	static class UBRApplicatorComponentListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorComponentListWidget>();
	}
};
static_assert(alignof(UBRApplicatorComponentListWidget) == 0x000008, "Wrong alignment on UBRApplicatorComponentListWidget");
static_assert(sizeof(UBRApplicatorComponentListWidget) == 0x000348, "Wrong size on UBRApplicatorComponentListWidget");
static_assert(offsetof(UBRApplicatorComponentListWidget, EntryWidgetClass) == 0x0002E0, "Member 'UBRApplicatorComponentListWidget::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentListWidget, CategoryWidgetClass) == 0x0002E8, "Member 'UBRApplicatorComponentListWidget::CategoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentListWidget, CategoriesBox) == 0x0002F0, "Member 'UBRApplicatorComponentListWidget::CategoriesBox' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentListWidget, CategoryWidgets) == 0x0002F8, "Member 'UBRApplicatorComponentListWidget::CategoryWidgets' has a wrong offset!");

// Class Brickadia.BRApplicatorComponentWidget
// 0x0068 (0x0338 - 0x02D0)
class UBRApplicatorComponentWidget final : public UUserWidget
{
public:
	class UImage*                                 ComponentIcon;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ComponentName;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ComponentEditContainer;                            // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ComponentEnabled;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              ComponentEnabledCheckbox;                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ComponentDelete;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x28];                                     // 0x0300(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UInspectorPropertyDescriptor_Bool*      ComponentEnabledDescriptor;                        // 0x0328(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBRApplicatorBrickDialog*               ApplicatorDialog;                                  // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnComponentEnabledChanged(bool bIsChecked);
	void Remove();
	void Setup(class UBRApplicatorBrickDialog* InApplicatorDialog, class UBrickComponentTypeBase* InComponentType);
	void TriggerEditComponent();
	void TriggerRemoveComponent();

	class UBrickComponentTypeBase* GetComponentType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorComponentWidget">();
	}
	static class UBRApplicatorComponentWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorComponentWidget>();
	}
};
static_assert(alignof(UBRApplicatorComponentWidget) == 0x000008, "Wrong alignment on UBRApplicatorComponentWidget");
static_assert(sizeof(UBRApplicatorComponentWidget) == 0x000338, "Wrong size on UBRApplicatorComponentWidget");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentIcon) == 0x0002D0, "Member 'UBRApplicatorComponentWidget::ComponentIcon' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentName) == 0x0002D8, "Member 'UBRApplicatorComponentWidget::ComponentName' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentEditContainer) == 0x0002E0, "Member 'UBRApplicatorComponentWidget::ComponentEditContainer' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentEnabled) == 0x0002E8, "Member 'UBRApplicatorComponentWidget::ComponentEnabled' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentEnabledCheckbox) == 0x0002F0, "Member 'UBRApplicatorComponentWidget::ComponentEnabledCheckbox' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentDelete) == 0x0002F8, "Member 'UBRApplicatorComponentWidget::ComponentDelete' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ComponentEnabledDescriptor) == 0x000328, "Member 'UBRApplicatorComponentWidget::ComponentEnabledDescriptor' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentWidget, ApplicatorDialog) == 0x000330, "Member 'UBRApplicatorComponentWidget::ApplicatorDialog' has a wrong offset!");

// Class Brickadia.ProceduralBrick
// 0x00A0 (0x0110 - 0x0070)
class UProceduralBrick final : public UBrickAsset
{
public:
	TSubclassOf<class UBrickTypeGenerator>        GeneratorClass;                                    // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FIntVector>                     BrickMenuSizePresets;                              // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBrickMenuSizePresetRow>        BrickMenuSizePresetRows;                           // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bEnableBrickMenuSizePresets;                       // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             DefaultEditorSize;                                 // 0x009C(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x00A8(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x00B8(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Tab;                                               // 0x00C8(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Summary;                                           // 0x00D8(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBrickTypeGenerator*                    GeneratorInstance;                                 // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanCreateBrickType(const struct FIntVector& HalfSize);
	TArray<struct FIntVector> ComputeBrickMenuPresets();
	TArray<class UBrickType*> CreateBrickMenuPresets();
	class UBrickType* FindBrickType(const struct FIntVector& HalfSize);
	class UBrickType* FindOrCreateBrickType(const struct FIntVector& HalfSize);
	class UBrickType* FindOrCreateBrickTypeChecked(const struct FIntVector& HalfSize);
	class FText GetAxisHalfSizeText(int32 HalfSize, EBrickAxis Axis);
	void GetResizerConfig(struct FIntVector* OutSizeMin, struct FIntVector* OutSizeMax, struct FIntVector* OutSizeStep);
	struct FIntVector NearestCreatableBrickType(const struct FIntVector& HalfSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralBrick">();
	}
	static class UProceduralBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralBrick>();
	}
};
static_assert(alignof(UProceduralBrick) == 0x000008, "Wrong alignment on UProceduralBrick");
static_assert(sizeof(UProceduralBrick) == 0x000110, "Wrong size on UProceduralBrick");
static_assert(offsetof(UProceduralBrick, GeneratorClass) == 0x000070, "Member 'UProceduralBrick::GeneratorClass' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, BrickMenuSizePresets) == 0x000078, "Member 'UProceduralBrick::BrickMenuSizePresets' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, BrickMenuSizePresetRows) == 0x000088, "Member 'UProceduralBrick::BrickMenuSizePresetRows' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, bEnableBrickMenuSizePresets) == 0x000098, "Member 'UProceduralBrick::bEnableBrickMenuSizePresets' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, DefaultEditorSize) == 0x00009C, "Member 'UProceduralBrick::DefaultEditorSize' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, DisplayName) == 0x0000A8, "Member 'UProceduralBrick::DisplayName' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, Category) == 0x0000B8, "Member 'UProceduralBrick::Category' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, Tab) == 0x0000C8, "Member 'UProceduralBrick::Tab' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, Summary) == 0x0000D8, "Member 'UProceduralBrick::Summary' has a wrong offset!");
static_assert(offsetof(UProceduralBrick, GeneratorInstance) == 0x0000E8, "Member 'UProceduralBrick::GeneratorInstance' has a wrong offset!");

// Class Brickadia.BRApplicatorDialogBase
// 0x0000 (0x02E0 - 0x02E0)
class UBRApplicatorDialogBase : public UBRDialogBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorDialogBase">();
	}
	static class UBRApplicatorDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorDialogBase>();
	}
};
static_assert(alignof(UBRApplicatorDialogBase) == 0x000008, "Wrong alignment on UBRApplicatorDialogBase");
static_assert(sizeof(UBRApplicatorDialogBase) == 0x0002E0, "Wrong size on UBRApplicatorDialogBase");

// Class Brickadia.BRApplicatorBrickDialog
// 0x0078 (0x0358 - 0x02E0)
class UBRApplicatorBrickDialog final : public UBRApplicatorDialogBase
{
public:
	TSubclassOf<class UBRApplicatorComponentWidget> EntryWidgetClass;                                  // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRApplicatorComponentDialog> EditDialogClass;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRApplicatorComponentListWidget> ComponentListWidgetClass;                          // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              VisibleCheckbox;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              CollidesCheckbox_Player;                           // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              CollidesCheckbox_Weapon;                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              CollidesCheckbox_Interaction;                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicEntryBox*                       ComponentsEntryBox;                                // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMenuAnchor*                            ComponentListAnchor;                               // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBrickComponentTypeBase*>        ListedComponents;                                  // 0x0328(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ABRTool_Applicator*                     Applicator;                                        // 0x0338(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x18];                                     // 0x0340(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UUserWidget* GetComponentListContent();
	void OnCollidesChanged_Interaction(bool bIsChecked);
	void OnCollidesChanged_Player(bool bIsChecked);
	void OnCollidesChanged_Weapon(bool bIsChecked);
	void OnVisibleChanged(bool bIsChecked);
	void SetupAndOpen(class ABRTool_Applicator* InApplicator, const struct FBrickHandle& BrickHandle);
	void TriggerClearAll();
	void TriggerLoadFromPreset(class UBRPreset* Preset);
	void TriggerResetToDefaults();
	void TriggerSaveToPreset(class UBRPreset* Preset);
	void TriggerShowComponentList();

	class ABRTool_Applicator* GetApplicator() const;
	const struct FBrickHandle GetCurrentBrickHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorBrickDialog">();
	}
	static class UBRApplicatorBrickDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorBrickDialog>();
	}
};
static_assert(alignof(UBRApplicatorBrickDialog) == 0x000008, "Wrong alignment on UBRApplicatorBrickDialog");
static_assert(sizeof(UBRApplicatorBrickDialog) == 0x000358, "Wrong size on UBRApplicatorBrickDialog");
static_assert(offsetof(UBRApplicatorBrickDialog, EntryWidgetClass) == 0x0002E0, "Member 'UBRApplicatorBrickDialog::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, EditDialogClass) == 0x0002E8, "Member 'UBRApplicatorBrickDialog::EditDialogClass' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, ComponentListWidgetClass) == 0x0002F0, "Member 'UBRApplicatorBrickDialog::ComponentListWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, VisibleCheckbox) == 0x0002F8, "Member 'UBRApplicatorBrickDialog::VisibleCheckbox' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, CollidesCheckbox_Player) == 0x000300, "Member 'UBRApplicatorBrickDialog::CollidesCheckbox_Player' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, CollidesCheckbox_Weapon) == 0x000308, "Member 'UBRApplicatorBrickDialog::CollidesCheckbox_Weapon' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, CollidesCheckbox_Interaction) == 0x000310, "Member 'UBRApplicatorBrickDialog::CollidesCheckbox_Interaction' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, ComponentsEntryBox) == 0x000318, "Member 'UBRApplicatorBrickDialog::ComponentsEntryBox' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, ComponentListAnchor) == 0x000320, "Member 'UBRApplicatorBrickDialog::ComponentListAnchor' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, ListedComponents) == 0x000328, "Member 'UBRApplicatorBrickDialog::ListedComponents' has a wrong offset!");
static_assert(offsetof(UBRApplicatorBrickDialog, Applicator) == 0x000338, "Member 'UBRApplicatorBrickDialog::Applicator' has a wrong offset!");

// Class Brickadia.DialogBackdropBase
// 0x0000 (0x02D0 - 0x02D0)
class UDialogBackdropBase : public UUserWidget
{
public:
	void DisableBackgroundBlur();
	void DisableClickCatcher();
	void EnableBackgroundBlur();
	void EnableClickCatcher();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DialogBackdropBase">();
	}
	static class UDialogBackdropBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDialogBackdropBase>();
	}
};
static_assert(alignof(UDialogBackdropBase) == 0x000008, "Wrong alignment on UDialogBackdropBase");
static_assert(sizeof(UDialogBackdropBase) == 0x0002D0, "Wrong size on UDialogBackdropBase");

// Class Brickadia.BRApplicatorComponentDialog
// 0x0020 (0x0300 - 0x02E0)
class UBRApplicatorComponentDialog final : public UBRApplicatorDialogBase
{
public:
	class UInspectorPanelBase*                    Inspector;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRTool_Applicator*                     Applicator;                                        // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickComponentTypeBase*                CurrentComponentType;                              // 0x02F8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyChanges();
	void CommitChanges();
	void SetupAndOpen(class ABRTool_Applicator* InApplicator, const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* ComponentType);
	void SetupOptions();
	void SubmitChanges(const struct FInspectorPropertyChangelist& Changelist, bool bCommit);
	void TriggerLoadFromPreset(class UBRPreset* Preset);
	void TriggerResetToDefaults();
	void TriggerReturn();
	void TriggerSaveToPreset(class UBRPreset* Preset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorComponentDialog">();
	}
	static class UBRApplicatorComponentDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorComponentDialog>();
	}
};
static_assert(alignof(UBRApplicatorComponentDialog) == 0x000008, "Wrong alignment on UBRApplicatorComponentDialog");
static_assert(sizeof(UBRApplicatorComponentDialog) == 0x000300, "Wrong size on UBRApplicatorComponentDialog");
static_assert(offsetof(UBRApplicatorComponentDialog, Inspector) == 0x0002E0, "Member 'UBRApplicatorComponentDialog::Inspector' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentDialog, Applicator) == 0x0002E8, "Member 'UBRApplicatorComponentDialog::Applicator' has a wrong offset!");
static_assert(offsetof(UBRApplicatorComponentDialog, CurrentComponentType) == 0x0002F8, "Member 'UBRApplicatorComponentDialog::CurrentComponentType' has a wrong offset!");

// Class Brickadia.BRApplicatorEntityDialog
// 0x0018 (0x02F8 - 0x02E0)
class UBRApplicatorEntityDialog final : public UBRApplicatorDialogBase
{
public:
	class UInspectorPanelBase*                    Inspector;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRTool_Applicator*                     Applicator;                                        // 0x02E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 CurrentEntity;                                     // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyChanges();
	void CommitChanges();
	void SetupAndOpen(class ABRTool_Applicator* InApplicator, class AActor* ENTITY);
	void SetupOptions();
	void SubmitChanges(const struct FInspectorPropertyChangelist& Changelist, bool bCommit);
	void TriggerLoadFromPreset(class UBRPreset* Preset);
	void TriggerResetToDefaults();
	void TriggerSaveToPreset(class UBRPreset* Preset);

	class AActor* GetCurrentEntity() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorEntityDialog">();
	}
	static class UBRApplicatorEntityDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorEntityDialog>();
	}
};
static_assert(alignof(UBRApplicatorEntityDialog) == 0x000008, "Wrong alignment on UBRApplicatorEntityDialog");
static_assert(sizeof(UBRApplicatorEntityDialog) == 0x0002F8, "Wrong size on UBRApplicatorEntityDialog");
static_assert(offsetof(UBRApplicatorEntityDialog, Inspector) == 0x0002E0, "Member 'UBRApplicatorEntityDialog::Inspector' has a wrong offset!");
static_assert(offsetof(UBRApplicatorEntityDialog, Applicator) == 0x0002E8, "Member 'UBRApplicatorEntityDialog::Applicator' has a wrong offset!");
static_assert(offsetof(UBRApplicatorEntityDialog, CurrentEntity) == 0x0002F0, "Member 'UBRApplicatorEntityDialog::CurrentEntity' has a wrong offset!");

// Class Brickadia.BrickAudioDescriptor
// 0x0068 (0x0098 - 0x0030)
class UBrickAudioDescriptor final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRCatalogData                         CatalogData;                                       // 0x0038(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             WidgetIconOverride;                                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoudnessWarning;                              // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickAudioDescriptor">();
	}
	static class UBrickAudioDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickAudioDescriptor>();
	}
};
static_assert(alignof(UBrickAudioDescriptor) == 0x000008, "Wrong alignment on UBrickAudioDescriptor");
static_assert(sizeof(UBrickAudioDescriptor) == 0x000098, "Wrong size on UBrickAudioDescriptor");
static_assert(offsetof(UBrickAudioDescriptor, CatalogData) == 0x000038, "Member 'UBrickAudioDescriptor::CatalogData' has a wrong offset!");
static_assert(offsetof(UBrickAudioDescriptor, WidgetIconOverride) == 0x000080, "Member 'UBrickAudioDescriptor::WidgetIconOverride' has a wrong offset!");
static_assert(offsetof(UBrickAudioDescriptor, bShowLoudnessWarning) == 0x000088, "Member 'UBrickAudioDescriptor::bShowLoudnessWarning' has a wrong offset!");
static_assert(offsetof(UBrickAudioDescriptor, Sound) == 0x000090, "Member 'UBrickAudioDescriptor::Sound' has a wrong offset!");

// Class Brickadia.BRAssetManager
// 0x0028 (0x04F8 - 0x04D0)
class UBRAssetManager final : public UAssetManager
{
public:
	uint8                                         Pad_4D0[0x28];                                     // 0x04D0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UBrickType*> GenerateCatalogBrickTypeArray();
	static bool IsBrickListReady(const TDelegate<void()>& EventToCallIfNot);
	static void SyncGetGameTypeAssets(TArray<class UBRGameTypeDescriptor*>* Assets);

	class UBrickAsset* FindBrickAssetByName(class FName Name_0);
	bool FindMapPackageByCommandName(const class FString& Name_0, TSoftObjectPtr<class UWorld>* MapPackage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAssetManager">();
	}
	static class UBRAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAssetManager>();
	}
};
static_assert(alignof(UBRAssetManager) == 0x000008, "Wrong alignment on UBRAssetManager");
static_assert(sizeof(UBRAssetManager) == 0x0004F8, "Wrong size on UBRAssetManager");

// Class Brickadia.BRAuthEditorSettings
// 0x0028 (0x0060 - 0x0038)
class UBRAuthEditorSettings final : public UDeveloperSettings
{
public:
	bool                                          bEnableAuth;                                       // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseProduction;                                    // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCacheLoginSessions;                               // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBRAuthUserInfo>                StagingAccounts;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FBRAuthUserInfo>                ProductionAccounts;                                // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAuthEditorSettings">();
	}
	static class UBRAuthEditorSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAuthEditorSettings>();
	}
};
static_assert(alignof(UBRAuthEditorSettings) == 0x000008, "Wrong alignment on UBRAuthEditorSettings");
static_assert(sizeof(UBRAuthEditorSettings) == 0x000060, "Wrong size on UBRAuthEditorSettings");
static_assert(offsetof(UBRAuthEditorSettings, bEnableAuth) == 0x000038, "Member 'UBRAuthEditorSettings::bEnableAuth' has a wrong offset!");
static_assert(offsetof(UBRAuthEditorSettings, bUseProduction) == 0x000039, "Member 'UBRAuthEditorSettings::bUseProduction' has a wrong offset!");
static_assert(offsetof(UBRAuthEditorSettings, bCacheLoginSessions) == 0x00003A, "Member 'UBRAuthEditorSettings::bCacheLoginSessions' has a wrong offset!");
static_assert(offsetof(UBRAuthEditorSettings, StagingAccounts) == 0x000040, "Member 'UBRAuthEditorSettings::StagingAccounts' has a wrong offset!");
static_assert(offsetof(UBRAuthEditorSettings, ProductionAccounts) == 0x000050, "Member 'UBRAuthEditorSettings::ProductionAccounts' has a wrong offset!");

// Class Brickadia.BRInteractablePromptWidget
// 0x0000 (0x02D0 - 0x02D0)
class UBRInteractablePromptWidget final : public UUserWidget
{
public:
	void Setup(const struct FBrickHandle& BrickHandle, const class FString& PromptMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInteractablePromptWidget">();
	}
	static class UBRInteractablePromptWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInteractablePromptWidget>();
	}
};
static_assert(alignof(UBRInteractablePromptWidget) == 0x000008, "Wrong alignment on UBRInteractablePromptWidget");
static_assert(sizeof(UBRInteractablePromptWidget) == 0x0002D0, "Wrong size on UBRInteractablePromptWidget");

// Class Brickadia.BRAuthOnline
// 0x0050 (0x0078 - 0x0028)
class UBRAuthOnline final : public UOnlineEngineInterface
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAuthOnline">();
	}
	static class UBRAuthOnline* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAuthOnline>();
	}
};
static_assert(alignof(UBRAuthOnline) == 0x000008, "Wrong alignment on UBRAuthOnline");
static_assert(sizeof(UBRAuthOnline) == 0x000078, "Wrong size on UBRAuthOnline");

// Class Brickadia.BRTickableGameInstanceSubsystem
// 0x0010 (0x0040 - 0x0030)
class UBRTickableGameInstanceSubsystem : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTickableGameInstanceSubsystem">();
	}
	static class UBRTickableGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTickableGameInstanceSubsystem>();
	}
};
static_assert(alignof(UBRTickableGameInstanceSubsystem) == 0x000008, "Wrong alignment on UBRTickableGameInstanceSubsystem");
static_assert(sizeof(UBRTickableGameInstanceSubsystem) == 0x000040, "Wrong size on UBRTickableGameInstanceSubsystem");

// Class Brickadia.BrickComponentType_InteractableBase
// 0x0010 (0x01E8 - 0x01D8)
class UBrickComponentType_InteractableBase : public UBrickComponentTypeBase
{
public:
	class FText                                   DefaultPromptLabel;                                // 0x01D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_InteractableBase">();
	}
	static class UBrickComponentType_InteractableBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_InteractableBase>();
	}
};
static_assert(alignof(UBrickComponentType_InteractableBase) == 0x000008, "Wrong alignment on UBrickComponentType_InteractableBase");
static_assert(sizeof(UBrickComponentType_InteractableBase) == 0x0001E8, "Wrong size on UBrickComponentType_InteractableBase");
static_assert(offsetof(UBrickComponentType_InteractableBase, DefaultPromptLabel) == 0x0001D8, "Member 'UBrickComponentType_InteractableBase::DefaultPromptLabel' has a wrong offset!");

// Class Brickadia.BrickComponentType_Button
// 0x0020 (0x0208 - 0x01E8)
class UBrickComponentType_Button : public UBrickComponentType_InteractableBase
{
public:
	class UBrickOneShotAudioDescriptor*           DefaultPressSound;                                 // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickOneShotAudioDescriptor*           DefaultReleaseSound;                               // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      InteractAttenuation;                               // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      InteractConcurrency;                               // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Button">();
	}
	static class UBrickComponentType_Button* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Button>();
	}
};
static_assert(alignof(UBrickComponentType_Button) == 0x000008, "Wrong alignment on UBrickComponentType_Button");
static_assert(sizeof(UBrickComponentType_Button) == 0x000208, "Wrong size on UBrickComponentType_Button");
static_assert(offsetof(UBrickComponentType_Button, DefaultPressSound) == 0x0001E8, "Member 'UBrickComponentType_Button::DefaultPressSound' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Button, DefaultReleaseSound) == 0x0001F0, "Member 'UBrickComponentType_Button::DefaultReleaseSound' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Button, InteractAttenuation) == 0x0001F8, "Member 'UBrickComponentType_Button::InteractAttenuation' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Button, InteractConcurrency) == 0x000200, "Member 'UBrickComponentType_Button::InteractConcurrency' has a wrong offset!");

// Class Brickadia.BRAuthSubsystem
// 0x01D0 (0x0210 - 0x0040)
class alignas(0x10) UBRAuthSubsystem final : public UBRTickableGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(EBRAuthState NewState, EBRAuthState PreviousState, const class FString& ErrorCode, const class FString& ErrorMessage)> OnAuthStateChanged;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnAuthStateBecomeValid;                            // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnChallengeRequestSent;                            // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnChallengeResponseReceived;                       // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& DisplayName)> OnDisplayNameChanged;                              // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0xE8];                                      // 0x0090(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const class FString& ConnectString)> OnServerJoinRequested;                             // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Sequence, bool bRequiresPassword)> OnServerRequestSucceeded;                          // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Sequence)> OnServerRequestFailed;                             // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x68];                                     // 0x01A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsSteamBuild();

	class FString GetConnectString();
	class FString GetExternalName();
	void RetryCheckLogin();
	void RetrySteamLogin();
	void StartConnectSteamAccount(const class FString& Email, const class FString& Password);
	void StartLogin(const class FString& Email, const class FString& Password);
	void StartLogout();
	void StartRegisterSteamAccount(const class FString& UserName);

	class FString GetAuthErrorCode() const;
	class FString GetAuthErrorMessage() const;
	EBRAuthState GetAuthState() const;
	const struct FBRAuthUserData GetAuthUserData() const;
	bool HasAuthError() const;
	bool IsAuthStateInvalid() const;
	bool IsAuthStatePending() const;
	bool IsAuthStateValid() const;
	bool IsLoggedInWithEOS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAuthSubsystem">();
	}
	static class UBRAuthSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAuthSubsystem>();
	}
};
static_assert(alignof(UBRAuthSubsystem) == 0x000010, "Wrong alignment on UBRAuthSubsystem");
static_assert(sizeof(UBRAuthSubsystem) == 0x000210, "Wrong size on UBRAuthSubsystem");
static_assert(offsetof(UBRAuthSubsystem, OnAuthStateChanged) == 0x000040, "Member 'UBRAuthSubsystem::OnAuthStateChanged' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnAuthStateBecomeValid) == 0x000050, "Member 'UBRAuthSubsystem::OnAuthStateBecomeValid' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnChallengeRequestSent) == 0x000060, "Member 'UBRAuthSubsystem::OnChallengeRequestSent' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnChallengeResponseReceived) == 0x000070, "Member 'UBRAuthSubsystem::OnChallengeResponseReceived' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnDisplayNameChanged) == 0x000080, "Member 'UBRAuthSubsystem::OnDisplayNameChanged' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnServerJoinRequested) == 0x000178, "Member 'UBRAuthSubsystem::OnServerJoinRequested' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnServerRequestSucceeded) == 0x000188, "Member 'UBRAuthSubsystem::OnServerRequestSucceeded' has a wrong offset!");
static_assert(offsetof(UBRAuthSubsystem, OnServerRequestFailed) == 0x000198, "Member 'UBRAuthSubsystem::OnServerRequestFailed' has a wrong offset!");

// Class Brickadia.BRAutoSaveSubsystem
// 0x0038 (0x0070 - 0x0038)
class UBRAutoSaveSubsystem final : public UBRWorldSubsystem
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceLastModifyTime(double Time);
	void HandleSettingsChange(class UBRGameSettingsBase* SettingsInstance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAutoSaveSubsystem">();
	}
	static class UBRAutoSaveSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRAutoSaveSubsystem>();
	}
};
static_assert(alignof(UBRAutoSaveSubsystem) == 0x000008, "Wrong alignment on UBRAutoSaveSubsystem");
static_assert(sizeof(UBRAutoSaveSubsystem) == 0x000070, "Wrong size on UBRAutoSaveSubsystem");

// Class Brickadia.BrickBehaviorType
// 0x0018 (0x01F0 - 0x01D8)
class UBrickBehaviorType final : public UBrickComponentTypeBase
{
public:
	class UBrickBehavior*                         Behavior;                                          // 0x01D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBHGeneratedData*                       InUseData;                                         // 0x01E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickBehaviorType">();
	}
	static class UBrickBehaviorType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickBehaviorType>();
	}
};
static_assert(alignof(UBrickBehaviorType) == 0x000008, "Wrong alignment on UBrickBehaviorType");
static_assert(sizeof(UBrickBehaviorType) == 0x0001F0, "Wrong size on UBrickBehaviorType");
static_assert(offsetof(UBrickBehaviorType, Behavior) == 0x0001D8, "Member 'UBrickBehaviorType::Behavior' has a wrong offset!");
static_assert(offsetof(UBrickBehaviorType, InUseData) == 0x0001E0, "Member 'UBrickBehaviorType::InUseData' has a wrong offset!");

// Class Brickadia.BRBlogHelpers
// 0x0000 (0x0028 - 0x0028)
class UBRBlogHelpers final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetBestBlogImageUrl(const class FString& FullSizeUrl, int32 DesiredWidth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBlogHelpers">();
	}
	static class UBRBlogHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBlogHelpers>();
	}
};
static_assert(alignof(UBRBlogHelpers) == 0x000008, "Wrong alignment on UBRBlogHelpers");
static_assert(sizeof(UBRBlogHelpers) == 0x000028, "Wrong size on UBRBlogHelpers");

// Class Brickadia.BRListBlogPostsAsyncAction
// 0x0038 (0x0068 - 0x0030)
class UBRListBlogPostsAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, const struct FJsonResponse_BlogListing& Result)> OnWorkComplete;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Sequence)> OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRListBlogPostsAsyncAction* AsyncListBlogPosts(class UObject* WorldContextObject, int32 InSequence, int32 NumPostsToRequest);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRListBlogPostsAsyncAction">();
	}
	static class UBRListBlogPostsAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRListBlogPostsAsyncAction>();
	}
};
static_assert(alignof(UBRListBlogPostsAsyncAction) == 0x000008, "Wrong alignment on UBRListBlogPostsAsyncAction");
static_assert(sizeof(UBRListBlogPostsAsyncAction) == 0x000068, "Wrong size on UBRListBlogPostsAsyncAction");
static_assert(offsetof(UBRListBlogPostsAsyncAction, OnWorkComplete) == 0x000030, "Member 'UBRListBlogPostsAsyncAction::OnWorkComplete' has a wrong offset!");
static_assert(offsetof(UBRListBlogPostsAsyncAction, OnError) == 0x000040, "Member 'UBRListBlogPostsAsyncAction::OnError' has a wrong offset!");

// Class Brickadia.BRDownloadAndResizeImageAsyncAction
// 0x0070 (0x00A0 - 0x0030)
class UBRDownloadAndResizeImageAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, class UTexture2DDynamic* Texture)> OnWorkComplete;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRDownloadAndResizeImageAsyncAction* AsyncDownloadAndResizeImage(class UObject* WorldContextObject, int32 InSequence, const class FString& URL, int32 DesiredWidth, int32 DesiredHeight, bool bUseCache);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDownloadAndResizeImageAsyncAction">();
	}
	static class UBRDownloadAndResizeImageAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDownloadAndResizeImageAsyncAction>();
	}
};
static_assert(alignof(UBRDownloadAndResizeImageAsyncAction) == 0x000008, "Wrong alignment on UBRDownloadAndResizeImageAsyncAction");
static_assert(sizeof(UBRDownloadAndResizeImageAsyncAction) == 0x0000A0, "Wrong size on UBRDownloadAndResizeImageAsyncAction");
static_assert(offsetof(UBRDownloadAndResizeImageAsyncAction, OnWorkComplete) == 0x000030, "Member 'UBRDownloadAndResizeImageAsyncAction::OnWorkComplete' has a wrong offset!");

// Class Brickadia.BRBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UBRBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AbortConnectingToServer();
	static bool ActorLineTraceSingle(struct FHitResult* OutHit, class AActor* Actor, const struct FVector& Start, const struct FVector& End, bool bTraceComplex);
	static class FString AssetNameToDisplayString(const class FString& InString);
	static bool BeginConnectingToServer(const class UObject* WorldContextObject, const class FString& AddressAndPort, const TMap<class FString, class FString>& Options, const class FString& ServerIdString);
	static void BRSaveConfig(class UObject* Object);
	static class UObject* ClassToObject(class UClass* Class_0);
	static struct FLinearColor ColorToLinearColorNoSRGB(const struct FColor& Color);
	static float ComputeExponentialClampDelta(float Current, float ClampMin, float ClampMax, float ExponentialDistance, float Delta, float& OverflowStorage);
	static struct FBox ComputePreciseSkeletalMeshBounds(class USkeletalMeshComponent* MeshComponent);
	static void Conv_StringToFColor(const class FString& InString, struct FColor* OutConvertedColor, bool* OutIsValid);
	static bool EqualEqual_ColorColor(const struct FColor& A, const struct FColor& B);
	static bool EqualEqual_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);
	static class FString EscapeNetOption(const class FString& Password);
	static class FText FormatLargeNumber(int32 Number);
	static class FString FormatLinearColorToHex(const struct FLinearColor& Color);
	static class FText FormatTimespanSimple(const struct FTimespan& Timespan);
	static bool FuzzyFindTest(const class FString& Name_0, const class FString& Query);
	static struct FVector GetActorBoundsCenter(class AActor* Actor, bool bNonColliding, bool bIncludeFromChildActors);
	static class FString GetBackendWebAddress();
	static class ABRGameStateBase* GetBRGameState(const class UObject* WorldContextObject);
	static class FString GetBrickadiaVersion();
	static int32 GetBrickadiaVersionChangelist();
	static class ABRPlayerController* GetBRPlayerController(const class UObject* WorldContextObject, int32 ID);
	static class UObject* GetClassDefaultObject(const class UClass* Class_0);
	static class FString GetConnectStringFromServerEntry(const struct FJsonResponse_GetServers_Entry& Entry, const class FString& InviteCode);
	static class FString GetLoadedLightScenario(const class UObject* WorldContextObject);
	static class UBRMapInfo* GetMapInfoForCurrentMap(const class UObject* WorldContextObject);
	static class UBRMapInfo* GetMapInfoForWorld(const class UWorld* World);
	static class UClass* GetObjectClass(const class UObject* Object);
	static class FString GetPlatformClipboard();
	static class FString GetSoftPackageName(const TSoftObjectPtr<class UObject>& Ptr);
	static int32 GetWeaponSimResourceState(const struct FBRWeaponSimulationState& State, int32 Index_0);
	static int32 IdOrRegisterBrickOwner(const class UObject* WorldContextObject, class ABRPlayerController* BrickOwner);
	static int32 IdOrRegisterBrickOwner_NotPresent(const class UObject* WorldContextObject, const struct FBrickOwnerData& BrickOwnerData);
	static bool IsClassPackageBlacklisted(class UClass* Class_0);
	static bool IsContrastColorLight(const struct FLinearColor& Color);
	static bool IsInputActionPressed(const class APlayerController* PlayerController, class FName InputActionName);
	static bool IsInviteCodeFormat(const class FString& String);
	static bool IsObjectPackageBlacklisted(const class UObject* Object);
	static bool IsPublicBuild();
	static class FText JoinTextArray(const TArray<class FText>& SourceArray, const class FText& Separator);
	static struct FTimerHandle K2_SetMultiTimerDelegate(TDelegate<void()> Delegate, float Time, bool bLooping);
	static struct FTimerHandle K2_SetTimerDelegateWithDelay(TDelegate<void()> Delegate, float Time, float FirstDelay, bool bLooping);
	static struct FColor LinearColorToColorNoSRGB(const struct FLinearColor& LinearColor);
	static void NativeBreakpoint();
	static void NaturalSortStringArray(TArray<class FString>& Strings);
	static bool NotEqual_ColorColor(const struct FColor& A, const struct FColor& B);
	static bool NotEqual_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);
	static class UClass* ObjectToClass(class UObject* Object);
	static struct FLinearColor ParseHexStringToLinearColor(const class FString& HexCode);
	static struct FColor RandomFColor();
	static int32 RangeWrapInteger(int32 Input, int32 RangeLowerBound, int32 RangeUpperBound);
	static struct FButtonStyle RecolorButtonStyle(const struct FButtonStyle& Style, const struct FLinearColor& LinearColor);
	static struct FSlateColor RecolorLinearColorFromDiff(const struct FLinearColor& OldColor, const struct FLinearColor& OldNormalColor, const struct FLinearColor& BaseColor);
	static struct FSlateBrush RecolorSlateButtonBrushFromDiff(const struct FSlateBrush& OldBrush, const struct FSlateBrush& OldNormalBrush, const struct FLinearColor& BaseColor);
	static struct FSlateColor RecolorSlateColorFromDiff(const struct FSlateColor& OldColor, const struct FSlateColor& OldNormalColor, const struct FLinearColor& BaseColor);
	static void RestartGame();
	static class FString SanitizeRegexString(const class FString& String);
	static void SetPlatformClipboard(const class FString& String);
	static void SetUnfocusedVolumeMultiplier(float NewMultiplier);
	static void SetWorldGravityZ(const class UObject* WorldContextObject, float GravityZ);
	static void SortPlayerStateArray(TArray<class ABRPlayerState*>& States);
	static void SortPlayerStateArray_ByName(TArray<class ABRPlayerState*>& States);
	static void SortTeamArray(TArray<class UBRRulesetTeam*>& Teams);
	static void SplitNetOptions(const class FString& Options, TMap<class FString, class FString>* Output);
	static class FString TrimStartAndEnd(const class FString& String);
	static class FString UnescapeNetOption(const class FString& Password);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBlueprintLibrary">();
	}
	static class UBRBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBlueprintLibrary>();
	}
};
static_assert(alignof(UBRBlueprintLibrary) == 0x000008, "Wrong alignment on UBRBlueprintLibrary");
static_assert(sizeof(UBRBlueprintLibrary) == 0x000028, "Wrong size on UBRBlueprintLibrary");

// Class Brickadia.BrickComponentType_Internal_JointBase
// 0x0008 (0x01E0 - 0x01D8)
class UBrickComponentType_Internal_JointBase : public UBrickComponentTypeBase
{
public:
	uint8                                         bAllowUseSphereWhenAttached : 1;                   // 0x01D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttachFreeX : 1;                                  // 0x01D8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttachFreeY : 1;                                  // 0x01D8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAttachFreeZ : 1;                                  // 0x01D8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_1D9[0x7];                                      // 0x01D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_JointBase">();
	}
	static class UBrickComponentType_Internal_JointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_JointBase>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_JointBase) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_JointBase");
static_assert(sizeof(UBrickComponentType_Internal_JointBase) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_JointBase");

// Class Brickadia.BrickComponentType_Internal_ConstraintJointBase
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_ConstraintJointBase : public UBrickComponentType_Internal_JointBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_ConstraintJointBase">();
	}
	static class UBrickComponentType_Internal_ConstraintJointBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_ConstraintJointBase>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_ConstraintJointBase) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_ConstraintJointBase");
static_assert(sizeof(UBrickComponentType_Internal_ConstraintJointBase) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_ConstraintJointBase");

// Class Brickadia.BrickComponentType_Internal_Joint_Bearing
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_Bearing : public UBrickComponentType_Internal_ConstraintJointBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_Bearing">();
	}
	static class UBrickComponentType_Internal_Joint_Bearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_Bearing>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_Bearing) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_Bearing");
static_assert(sizeof(UBrickComponentType_Internal_Joint_Bearing) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_Bearing");

// Class Brickadia.BRBulkDataChannel
// 0x00C8 (0x0130 - 0x0068)
class UBRBulkDataChannel final : public UChannel
{
public:
	uint8                                         Pad_68[0xC8];                                      // 0x0068(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBulkDataChannel">();
	}
	static class UBRBulkDataChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBulkDataChannel>();
	}
};
static_assert(alignof(UBRBulkDataChannel) == 0x000008, "Wrong alignment on UBRBulkDataChannel");
static_assert(sizeof(UBRBulkDataChannel) == 0x000130, "Wrong size on UBRBulkDataChannel");

// Class Brickadia.BRBundleManager
// 0x0090 (0x00C0 - 0x0030)
class UBRBundleManager final : public UGameInstanceSubsystem
{
public:
	class UBRBundleDatabase*                      WorldBundle;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRBundleDatabase*                      PendingWorldBundle;                                // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UBRBundleDatabase*> OpenBundles;                                       // 0x0050(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TScriptInterface<class IBRBundleListingProvider> LocalListingProvider;                              // 0x00A0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IBRBundleListingProvider> GalleryListingProvider;                            // 0x00B0(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void RequestTravelToEnvironment(const class FString& Environment, bool bHostListenServer);
	bool RequestTravelToWorld(const class FString& FilePath, int32 Revision, bool bHostListenServer, bool bWriteable);

	TScriptInterface<class IBRBundleListingProvider> GetGalleryListingProvider() const;
	TScriptInterface<class IBRBundleListingProvider> GetLocalListingProvider() const;
	class UBRBundleDatabase* GetPendingWorldBundle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleManager">();
	}
	static class UBRBundleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBundleManager>();
	}
};
static_assert(alignof(UBRBundleManager) == 0x000008, "Wrong alignment on UBRBundleManager");
static_assert(sizeof(UBRBundleManager) == 0x0000C0, "Wrong size on UBRBundleManager");
static_assert(offsetof(UBRBundleManager, WorldBundle) == 0x000030, "Member 'UBRBundleManager::WorldBundle' has a wrong offset!");
static_assert(offsetof(UBRBundleManager, PendingWorldBundle) == 0x000038, "Member 'UBRBundleManager::PendingWorldBundle' has a wrong offset!");
static_assert(offsetof(UBRBundleManager, OpenBundles) == 0x000050, "Member 'UBRBundleManager::OpenBundles' has a wrong offset!");
static_assert(offsetof(UBRBundleManager, LocalListingProvider) == 0x0000A0, "Member 'UBRBundleManager::LocalListingProvider' has a wrong offset!");
static_assert(offsetof(UBRBundleManager, GalleryListingProvider) == 0x0000B0, "Member 'UBRBundleManager::GalleryListingProvider' has a wrong offset!");

// Class Brickadia.BRBundleDataProvider
// 0x0000 (0x0028 - 0x0028)
class IBRBundleDataProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleDataProvider">();
	}
	static class IBRBundleDataProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBRBundleDataProvider>();
	}
};
static_assert(alignof(IBRBundleDataProvider) == 0x000008, "Wrong alignment on IBRBundleDataProvider");
static_assert(sizeof(IBRBundleDataProvider) == 0x000028, "Wrong size on IBRBundleDataProvider");

// Class Brickadia.BRBundleFolderInfoProvider
// 0x0000 (0x0028 - 0x0028)
class IBRBundleFolderInfoProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleFolderInfoProvider">();
	}
	static class IBRBundleFolderInfoProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBRBundleFolderInfoProvider>();
	}
};
static_assert(alignof(IBRBundleFolderInfoProvider) == 0x000008, "Wrong alignment on IBRBundleFolderInfoProvider");
static_assert(sizeof(IBRBundleFolderInfoProvider) == 0x000028, "Wrong size on IBRBundleFolderInfoProvider");

// Class Brickadia.BRBundleListingProvider
// 0x0000 (0x0028 - 0x0028)
class IBRBundleListingProvider final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleListingProvider">();
	}
	static class IBRBundleListingProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBRBundleListingProvider>();
	}
};
static_assert(alignof(IBRBundleListingProvider) == 0x000008, "Wrong alignment on IBRBundleListingProvider");
static_assert(sizeof(IBRBundleListingProvider) == 0x000028, "Wrong size on IBRBundleListingProvider");

// Class Brickadia.BRBundleDataProviderLocal
// 0x0050 (0x0078 - 0x0028)
class UBRBundleDataProviderLocal final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UBRBundleDatabase>       OpenBundle;                                        // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRBundleListingProviderLocal*          ListingProvider;                                   // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRBundleManager*                       BundleManager;                                     // 0x0070(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleDataProviderLocal">();
	}
	static class UBRBundleDataProviderLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBundleDataProviderLocal>();
	}
};
static_assert(alignof(UBRBundleDataProviderLocal) == 0x000008, "Wrong alignment on UBRBundleDataProviderLocal");
static_assert(sizeof(UBRBundleDataProviderLocal) == 0x000078, "Wrong size on UBRBundleDataProviderLocal");
static_assert(offsetof(UBRBundleDataProviderLocal, OpenBundle) == 0x000060, "Member 'UBRBundleDataProviderLocal::OpenBundle' has a wrong offset!");
static_assert(offsetof(UBRBundleDataProviderLocal, ListingProvider) == 0x000068, "Member 'UBRBundleDataProviderLocal::ListingProvider' has a wrong offset!");
static_assert(offsetof(UBRBundleDataProviderLocal, BundleManager) == 0x000070, "Member 'UBRBundleDataProviderLocal::BundleManager' has a wrong offset!");

// Class Brickadia.BRBundleFolderInfoProviderLocal
// 0x0048 (0x0070 - 0x0028)
class UBRBundleFolderInfoProviderLocal final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRBundleListingProviderLocal*          ListingProvider;                                   // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRBundleManager*                       BundleManager;                                     // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleFolderInfoProviderLocal">();
	}
	static class UBRBundleFolderInfoProviderLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBundleFolderInfoProviderLocal>();
	}
};
static_assert(alignof(UBRBundleFolderInfoProviderLocal) == 0x000008, "Wrong alignment on UBRBundleFolderInfoProviderLocal");
static_assert(sizeof(UBRBundleFolderInfoProviderLocal) == 0x000070, "Wrong size on UBRBundleFolderInfoProviderLocal");
static_assert(offsetof(UBRBundleFolderInfoProviderLocal, ListingProvider) == 0x000060, "Member 'UBRBundleFolderInfoProviderLocal::ListingProvider' has a wrong offset!");
static_assert(offsetof(UBRBundleFolderInfoProviderLocal, BundleManager) == 0x000068, "Member 'UBRBundleFolderInfoProviderLocal::BundleManager' has a wrong offset!");

// Class Brickadia.BRBundleListingProviderLocal
// 0x0028 (0x0050 - 0x0028)
class UBRBundleListingProviderLocal final : public UObject
{
public:
	uint8                                         Pad_28[0x18];                                      // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRBundleManager*                       BundleManager;                                     // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleListingProviderLocal">();
	}
	static class UBRBundleListingProviderLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBundleListingProviderLocal>();
	}
};
static_assert(alignof(UBRBundleListingProviderLocal) == 0x000008, "Wrong alignment on UBRBundleListingProviderLocal");
static_assert(sizeof(UBRBundleListingProviderLocal) == 0x000050, "Wrong size on UBRBundleListingProviderLocal");
static_assert(offsetof(UBRBundleListingProviderLocal, BundleManager) == 0x000040, "Member 'UBRBundleListingProviderLocal::BundleManager' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_EntityGate_SetRotation
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_SetRotation final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_SetRotation">();
	}
	static class UBrickComponentType_Internal_EntityGate_SetRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_SetRotation>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_SetRotation) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_SetRotation");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_SetRotation) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_SetRotation");

// Class Brickadia.BRCatalogCustomizationData
// 0x0018 (0x0048 - 0x0030)
class UBRCatalogCustomizationData final : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBRGenericCatalogTabPriority>   TabsThatComeFirst;                                 // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRCatalogCustomizationData">();
	}
	static class UBRCatalogCustomizationData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRCatalogCustomizationData>();
	}
};
static_assert(alignof(UBRCatalogCustomizationData) == 0x000008, "Wrong alignment on UBRCatalogCustomizationData");
static_assert(sizeof(UBRCatalogCustomizationData) == 0x000048, "Wrong size on UBRCatalogCustomizationData");
static_assert(offsetof(UBRCatalogCustomizationData, PrimaryAssetType) == 0x000030, "Member 'UBRCatalogCustomizationData::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(UBRCatalogCustomizationData, TabsThatComeFirst) == 0x000038, "Member 'UBRCatalogCustomizationData::TabsThatComeFirst' has a wrong offset!");

// Class Brickadia.BRCatalogObject
// 0x0000 (0x0028 - 0x0028)
class IBRCatalogObject final : public IInterface
{
public:
	struct FBRCatalogData GetCatalogData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRCatalogObject">();
	}
	static class IBRCatalogObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBRCatalogObject>();
	}
};
static_assert(alignof(IBRCatalogObject) == 0x000008, "Wrong alignment on IBRCatalogObject");
static_assert(sizeof(IBRCatalogObject) == 0x000028, "Wrong size on IBRCatalogObject");

// Class Brickadia.BrickComponentType_Internal_Joint_Servo
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_Servo final : public UBrickComponentType_Internal_Joint_Bearing
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_Servo">();
	}
	static class UBrickComponentType_Internal_Joint_Servo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_Servo>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_Servo) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_Servo");
static_assert(sizeof(UBrickComponentType_Internal_Joint_Servo) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_Servo");

// Class Brickadia.BRCatalog
// 0x0060 (0x0088 - 0x0028)
class UBRCatalog final : public UObject
{
public:
	TArray<struct FBRCatalogTab>                  CatalogTabs;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, int32>                      TabLookup;                                         // 0x0038(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UBRCatalog* Combined(const TArray<class UBRCatalog*>& Catalogs, class UBRCatalogCustomizationData* Customization);

	void AddItem(class UObject* Item, const class FText& Name_0, const class FText& Category, const class FText& Tab, const class FText& Summary, const struct FBRCatalogOverrides& Overrides);
	void Sort(class UBRCatalogCustomizationData* Customization);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRCatalog">();
	}
	static class UBRCatalog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRCatalog>();
	}
};
static_assert(alignof(UBRCatalog) == 0x000008, "Wrong alignment on UBRCatalog");
static_assert(sizeof(UBRCatalog) == 0x000088, "Wrong size on UBRCatalog");
static_assert(offsetof(UBRCatalog, CatalogTabs) == 0x000028, "Member 'UBRCatalog::CatalogTabs' has a wrong offset!");
static_assert(offsetof(UBRCatalog, TabLookup) == 0x000038, "Member 'UBRCatalog::TabLookup' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor
// 0x0060 (0x0088 - 0x0028)
class UInspectorPropertyDescriptor : public UObject
{
public:
	class FName                                   Name_0;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Tooltip;                                           // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanSetToDefault;                                  // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInspectorPropertyWidgetBase> WidgetClassOverride;                               // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, AdvancedDisplay, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGetFunction;                                   // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSetFunction;                                   // 0x0061(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GetFunctionOverride;                               // 0x0064(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SetFunctionOverride;                               // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EIsEnabledMode                                IsEnabledMode;                                     // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IsEnabledFunctionOrProperty;                       // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEnabled(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget);
	void SetValue(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, const struct FInspectorPropertyValue& ChangeValue, bool bRunNotify);

	struct FInspectorPropertyValue GetDefaultValue(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget) const;
	struct FInspectorPropertyValue GetValue(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget) const;
	bool IsDefaultValue(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor">();
	}
	static class UInspectorPropertyDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor");
static_assert(sizeof(UInspectorPropertyDescriptor) == 0x000088, "Wrong size on UInspectorPropertyDescriptor");
static_assert(offsetof(UInspectorPropertyDescriptor, Name_0) == 0x000028, "Member 'UInspectorPropertyDescriptor::Name_0' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, DisplayName) == 0x000030, "Member 'UInspectorPropertyDescriptor::DisplayName' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, Tooltip) == 0x000040, "Member 'UInspectorPropertyDescriptor::Tooltip' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, bCanSetToDefault) == 0x000050, "Member 'UInspectorPropertyDescriptor::bCanSetToDefault' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, WidgetClassOverride) == 0x000058, "Member 'UInspectorPropertyDescriptor::WidgetClassOverride' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, bUseGetFunction) == 0x000060, "Member 'UInspectorPropertyDescriptor::bUseGetFunction' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, bUseSetFunction) == 0x000061, "Member 'UInspectorPropertyDescriptor::bUseSetFunction' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, GetFunctionOverride) == 0x000064, "Member 'UInspectorPropertyDescriptor::GetFunctionOverride' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, SetFunctionOverride) == 0x00006C, "Member 'UInspectorPropertyDescriptor::SetFunctionOverride' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, IsEnabledMode) == 0x000074, "Member 'UInspectorPropertyDescriptor::IsEnabledMode' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, IsEnabledFunctionOrProperty) == 0x000078, "Member 'UInspectorPropertyDescriptor::IsEnabledFunctionOrProperty' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor, bHidden) == 0x000080, "Member 'UInspectorPropertyDescriptor::bHidden' has a wrong offset!");

// Class Brickadia.BrickComponentType_Switch
// 0x0018 (0x0200 - 0x01E8)
class UBrickComponentType_Switch : public UBrickComponentType_InteractableBase
{
public:
	class UBrickOneShotAudioDescriptor*           DefaultInteractSound;                              // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      InteractAttenuation;                               // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      InteractConcurrency;                               // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Switch">();
	}
	static class UBrickComponentType_Switch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Switch>();
	}
};
static_assert(alignof(UBrickComponentType_Switch) == 0x000008, "Wrong alignment on UBrickComponentType_Switch");
static_assert(sizeof(UBrickComponentType_Switch) == 0x000200, "Wrong size on UBrickComponentType_Switch");
static_assert(offsetof(UBrickComponentType_Switch, DefaultInteractSound) == 0x0001E8, "Member 'UBrickComponentType_Switch::DefaultInteractSound' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Switch, InteractAttenuation) == 0x0001F0, "Member 'UBrickComponentType_Switch::InteractAttenuation' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Switch, InteractConcurrency) == 0x0001F8, "Member 'UBrickComponentType_Switch::InteractConcurrency' has a wrong offset!");

// Class Brickadia.BRInspectorPropertyDescriptor_PrimaryAssetCatalog
// 0x0020 (0x00A8 - 0x0088)
class UBRInspectorPropertyDescriptor_PrimaryAssetCatalog final : public UInspectorPropertyDescriptor
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeNull;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UThumbnailProcessor>        OverrideThumbnailProcessorClass;                   // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogWidget>    OverrideCatalogWidget;                             // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AsyncGenerateCatalog(class UObject* WorldContext, const TDelegate<void(class UBRCatalog* CreatedCatalog)>& OnLoadedDelegate);
	struct FBRCatalogData NameToCatalogData(class FName NameValue);
	class UObject* NameToObject(class FName NameValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInspectorPropertyDescriptor_PrimaryAssetCatalog">();
	}
	static class UBRInspectorPropertyDescriptor_PrimaryAssetCatalog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInspectorPropertyDescriptor_PrimaryAssetCatalog>();
	}
};
static_assert(alignof(UBRInspectorPropertyDescriptor_PrimaryAssetCatalog) == 0x000008, "Wrong alignment on UBRInspectorPropertyDescriptor_PrimaryAssetCatalog");
static_assert(sizeof(UBRInspectorPropertyDescriptor_PrimaryAssetCatalog) == 0x0000A8, "Wrong size on UBRInspectorPropertyDescriptor_PrimaryAssetCatalog");
static_assert(offsetof(UBRInspectorPropertyDescriptor_PrimaryAssetCatalog, PrimaryAssetType) == 0x000088, "Member 'UBRInspectorPropertyDescriptor_PrimaryAssetCatalog::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(UBRInspectorPropertyDescriptor_PrimaryAssetCatalog, bCanBeNull) == 0x000090, "Member 'UBRInspectorPropertyDescriptor_PrimaryAssetCatalog::bCanBeNull' has a wrong offset!");
static_assert(offsetof(UBRInspectorPropertyDescriptor_PrimaryAssetCatalog, OverrideThumbnailProcessorClass) == 0x000098, "Member 'UBRInspectorPropertyDescriptor_PrimaryAssetCatalog::OverrideThumbnailProcessorClass' has a wrong offset!");
static_assert(offsetof(UBRInspectorPropertyDescriptor_PrimaryAssetCatalog, OverrideCatalogWidget) == 0x0000A0, "Member 'UBRInspectorPropertyDescriptor_PrimaryAssetCatalog::OverrideCatalogWidget' has a wrong offset!");

// Class Brickadia.BRCatalogSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UBRCatalogSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FName, class UBRCatalog*>          CachedCatalogs;                                    // 0x0030(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<struct FPrimaryAssetType, class UBRCatalogCustomizationData*> Customizations;                                    // 0x0080(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void AsyncGetOrGeneratePrimaryAssetCatalog(const struct FPrimaryAssetType& Type, const TDelegate<void(class UBRCatalog* CreatedCatalog)>& OnLoadedDelegate, class FName CacheName, const struct FBRCatalogOverrides& Overrides);
	class UBRCatalog* GetOrGenerateCatalog(const TArray<class UObject*>& Assets, class FName CacheName, class UBRCatalogCustomizationData* Customization, const struct FBRCatalogOverrides& Overrides);
	class UBRCatalog* SyncGetOrGeneratePrimaryAssetCatalog(const struct FPrimaryAssetType& Type, class FName CacheName, const struct FBRCatalogOverrides& Overrides);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRCatalogSubsystem">();
	}
	static class UBRCatalogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRCatalogSubsystem>();
	}
};
static_assert(alignof(UBRCatalogSubsystem) == 0x000008, "Wrong alignment on UBRCatalogSubsystem");
static_assert(sizeof(UBRCatalogSubsystem) == 0x0000D0, "Wrong size on UBRCatalogSubsystem");
static_assert(offsetof(UBRCatalogSubsystem, CachedCatalogs) == 0x000030, "Member 'UBRCatalogSubsystem::CachedCatalogs' has a wrong offset!");
static_assert(offsetof(UBRCatalogSubsystem, Customizations) == 0x000080, "Member 'UBRCatalogSubsystem::Customizations' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_EntityGate_SetLocationAndRotation
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_SetLocationAndRotation final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_SetLocationAndRotation">();
	}
	static class UBrickComponentType_Internal_EntityGate_SetLocationAndRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_SetLocationAndRotation>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_SetLocationAndRotation) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_SetLocationAndRotation");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_SetLocationAndRotation) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_SetLocationAndRotation");

// Class Brickadia.BRCharacter
// 0x0540 (0x0B90 - 0x0650)
class ABRCharacter : public ACharacter
{
public:
	uint8                                         Pad_648[0x8];                                      // 0x0648(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABRCharacter* Character, float FinalDamage, const class UDamageType* DeathType, class AActor* DeathCauser, class FName ImpulseBone, const struct FVector& ImpulseDirection, const struct FVector& PreDeathVelocity)> OnDeath;                                           // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x18];                                     // 0x0660(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldPlayFootsteps;                              // 0x0678(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_679[0x7];                                      // 0x0679(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              FootstepSoundCue;                                  // 0x0680(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        FootstepAudioComponent;                            // 0x0688(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class USoundBase*, class UAudioComponent*> ActiveFootstepLayers;                              // 0x0690(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bCollideWithPawns;                                 // 0x06E0(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanStackWithPawns;                                // 0x06E1(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGhost;                                            // 0x06E2(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReplicatedControlMode;                             // 0x06E3(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTouchingWater;                                  // 0x06E4(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E5[0x17];                                     // 0x06E5(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActivateRange;                                     // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_700[0xC];                                      // 0x0700(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInteractHeld;                                     // 0x070C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70D[0x3];                                      // 0x070D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicsHandleComponent*                PhysicsHandleNative;                               // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_718[0x20];                                     // 0x0718(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRManipulatorInputCapturer*            GrabInputCapturer;                                 // 0x0738(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGrabbingPhysicsObject;                          // 0x0740(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasGrabbableTarget;                               // 0x0741(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasUseableTarget;                                 // 0x0742(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_743[0x5];                                      // 0x0743(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPrimitiveComponent*>            CurrentOverlappedComponents;                       // 0x0748(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_758[0x10];                                     // 0x0758(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABRCharacter* Character, float Damage, float DamageLimit)> OnHealthChanged;                                   // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FName                                   LastDamagedBoneName;                               // 0x0778(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LastDamageDirection;                               // 0x0780(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                SelfDestructDamageType;                            // 0x0798(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                PhysicsDamageType;                                 // 0x07A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x07A8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInvincible;                                     // 0x07A9(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanSelfDestruct;                                  // 0x07AA(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7AB[0x1];                                      // 0x07AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Damage;                                            // 0x07AC(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DamageLimit;                                       // 0x07B0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_7B4[0x1C];                                     // 0x07B4(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABRItemBase* Item)> OnWieldItem;                                       // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRItemBase* Item)> OnUnwieldItem;                                     // 0x07E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRInventoryEntryBase* Entry)> OnActiveInventoryEntryChanged;                     // 0x07F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBRWeaponSimulationState_Character     WeaponSimState;                                    // 0x0800(0x0030)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBRWeaponSimulationInputs_Character    PendingWeaponSimInputs;                            // 0x0830(0x0002)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_832[0x6];                                      // 0x0832(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRWeaponSimulationState_Character_RepOwner ReplicatedWeaponSimState_Owner;                    // 0x0838(0x00A0)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FBRWeaponSimulationState_Character_RepRemote ReplicatedWeaponSimState_Remote;                   // 0x08D8(0x0018)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBRWeaponPredictionHistory_Character   WeaponSimHistory;                                  // 0x08F0(0x0010)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_900[0x8];                                      // 0x0900(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRInventoryComponent*                  CharacterInventory;                                // 0x0908(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUsePlayerParts;                                   // 0x0910(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_911[0x7];                                      // 0x0911(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRPlayerAvatarCustomizationV3         ReplicatedAvatar;                                  // 0x0918(0x0010)(Net, Transient, RepNotify, NativeAccessSpecifierPublic)
	TArray<class UBRPlayerPartComponent*>         PlayerParts;                                       // 0x0928(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBRPlayerPartComponent*>         ViewModelPlayerParts;                              // 0x0938(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRPlayerPartSocketTree>    PartSocketTree;                                    // 0x0948(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPartCollisionEnabledForAvatarEditing;             // 0x0950(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_951[0x7];                                      // 0x0951(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, class UBRPlayerPartComponent*>    TreeIndexPartMap;                                  // 0x0958(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<int32, class UBRPlayerPartComponent*>    TreeIndexViewModelPartMap;                         // 0x09A8(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bOutOfBody;                                        // 0x09F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F9[0x7];                                      // 0x09F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               OutOfBodyRotation;                                 // 0x0A00(0x0018)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                TargetViewModelOffset;                             // 0x0A18(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraArmComponent;                                // 0x0A30(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraComponent*                       CameraComponent;                                   // 0x0A38(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkeletalMeshComponent*                 ViewModelComponent;                                // 0x0A40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A48[0x20];                                     // 0x0A48(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocalPointAtLocation;                              // 0x0A68(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PointAtLocation;                                   // 0x0A80(0x0018)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPoint;                                         // 0x0A98(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseAlternateJump;                                 // 0x0A99(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9A[0x6];                                      // 0x0A9A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ActorDeltaRotation;                                // 0x0AA0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               AimDeltaRotation;                                  // 0x0AB8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               PreviousActorRotation;                             // 0x0AD0(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FRotator                               PreviousAimRotation;                               // 0x0AE8(0x0018)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBrickLatentHandle                     PendingSeatBrickHandle;                            // 0x0B00(0x000C)(Net, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0C[0x4C];                                     // 0x0B0C(0x004C)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      SeatCollider;                                      // 0x0B58(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBrickHandle                           LocalClosestInteractableBrick;                     // 0x0B60(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrickHandle                           CurrentAimBrick;                                   // 0x0B68(0x0008)(Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRInteractablePromptWidget> InteractableWidgetClass;                           // 0x0B70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetComponent*                       InteractableWidgetComponent;                       // 0x0B78(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearbyInteractRadius;                              // 0x0B80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B84[0xC];                                      // 0x0B84(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsAnyPartTagValid(const TArray<class FName>& PartTags, const TSet<class FName>& AllowedTags);

	void AddStartingInventory();
	bool AttachPlayerDecal(class UBRPlayerDecalDescriptor* Descriptor);
	class UBRPlayerPartComponent* AttachPlayerPart(class UBRPlayerPartDescriptor* Descriptor, bool bIgnoreRules);
	class UBRPlayerPartComponent* AttachPlayerPartBySocketName(class UBRPlayerPartDescriptor* Descriptor, class FName InSocketName, bool bIgnoreRules);
	class UBRPlayerPartComponent* AttachPlayerPartByTreeIndex(class UBRPlayerPartDescriptor* Descriptor, int32 TreeIndex, bool bIgnoreRules);
	bool AttachRequiredParts(TArray<class UBRPlayerPartComponent*>* OutAttachedParts);
	struct FBRPlayerAvatarCustomizationV3 BuildAvatarCustomizationFromPlayerParts();
	bool BuildPlayerAvatar(const struct FBRPlayerAvatarCustomizationV3& NewAvatar, bool bIgnoreRules);
	void ChangeSeatZoomLevel(const float Amount);
	void ClearDesiredInventoryIndex();
	void ClientOnObjectReleased();
	void ClientSetFirstPerson(bool bNewFirstPerson);
	void ClientSetFlying(EBRCharacterFlyMode NewFlyMode);
	void EquipPlacer();
	void HandleAttachWieldedItem(class ABRItemBase* Instance);
	void HandleDetachWieldedItem(class ABRItemBase* Instance);
	void HandleLocalGeneralSettingsChanged(class UBRGameSettingsBase* SettingsObject);
	bool IsGhost();
	void MaybeStartInteract();
	void MaybeStopInteract();
	void MulticastHandleDeath(float FinalDamage, const class UDamageType* DeathType, class ABRPlayerState* InstigatedBy, class AActor* DeathCauser, class FName ImpulseBone, const struct FVector_NetQuantizeNormal& ImpulseDirection, const struct FVector_NetQuantize100& PreDeathVelocity);
	void MulticastOnInteractPress(EBRCharacterInteractAnimType AnimType);
	void MulticastOnInteractRelease();
	void MulticastOnObjectGrabbed();
	void MulticastPlaySound(class USoundBase* Sound);
	void MulticastSetIgnoreBaseRotation(bool bNewIgnoreBaseRotation);
	void OnGrabRotatePressed();
	void OnGrabRotateReleased();
	void OnHealthRegenStart();
	void OnInteractPress(EBRCharacterInteractAnimType AnimType);
	void OnInteractRelease();
	void OnObjectGrabbed();
	void OnRep_CollideWithPawns();
	void OnRep_Ghost();
	void OnRep_Health();
	void OnRep_PendingSeatBrickHandle();
	void OnRep_PointAtLocation();
	void OnRep_ReplicatedAvatar();
	void OnRep_ReplicatedControlMode();
	void OnRep_StackWithPawns();
	void OnRep_WeaponSimState_Owner();
	void OnRep_WeaponSimState_Remote();
	void OnRespawnInvulnerabilityExpire();
	void OnSelfDestructPreventionEnd();
	void PauseAnimMontage(class UAnimMontage* AnimMontage);
	void PlayAnimMontageFromTime(class UAnimMontage* AnimMontage, float Rate, float StartTime);
	void PlayFootstepSound(int32 Type, float VolumeMultiplier);
	void PopFootstepLayer(class USoundBase* LayerSound);
	void PushFootstepLayer(class USoundBase* LayerSound);
	void ReceiveOnRep_PlayerState();
	void RemoveAllPlayerParts();
	void RemoveChildrenPlayerPartsFromSocketName(class FName SocketName);
	void RemoveChildrenPlayerPartsFromTreeIndex(int32 TreeIndex);
	void RemovePlayerPartAtSocketName(class FName SocketName, bool bRemoveChildren);
	void RemovePlayerPartAtTreeIndex(int32 TreeIndex, bool bRemoveChildren);
	void ResetPlayerParts();
	void ResumeAnimMontage(class UAnimMontage* AnimMontage);
	void ServerGrabObject(class UPrimitiveComponent* ObjectToGrab, const struct FVector& HitLocation, float HitDistance);
	void ServerLeaveSeat();
	void ServerMaybeStartInteract(const struct FBrickHandle& BrickHandle, EBRCharacterInteractAnimType AnimType, bool bIsNearbyInteraction);
	void ServerProcessMousePitchForGrab(float Pitch);
	void ServerProcessMouseYawForGrab(float Yaw);
	void ServerReleaseHeldObject();
	void ServerSelfDestruct();
	void ServerSetDesiredIgnoreBaseRotation(bool bIgnoreBaseRotation);
	void ServerSetOutOfBody(bool bNewOutOfBody);
	void ServerSetOutOfBodyRotation(const struct FRotator& NewRotation);
	void ServerStopAnyInteract();
	void ServerTeleportToView();
	void SetCamera(class FName ComponentName);
	void SetCameraArm(class FName ComponentName);
	void SetCanStack(bool bStacks);
	void SetDamage(float DamageIn);
	void SetDamageLimit(float Limit);
	void SetDesiredMainInventoryIndex(int32 Index_0);
	void SetDesiredToolInventoryIndex(int32 Index_0);
	void SetDesiredToTempSlot();
	void SetFirstPerson(bool bNewFirstPerson);
	void SetFlyMode(EBRCharacterFlyMode NewFlyMode);
	void SetGhost(bool bNewGhost);
	void SetOutOfBody(bool bNewOutOfBody);
	void SetOutOfBodyRotation(const struct FRotator& NewRotation);
	void SetPartCollisionEnabledForAvatarEditing(bool bNewCollision);
	void SetPawnCollision(bool bCollides);
	void SetPlayerPartVisibility(bool bThirdPerson);
	void SetSprinting(bool bNewSprinting);
	void SetViewModel(class FName ComponentName);
	void SkipFirstPersonTransitionAnimation();
	void StopAnimMontageImmediately(class UAnimMontage* AnimMontage);
	void TryAutoToggleTool(TSubclassOf<class ABRToolBase> Tool);

	bool CanAttachPlayerPartAtTreeIndex(const class UBRPlayerPartDescriptor* Descriptor, int32 TreeIndex) const;
	bool CanFly() const;
	bool CanGhost() const;
	class UBRPlayerPartComponent* FindPlayerPartByTreeIndex(int32 TreeIndex) const;
	struct FRotator GetActorDeltaRotation() const;
	struct FRotator GetAimDeltaRotation() const;
	void GetAvailableSocketsFromDecal(const class UBRPlayerDecalDescriptor* Descriptor, TArray<int32>* TreeIndices) const;
	void GetAvailableSocketsFromPart(class UBRPlayerPartDescriptor* Descriptor, TArray<int32>* TreeIndices) const;
	class UBRCharacterMovementComponent* GetBRCharacterMovement() const;
	class ABRPlayerController* GetBRPlayerController() const;
	class ABRPlayerState* GetBRPlayerState() const;
	class UCameraComponent* GetCamera() const;
	class USpringArmComponent* GetCameraArm() const;
	bool GetCanStack() const;
	class UBRInventoryComponent* GetCharacterInventory() const;
	class UBRInventoryEntryBase* GetCharacterInventoryEntry(int32 Slot) const;
	class UBRInventoryEntryBase* GetCharacterTempInventoryEntry() const;
	class UBRInventoryEntryBase* GetCurrentInventoryEntry() const;
	float GetDamage() const;
	float GetDamageLimit() const;
	TSubclassOf<class ABRItemBase> GetDesiredItemClass() const;
	class ABRItemBase* GetDesiredItemInstance() const;
	struct FVector GetFireOcclusionStartPosition() const;
	EBRCharacterFlyMode GetFlyMode() const;
	bool GetFreeMouse() const;
	struct FTransform GetItemAttachmentSocketTransform() const;
	TSubclassOf<class ABRItemBase> GetItemClass() const;
	class ABRItemBase* GetItemInstance() const;
	struct FVector GetItemMuzzleLocationLocalSpace(class FName MuzzleSocket) const;
	struct FVector GetLocationUnderCrosshair(const struct FVector& PointOnStartPlane, float Latency, float Radius) const;
	bool GetOutOfBody() const;
	struct FRotator GetOutOfBodyRotation() const;
	bool GetPawnCollision() const;
	void GetRemainingRequiredParts(TArray<int32>* TreeIndices) const;
	struct FBrickHandle GetSeatBrick() const;
	struct FVector GetSeatedOffset() const;
	struct FRotator GetSeatedRotation() const;
	float GetSeatZoomLevel(float Amount) const;
	bool GetShowFirstPersonModel() const;
	bool GetSprinting() const;
	class USkeletalMeshComponent* GetViewModel() const;
	bool HasItem() const;
	bool HasRequiredPartsAttached() const;
	bool IsFirstPerson() const;
	bool IsSitting() const;
	bool IsStrafing() const;
	void MulticastDebugDrawBoxes(const TArray<struct FTransform>& BoxTransforms, const TArray<struct FVector>& BoxExtents, const struct FVector& Start, const struct FVector& End, bool bHit) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRCharacter">();
	}
	static class ABRCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRCharacter>();
	}
};
static_assert(alignof(ABRCharacter) == 0x000010, "Wrong alignment on ABRCharacter");
static_assert(sizeof(ABRCharacter) == 0x000B90, "Wrong size on ABRCharacter");
static_assert(offsetof(ABRCharacter, OnDeath) == 0x000650, "Member 'ABRCharacter::OnDeath' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bShouldPlayFootsteps) == 0x000678, "Member 'ABRCharacter::bShouldPlayFootsteps' has a wrong offset!");
static_assert(offsetof(ABRCharacter, FootstepSoundCue) == 0x000680, "Member 'ABRCharacter::FootstepSoundCue' has a wrong offset!");
static_assert(offsetof(ABRCharacter, FootstepAudioComponent) == 0x000688, "Member 'ABRCharacter::FootstepAudioComponent' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ActiveFootstepLayers) == 0x000690, "Member 'ABRCharacter::ActiveFootstepLayers' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bCollideWithPawns) == 0x0006E0, "Member 'ABRCharacter::bCollideWithPawns' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bCanStackWithPawns) == 0x0006E1, "Member 'ABRCharacter::bCanStackWithPawns' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bGhost) == 0x0006E2, "Member 'ABRCharacter::bGhost' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ReplicatedControlMode) == 0x0006E3, "Member 'ABRCharacter::ReplicatedControlMode' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bIsTouchingWater) == 0x0006E4, "Member 'ABRCharacter::bIsTouchingWater' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ActivateRange) == 0x0006FC, "Member 'ABRCharacter::ActivateRange' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bInteractHeld) == 0x00070C, "Member 'ABRCharacter::bInteractHeld' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PhysicsHandleNative) == 0x000710, "Member 'ABRCharacter::PhysicsHandleNative' has a wrong offset!");
static_assert(offsetof(ABRCharacter, GrabInputCapturer) == 0x000738, "Member 'ABRCharacter::GrabInputCapturer' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bIsGrabbingPhysicsObject) == 0x000740, "Member 'ABRCharacter::bIsGrabbingPhysicsObject' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bHasGrabbableTarget) == 0x000741, "Member 'ABRCharacter::bHasGrabbableTarget' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bHasUseableTarget) == 0x000742, "Member 'ABRCharacter::bHasUseableTarget' has a wrong offset!");
static_assert(offsetof(ABRCharacter, CurrentOverlappedComponents) == 0x000748, "Member 'ABRCharacter::CurrentOverlappedComponents' has a wrong offset!");
static_assert(offsetof(ABRCharacter, OnHealthChanged) == 0x000768, "Member 'ABRCharacter::OnHealthChanged' has a wrong offset!");
static_assert(offsetof(ABRCharacter, LastDamagedBoneName) == 0x000778, "Member 'ABRCharacter::LastDamagedBoneName' has a wrong offset!");
static_assert(offsetof(ABRCharacter, LastDamageDirection) == 0x000780, "Member 'ABRCharacter::LastDamageDirection' has a wrong offset!");
static_assert(offsetof(ABRCharacter, SelfDestructDamageType) == 0x000798, "Member 'ABRCharacter::SelfDestructDamageType' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PhysicsDamageType) == 0x0007A0, "Member 'ABRCharacter::PhysicsDamageType' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bIsDead) == 0x0007A8, "Member 'ABRCharacter::bIsDead' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bIsInvincible) == 0x0007A9, "Member 'ABRCharacter::bIsInvincible' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bCanSelfDestruct) == 0x0007AA, "Member 'ABRCharacter::bCanSelfDestruct' has a wrong offset!");
static_assert(offsetof(ABRCharacter, Damage) == 0x0007AC, "Member 'ABRCharacter::Damage' has a wrong offset!");
static_assert(offsetof(ABRCharacter, DamageLimit) == 0x0007B0, "Member 'ABRCharacter::DamageLimit' has a wrong offset!");
static_assert(offsetof(ABRCharacter, OnWieldItem) == 0x0007D0, "Member 'ABRCharacter::OnWieldItem' has a wrong offset!");
static_assert(offsetof(ABRCharacter, OnUnwieldItem) == 0x0007E0, "Member 'ABRCharacter::OnUnwieldItem' has a wrong offset!");
static_assert(offsetof(ABRCharacter, OnActiveInventoryEntryChanged) == 0x0007F0, "Member 'ABRCharacter::OnActiveInventoryEntryChanged' has a wrong offset!");
static_assert(offsetof(ABRCharacter, WeaponSimState) == 0x000800, "Member 'ABRCharacter::WeaponSimState' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PendingWeaponSimInputs) == 0x000830, "Member 'ABRCharacter::PendingWeaponSimInputs' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ReplicatedWeaponSimState_Owner) == 0x000838, "Member 'ABRCharacter::ReplicatedWeaponSimState_Owner' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ReplicatedWeaponSimState_Remote) == 0x0008D8, "Member 'ABRCharacter::ReplicatedWeaponSimState_Remote' has a wrong offset!");
static_assert(offsetof(ABRCharacter, WeaponSimHistory) == 0x0008F0, "Member 'ABRCharacter::WeaponSimHistory' has a wrong offset!");
static_assert(offsetof(ABRCharacter, CharacterInventory) == 0x000908, "Member 'ABRCharacter::CharacterInventory' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bUsePlayerParts) == 0x000910, "Member 'ABRCharacter::bUsePlayerParts' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ReplicatedAvatar) == 0x000918, "Member 'ABRCharacter::ReplicatedAvatar' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PlayerParts) == 0x000928, "Member 'ABRCharacter::PlayerParts' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ViewModelPlayerParts) == 0x000938, "Member 'ABRCharacter::ViewModelPlayerParts' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PartSocketTree) == 0x000948, "Member 'ABRCharacter::PartSocketTree' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bPartCollisionEnabledForAvatarEditing) == 0x000950, "Member 'ABRCharacter::bPartCollisionEnabledForAvatarEditing' has a wrong offset!");
static_assert(offsetof(ABRCharacter, TreeIndexPartMap) == 0x000958, "Member 'ABRCharacter::TreeIndexPartMap' has a wrong offset!");
static_assert(offsetof(ABRCharacter, TreeIndexViewModelPartMap) == 0x0009A8, "Member 'ABRCharacter::TreeIndexViewModelPartMap' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bOutOfBody) == 0x0009F8, "Member 'ABRCharacter::bOutOfBody' has a wrong offset!");
static_assert(offsetof(ABRCharacter, OutOfBodyRotation) == 0x000A00, "Member 'ABRCharacter::OutOfBodyRotation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, TargetViewModelOffset) == 0x000A18, "Member 'ABRCharacter::TargetViewModelOffset' has a wrong offset!");
static_assert(offsetof(ABRCharacter, CameraArmComponent) == 0x000A30, "Member 'ABRCharacter::CameraArmComponent' has a wrong offset!");
static_assert(offsetof(ABRCharacter, CameraComponent) == 0x000A38, "Member 'ABRCharacter::CameraComponent' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ViewModelComponent) == 0x000A40, "Member 'ABRCharacter::ViewModelComponent' has a wrong offset!");
static_assert(offsetof(ABRCharacter, LocalPointAtLocation) == 0x000A68, "Member 'ABRCharacter::LocalPointAtLocation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PointAtLocation) == 0x000A80, "Member 'ABRCharacter::PointAtLocation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bCanPoint) == 0x000A98, "Member 'ABRCharacter::bCanPoint' has a wrong offset!");
static_assert(offsetof(ABRCharacter, bUseAlternateJump) == 0x000A99, "Member 'ABRCharacter::bUseAlternateJump' has a wrong offset!");
static_assert(offsetof(ABRCharacter, ActorDeltaRotation) == 0x000AA0, "Member 'ABRCharacter::ActorDeltaRotation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, AimDeltaRotation) == 0x000AB8, "Member 'ABRCharacter::AimDeltaRotation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PreviousActorRotation) == 0x000AD0, "Member 'ABRCharacter::PreviousActorRotation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PreviousAimRotation) == 0x000AE8, "Member 'ABRCharacter::PreviousAimRotation' has a wrong offset!");
static_assert(offsetof(ABRCharacter, PendingSeatBrickHandle) == 0x000B00, "Member 'ABRCharacter::PendingSeatBrickHandle' has a wrong offset!");
static_assert(offsetof(ABRCharacter, SeatCollider) == 0x000B58, "Member 'ABRCharacter::SeatCollider' has a wrong offset!");
static_assert(offsetof(ABRCharacter, LocalClosestInteractableBrick) == 0x000B60, "Member 'ABRCharacter::LocalClosestInteractableBrick' has a wrong offset!");
static_assert(offsetof(ABRCharacter, CurrentAimBrick) == 0x000B68, "Member 'ABRCharacter::CurrentAimBrick' has a wrong offset!");
static_assert(offsetof(ABRCharacter, InteractableWidgetClass) == 0x000B70, "Member 'ABRCharacter::InteractableWidgetClass' has a wrong offset!");
static_assert(offsetof(ABRCharacter, InteractableWidgetComponent) == 0x000B78, "Member 'ABRCharacter::InteractableWidgetComponent' has a wrong offset!");
static_assert(offsetof(ABRCharacter, NearbyInteractRadius) == 0x000B80, "Member 'ABRCharacter::NearbyInteractRadius' has a wrong offset!");

// Class Brickadia.BRCharacterMovementComponent
// 0x04A0 (0x1330 - 0x0E90)
class UBRCharacterMovementComponent final : public UCharacterMovementComponent
{
public:
	float                                         MaxWalkSpeedSprinting;                             // 0x0E88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFlySpeedSprinting;                              // 0x0E8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAccelerationWhileFlying;                        // 0x0E90(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E94[0x4];                                      // 0x0E94(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(EBRCharacterFlyMode bFlying)> OnFlyingChanged;                                   // 0x0E98(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EBRCharacterFlyMode bFlying)> OnSprintingChanged;                                // 0x0EA8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(EBRCharacterControlMode ControlMode)> OnControlModeChanged;                              // 0x0EB8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC8[0x38];                                     // 0x0EC8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReplicatedVehicleControlInput;                     // 0x0F00(0x0018)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F18[0x418];                                    // 0x0F18(0x0418)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddVehicleControlInput(const struct FVector& VehicleDirection, const float ScaleValue);
	void OnRep_ReplicatedVehicleControlInput();
	void SetControlMode(EBRCharacterControlMode NewControlMode);
	void SetFlyMode(EBRCharacterFlyMode NewFlyMode);
	void SetSprinting(bool bNewSprinting);

	class ABRCharacter* GetBRCharacterOwner() const;
	struct FVector GetClientVehicleControlInput() const;
	EBRCharacterControlMode GetControlMode() const;
	EBRCharacterFlyMode GetFlyMode() const;
	bool GetSprinting() const;
	bool IsFirstPerson() const;
	bool IsStrafing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRCharacterMovementComponent">();
	}
	static class UBRCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRCharacterMovementComponent>();
	}
};
static_assert(alignof(UBRCharacterMovementComponent) == 0x000010, "Wrong alignment on UBRCharacterMovementComponent");
static_assert(sizeof(UBRCharacterMovementComponent) == 0x001330, "Wrong size on UBRCharacterMovementComponent");
static_assert(offsetof(UBRCharacterMovementComponent, MaxWalkSpeedSprinting) == 0x000E88, "Member 'UBRCharacterMovementComponent::MaxWalkSpeedSprinting' has a wrong offset!");
static_assert(offsetof(UBRCharacterMovementComponent, MaxFlySpeedSprinting) == 0x000E8C, "Member 'UBRCharacterMovementComponent::MaxFlySpeedSprinting' has a wrong offset!");
static_assert(offsetof(UBRCharacterMovementComponent, MaxAccelerationWhileFlying) == 0x000E90, "Member 'UBRCharacterMovementComponent::MaxAccelerationWhileFlying' has a wrong offset!");
static_assert(offsetof(UBRCharacterMovementComponent, OnFlyingChanged) == 0x000E98, "Member 'UBRCharacterMovementComponent::OnFlyingChanged' has a wrong offset!");
static_assert(offsetof(UBRCharacterMovementComponent, OnSprintingChanged) == 0x000EA8, "Member 'UBRCharacterMovementComponent::OnSprintingChanged' has a wrong offset!");
static_assert(offsetof(UBRCharacterMovementComponent, OnControlModeChanged) == 0x000EB8, "Member 'UBRCharacterMovementComponent::OnControlModeChanged' has a wrong offset!");
static_assert(offsetof(UBRCharacterMovementComponent, ReplicatedVehicleControlInput) == 0x000F00, "Member 'UBRCharacterMovementComponent::ReplicatedVehicleControlInput' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateNotBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNotBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNotBool">();
	}
	static class UBrickComponentType_GateNotBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNotBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateNotBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateNotBool");
static_assert(sizeof(UBrickComponentType_GateNotBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateNotBool");

// Class Brickadia.BRChatCommandLibrary
// 0x0010 (0x0038 - 0x0028)
class UBRChatCommandLibrary : public UObject
{
public:
	TArray<struct FBRChatCommandDescriptor>       ChatCommandDefinitions;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRChatCommandLibrary">();
	}
	static class UBRChatCommandLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRChatCommandLibrary>();
	}
};
static_assert(alignof(UBRChatCommandLibrary) == 0x000008, "Wrong alignment on UBRChatCommandLibrary");
static_assert(sizeof(UBRChatCommandLibrary) == 0x000038, "Wrong size on UBRChatCommandLibrary");
static_assert(offsetof(UBRChatCommandLibrary, ChatCommandDefinitions) == 0x000028, "Member 'UBRChatCommandLibrary::ChatCommandDefinitions' has a wrong offset!");

// Class Brickadia.BRChatCommandLibrary_Default
// 0x0000 (0x0038 - 0x0038)
class UBRChatCommandLibrary_Default final : public UBRChatCommandLibrary
{
public:
	void Ban(const struct FBRChatCommandContext& Context, const class FString& Player, int32 Minutes);
	void BanAdv(const struct FBRChatCommandContext& Context, const class FString& Player, int32 Minutes, const class FString& Reason);
	void BrickCount(class ABRPlayerController* Caller);
	void ClearAllObjects(class ABRPlayerController* Caller);
	void ClearCheckPoint(class ABRPlayerController* Caller);
	void ClearObjects(class ABRPlayerController* Caller, const class FString& Player);
	void ClearOwnObjects(class ABRPlayerController* Caller);
	void GetTransformSelf(class ABRPlayerController* Caller);
	void GetTransformTarget(const struct FBRChatCommandContext& Context, const class FString& Player);
	void Ghost(class ABRPlayerController* Caller);
	void GrantRole(const struct FBRChatCommandContext& Context, const class FString& Role, const class FString& Player);
	void Help(const struct FBRChatCommandContext& Context);
	void HelpSpecific(const struct FBRChatCommandContext& Context, const class FString& CommandName);
	void JoinTeam(class ABRPlayerController* Caller, const class FString& Team);
	void Kick(const struct FBRChatCommandContext& Context, const class FString& Player);
	void KickAdv(const struct FBRChatCommandContext& Context, const class FString& Player, const class FString& Reason);
	void LeaveTeam(class ABRPlayerController* Caller);
	void List16AutoSaves(const struct FBRChatCommandContext& Context);
	void ListNumAutoSaves(const struct FBRChatCommandContext& Context, int32 NumAutoSaves);
	void ListPlayers(class ABRPlayerController* Caller);
	void ListRoles(class ABRPlayerController* Caller);
	void ListTeams(class ABRPlayerController* Caller);
	void Load(const struct FBRChatCommandContext& Context, const class FString& File);
	void LoadLastAutoSave(const struct FBRChatCommandContext& Context);
	void LoadNthLastAutoSave(const struct FBRChatCommandContext& Context, int32 NFromLast);
	void LoadOffset(const struct FBRChatCommandContext& Context, const class FString& File, int32 OffsetX, int32 OffsetY, int32 OffsetZ);
	void LoadOffsetAdv(const struct FBRChatCommandContext& Context, const class FString& File, int32 OffsetX, int32 OffsetY, int32 OffsetZ, bool bCorrectPaletteColors, bool bCorrectCustomColors);
	void PlayerCount(class ABRPlayerController* Caller);
	void RevokeRole(const struct FBRChatCommandContext& Context, const class FString& Role, const class FString& Player);
	void Teleport(const struct FBRChatCommandContext& Context, const class FString& Player, const class FString& OtherPlayer);
	void TeleportBack(class ABRPlayerController* Caller);
	void TeleportPlayerBack(class ABRPlayerController* Caller, const class FString& Player);
	void TeleportPlayerToLocation(const struct FBRChatCommandContext& Context, const class FString& Player, float X, float Y, float Z, bool bKeepVelocity);
	void TeleportPlayerToLocationRotation(const struct FBRChatCommandContext& Context, const class FString& Player, float X, float Y, float Z, float Pitch, float Yaw, bool bKeepVelocity);
	void TeleportSelf(class ABRPlayerController* Caller, const class FString& OtherPlayer);
	void TeleportToAimTarget(class ABRPlayerController* Caller);
	void ToggleSpectatorMode(class ABRPlayerController* Caller);
	void Unban(const struct FBRChatCommandContext& Context, const class FString& Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRChatCommandLibrary_Default">();
	}
	static class UBRChatCommandLibrary_Default* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRChatCommandLibrary_Default>();
	}
};
static_assert(alignof(UBRChatCommandLibrary_Default) == 0x000008, "Wrong alignment on UBRChatCommandLibrary_Default");
static_assert(sizeof(UBRChatCommandLibrary_Default) == 0x000038, "Wrong size on UBRChatCommandLibrary_Default");

// Class Brickadia.BrickComponentType_Internal_EntityGate_SetVelocity
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_SetVelocity final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_SetVelocity">();
	}
	static class UBrickComponentType_Internal_EntityGate_SetVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_SetVelocity>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_SetVelocity) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_SetVelocity");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_SetVelocity) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_SetVelocity");

// Class Brickadia.BRChatCommandLibrary_DynamicGrids
// 0x0000 (0x0038 - 0x0038)
class UBRChatCommandLibrary_DynamicGrids final : public UBRChatCommandLibrary
{
public:
	void DestroyAllDynamicGrids(const struct FBRChatCommandContext& Context);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRChatCommandLibrary_DynamicGrids">();
	}
	static class UBRChatCommandLibrary_DynamicGrids* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRChatCommandLibrary_DynamicGrids>();
	}
};
static_assert(alignof(UBRChatCommandLibrary_DynamicGrids) == 0x000008, "Wrong alignment on UBRChatCommandLibrary_DynamicGrids");
static_assert(sizeof(UBRChatCommandLibrary_DynamicGrids) == 0x000038, "Wrong size on UBRChatCommandLibrary_DynamicGrids");

// Class Brickadia.BRColorSelectorColorWidget
// 0x0068 (0x0338 - 0x02D0)
class UBRColorSelectorColorWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       SelectAnimation;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       DeselectAnimation;                                 // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x0310(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0318(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                ColorButton;                                       // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ColorImage;                                        // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleClicked();
	void HandleHovered();
	void HandleUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorColorWidget">();
	}
	static class UBRColorSelectorColorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorColorWidget>();
	}
};
static_assert(alignof(UBRColorSelectorColorWidget) == 0x000008, "Wrong alignment on UBRColorSelectorColorWidget");
static_assert(sizeof(UBRColorSelectorColorWidget) == 0x000338, "Wrong size on UBRColorSelectorColorWidget");
static_assert(offsetof(UBRColorSelectorColorWidget, SelectAnimation) == 0x000300, "Member 'UBRColorSelectorColorWidget::SelectAnimation' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorWidget, DeselectAnimation) == 0x000308, "Member 'UBRColorSelectorColorWidget::DeselectAnimation' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorWidget, Color) == 0x000310, "Member 'UBRColorSelectorColorWidget::Color' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorWidget, Name_0) == 0x000318, "Member 'UBRColorSelectorColorWidget::Name_0' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorWidget, ColorButton) == 0x000328, "Member 'UBRColorSelectorColorWidget::ColorButton' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorWidget, ColorImage) == 0x000330, "Member 'UBRColorSelectorColorWidget::ColorImage' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_Teleporter
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_Teleporter final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Teleporter">();
	}
	static class UBrickComponentType_Internal_Teleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Teleporter>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Teleporter) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Teleporter");
static_assert(sizeof(UBrickComponentType_Internal_Teleporter) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_Teleporter");

// Class Brickadia.BRColorSelectorMaterialWidget
// 0x0050 (0x0320 - 0x02D0)
class UBRColorSelectorMaterialWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       SelectAnimation;                                   // 0x0300(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x0308(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                MaterialButton;                                    // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 MaterialImage;                                     // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleClicked();
	void HandleHovered();
	void HandleUnhovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorMaterialWidget">();
	}
	static class UBRColorSelectorMaterialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorMaterialWidget>();
	}
};
static_assert(alignof(UBRColorSelectorMaterialWidget) == 0x000008, "Wrong alignment on UBRColorSelectorMaterialWidget");
static_assert(sizeof(UBRColorSelectorMaterialWidget) == 0x000320, "Wrong size on UBRColorSelectorMaterialWidget");
static_assert(offsetof(UBRColorSelectorMaterialWidget, SelectAnimation) == 0x000300, "Member 'UBRColorSelectorMaterialWidget::SelectAnimation' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialWidget, MaterialIndex) == 0x000308, "Member 'UBRColorSelectorMaterialWidget::MaterialIndex' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialWidget, MaterialButton) == 0x000310, "Member 'UBRColorSelectorMaterialWidget::MaterialButton' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialWidget, MaterialImage) == 0x000318, "Member 'UBRColorSelectorMaterialWidget::MaterialImage' has a wrong offset!");

// Class Brickadia.BRColorSelectorColumnWidget
// 0x0008 (0x02D8 - 0x02D0)
class UBRColorSelectorColumnWidget final : public UUserWidget
{
public:
	class UDynamicEntryBox*                       ColorsBox;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorColumnWidget">();
	}
	static class UBRColorSelectorColumnWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorColumnWidget>();
	}
};
static_assert(alignof(UBRColorSelectorColumnWidget) == 0x000008, "Wrong alignment on UBRColorSelectorColumnWidget");
static_assert(sizeof(UBRColorSelectorColumnWidget) == 0x0002D8, "Wrong size on UBRColorSelectorColumnWidget");
static_assert(offsetof(UBRColorSelectorColumnWidget, ColorsBox) == 0x0002D0, "Member 'UBRColorSelectorColumnWidget::ColorsBox' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_Joint_Wheel
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_Wheel : public UBrickComponentType_Internal_ConstraintJointBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_Wheel">();
	}
	static class UBrickComponentType_Internal_Joint_Wheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_Wheel>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_Wheel) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_Wheel");
static_assert(sizeof(UBrickComponentType_Internal_Joint_Wheel) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_Wheel");

// Class Brickadia.BRColorSelectorColorsWidget
// 0x00F8 (0x03C8 - 0x02D0)
class UBRColorSelectorColorsWidget final : public UUserWidget
{
public:
	class UImage*                                 OutOfPaletteColorImage;                            // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             CurrentColorText;                                  // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicEntryBox*                       ServerPaletteColumns;                              // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SelectionState;                                    // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FColor& SelectionState)> OnSelectionStateUpdated;                           // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBRColorSelectorColorWidget*            SelectedColorWidget;                               // 0x0300(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRColorPalette*                        CachedPalette;                                     // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBRColorSelectorColorWidget*>    ColorWidgetLookup;                                 // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class UBRColorSelectorColorWidget*, int32> ColorWidgetReverseLookup;                          // 0x0320(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TMap<class UBRColorSelectorColorWidget*, struct FBRColorColumnAndIndexInColumn> ColorColumnLookup;                                 // 0x0370(0x0050)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleServerColorsChanged(class UBRGameSettingsBase* SettingsObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorColorsWidget">();
	}
	static class UBRColorSelectorColorsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorColorsWidget>();
	}
};
static_assert(alignof(UBRColorSelectorColorsWidget) == 0x000008, "Wrong alignment on UBRColorSelectorColorsWidget");
static_assert(sizeof(UBRColorSelectorColorsWidget) == 0x0003C8, "Wrong size on UBRColorSelectorColorsWidget");
static_assert(offsetof(UBRColorSelectorColorsWidget, OutOfPaletteColorImage) == 0x0002D0, "Member 'UBRColorSelectorColorsWidget::OutOfPaletteColorImage' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, CurrentColorText) == 0x0002D8, "Member 'UBRColorSelectorColorsWidget::CurrentColorText' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, ServerPaletteColumns) == 0x0002E0, "Member 'UBRColorSelectorColorsWidget::ServerPaletteColumns' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, SelectionState) == 0x0002E8, "Member 'UBRColorSelectorColorsWidget::SelectionState' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, OnSelectionStateUpdated) == 0x0002F0, "Member 'UBRColorSelectorColorsWidget::OnSelectionStateUpdated' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, SelectedColorWidget) == 0x000300, "Member 'UBRColorSelectorColorsWidget::SelectedColorWidget' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, CachedPalette) == 0x000308, "Member 'UBRColorSelectorColorsWidget::CachedPalette' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, ColorWidgetLookup) == 0x000310, "Member 'UBRColorSelectorColorsWidget::ColorWidgetLookup' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, ColorWidgetReverseLookup) == 0x000320, "Member 'UBRColorSelectorColorsWidget::ColorWidgetReverseLookup' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorColorsWidget, ColorColumnLookup) == 0x000370, "Member 'UBRColorSelectorColorsWidget::ColorColumnLookup' has a wrong offset!");

// Class Brickadia.BRColorSelectorMaterialsWidget
// 0x0048 (0x0318 - 0x02D0)
class UBRColorSelectorMaterialsWidget final : public UUserWidget
{
public:
	class UTextBlock*                             CurrentMaterialText;                               // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDynamicEntryBox*                       MaterialPaletteColumn;                             // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USlider*                                MaterialAlphaSlider;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             MaterialAlphaSliderValueText;                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaterialIndex;                                     // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaterialAlpha;                                     // 0x02F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F5[0x3];                                      // 0x02F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(int32 MaterialIndex, uint8 MaterialAlpha)> OnSelectionStateUpdated;                           // 0x02F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBRColorSelectorMaterialWidget*         SelectedMaterialWidget;                            // 0x0308(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleMaterialAlphaChanged(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorMaterialsWidget">();
	}
	static class UBRColorSelectorMaterialsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorMaterialsWidget>();
	}
};
static_assert(alignof(UBRColorSelectorMaterialsWidget) == 0x000008, "Wrong alignment on UBRColorSelectorMaterialsWidget");
static_assert(sizeof(UBRColorSelectorMaterialsWidget) == 0x000318, "Wrong size on UBRColorSelectorMaterialsWidget");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, CurrentMaterialText) == 0x0002D0, "Member 'UBRColorSelectorMaterialsWidget::CurrentMaterialText' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, MaterialPaletteColumn) == 0x0002D8, "Member 'UBRColorSelectorMaterialsWidget::MaterialPaletteColumn' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, MaterialAlphaSlider) == 0x0002E0, "Member 'UBRColorSelectorMaterialsWidget::MaterialAlphaSlider' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, MaterialAlphaSliderValueText) == 0x0002E8, "Member 'UBRColorSelectorMaterialsWidget::MaterialAlphaSliderValueText' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, MaterialIndex) == 0x0002F0, "Member 'UBRColorSelectorMaterialsWidget::MaterialIndex' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, MaterialAlpha) == 0x0002F4, "Member 'UBRColorSelectorMaterialsWidget::MaterialAlpha' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, OnSelectionStateUpdated) == 0x0002F8, "Member 'UBRColorSelectorMaterialsWidget::OnSelectionStateUpdated' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorMaterialsWidget, SelectedMaterialWidget) == 0x000308, "Member 'UBRColorSelectorMaterialsWidget::SelectedMaterialWidget' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateNorInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNorInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNorInt">();
	}
	static class UBrickComponentType_GateNorInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNorInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateNorInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateNorInt");
static_assert(sizeof(UBrickComponentType_GateNorInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateNorInt");

// Class Brickadia.BRColorSelectorWidget
// 0x0030 (0x0300 - 0x02D0)
class UBRColorSelectorWidget final : public UUserWidget
{
public:
	class UBRColorSelectorColorsWidget*           ColorsWidget;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRColorSelectorMaterialsWidget*        MaterialsWidget;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRColorSelectionState                 SelectionState;                                    // 0x02E0(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(const struct FBRColorSelectionState& SelectionState)> OnSelectionStateUpdated;                           // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HandleColorSelectionStateUpdated(const struct FColor& NewState);
	void HandleMaterialSelectionStateUpdated(int32 MaterialIndex, uint8 MaterialAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorWidget">();
	}
	static class UBRColorSelectorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorWidget>();
	}
};
static_assert(alignof(UBRColorSelectorWidget) == 0x000008, "Wrong alignment on UBRColorSelectorWidget");
static_assert(sizeof(UBRColorSelectorWidget) == 0x000300, "Wrong size on UBRColorSelectorWidget");
static_assert(offsetof(UBRColorSelectorWidget, ColorsWidget) == 0x0002D0, "Member 'UBRColorSelectorWidget::ColorsWidget' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorWidget, MaterialsWidget) == 0x0002D8, "Member 'UBRColorSelectorWidget::MaterialsWidget' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorWidget, SelectionState) == 0x0002E0, "Member 'UBRColorSelectorWidget::SelectionState' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorWidget, OnSelectionStateUpdated) == 0x0002F0, "Member 'UBRColorSelectorWidget::OnSelectionStateUpdated' has a wrong offset!");

// Class Brickadia.BRColorSelectorDialog
// 0x0018 (0x02F8 - 0x02E0)
class UBRColorSelectorDialog final : public UBRDialogBase
{
public:
	class UBRColorSelectorWidget*                 ColorSelector;                                     // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRColorPaletteToolBase*                Tool;                                              // 0x02E8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleSelectionStateUpdated(const struct FBRColorSelectionState& SelectionState);
	void PaintReleased();
	void ScrollDown();
	void ScrollLeft();
	void ScrollRight();
	void ScrollUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSelectorDialog">();
	}
	static class UBRColorSelectorDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSelectorDialog>();
	}
};
static_assert(alignof(UBRColorSelectorDialog) == 0x000008, "Wrong alignment on UBRColorSelectorDialog");
static_assert(sizeof(UBRColorSelectorDialog) == 0x0002F8, "Wrong size on UBRColorSelectorDialog");
static_assert(offsetof(UBRColorSelectorDialog, ColorSelector) == 0x0002E0, "Member 'UBRColorSelectorDialog::ColorSelector' has a wrong offset!");
static_assert(offsetof(UBRColorSelectorDialog, Tool) == 0x0002E8, "Member 'UBRColorSelectorDialog::Tool' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateAndBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateAndBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateAndBool">();
	}
	static class UBrickComponentType_GateAndBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateAndBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateAndBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateAndBool");
static_assert(sizeof(UBrickComponentType_GateAndBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateAndBool");

// Class Brickadia.BRToolWidget
// 0x0008 (0x02D8 - 0x02D0)
class UBRToolWidget : public UUserWidget
{
public:
	class ABRToolBase*                            Tool;                                              // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolWidget">();
	}
	static class UBRToolWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolWidget>();
	}
};
static_assert(alignof(UBRToolWidget) == 0x000008, "Wrong alignment on UBRToolWidget");
static_assert(sizeof(UBRToolWidget) == 0x0002D8, "Wrong size on UBRToolWidget");
static_assert(offsetof(UBRToolWidget, Tool) == 0x0002D0, "Member 'UBRToolWidget::Tool' has a wrong offset!");

// Class Brickadia.BRPaletteToolWidget
// 0x0000 (0x02D8 - 0x02D8)
class UBRPaletteToolWidget : public UBRToolWidget
{
public:
	void OnColorSelectionStateUpdated(const struct FBRColorSelectionState& NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPaletteToolWidget">();
	}
	static class UBRPaletteToolWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPaletteToolWidget>();
	}
};
static_assert(alignof(UBRPaletteToolWidget) == 0x000008, "Wrong alignment on UBRPaletteToolWidget");
static_assert(sizeof(UBRPaletteToolWidget) == 0x0002D8, "Wrong size on UBRPaletteToolWidget");

// Class Brickadia.BrickComponentType_Internal_EntityGate_PlayAudioOn
// 0x0008 (0x01E0 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_PlayAudioOn final : public UBrickComponentTypeBase
{
public:
	class UBrickOneShotAudioDescriptor*           DefaultBrickOneShotAudioDescriptor;                // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_PlayAudioOn">();
	}
	static class UBrickComponentType_Internal_EntityGate_PlayAudioOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_PlayAudioOn>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_PlayAudioOn) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_PlayAudioOn");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_PlayAudioOn) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_EntityGate_PlayAudioOn");
static_assert(offsetof(UBrickComponentType_Internal_EntityGate_PlayAudioOn, DefaultBrickOneShotAudioDescriptor) == 0x0001D8, "Member 'UBrickComponentType_Internal_EntityGate_PlayAudioOn::DefaultBrickOneShotAudioDescriptor' has a wrong offset!");

// Class Brickadia.BRItemBase
// 0x00D0 (0x0380 - 0x02B0)
class ABRItemBase : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshComponent*                 Mesh;                                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x02D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Tab;                                               // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Summary;                                           // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHideInCatalog;                                    // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_301[0x3];                                      // 0x0301(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AttachSocket;                                      // 0x0304(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             EquippedFootstepLayer;                             // 0x0310(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   AimOffset;                                         // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          IdleSequence;                                      // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FirstPersonViewOffset;                             // 0x0328(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 MeshColors[0x8];                                   // 0x0340(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAim;                                           // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanAutoToggleOff;                                 // 0x0361(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_362[0x6];                                      // 0x0362(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRCharacter*                           CachedWielder;                                     // 0x0368(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBRInventoryEntryBase*                  OwningInventoryEntry;                              // 0x0370(0x0008)(Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMeshColors();
	void HideItem();
	void OnPutAway();
	void OnRep_MeshColors();
	void OnWielded();
	void PauseAnimMontage(class UAnimMontage* AnimMontage);
	void PlayAnimMontage(class UAnimMontage* AnimMontage, float Rate, float StartTime);
	void ResumeAnimMontage(class UAnimMontage* AnimMontage);
	void SetMeshColor(int32 Index_0, const struct FColor& Value);
	void StopAnimMontageImmediately(class UAnimMontage* AnimMontage);
	void UnhideItem();

	bool CanWield(class ABRCharacter* WielderIn, bool bFirstCheck) const;
	struct FVector GetFireAtLocation(const struct FVector& PointOnStartPlane, float Radius) const;
	struct FColor GetMeshColor(int32 Index_0) const;
	struct FVector GetMuzzleLocationLocalSpace(class FName MuzzleSocket) const;
	struct FVector GetMuzzleLocationWorldSpace(class FName MuzzleSocket) const;
	class ABRPlayerController* GetOwnerBRPlayerController() const;
	class ABRPlayerState* GetOwnerBRPlayerState() const;
	class AController* GetOwnerController() const;
	class UBRInventoryComponent* GetOwningInventory() const;
	class UBRInventoryEntryBase* GetOwningInventoryEntry() const;
	class ABRCharacter* GetWielder() const;
	bool IsLocallyControlled() const;
	bool IsPuttingAway() const;
	bool IsTool() const;
	bool IsWielded() const;
	bool ShouldUseFireAtLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRItemBase">();
	}
	static class ABRItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRItemBase>();
	}
};
static_assert(alignof(ABRItemBase) == 0x000008, "Wrong alignment on ABRItemBase");
static_assert(sizeof(ABRItemBase) == 0x000380, "Wrong size on ABRItemBase");
static_assert(offsetof(ABRItemBase, Mesh) == 0x0002B8, "Member 'ABRItemBase::Mesh' has a wrong offset!");
static_assert(offsetof(ABRItemBase, DisplayName) == 0x0002C0, "Member 'ABRItemBase::DisplayName' has a wrong offset!");
static_assert(offsetof(ABRItemBase, Category) == 0x0002D0, "Member 'ABRItemBase::Category' has a wrong offset!");
static_assert(offsetof(ABRItemBase, Tab) == 0x0002E0, "Member 'ABRItemBase::Tab' has a wrong offset!");
static_assert(offsetof(ABRItemBase, Summary) == 0x0002F0, "Member 'ABRItemBase::Summary' has a wrong offset!");
static_assert(offsetof(ABRItemBase, bHideInCatalog) == 0x000300, "Member 'ABRItemBase::bHideInCatalog' has a wrong offset!");
static_assert(offsetof(ABRItemBase, AttachSocket) == 0x000304, "Member 'ABRItemBase::AttachSocket' has a wrong offset!");
static_assert(offsetof(ABRItemBase, EquippedFootstepLayer) == 0x000310, "Member 'ABRItemBase::EquippedFootstepLayer' has a wrong offset!");
static_assert(offsetof(ABRItemBase, AimOffset) == 0x000318, "Member 'ABRItemBase::AimOffset' has a wrong offset!");
static_assert(offsetof(ABRItemBase, IdleSequence) == 0x000320, "Member 'ABRItemBase::IdleSequence' has a wrong offset!");
static_assert(offsetof(ABRItemBase, FirstPersonViewOffset) == 0x000328, "Member 'ABRItemBase::FirstPersonViewOffset' has a wrong offset!");
static_assert(offsetof(ABRItemBase, MeshColors) == 0x000340, "Member 'ABRItemBase::MeshColors' has a wrong offset!");
static_assert(offsetof(ABRItemBase, bCanAim) == 0x000360, "Member 'ABRItemBase::bCanAim' has a wrong offset!");
static_assert(offsetof(ABRItemBase, bCanAutoToggleOff) == 0x000361, "Member 'ABRItemBase::bCanAutoToggleOff' has a wrong offset!");
static_assert(offsetof(ABRItemBase, CachedWielder) == 0x000368, "Member 'ABRItemBase::CachedWielder' has a wrong offset!");
static_assert(offsetof(ABRItemBase, OwningInventoryEntry) == 0x000370, "Member 'ABRItemBase::OwningInventoryEntry' has a wrong offset!");

// Class Brickadia.BRToolBase
// 0x0270 (0x05F0 - 0x0380)
class ABRToolBase : public ABRItemBase
{
public:
	class USceneComponent*                        Muzzle;                                            // 0x0380(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UsagePermission;                                   // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInToolWheel;                                  // 0x0390(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x7];                                      // 0x0391(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           WieldAnimation;                                    // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WieldSound;                                        // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnToolBindInfosChanged;                            // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBRToolBindHint_WithTags>       ToolBindHints;                                     // 0x03B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSet<class FName>                             DefaultVisibleToolBindTags;                        // 0x03C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bShowHiddenBricks;                                 // 0x0418(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             VisibleToolBindTags;                               // 0x0420(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x8];                                      // 0x0470(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRToolWidget>              ToolWidgetClass;                                   // 0x0478(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBRToolWidget>              ToolQuickbarWidgetClass;                           // 0x0480(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBRToolWidget>              ToolCrosshairWidgetClass;                          // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBRToolWidget*                          ToolWidgetInstance;                                // 0x0490(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRToolWidget*                          ToolQuickbarWidgetInstance;                        // 0x0498(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRToolWidget*                          ToolCrosshairWidgetInstance;                       // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBrickSelectionLayers                         HighlightSelectionLayers;                          // 0x04A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A9[0x7];                                      // 0x04A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           CurrentHighlightedActors;                          // 0x04B0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<struct FBrickHandle>                     CurrentHighlightedBricks;                          // 0x0500(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TSet<class AActor*>                           DesiredHighlightedActors;                          // 0x0550(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	TSet<struct FBrickHandle>                     DesiredHighlightedBricks;                          // 0x05A0(0x0050)(Transient, NativeAccessSpecifierPrivate)

public:
	void AddHighlightedActor(class AActor* Actor);
	void AddHighlightedBrick(const struct FBrickHandle& BrickHandle);
	void ClearHighlighted();
	EControllerInputMode GetControllerInputMode();
	void RefreshHighlights();
	void RemoveHighlightedActor(class AActor* Actor);
	void RemoveHighlightedBrick(const struct FBrickHandle& BrickHandle);
	void SetDeferToolBindVisibilityChanges(bool bNewDeferring);
	void SetHighlightSelectionLayers(EBrickSelectionLayers NewSelectionLayers);
	void SetToolBindTagVisible(class FName BindInfoId, bool bVisible);

	bool BP_LineTraceByChannelMuzzleToAim(struct FHitResult* HitResult, float Distance, bool bUseCameraRay) const;
	bool BP_LineTraceByChannelMuzzleToAim_CustomChannel(struct FHitResult* HitResult, ECollisionChannel TraceChannel, float Distance, bool bUseCameraRay) const;
	bool BP_LineTraceByChannelMuzzleToCursor(struct FHitResult* HitResult, float Distance, bool bUseCameraRay) const;
	bool BP_LineTraceByChannelMuzzleToCursor_CustomChannel(struct FHitResult* HitResult, ECollisionChannel TraceChannel, float Distance, bool bUseCameraRay) const;
	bool BP_LineTraceByChannelMuzzleToScreenCenter(struct FHitResult* HitResult, float Distance, bool bUseCameraRay) const;
	bool BP_LineTraceByChannelMuzzleToScreenCenter_CustomChannel(struct FHitResult* HitResult, ECollisionChannel TraceChannel, float Distance, bool bUseCameraRay) const;
	bool GetAimRay(struct FRay* OutRay) const;
	struct FBrickHandle GetBrickUnderCursor() const;
	bool GetCursorRay(struct FRay* OutRay) const;
	bool GetScreenCenterRay(struct FRay* OutRay) const;
	class UBRToolWidget* GetToolCrosshairWidget() const;
	class UBRToolWidget* GetToolQuickbarWidget() const;
	class UBRToolWidget* GetToolWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolBase">();
	}
	static class ABRToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRToolBase>();
	}
};
static_assert(alignof(ABRToolBase) == 0x000008, "Wrong alignment on ABRToolBase");
static_assert(sizeof(ABRToolBase) == 0x0005F0, "Wrong size on ABRToolBase");
static_assert(offsetof(ABRToolBase, Muzzle) == 0x000380, "Member 'ABRToolBase::Muzzle' has a wrong offset!");
static_assert(offsetof(ABRToolBase, UsagePermission) == 0x000388, "Member 'ABRToolBase::UsagePermission' has a wrong offset!");
static_assert(offsetof(ABRToolBase, bShowInToolWheel) == 0x000390, "Member 'ABRToolBase::bShowInToolWheel' has a wrong offset!");
static_assert(offsetof(ABRToolBase, WieldAnimation) == 0x000398, "Member 'ABRToolBase::WieldAnimation' has a wrong offset!");
static_assert(offsetof(ABRToolBase, WieldSound) == 0x0003A0, "Member 'ABRToolBase::WieldSound' has a wrong offset!");
static_assert(offsetof(ABRToolBase, OnToolBindInfosChanged) == 0x0003A8, "Member 'ABRToolBase::OnToolBindInfosChanged' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolBindHints) == 0x0003B8, "Member 'ABRToolBase::ToolBindHints' has a wrong offset!");
static_assert(offsetof(ABRToolBase, DefaultVisibleToolBindTags) == 0x0003C8, "Member 'ABRToolBase::DefaultVisibleToolBindTags' has a wrong offset!");
static_assert(offsetof(ABRToolBase, bShowHiddenBricks) == 0x000418, "Member 'ABRToolBase::bShowHiddenBricks' has a wrong offset!");
static_assert(offsetof(ABRToolBase, VisibleToolBindTags) == 0x000420, "Member 'ABRToolBase::VisibleToolBindTags' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolWidgetClass) == 0x000478, "Member 'ABRToolBase::ToolWidgetClass' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolQuickbarWidgetClass) == 0x000480, "Member 'ABRToolBase::ToolQuickbarWidgetClass' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolCrosshairWidgetClass) == 0x000488, "Member 'ABRToolBase::ToolCrosshairWidgetClass' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolWidgetInstance) == 0x000490, "Member 'ABRToolBase::ToolWidgetInstance' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolQuickbarWidgetInstance) == 0x000498, "Member 'ABRToolBase::ToolQuickbarWidgetInstance' has a wrong offset!");
static_assert(offsetof(ABRToolBase, ToolCrosshairWidgetInstance) == 0x0004A0, "Member 'ABRToolBase::ToolCrosshairWidgetInstance' has a wrong offset!");
static_assert(offsetof(ABRToolBase, HighlightSelectionLayers) == 0x0004A8, "Member 'ABRToolBase::HighlightSelectionLayers' has a wrong offset!");
static_assert(offsetof(ABRToolBase, CurrentHighlightedActors) == 0x0004B0, "Member 'ABRToolBase::CurrentHighlightedActors' has a wrong offset!");
static_assert(offsetof(ABRToolBase, CurrentHighlightedBricks) == 0x000500, "Member 'ABRToolBase::CurrentHighlightedBricks' has a wrong offset!");
static_assert(offsetof(ABRToolBase, DesiredHighlightedActors) == 0x000550, "Member 'ABRToolBase::DesiredHighlightedActors' has a wrong offset!");
static_assert(offsetof(ABRToolBase, DesiredHighlightedBricks) == 0x0005A0, "Member 'ABRToolBase::DesiredHighlightedBricks' has a wrong offset!");

// Class Brickadia.BRConnectorPortSelectDialog
// 0x0058 (0x0338 - 0x02E0)
class UBRConnectorPortSelectDialog final : public UBRDialogBase
{
public:
	uint8                                         Pad_2E0[0x30];                                     // 0x02E0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickHandle                           BrickHandle;                                       // 0x0310(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBulkMode;                                         // 0x0318(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRConnectorComponentPortWidget*        FirstShowingPort;                                  // 0x0320(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEditableTextBox*                       NarrowSearchBox;                                   // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDynamicEntryBox*                       ComponentsBox;                                     // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleNarrowSearchTextChanged(const class FText& NewText);
	void HandleNarrowSearchTextCommitted(const class FText& NewText, ETextCommit CommitMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRConnectorPortSelectDialog">();
	}
	static class UBRConnectorPortSelectDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRConnectorPortSelectDialog>();
	}
};
static_assert(alignof(UBRConnectorPortSelectDialog) == 0x000008, "Wrong alignment on UBRConnectorPortSelectDialog");
static_assert(sizeof(UBRConnectorPortSelectDialog) == 0x000338, "Wrong size on UBRConnectorPortSelectDialog");
static_assert(offsetof(UBRConnectorPortSelectDialog, BrickHandle) == 0x000310, "Member 'UBRConnectorPortSelectDialog::BrickHandle' has a wrong offset!");
static_assert(offsetof(UBRConnectorPortSelectDialog, bBulkMode) == 0x000318, "Member 'UBRConnectorPortSelectDialog::bBulkMode' has a wrong offset!");
static_assert(offsetof(UBRConnectorPortSelectDialog, FirstShowingPort) == 0x000320, "Member 'UBRConnectorPortSelectDialog::FirstShowingPort' has a wrong offset!");
static_assert(offsetof(UBRConnectorPortSelectDialog, NarrowSearchBox) == 0x000328, "Member 'UBRConnectorPortSelectDialog::NarrowSearchBox' has a wrong offset!");
static_assert(offsetof(UBRConnectorPortSelectDialog, ComponentsBox) == 0x000330, "Member 'UBRConnectorPortSelectDialog::ComponentsBox' has a wrong offset!");

// Class Brickadia.BrickComposablePart
// 0x0028 (0x0050 - 0x0028)
class UBrickComposablePart final : public UObject
{
public:
	struct FIntVector                             BaseHalfSize;                                      // 0x0028(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x14];                                      // 0x0034(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExtendOffEdges;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComposablePart">();
	}
	static class UBrickComposablePart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComposablePart>();
	}
};
static_assert(alignof(UBrickComposablePart) == 0x000008, "Wrong alignment on UBrickComposablePart");
static_assert(sizeof(UBrickComposablePart) == 0x000050, "Wrong size on UBrickComposablePart");
static_assert(offsetof(UBrickComposablePart, BaseHalfSize) == 0x000028, "Member 'UBrickComposablePart::BaseHalfSize' has a wrong offset!");
static_assert(offsetof(UBrickComposablePart, ExtendOffEdges) == 0x000048, "Member 'UBrickComposablePart::ExtendOffEdges' has a wrong offset!");

// Class Brickadia.BRColorPaletteToolBase
// 0x0010 (0x0600 - 0x05F0)
class ABRColorPaletteToolBase : public ABRToolBase
{
public:
	TSubclassOf<class UBRColorSelectorDialog>     ColorSelectorDialogClass;                          // 0x05F0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRColorSelectorDialog*                 ColorSelectorDialog;                               // 0x05F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleServerColorsChanged(class UBRGameSettingsBase* SettingsObject);
	void OnColorSelectionStateUpdated();
	void PickColorUnderCursor();
	void SetColorSelectionState(const struct FBRColorSelectionState& SelectionState);

	const struct FBRColorSelectionState GetColorSelectionState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorPaletteToolBase">();
	}
	static class ABRColorPaletteToolBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRColorPaletteToolBase>();
	}
};
static_assert(alignof(ABRColorPaletteToolBase) == 0x000008, "Wrong alignment on ABRColorPaletteToolBase");
static_assert(sizeof(ABRColorPaletteToolBase) == 0x000600, "Wrong size on ABRColorPaletteToolBase");
static_assert(offsetof(ABRColorPaletteToolBase, ColorSelectorDialogClass) == 0x0005F0, "Member 'ABRColorPaletteToolBase::ColorSelectorDialogClass' has a wrong offset!");
static_assert(offsetof(ABRColorPaletteToolBase, ColorSelectorDialog) == 0x0005F8, "Member 'ABRColorPaletteToolBase::ColorSelectorDialog' has a wrong offset!");

// Class Brickadia.BRColorStatics
// 0x0000 (0x0028 - 0x0028)
class UBRColorStatics final : public UBlueprintFunctionLibrary
{
public:
	static float BrickColorDistance(const struct FColor& Color1, const struct FColor& Color2);
	static struct FLinearColor ConvertFromOklab(const struct FLinearColor& Color);
	static struct FLinearColor ConvertToOklab(const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorStatics">();
	}
	static class UBRColorStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorStatics>();
	}
};
static_assert(alignof(UBRColorStatics) == 0x000008, "Wrong alignment on UBRColorStatics");
static_assert(sizeof(UBRColorStatics) == 0x000028, "Wrong size on UBRColorStatics");

// Class Brickadia.BrickComponentType_GateMultiplyFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateMultiplyFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateMultiplyFloat">();
	}
	static class UBrickComponentType_GateMultiplyFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateMultiplyFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateMultiplyFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateMultiplyFloat");
static_assert(sizeof(UBrickComponentType_GateMultiplyFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateMultiplyFloat");

// Class Brickadia.BRColorPalette
// 0x0038 (0x0060 - 0x0028)
class UBRColorPalette final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRColorPaletteData                    Data;                                              // 0x0030(0x0020)(Edit, BlueprintVisible, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetMaxGroupNameLength();

	void OnRep_Data();
	void SetData(const struct FBRColorPaletteData& InData);

	void GetAllColors(TArray<struct FColor>* OutColors) const;
	struct FColor GetClosestColor(const struct FColor& Input) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorPalette">();
	}
	static class UBRColorPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorPalette>();
	}
};
static_assert(alignof(UBRColorPalette) == 0x000008, "Wrong alignment on UBRColorPalette");
static_assert(sizeof(UBRColorPalette) == 0x000060, "Wrong size on UBRColorPalette");
static_assert(offsetof(UBRColorPalette, Data) == 0x000030, "Member 'UBRColorPalette::Data' has a wrong offset!");

// Class Brickadia.BRColorSubsystem
// 0x0000 (0x0030 - 0x0030)
class UBRColorSubsystem final : public UGameInstanceSubsystem
{
public:
	bool FixColorPaletteAlpha(class UBRColorPalette* Palette);
	void ForceFixColorPalette(class UBRColorPalette* Palette);
	TArray<class FString> GetColorPaletteList();
	class UBRColorPalette* GetDefaultColorPalette();
	int32 GetMaxGroups();
	int32 GetMaxRows();
	bool IsValidColorPalette(const struct FBRColorPaletteData& PaletteData);
	void SaveColorPalette(class UObject* WorldContext, const class FString& Name_0, class UBRColorPalette* Palette);
	class UBRColorPalette* TryLoadColorPalette(class UObject* WorldContext, const class FString& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRColorSubsystem">();
	}
	static class UBRColorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRColorSubsystem>();
	}
};
static_assert(alignof(UBRColorSubsystem) == 0x000008, "Wrong alignment on UBRColorSubsystem");
static_assert(sizeof(UBRColorSubsystem) == 0x000030, "Wrong size on UBRColorSubsystem");

// Class Brickadia.BrickSelection
// 0x0050 (0x0078 - 0x0028)
class UBrickSelection final : public UObject
{
public:
	TSet<struct FBrickPersistentHandle>           SelectedBricks;                                    // 0x0028(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSelection">();
	}
	static class UBrickSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSelection>();
	}
};
static_assert(alignof(UBrickSelection) == 0x000008, "Wrong alignment on UBrickSelection");
static_assert(sizeof(UBrickSelection) == 0x000078, "Wrong size on UBrickSelection");
static_assert(offsetof(UBrickSelection, SelectedBricks) == 0x000028, "Member 'UBrickSelection::SelectedBricks' has a wrong offset!");

// Class Brickadia.BRServerSettingsActor
// 0x0070 (0x0320 - 0x02B0)
class ABRServerSettingsActor final : public AActor
{
public:
	TArray<class UBRServerSettingsBase*>          SettingsInstanceCollection;                        // 0x02B0(0x0010)(Net, ZeroConstructor, Transient, RepNotify, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBRServerSettingsBase*>          PreviouslyReceivedInstances;                       // 0x02C0(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBRGameSettingsBase>, class UBRServerSettingsBase*> SettingsInstanceLookup;                            // 0x02D0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void OnRep_SettingsInstanceCollection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettingsActor">();
	}
	static class ABRServerSettingsActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRServerSettingsActor>();
	}
};
static_assert(alignof(ABRServerSettingsActor) == 0x000008, "Wrong alignment on ABRServerSettingsActor");
static_assert(sizeof(ABRServerSettingsActor) == 0x000320, "Wrong size on ABRServerSettingsActor");
static_assert(offsetof(ABRServerSettingsActor, SettingsInstanceCollection) == 0x0002B0, "Member 'ABRServerSettingsActor::SettingsInstanceCollection' has a wrong offset!");
static_assert(offsetof(ABRServerSettingsActor, PreviouslyReceivedInstances) == 0x0002C0, "Member 'ABRServerSettingsActor::PreviouslyReceivedInstances' has a wrong offset!");
static_assert(offsetof(ABRServerSettingsActor, SettingsInstanceLookup) == 0x0002D0, "Member 'ABRServerSettingsActor::SettingsInstanceLookup' has a wrong offset!");

// Class Brickadia.BRGameSettingsBase
// 0x0020 (0x0048 - 0x0028)
class UBRGameSettingsBase : public UObject
{
public:
	TMulticastInlineDelegate<void(class UBRGameSettingsBase* SettingsObject)> OnSettingsLiveChanged;                             // 0x0028(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGameSettingsBase* SettingsObject)> OnSettingsChanged;                                 // 0x0038(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPublic)

public:
	void LiveChangeSettings();
	void PostInitSettings();
	void PostLiveChangeSettings();
	void PostReloadSettings();
	void PostSaveSettings();
	void ReloadSettings();
	void SaveSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameSettingsBase">();
	}
	static class UBRGameSettingsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameSettingsBase>();
	}
};
static_assert(alignof(UBRGameSettingsBase) == 0x000008, "Wrong alignment on UBRGameSettingsBase");
static_assert(sizeof(UBRGameSettingsBase) == 0x000048, "Wrong size on UBRGameSettingsBase");
static_assert(offsetof(UBRGameSettingsBase, OnSettingsLiveChanged) == 0x000028, "Member 'UBRGameSettingsBase::OnSettingsLiveChanged' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase, OnSettingsChanged) == 0x000038, "Member 'UBRGameSettingsBase::OnSettingsChanged' has a wrong offset!");

// Class Brickadia.BRServerSettingsBase
// 0x0000 (0x0048 - 0x0048)
class UBRServerSettingsBase : public UBRGameSettingsBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettingsBase">();
	}
	static class UBRServerSettingsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerSettingsBase>();
	}
};
static_assert(alignof(UBRServerSettingsBase) == 0x000008, "Wrong alignment on UBRServerSettingsBase");
static_assert(sizeof(UBRServerSettingsBase) == 0x000048, "Wrong size on UBRServerSettingsBase");

// Class Brickadia.BRConnectorComponentPortsWidget
// 0x0028 (0x02F8 - 0x02D0)
class UBRConnectorComponentPortsWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDynamicEntryBox*                       PortsBox;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ReceiveComponentDisplayName(const class FText& DisplayName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRConnectorComponentPortsWidget">();
	}
	static class UBRConnectorComponentPortsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRConnectorComponentPortsWidget>();
	}
};
static_assert(alignof(UBRConnectorComponentPortsWidget) == 0x000008, "Wrong alignment on UBRConnectorComponentPortsWidget");
static_assert(sizeof(UBRConnectorComponentPortsWidget) == 0x0002F8, "Wrong size on UBRConnectorComponentPortsWidget");
static_assert(offsetof(UBRConnectorComponentPortsWidget, PortsBox) == 0x0002F0, "Member 'UBRConnectorComponentPortsWidget::PortsBox' has a wrong offset!");

// Class Brickadia.BrickComponentType_LightBase
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_LightBase : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_LightBase">();
	}
	static class UBrickComponentType_LightBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_LightBase>();
	}
};
static_assert(alignof(UBrickComponentType_LightBase) == 0x000008, "Wrong alignment on UBrickComponentType_LightBase");
static_assert(sizeof(UBrickComponentType_LightBase) == 0x0001D8, "Wrong size on UBrickComponentType_LightBase");

// Class Brickadia.BrickComponentType_SpotLight
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_SpotLight final : public UBrickComponentType_LightBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_SpotLight">();
	}
	static class UBrickComponentType_SpotLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_SpotLight>();
	}
};
static_assert(alignof(UBrickComponentType_SpotLight) == 0x000008, "Wrong alignment on UBrickComponentType_SpotLight");
static_assert(sizeof(UBrickComponentType_SpotLight) == 0x0001D8, "Wrong size on UBrickComponentType_SpotLight");

// Class Brickadia.BRServerSettings_Color
// 0x0038 (0x0080 - 0x0048)
class UBRServerSettings_Color final : public UBRServerSettingsBase
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBRColorPalette*>                ServerPalettes;                                    // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FBRColorPaletteData>            SavedServerPalettes;                               // 0x0060(0x0010)(ZeroConstructor, Config, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddServerPalette(const struct FBRColorPaletteData& PaletteData);
	class UBRColorPalette* GetServerPalette(int32 Index_0);
	void OnRep_ServerPalettes();
	bool RemoveServerPalette(int32 ID);
	bool SetServerPalette(const struct FBRColorPaletteData& PaletteData, int32 Index_0);

	struct FColor GetClosestServerColor(const struct FColor& Input) const;
	const TArray<struct FColor> GetColorList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettings_Color">();
	}
	static class UBRServerSettings_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerSettings_Color>();
	}
};
static_assert(alignof(UBRServerSettings_Color) == 0x000008, "Wrong alignment on UBRServerSettings_Color");
static_assert(sizeof(UBRServerSettings_Color) == 0x000080, "Wrong size on UBRServerSettings_Color");
static_assert(offsetof(UBRServerSettings_Color, ServerPalettes) == 0x000050, "Member 'UBRServerSettings_Color::ServerPalettes' has a wrong offset!");
static_assert(offsetof(UBRServerSettings_Color, SavedServerPalettes) == 0x000060, "Member 'UBRServerSettings_Color::SavedServerPalettes' has a wrong offset!");

// Class Brickadia.BRPlacerWidget
// 0x0000 (0x02D8 - 0x02D8)
class UBRPlacerWidget : public UBRPaletteToolWidget
{
public:
	void OnNewAlignmentMode(class UBRPlacerAlignmentModeBase* NewAlignmentMode);
	void OnNewPlacementMode(class UBRPlacerPlacementModeBase* NewPlacementMode);
	void OnNewPlacingState(EBRPlacerPlacingState NewPlacingState);

	class ABRTool_Placer* GetPlacer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerWidget">();
	}
	static class UBRPlacerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerWidget>();
	}
};
static_assert(alignof(UBRPlacerWidget) == 0x000008, "Wrong alignment on UBRPlacerWidget");
static_assert(sizeof(UBRPlacerWidget) == 0x0002D8, "Wrong size on UBRPlacerWidget");

// Class Brickadia.BRPlacerStatusWidget
// 0x0000 (0x02D8 - 0x02D8)
class UBRPlacerStatusWidget final : public UBRPlacerWidget
{
public:
	void SetBrickName(const class FText& NewBrickName);
	void SetDragText(const class FText& NewSizeText);
	void SetPlaceAsPhysicsAvailable(bool bAvailable);
	void SetPlaceAsPhysicsEnabled(bool bEnabled);
	void SetSpacingText(const class FText& NewSpacingText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerStatusWidget">();
	}
	static class UBRPlacerStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerStatusWidget>();
	}
};
static_assert(alignof(UBRPlacerStatusWidget) == 0x000008, "Wrong alignment on UBRPlacerStatusWidget");
static_assert(sizeof(UBRPlacerStatusWidget) == 0x0002D8, "Wrong size on UBRPlacerStatusWidget");

// Class Brickadia.BrickComponentType_GateAddFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateAddFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateAddFloat">();
	}
	static class UBrickComponentType_GateAddFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateAddFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateAddFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateAddFloat");
static_assert(sizeof(UBrickComponentType_GateAddFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateAddFloat");

// Class Brickadia.BRConsole
// 0x0000 (0x0160 - 0x0160)
class UBRConsole final : public UConsole
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRConsole">();
	}
	static class UBRConsole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRConsole>();
	}
};
static_assert(alignof(UBRConsole) == 0x000008, "Wrong alignment on UBRConsole");
static_assert(sizeof(UBRConsole) == 0x000160, "Wrong size on UBRConsole");

// Class Brickadia.BRDamageType
// 0x00C0 (0x0100 - 0x0040)
class UBRDamageType : public UDamageType
{
public:
	struct FSlateBrush                            Icon;                                              // 0x0040(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCausedByHeadshot;                                 // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCausedByExplosion;                                // 0x00F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCausedByPhysics;                                  // 0x00F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDismantleCharacter;                               // 0x00F3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoNotStopHealthRegen;                             // 0x00F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SelfDamageScale;                                   // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDamageType">();
	}
	static class UBRDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDamageType>();
	}
};
static_assert(alignof(UBRDamageType) == 0x000010, "Wrong alignment on UBRDamageType");
static_assert(sizeof(UBRDamageType) == 0x000100, "Wrong size on UBRDamageType");
static_assert(offsetof(UBRDamageType, Icon) == 0x000040, "Member 'UBRDamageType::Icon' has a wrong offset!");
static_assert(offsetof(UBRDamageType, bCausedByHeadshot) == 0x0000F0, "Member 'UBRDamageType::bCausedByHeadshot' has a wrong offset!");
static_assert(offsetof(UBRDamageType, bCausedByExplosion) == 0x0000F1, "Member 'UBRDamageType::bCausedByExplosion' has a wrong offset!");
static_assert(offsetof(UBRDamageType, bCausedByPhysics) == 0x0000F2, "Member 'UBRDamageType::bCausedByPhysics' has a wrong offset!");
static_assert(offsetof(UBRDamageType, bDismantleCharacter) == 0x0000F3, "Member 'UBRDamageType::bDismantleCharacter' has a wrong offset!");
static_assert(offsetof(UBRDamageType, bDoNotStopHealthRegen) == 0x0000F4, "Member 'UBRDamageType::bDoNotStopHealthRegen' has a wrong offset!");
static_assert(offsetof(UBRDamageType, SelfDamageScale) == 0x0000F8, "Member 'UBRDamageType::SelfDamageScale' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateSubtractInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateSubtractInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateSubtractInt">();
	}
	static class UBrickComponentType_GateSubtractInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateSubtractInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateSubtractInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateSubtractInt");
static_assert(sizeof(UBrickComponentType_GateSubtractInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateSubtractInt");

// Class Brickadia.BRDeveloperSettings
// 0x0028 (0x0060 - 0x0038)
class UBRDeveloperSettings final : public UDeveloperSettings
{
public:
	TSoftObjectPtr<class UTexture2D>              BehaviorComponentIcon;                             // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDeveloperSettings">();
	}
	static class UBRDeveloperSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDeveloperSettings>();
	}
};
static_assert(alignof(UBRDeveloperSettings) == 0x000008, "Wrong alignment on UBRDeveloperSettings");
static_assert(sizeof(UBRDeveloperSettings) == 0x000060, "Wrong size on UBRDeveloperSettings");
static_assert(offsetof(UBRDeveloperSettings, BehaviorComponentIcon) == 0x000038, "Member 'UBRDeveloperSettings::BehaviorComponentIcon' has a wrong offset!");

// Class Brickadia.BRDialogButtonBase
// 0x0050 (0x0320 - 0x02D0)
class UBRDialogButtonBase : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnClicked;                                         // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPressed;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReleased;                                        // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnHovered;                                         // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUnhovered;                                       // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void SetButtonEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDialogButtonBase">();
	}
	static class UBRDialogButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDialogButtonBase>();
	}
};
static_assert(alignof(UBRDialogButtonBase) == 0x000008, "Wrong alignment on UBRDialogButtonBase");
static_assert(sizeof(UBRDialogButtonBase) == 0x000320, "Wrong size on UBRDialogButtonBase");
static_assert(offsetof(UBRDialogButtonBase, OnClicked) == 0x0002D0, "Member 'UBRDialogButtonBase::OnClicked' has a wrong offset!");
static_assert(offsetof(UBRDialogButtonBase, OnPressed) == 0x0002E0, "Member 'UBRDialogButtonBase::OnPressed' has a wrong offset!");
static_assert(offsetof(UBRDialogButtonBase, OnReleased) == 0x0002F0, "Member 'UBRDialogButtonBase::OnReleased' has a wrong offset!");
static_assert(offsetof(UBRDialogButtonBase, OnHovered) == 0x000300, "Member 'UBRDialogButtonBase::OnHovered' has a wrong offset!");
static_assert(offsetof(UBRDialogButtonBase, OnUnhovered) == 0x000310, "Member 'UBRDialogButtonBase::OnUnhovered' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateModFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateModFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateModFloat">();
	}
	static class UBrickComponentType_GateModFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateModFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateModFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateModFloat");
static_assert(sizeof(UBrickComponentType_GateModFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateModFloat");

// Class Brickadia.BRDialogFrameBase
// 0x0000 (0x02D0 - 0x02D0)
class UBRDialogFrameBase : public UUserWidget
{
public:
	void SetDialogTitle(const class FText& DialogTitle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDialogFrameBase">();
	}
	static class UBRDialogFrameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDialogFrameBase>();
	}
};
static_assert(alignof(UBRDialogFrameBase) == 0x000008, "Wrong alignment on UBRDialogFrameBase");
static_assert(sizeof(UBRDialogFrameBase) == 0x0002D0, "Wrong size on UBRDialogFrameBase");

// Class Brickadia.BRDialogContainerBase
// 0x0020 (0x02F0 - 0x02D0)
class UBRDialogContainerBase : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnOpenAnimationComplete;                           // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCloseAnimationComplete;                          // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void PlayCloseAnimation();
	void PlayOpenAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDialogContainerBase">();
	}
	static class UBRDialogContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDialogContainerBase>();
	}
};
static_assert(alignof(UBRDialogContainerBase) == 0x000008, "Wrong alignment on UBRDialogContainerBase");
static_assert(sizeof(UBRDialogContainerBase) == 0x0002F0, "Wrong size on UBRDialogContainerBase");
static_assert(offsetof(UBRDialogContainerBase, OnOpenAnimationComplete) == 0x0002D0, "Member 'UBRDialogContainerBase::OnOpenAnimationComplete' has a wrong offset!");
static_assert(offsetof(UBRDialogContainerBase, OnCloseAnimationComplete) == 0x0002E0, "Member 'UBRDialogContainerBase::OnCloseAnimationComplete' has a wrong offset!");

// Class Brickadia.BROneButtonDialogBase
// 0x0050 (0x0330 - 0x02E0)
class UBROneButtonDialogBase : public UBRDialogBase
{
public:
	class UBRDialogButtonBase*                    DialogButton;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DialogTitle;                                       // 0x02E8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogMessage;                                     // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogButtonMessage;                               // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBRDialogButtonStyle                          DialogButtonStyle;                                 // 0x0318(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_319[0x7];                                      // 0x0319(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DialogButtonIcon;                                  // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEscapeDialog;                                // 0x0328(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SimulateButtonClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BROneButtonDialogBase">();
	}
	static class UBROneButtonDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBROneButtonDialogBase>();
	}
};
static_assert(alignof(UBROneButtonDialogBase) == 0x000008, "Wrong alignment on UBROneButtonDialogBase");
static_assert(sizeof(UBROneButtonDialogBase) == 0x000330, "Wrong size on UBROneButtonDialogBase");
static_assert(offsetof(UBROneButtonDialogBase, DialogButton) == 0x0002E0, "Member 'UBROneButtonDialogBase::DialogButton' has a wrong offset!");
static_assert(offsetof(UBROneButtonDialogBase, DialogTitle) == 0x0002E8, "Member 'UBROneButtonDialogBase::DialogTitle' has a wrong offset!");
static_assert(offsetof(UBROneButtonDialogBase, DialogMessage) == 0x0002F8, "Member 'UBROneButtonDialogBase::DialogMessage' has a wrong offset!");
static_assert(offsetof(UBROneButtonDialogBase, DialogButtonMessage) == 0x000308, "Member 'UBROneButtonDialogBase::DialogButtonMessage' has a wrong offset!");
static_assert(offsetof(UBROneButtonDialogBase, DialogButtonStyle) == 0x000318, "Member 'UBROneButtonDialogBase::DialogButtonStyle' has a wrong offset!");
static_assert(offsetof(UBROneButtonDialogBase, DialogButtonIcon) == 0x000320, "Member 'UBROneButtonDialogBase::DialogButtonIcon' has a wrong offset!");
static_assert(offsetof(UBROneButtonDialogBase, bAllowEscapeDialog) == 0x000328, "Member 'UBROneButtonDialogBase::bAllowEscapeDialog' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateShiftLeftInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateShiftLeftInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateShiftLeftInt">();
	}
	static class UBrickComponentType_GateShiftLeftInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateShiftLeftInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateShiftLeftInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateShiftLeftInt");
static_assert(sizeof(UBrickComponentType_GateShiftLeftInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateShiftLeftInt");

// Class Brickadia.BRTwoButtonsDialogBase
// 0x0070 (0x0350 - 0x02E0)
class UBRTwoButtonsDialogBase : public UBRDialogBase
{
public:
	class UBRDialogButtonBase*                    DialogButton1;                                     // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    DialogButton2;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DialogTitle;                                       // 0x02F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogMessage;                                     // 0x0300(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogButtonMessage1;                              // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogButtonMessage2;                              // 0x0320(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBRDialogButtonStyle                          DialogButtonStyle1;                                // 0x0330(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRDialogButtonStyle                          DialogButtonStyle2;                                // 0x0331(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_332[0x6];                                      // 0x0332(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DialogButtonIcon1;                                 // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DialogButtonIcon2;                                 // 0x0340(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEscapeDialog;                                // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x7];                                      // 0x0349(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SimulateButton1Click();
	void SimulateButton2Click();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTwoButtonsDialogBase">();
	}
	static class UBRTwoButtonsDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTwoButtonsDialogBase>();
	}
};
static_assert(alignof(UBRTwoButtonsDialogBase) == 0x000008, "Wrong alignment on UBRTwoButtonsDialogBase");
static_assert(sizeof(UBRTwoButtonsDialogBase) == 0x000350, "Wrong size on UBRTwoButtonsDialogBase");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButton1) == 0x0002E0, "Member 'UBRTwoButtonsDialogBase::DialogButton1' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButton2) == 0x0002E8, "Member 'UBRTwoButtonsDialogBase::DialogButton2' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogTitle) == 0x0002F0, "Member 'UBRTwoButtonsDialogBase::DialogTitle' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogMessage) == 0x000300, "Member 'UBRTwoButtonsDialogBase::DialogMessage' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButtonMessage1) == 0x000310, "Member 'UBRTwoButtonsDialogBase::DialogButtonMessage1' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButtonMessage2) == 0x000320, "Member 'UBRTwoButtonsDialogBase::DialogButtonMessage2' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButtonStyle1) == 0x000330, "Member 'UBRTwoButtonsDialogBase::DialogButtonStyle1' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButtonStyle2) == 0x000331, "Member 'UBRTwoButtonsDialogBase::DialogButtonStyle2' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButtonIcon1) == 0x000338, "Member 'UBRTwoButtonsDialogBase::DialogButtonIcon1' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, DialogButtonIcon2) == 0x000340, "Member 'UBRTwoButtonsDialogBase::DialogButtonIcon2' has a wrong offset!");
static_assert(offsetof(UBRTwoButtonsDialogBase, bAllowEscapeDialog) == 0x000348, "Member 'UBRTwoButtonsDialogBase::bAllowEscapeDialog' has a wrong offset!");

// Class Brickadia.BRWeaponLibrary
// 0x0000 (0x0028 - 0x0028)
class UBRWeaponLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SpawnExplosionAtLocation(const class UObject* WorldContextObject, TSubclassOf<class UBRWeaponExplosion> ExplosionClass, const struct FVector& Location, const struct FVector& Normal, const struct FVector& Scale, class AActor* DamageCauser, class AController* InstigatorController);
	static void SpawnExplosionAtLocationWithIgnoredActors(const class UObject* WorldContextObject, TSubclassOf<class UBRWeaponExplosion> ExplosionClass, const struct FVector& Location, const struct FVector& Normal, const struct FVector& Scale, const TArray<class AActor*>& IgnoredActors, class AActor* DamageCauser, class AController* InstigatorController);
	static void SpawnExplosionAtLocationWithSeed(const class UObject* WorldContextObject, TSubclassOf<class UBRWeaponExplosion> ExplosionClass, const struct FVector& Location, const struct FVector& Normal, const struct FVector& Scale, const int32 RandomSeed, class AActor* DamageCauser, class AController* InstigatorController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponLibrary">();
	}
	static class UBRWeaponLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponLibrary>();
	}
};
static_assert(alignof(UBRWeaponLibrary) == 0x000008, "Wrong alignment on UBRWeaponLibrary");
static_assert(sizeof(UBRWeaponLibrary) == 0x000028, "Wrong size on UBRWeaponLibrary");

// Class Brickadia.BrickComponentType_GateBlendFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateBlendFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateBlendFloat">();
	}
	static class UBrickComponentType_GateBlendFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateBlendFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateBlendFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateBlendFloat");
static_assert(sizeof(UBrickComponentType_GateBlendFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateBlendFloat");

// Class Brickadia.BRThreeButtonsDialogBase
// 0x0090 (0x0370 - 0x02E0)
class UBRThreeButtonsDialogBase : public UBRDialogBase
{
public:
	class UBRDialogButtonBase*                    DialogButton1;                                     // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    DialogButton2;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    DialogButton3;                                     // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DialogTitle;                                       // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogMessage;                                     // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogButtonMessage1;                              // 0x0318(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogButtonMessage2;                              // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   DialogButtonMessage3;                              // 0x0338(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EBRDialogButtonStyle                          DialogButtonStyle1;                                // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRDialogButtonStyle                          DialogButtonStyle2;                                // 0x0349(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRDialogButtonStyle                          DialogButtonStyle3;                                // 0x034A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34B[0x5];                                      // 0x034B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DialogButtonIcon1;                                 // 0x0350(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DialogButtonIcon2;                                 // 0x0358(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             DialogButtonIcon3;                                 // 0x0360(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowEscapeDialog;                                // 0x0368(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x7];                                      // 0x0369(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SimulateButton1Click();
	void SimulateButton2Click();
	void SimulateButton3Click();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRThreeButtonsDialogBase">();
	}
	static class UBRThreeButtonsDialogBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRThreeButtonsDialogBase>();
	}
};
static_assert(alignof(UBRThreeButtonsDialogBase) == 0x000008, "Wrong alignment on UBRThreeButtonsDialogBase");
static_assert(sizeof(UBRThreeButtonsDialogBase) == 0x000370, "Wrong size on UBRThreeButtonsDialogBase");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButton1) == 0x0002E0, "Member 'UBRThreeButtonsDialogBase::DialogButton1' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButton2) == 0x0002E8, "Member 'UBRThreeButtonsDialogBase::DialogButton2' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButton3) == 0x0002F0, "Member 'UBRThreeButtonsDialogBase::DialogButton3' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogTitle) == 0x0002F8, "Member 'UBRThreeButtonsDialogBase::DialogTitle' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogMessage) == 0x000308, "Member 'UBRThreeButtonsDialogBase::DialogMessage' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonMessage1) == 0x000318, "Member 'UBRThreeButtonsDialogBase::DialogButtonMessage1' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonMessage2) == 0x000328, "Member 'UBRThreeButtonsDialogBase::DialogButtonMessage2' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonMessage3) == 0x000338, "Member 'UBRThreeButtonsDialogBase::DialogButtonMessage3' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonStyle1) == 0x000348, "Member 'UBRThreeButtonsDialogBase::DialogButtonStyle1' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonStyle2) == 0x000349, "Member 'UBRThreeButtonsDialogBase::DialogButtonStyle2' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonStyle3) == 0x00034A, "Member 'UBRThreeButtonsDialogBase::DialogButtonStyle3' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonIcon1) == 0x000350, "Member 'UBRThreeButtonsDialogBase::DialogButtonIcon1' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonIcon2) == 0x000358, "Member 'UBRThreeButtonsDialogBase::DialogButtonIcon2' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, DialogButtonIcon3) == 0x000360, "Member 'UBRThreeButtonsDialogBase::DialogButtonIcon3' has a wrong offset!");
static_assert(offsetof(UBRThreeButtonsDialogBase, bAllowEscapeDialog) == 0x000368, "Member 'UBRThreeButtonsDialogBase::bAllowEscapeDialog' has a wrong offset!");

// Class Brickadia.BRConnectorComponentPortWidget
// 0x0050 (0x0320 - 0x02D0)
class UBRConnectorComponentPortWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickComponentWirePortRef             WirePortRef;                                       // 0x02F0(0x0018)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOutput;                                         // 0x0308(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConnected;                                      // 0x0309(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30A[0x6];                                      // 0x030A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SearchName;                                        // 0x0310(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void NotifyChoose();
	void NotifyDisconnect();
	void ReceiveIsConnected(bool bConnected);
	void ReceivePortDisplayInfo(const class FText& DisplayName, const class FText& Tooltip, const struct FBHResolvedTypeInfo& TypeInfo, bool bInIsOutput);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRConnectorComponentPortWidget">();
	}
	static class UBRConnectorComponentPortWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRConnectorComponentPortWidget>();
	}
};
static_assert(alignof(UBRConnectorComponentPortWidget) == 0x000008, "Wrong alignment on UBRConnectorComponentPortWidget");
static_assert(sizeof(UBRConnectorComponentPortWidget) == 0x000320, "Wrong size on UBRConnectorComponentPortWidget");
static_assert(offsetof(UBRConnectorComponentPortWidget, WirePortRef) == 0x0002F0, "Member 'UBRConnectorComponentPortWidget::WirePortRef' has a wrong offset!");
static_assert(offsetof(UBRConnectorComponentPortWidget, bIsOutput) == 0x000308, "Member 'UBRConnectorComponentPortWidget::bIsOutput' has a wrong offset!");
static_assert(offsetof(UBRConnectorComponentPortWidget, bIsConnected) == 0x000309, "Member 'UBRConnectorComponentPortWidget::bIsConnected' has a wrong offset!");
static_assert(offsetof(UBRConnectorComponentPortWidget, SearchName) == 0x000310, "Member 'UBRConnectorComponentPortWidget::SearchName' has a wrong offset!");

// Class Brickadia.BRDynamicImage
// 0x0020 (0x02D0 - 0x02B0)
class UBRDynamicImage : public UImage
{
public:
	uint8                                         Pad_2A8[0x28];                                     // 0x02A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDynamicImage">();
	}
	static class UBRDynamicImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDynamicImage>();
	}
};
static_assert(alignof(UBRDynamicImage) == 0x000010, "Wrong alignment on UBRDynamicImage");
static_assert(sizeof(UBRDynamicImage) == 0x0002D0, "Wrong size on UBRDynamicImage");

// Class Brickadia.BrickComponentType_GateNotEqualsBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNotEqualsBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNotEqualsBool">();
	}
	static class UBrickComponentType_GateNotEqualsBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNotEqualsBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateNotEqualsBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateNotEqualsBool");
static_assert(sizeof(UBrickComponentType_GateNotEqualsBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateNotEqualsBool");

// Class Brickadia.BRDynamicTransformProxy
// 0x0000 (0x01B0 - 0x01B0)
class UBRDynamicTransformProxy final : public UTransformProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDynamicTransformProxy">();
	}
	static class UBRDynamicTransformProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDynamicTransformProxy>();
	}
};
static_assert(alignof(UBRDynamicTransformProxy) == 0x000010, "Wrong alignment on UBRDynamicTransformProxy");
static_assert(sizeof(UBRDynamicTransformProxy) == 0x0001B0, "Wrong size on UBRDynamicTransformProxy");

// Class Brickadia.BREntityActor
// 0x0030 (0x02E0 - 0x02B0)
class ABREntityActor : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OwnerId;                                           // 0x02B8(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Colors[0x8];                                       // 0x02BC(0x0004)(Edit, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateColors();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BREntityActor">();
	}
	static class ABREntityActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABREntityActor>();
	}
};
static_assert(alignof(ABREntityActor) == 0x000008, "Wrong alignment on ABREntityActor");
static_assert(sizeof(ABREntityActor) == 0x0002E0, "Wrong size on ABREntityActor");
static_assert(offsetof(ABREntityActor, OwnerId) == 0x0002B8, "Member 'ABREntityActor::OwnerId' has a wrong offset!");
static_assert(offsetof(ABREntityActor, Colors) == 0x0002BC, "Member 'ABREntityActor::Colors' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateDivideInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateDivideInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateDivideInt">();
	}
	static class UBrickComponentType_GateDivideInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateDivideInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateDivideInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateDivideInt");
static_assert(sizeof(UBrickComponentType_GateDivideInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateDivideInt");

// Class Brickadia.BREntity
// 0x0000 (0x0028 - 0x0028)
class IBREntity final : public IInterface
{
public:
	void SetColor(int32 Index_0, const struct FColor& Color);
	void SetOwnerId(int32 OwnerId);

	struct FColor GetColor(int32 Index_0) const;
	struct FColor GetDefaultColor(int32 Index_0) const;
	class UBREntityTypeBase* GetEntityType() const;
	struct FBrickOwnerData GetOwnerData() const;
	int32 GetOwnerId() const;
	struct FBREntityPersistentHandle GetPersistentHandle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BREntity">();
	}
	static class IBREntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBREntity>();
	}
};
static_assert(alignof(IBREntity) == 0x000008, "Wrong alignment on IBREntity");
static_assert(sizeof(IBREntity) == 0x000028, "Wrong size on IBREntity");

// Class Brickadia.BREntityTypeBase
// 0x0080 (0x00A8 - 0x0028)
class UBREntityTypeBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            PreviewMesh;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyDescriptorList> InspectorList;                                     // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPresetDescriptor*                    PresetDescriptor;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRCatalogData                         CatalogData;                                       // 0x0050(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CurrentVersion;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerPlaceable;                                  // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerRemovable;                                  // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0xA];                                       // 0x009E(0x000A)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BREntityTypeBase">();
	}
	static class UBREntityTypeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBREntityTypeBase>();
	}
};
static_assert(alignof(UBREntityTypeBase) == 0x000008, "Wrong alignment on UBREntityTypeBase");
static_assert(sizeof(UBREntityTypeBase) == 0x0000A8, "Wrong size on UBREntityTypeBase");
static_assert(offsetof(UBREntityTypeBase, ActorClass) == 0x000030, "Member 'UBREntityTypeBase::ActorClass' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, PreviewMesh) == 0x000038, "Member 'UBREntityTypeBase::PreviewMesh' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, InspectorList) == 0x000040, "Member 'UBREntityTypeBase::InspectorList' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, PresetDescriptor) == 0x000048, "Member 'UBREntityTypeBase::PresetDescriptor' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, CatalogData) == 0x000050, "Member 'UBREntityTypeBase::CatalogData' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, CurrentVersion) == 0x000098, "Member 'UBREntityTypeBase::CurrentVersion' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, bPlayerPlaceable) == 0x00009C, "Member 'UBREntityTypeBase::bPlayerPlaceable' has a wrong offset!");
static_assert(offsetof(UBREntityTypeBase, bPlayerRemovable) == 0x00009D, "Member 'UBREntityTypeBase::bPlayerRemovable' has a wrong offset!");

// Class Brickadia.BREnvironmentManagerComponent
// 0x0000 (0x00A8 - 0x00A8)
class UBREnvironmentManagerComponent final : public UActorComponent
{
public:
	void ServerChangeEnvironmentSettingsGroup(class FName SettingsGroupName, const struct FInspectorPropertyChangelist& Changelist);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BREnvironmentManagerComponent">();
	}
	static class UBREnvironmentManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBREnvironmentManagerComponent>();
	}
};
static_assert(alignof(UBREnvironmentManagerComponent) == 0x000008, "Wrong alignment on UBREnvironmentManagerComponent");
static_assert(sizeof(UBREnvironmentManagerComponent) == 0x0000A8, "Wrong size on UBREnvironmentManagerComponent");

// Class Brickadia.BRWeaponExplosion
// 0x0050 (0x0078 - 0x0028)
class UBRWeaponExplosion final : public UObject
{
public:
	class UParticleSystem*                        ParticleEffect;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundEffect;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRadialDamage;                               // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableRadialDamageOcclusion;                      // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRDamageType>              RadialDamageType;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRadialDamageParams                    RadialDamageParams;                                // 0x0048(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ABRWeaponProjectile>        ProjectileClass;                                   // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfShots;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadConeAngle;                                   // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpreadBiasedTowardsCenter;                        // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SpawnExplosionAtLocation(const class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Normal, const struct FVector& Scale, const TArray<class AActor*>& IgnoredActors, class AActor* DamageCauser, class AController* InstigatorController) const;
	void SpawnExplosionAtLocationWithSeed(const class UObject* WorldContextObject, const struct FVector& Location, const struct FVector& Normal, const struct FVector& Scale, const int32 RandomSeed, const TArray<class AActor*>& IgnoredActors, class AActor* DamageCauser, class AController* InstigatorController) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponExplosion">();
	}
	static class UBRWeaponExplosion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponExplosion>();
	}
};
static_assert(alignof(UBRWeaponExplosion) == 0x000008, "Wrong alignment on UBRWeaponExplosion");
static_assert(sizeof(UBRWeaponExplosion) == 0x000078, "Wrong size on UBRWeaponExplosion");
static_assert(offsetof(UBRWeaponExplosion, ParticleEffect) == 0x000028, "Member 'UBRWeaponExplosion::ParticleEffect' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, SoundEffect) == 0x000030, "Member 'UBRWeaponExplosion::SoundEffect' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, bEnableRadialDamage) == 0x000038, "Member 'UBRWeaponExplosion::bEnableRadialDamage' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, bEnableRadialDamageOcclusion) == 0x000039, "Member 'UBRWeaponExplosion::bEnableRadialDamageOcclusion' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, RadialDamageType) == 0x000040, "Member 'UBRWeaponExplosion::RadialDamageType' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, RadialDamageParams) == 0x000048, "Member 'UBRWeaponExplosion::RadialDamageParams' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, ProjectileClass) == 0x000060, "Member 'UBRWeaponExplosion::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, NumberOfShots) == 0x000068, "Member 'UBRWeaponExplosion::NumberOfShots' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, SpreadConeAngle) == 0x00006C, "Member 'UBRWeaponExplosion::SpreadConeAngle' has a wrong offset!");
static_assert(offsetof(UBRWeaponExplosion, bSpreadBiasedTowardsCenter) == 0x000070, "Member 'UBRWeaponExplosion::bSpreadBiasedTowardsCenter' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateFloorFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateFloorFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateFloorFloat">();
	}
	static class UBrickComponentType_GateFloorFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateFloorFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateFloorFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateFloorFloat");
static_assert(sizeof(UBrickComponentType_GateFloorFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateFloorFloat");

// Class Brickadia.BRFontHelperLibrary
// 0x0000 (0x0028 - 0x0028)
class UBRFontHelperLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FVector2D MeasureString(const class FString& Text, const struct FSlateFontInfo& InFontInfo, float FontScale);
	static struct FVector2D MeasureStringExtended(const class FString& Text, int32 StartIndex, int32 EndIndex, const struct FSlateFontInfo& InFontInfo, bool bIncludeKerningWithPrecedingChar, float FontScale);
	static struct FVector2D MeasureText(const class FText& Text, const struct FSlateFontInfo& InFontInfo, float FontScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRFontHelperLibrary">();
	}
	static class UBRFontHelperLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRFontHelperLibrary>();
	}
};
static_assert(alignof(UBRFontHelperLibrary) == 0x000008, "Wrong alignment on UBRFontHelperLibrary");
static_assert(sizeof(UBRFontHelperLibrary) == 0x000028, "Wrong size on UBRFontHelperLibrary");

// Class Brickadia.BRWeaponStateBehavior
// 0x0000 (0x0028 - 0x0028)
class UBRWeaponStateBehavior : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior">();
	}
	static class UBRWeaponStateBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior");
static_assert(sizeof(UBRWeaponStateBehavior) == 0x000028, "Wrong size on UBRWeaponStateBehavior");

// Class Brickadia.BRWeaponStateBehavior_ChangesResources
// 0x0010 (0x0038 - 0x0028)
class UBRWeaponStateBehavior_ChangesResources : public UBRWeaponStateBehavior
{
public:
	TArray<struct FBRWeaponResourceChange>        ResourcesToChange;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	void ProcessResources(class ABRWeaponBase* Weapon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_ChangesResources">();
	}
	static class UBRWeaponStateBehavior_ChangesResources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_ChangesResources>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_ChangesResources) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_ChangesResources");
static_assert(sizeof(UBRWeaponStateBehavior_ChangesResources) == 0x000038, "Wrong size on UBRWeaponStateBehavior_ChangesResources");
static_assert(offsetof(UBRWeaponStateBehavior_ChangesResources, ResourcesToChange) == 0x000028, "Member 'UBRWeaponStateBehavior_ChangesResources::ResourcesToChange' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_Firing
// 0x0018 (0x0050 - 0x0038)
class UBRWeaponStateBehavior_Firing : public UBRWeaponStateBehavior_ChangesResources
{
public:
	class FName                                   MuzzleSocket;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfShots;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegacyAmmoToSubtract;                              // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpreadConeAngle;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpreadBiasedTowardsCenter;                        // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_Firing">();
	}
	static class UBRWeaponStateBehavior_Firing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_Firing>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_Firing) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_Firing");
static_assert(sizeof(UBRWeaponStateBehavior_Firing) == 0x000050, "Wrong size on UBRWeaponStateBehavior_Firing");
static_assert(offsetof(UBRWeaponStateBehavior_Firing, MuzzleSocket) == 0x000038, "Member 'UBRWeaponStateBehavior_Firing::MuzzleSocket' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_Firing, NumberOfShots) == 0x000040, "Member 'UBRWeaponStateBehavior_Firing::NumberOfShots' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_Firing, LegacyAmmoToSubtract) == 0x000044, "Member 'UBRWeaponStateBehavior_Firing::LegacyAmmoToSubtract' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_Firing, SpreadConeAngle) == 0x000048, "Member 'UBRWeaponStateBehavior_Firing::SpreadConeAngle' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_Firing, bSpreadBiasedTowardsCenter) == 0x00004C, "Member 'UBRWeaponStateBehavior_Firing::bSpreadBiasedTowardsCenter' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateBlendInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateBlendInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateBlendInt">();
	}
	static class UBrickComponentType_GateBlendInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateBlendInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateBlendInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateBlendInt");
static_assert(sizeof(UBrickComponentType_GateBlendInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateBlendInt");

// Class Brickadia.BRConnectorStatusWidget
// 0x0000 (0x02D8 - 0x02D8)
class UBRConnectorStatusWidget final : public UBRToolWidget
{
public:
	void ClearInput();
	void ClearOutput();
	void SetInputActive(bool bActive);
	void SetInputName(const class FText& CompName, const class FText& Name_0);
	void SetOutputActive(bool bActive);
	void SetOutputName(const class FText& CompName, const class FText& Name_0);

	class ABRTool_Connector* GetConnector() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRConnectorStatusWidget">();
	}
	static class UBRConnectorStatusWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRConnectorStatusWidget>();
	}
};
static_assert(alignof(UBRConnectorStatusWidget) == 0x000008, "Wrong alignment on UBRConnectorStatusWidget");
static_assert(sizeof(UBRConnectorStatusWidget) == 0x0002D8, "Wrong size on UBRConnectorStatusWidget");

// Class Brickadia.BRGameEngine
// 0x0008 (0x1250 - 0x1248)
class UBRGameEngine final : public UGameEngine
{
public:
	uint8                                         Pad_1248[0x8];                                     // 0x1248(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameEngine">();
	}
	static class UBRGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameEngine>();
	}
};
static_assert(alignof(UBRGameEngine) == 0x000008, "Wrong alignment on UBRGameEngine");
static_assert(sizeof(UBRGameEngine) == 0x001250, "Wrong size on UBRGameEngine");

// Class Brickadia.BRTool_Painter
// 0x0028 (0x0628 - 0x0600)
class ABRTool_Painter final : public ABRColorPaletteToolBase
{
public:
	class USoundBase*                             FillSound;                                         // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      FillSoundAttenuation;                              // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      FillSoundConcurrency;                              // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFiring;                                           // 0x0618(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_619[0xF];                                      // 0x0619(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Effects_FillPaint();
	void Effects_FiringChanged();
	void MulticastFillPaintEffects();
	void ServerFillPaint(const struct FBrickHandle& BrickHandle, const struct FBRColorSelectionState& ClientColorSelectionState, bool bPaintColor, bool bPaintMaterial);
	void ServerPaintBrick(const struct FBrickHandle& BrickHandle, const struct FBRColorSelectionState& ClientColorSelectionState, int32 ClientStrokeIndex, bool bMergePaintStrokes, bool bPaintColor, bool bPaintMaterial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Painter">();
	}
	static class ABRTool_Painter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Painter>();
	}
};
static_assert(alignof(ABRTool_Painter) == 0x000008, "Wrong alignment on ABRTool_Painter");
static_assert(sizeof(ABRTool_Painter) == 0x000628, "Wrong size on ABRTool_Painter");
static_assert(offsetof(ABRTool_Painter, FillSound) == 0x000600, "Member 'ABRTool_Painter::FillSound' has a wrong offset!");
static_assert(offsetof(ABRTool_Painter, FillSoundAttenuation) == 0x000608, "Member 'ABRTool_Painter::FillSoundAttenuation' has a wrong offset!");
static_assert(offsetof(ABRTool_Painter, FillSoundConcurrency) == 0x000610, "Member 'ABRTool_Painter::FillSoundConcurrency' has a wrong offset!");
static_assert(offsetof(ABRTool_Painter, bFiring) == 0x000618, "Member 'ABRTool_Painter::bFiring' has a wrong offset!");

// Class Brickadia.BRGameInstance
// 0x02B0 (0x0470 - 0x01C0)
class UBRGameInstance : public UGameInstance
{
public:
	TMulticastInlineDelegate<void()>              OnRecentlyUsedBricksUpdated;                       // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D0[0x20];                                     // 0x01D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             TextFilterTable;                                   // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HintTable;                                         // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPresetDescriptor*                    ColorPalettePresetDescriptor;                      // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRColorPalette*                        DefaultColorPalette;                               // 0x0208(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxColorPaletteGroups;                             // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxColorPaletteRows;                               // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBrickMaterialCollection*>       BrickMaterials;                                    // 0x0218(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UBrickType*>                     RecentlyUsedBricks;                                // 0x0228(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FBRPickupMaterialCollection>    DefaultPickupMaterialCollections;                  // 0x0238(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2DArray*                        BrickPortTextures;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  DefaultInventory[0xA];                             // 0x0250(0x0030)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FBrickTypeNetWrapper                   DefaultPlacerBrickType;                            // 0x0430(0x0018)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             EmojiSet;                                          // 0x0448(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_450[0x20];                                     // 0x0450(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRGameInstance* GetBRGameInstance(const class UObject* WorldContextObject);

	TArray<class FString> GetMessagesFromHistory(int32 StartIndex, int32 MaxNumMessages);
	int32 GetNumRecentMessages(float Time);
	bool PushChatMessage(const class FString& Message, const struct FBRGuid& SenderId);
	void PushRecentlyUsedBrick(class UBrickType* BrickType);
	void RemoveRecentlyUsedBrick(class UBrickType* BrickType);
	void RequestNewInviteCodeNextSession();

	struct FSlateBrush FindEmojiBrush(class FName TagOrId) const;
	int32 GetBrickMaterialIndex(class FName Name_0) const;
	TArray<int32> GetMaterialIndicesUsableForPainting() const;
	int32 GetMessageHistoryLength() const;
	bool IsMaterialIndexUsableForPainting(int32 MaterialIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameInstance">();
	}
	static class UBRGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameInstance>();
	}
};
static_assert(alignof(UBRGameInstance) == 0x000008, "Wrong alignment on UBRGameInstance");
static_assert(sizeof(UBRGameInstance) == 0x000470, "Wrong size on UBRGameInstance");
static_assert(offsetof(UBRGameInstance, OnRecentlyUsedBricksUpdated) == 0x0001C0, "Member 'UBRGameInstance::OnRecentlyUsedBricksUpdated' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, TextFilterTable) == 0x0001F0, "Member 'UBRGameInstance::TextFilterTable' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, HintTable) == 0x0001F8, "Member 'UBRGameInstance::HintTable' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, ColorPalettePresetDescriptor) == 0x000200, "Member 'UBRGameInstance::ColorPalettePresetDescriptor' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, DefaultColorPalette) == 0x000208, "Member 'UBRGameInstance::DefaultColorPalette' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, MaxColorPaletteGroups) == 0x000210, "Member 'UBRGameInstance::MaxColorPaletteGroups' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, MaxColorPaletteRows) == 0x000214, "Member 'UBRGameInstance::MaxColorPaletteRows' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, BrickMaterials) == 0x000218, "Member 'UBRGameInstance::BrickMaterials' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, RecentlyUsedBricks) == 0x000228, "Member 'UBRGameInstance::RecentlyUsedBricks' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, DefaultPickupMaterialCollections) == 0x000238, "Member 'UBRGameInstance::DefaultPickupMaterialCollections' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, BrickPortTextures) == 0x000248, "Member 'UBRGameInstance::BrickPortTextures' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, DefaultInventory) == 0x000250, "Member 'UBRGameInstance::DefaultInventory' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, DefaultPlacerBrickType) == 0x000430, "Member 'UBRGameInstance::DefaultPlacerBrickType' has a wrong offset!");
static_assert(offsetof(UBRGameInstance, EmojiSet) == 0x000448, "Member 'UBRGameInstance::EmojiSet' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateNotEqualsInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNotEqualsInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNotEqualsInt">();
	}
	static class UBrickComponentType_GateNotEqualsInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNotEqualsInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateNotEqualsInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateNotEqualsInt");
static_assert(sizeof(UBrickComponentType_GateNotEqualsInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateNotEqualsInt");

// Class Brickadia.BRServerSettingsGameModeBase
// 0x0000 (0x0348 - 0x0348)
class ABRServerSettingsGameModeBase : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettingsGameModeBase">();
	}
	static class ABRServerSettingsGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRServerSettingsGameModeBase>();
	}
};
static_assert(alignof(ABRServerSettingsGameModeBase) == 0x000008, "Wrong alignment on ABRServerSettingsGameModeBase");
static_assert(sizeof(ABRServerSettingsGameModeBase) == 0x000348, "Wrong size on ABRServerSettingsGameModeBase");

// Class Brickadia.BRGameModeBase
// 0x0018 (0x0360 - 0x0348)
class ABRGameModeBase final : public ABRServerSettingsGameModeBase
{
public:
	TSubclassOf<class ABRRuleset>                 RulesetClass;                                      // 0x0348(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBRCharacterWithHistory>        CharactersWithHistory;                             // 0x0350(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameModeBase">();
	}
	static class ABRGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRGameModeBase>();
	}
};
static_assert(alignof(ABRGameModeBase) == 0x000008, "Wrong alignment on ABRGameModeBase");
static_assert(sizeof(ABRGameModeBase) == 0x000360, "Wrong size on ABRGameModeBase");
static_assert(offsetof(ABRGameModeBase, RulesetClass) == 0x000348, "Member 'ABRGameModeBase::RulesetClass' has a wrong offset!");
static_assert(offsetof(ABRGameModeBase, CharactersWithHistory) == 0x000350, "Member 'ABRGameModeBase::CharactersWithHistory' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateNotEqualsFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNotEqualsFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNotEqualsFloat">();
	}
	static class UBrickComponentType_GateNotEqualsFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNotEqualsFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateNotEqualsFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateNotEqualsFloat");
static_assert(sizeof(UBrickComponentType_GateNotEqualsFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateNotEqualsFloat");

// Class Brickadia.BRGamepadControls
// 0x0010 (0x0040 - 0x0030)
class UBRGamepadControls final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGamepadControls">();
	}
	static class UBRGamepadControls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGamepadControls>();
	}
};
static_assert(alignof(UBRGamepadControls) == 0x000008, "Wrong alignment on UBRGamepadControls");
static_assert(sizeof(UBRGamepadControls) == 0x000040, "Wrong size on UBRGamepadControls");

// Class Brickadia.BRGameSession
// 0x0060 (0x0338 - 0x02D8)
class ABRGameSession final : public AGameSession
{
public:
	uint8                                         Pad_2D8[0x40];                                     // 0x02D8(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UNetConnection*>                 ConnectionsAwaitingChallenge;                      // 0x0318(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool BRKickPlayer(class ABRPlayerController* KickedPlayer, class ABRPlayerController* Kicker, const class FString& KickReason);
	void HandleAuthComplete();
	void HandleServerSettingsUpdate(class UBRGameSettingsBase* Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameSession">();
	}
	static class ABRGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRGameSession>();
	}
};
static_assert(alignof(ABRGameSession) == 0x000008, "Wrong alignment on ABRGameSession");
static_assert(sizeof(ABRGameSession) == 0x000338, "Wrong size on ABRGameSession");
static_assert(offsetof(ABRGameSession, ConnectionsAwaitingChallenge) == 0x000318, "Member 'ABRGameSession::ConnectionsAwaitingChallenge' has a wrong offset!");

// Class Brickadia.BRServerListItem
// 0x00F0 (0x0118 - 0x0028)
class UBRServerListItem final : public UObject
{
public:
	struct FJsonResponse_GetServers_Entry         ServerInfo;                                        // 0x0028(0x00F0)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerListItem">();
	}
	static class UBRServerListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerListItem>();
	}
};
static_assert(alignof(UBRServerListItem) == 0x000008, "Wrong alignment on UBRServerListItem");
static_assert(sizeof(UBRServerListItem) == 0x000118, "Wrong size on UBRServerListItem");
static_assert(offsetof(UBRServerListItem, ServerInfo) == 0x000028, "Member 'UBRServerListItem::ServerInfo' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_DamageOrHeal
// 0x0008 (0x0030 - 0x0028)
class UBRWeaponStateBehavior_DamageOrHeal final : public UBRWeaponStateBehavior
{
public:
	float                                         Damage;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamageScalesWithItemScale;                        // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_DamageOrHeal">();
	}
	static class UBRWeaponStateBehavior_DamageOrHeal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_DamageOrHeal>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_DamageOrHeal) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_DamageOrHeal");
static_assert(sizeof(UBRWeaponStateBehavior_DamageOrHeal) == 0x000030, "Wrong size on UBRWeaponStateBehavior_DamageOrHeal");
static_assert(offsetof(UBRWeaponStateBehavior_DamageOrHeal, Damage) == 0x000028, "Member 'UBRWeaponStateBehavior_DamageOrHeal::Damage' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_DamageOrHeal, bDamageScalesWithItemScale) == 0x00002C, "Member 'UBRWeaponStateBehavior_DamageOrHeal::bDamageScalesWithItemScale' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateModInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateModInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateModInt">();
	}
	static class UBrickComponentType_GateModInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateModInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateModInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateModInt");
static_assert(sizeof(UBrickComponentType_GateModInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateModInt");

// Class Brickadia.BRGetServerListAsyncAction
// 0x0028 (0x0058 - 0x0030)
class UBRGetServerListAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, const TArray<class UBRServerListItem*>& Items, int32 NumPlayers, int32 NumServers)> OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Sequence)> OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRGetServerListAsyncAction* AsyncGetServerList(class UObject* WorldContextObject, int32 InSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGetServerListAsyncAction">();
	}
	static class UBRGetServerListAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGetServerListAsyncAction>();
	}
};
static_assert(alignof(UBRGetServerListAsyncAction) == 0x000008, "Wrong alignment on UBRGetServerListAsyncAction");
static_assert(sizeof(UBRGetServerListAsyncAction) == 0x000058, "Wrong size on UBRGetServerListAsyncAction");
static_assert(offsetof(UBRGetServerListAsyncAction, OnSuccess) == 0x000030, "Member 'UBRGetServerListAsyncAction::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBRGetServerListAsyncAction, OnFailed) == 0x000040, "Member 'UBRGetServerListAsyncAction::OnFailed' has a wrong offset!");

// Class Brickadia.BrickComponentType_GoalPoint
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GoalPoint final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GoalPoint">();
	}
	static class UBrickComponentType_GoalPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GoalPoint>();
	}
};
static_assert(alignof(UBrickComponentType_GoalPoint) == 0x000008, "Wrong alignment on UBrickComponentType_GoalPoint");
static_assert(sizeof(UBrickComponentType_GoalPoint) == 0x0001D8, "Wrong size on UBrickComponentType_GoalPoint");

// Class Brickadia.BRGetServerInfoAsyncAction
// 0x0038 (0x0068 - 0x0030)
class UBRGetServerInfoAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, const struct FJsonResponse_GetServers_Entry& Response)> OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Sequence)> OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRGetServerInfoAsyncAction* AsyncGetServerInfo(class UObject* WorldContextObject, int32 InSequence, const class FString& Identity);
	static class UBRGetServerInfoAsyncAction* AsyncGetServerInfoByInviteCode(class UObject* WorldContextObject, int32 InSequence, const class FString& InviteCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGetServerInfoAsyncAction">();
	}
	static class UBRGetServerInfoAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGetServerInfoAsyncAction>();
	}
};
static_assert(alignof(UBRGetServerInfoAsyncAction) == 0x000008, "Wrong alignment on UBRGetServerInfoAsyncAction");
static_assert(sizeof(UBRGetServerInfoAsyncAction) == 0x000068, "Wrong size on UBRGetServerInfoAsyncAction");
static_assert(offsetof(UBRGetServerInfoAsyncAction, OnSuccess) == 0x000030, "Member 'UBRGetServerInfoAsyncAction::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBRGetServerInfoAsyncAction, OnFailed) == 0x000040, "Member 'UBRGetServerInfoAsyncAction::OnFailed' has a wrong offset!");

// Class Brickadia.BRServerListHelpers
// 0x0000 (0x0028 - 0x0028)
class UBRServerListHelpers final : public UBlueprintFunctionLibrary
{
public:
	static void FilterServerItems(const TArray<class UObject*>& Items, const class FString& SearchString, TArray<class UObject*>* OutFilteredItems);
	static class UObject* FilterServerItemsExact(const TArray<class UObject*>& Items, const class FString& Identity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerListHelpers">();
	}
	static class UBRServerListHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerListHelpers>();
	}
};
static_assert(alignof(UBRServerListHelpers) == 0x000008, "Wrong alignment on UBRServerListHelpers");
static_assert(sizeof(UBRServerListHelpers) == 0x000028, "Wrong size on UBRServerListHelpers");

// Class Brickadia.BrickComponentType_ConstantString
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_ConstantString final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_ConstantString">();
	}
	static class UBrickComponentType_ConstantString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_ConstantString>();
	}
};
static_assert(alignof(UBrickComponentType_ConstantString) == 0x000008, "Wrong alignment on UBrickComponentType_ConstantString");
static_assert(sizeof(UBrickComponentType_ConstantString) == 0x0001D8, "Wrong size on UBrickComponentType_ConstantString");

// Class Brickadia.BRInputBindingDescriptorList
// 0x0010 (0x0040 - 0x0030)
class UBRInputBindingDescriptorList final : public UDataAsset
{
public:
	TArray<struct FBRInputCategoryDescriptor>     Categories;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputBindingDescriptorList">();
	}
	static class UBRInputBindingDescriptorList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputBindingDescriptorList>();
	}
};
static_assert(alignof(UBRInputBindingDescriptorList) == 0x000008, "Wrong alignment on UBRInputBindingDescriptorList");
static_assert(sizeof(UBRInputBindingDescriptorList) == 0x000040, "Wrong size on UBRInputBindingDescriptorList");
static_assert(offsetof(UBRInputBindingDescriptorList, Categories) == 0x000030, "Member 'UBRInputBindingDescriptorList::Categories' has a wrong offset!");

// Class Brickadia.BRInputKeyDisplayNames
// 0x0090 (0x00C0 - 0x0030)
class UBRInputKeyDisplayNames final : public UDataAsset
{
public:
	TMap<struct FKey, class FText>                KeyDisplayNameOverrides;                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ShiftDisplayName;                                  // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CtrlDisplayName;                                   // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   AltDisplayName;                                    // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CmdDisplayName;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class FText GetShortKeyDisplayName(const struct FKey& Key) const;
	class FText GetShortKeyDisplayName_WithModifiers(const struct FBRInputKey_WithModifiers& KeyWithModifiers) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputKeyDisplayNames">();
	}
	static class UBRInputKeyDisplayNames* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputKeyDisplayNames>();
	}
};
static_assert(alignof(UBRInputKeyDisplayNames) == 0x000008, "Wrong alignment on UBRInputKeyDisplayNames");
static_assert(sizeof(UBRInputKeyDisplayNames) == 0x0000C0, "Wrong size on UBRInputKeyDisplayNames");
static_assert(offsetof(UBRInputKeyDisplayNames, KeyDisplayNameOverrides) == 0x000030, "Member 'UBRInputKeyDisplayNames::KeyDisplayNameOverrides' has a wrong offset!");
static_assert(offsetof(UBRInputKeyDisplayNames, ShiftDisplayName) == 0x000080, "Member 'UBRInputKeyDisplayNames::ShiftDisplayName' has a wrong offset!");
static_assert(offsetof(UBRInputKeyDisplayNames, CtrlDisplayName) == 0x000090, "Member 'UBRInputKeyDisplayNames::CtrlDisplayName' has a wrong offset!");
static_assert(offsetof(UBRInputKeyDisplayNames, AltDisplayName) == 0x0000A0, "Member 'UBRInputKeyDisplayNames::AltDisplayName' has a wrong offset!");
static_assert(offsetof(UBRInputKeyDisplayNames, CmdDisplayName) == 0x0000B0, "Member 'UBRInputKeyDisplayNames::CmdDisplayName' has a wrong offset!");

// Class Brickadia.BrickComponentType_Touch
// 0x0020 (0x01F8 - 0x01D8)
class UBrickComponentType_Touch : public UBrickComponentTypeBase
{
public:
	class UBrickOneShotAudioDescriptor*           DefaultBeginTouchSound;                            // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickOneShotAudioDescriptor*           DefaultEndTouchSound;                              // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      TouchAttenuation;                                  // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      TouchConcurrency;                                  // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Touch">();
	}
	static class UBrickComponentType_Touch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Touch>();
	}
};
static_assert(alignof(UBrickComponentType_Touch) == 0x000008, "Wrong alignment on UBrickComponentType_Touch");
static_assert(sizeof(UBrickComponentType_Touch) == 0x0001F8, "Wrong size on UBrickComponentType_Touch");
static_assert(offsetof(UBrickComponentType_Touch, DefaultBeginTouchSound) == 0x0001D8, "Member 'UBrickComponentType_Touch::DefaultBeginTouchSound' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Touch, DefaultEndTouchSound) == 0x0001E0, "Member 'UBrickComponentType_Touch::DefaultEndTouchSound' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Touch, TouchAttenuation) == 0x0001E8, "Member 'UBrickComponentType_Touch::TouchAttenuation' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Touch, TouchConcurrency) == 0x0001F0, "Member 'UBrickComponentType_Touch::TouchConcurrency' has a wrong offset!");

// Class Brickadia.BRGameSettingsSubsystem
// 0x0110 (0x0140 - 0x0030)
class UBRGameSettingsSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<TSubclassOf<class UBRServerSettingsBase>> ServerSettingsClasses;                             // 0x0030(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRServerSettingsBase* SettingsObject)> OnServerSettingsBecomeAvailable;                   // 0x0040(0x0010)(ZeroConstructor, Transient, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UBRGameSettingsBase>, class UBRGameSettingsBase*> SettingsInstanceCollection;                        // 0x0050(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0xA0];                                      // 0x00A0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReloadAllSettings();
	void SaveAllSettings();
	void SubscribeToChanges(TSubclassOf<class UBRGameSettingsBase> SettingsClass, const TDelegate<void(class UBRGameSettingsBase* SettingsObject)>& Event);
	void SubscribeToLiveChanges(TSubclassOf<class UBRGameSettingsBase> SettingsClass, const TDelegate<void(class UBRGameSettingsBase* SettingsObject)>& Event);

	TArray<class UBRGameSettingsBase*> GetAllSettingsInstances() const;
	class UBRGameSettingsBase* GetSettingsInstance(TSubclassOf<class UBRGameSettingsBase> SettingsClass) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameSettingsSubsystem">();
	}
	static class UBRGameSettingsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameSettingsSubsystem>();
	}
};
static_assert(alignof(UBRGameSettingsSubsystem) == 0x000008, "Wrong alignment on UBRGameSettingsSubsystem");
static_assert(sizeof(UBRGameSettingsSubsystem) == 0x000140, "Wrong size on UBRGameSettingsSubsystem");
static_assert(offsetof(UBRGameSettingsSubsystem, ServerSettingsClasses) == 0x000030, "Member 'UBRGameSettingsSubsystem::ServerSettingsClasses' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsSubsystem, OnServerSettingsBecomeAvailable) == 0x000040, "Member 'UBRGameSettingsSubsystem::OnServerSettingsBecomeAvailable' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsSubsystem, SettingsInstanceCollection) == 0x000050, "Member 'UBRGameSettingsSubsystem::SettingsInstanceCollection' has a wrong offset!");

// Class Brickadia.BRGameSettingsBase_Controls
// 0x0138 (0x0180 - 0x0048)
class UBRGameSettingsBase_Controls : public UBRGameSettingsBase
{
public:
	uint8                                         Pad_48[0x30];                                      // 0x0048(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTapToSprint;                                      // 0x0078(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MouseSensitivityX;                                 // 0x007C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MouseSensitivityY;                                 // 0x0080(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMouseSmoothing;                             // 0x0084(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftStickSensitivityX;                             // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftStickSensitivityY;                             // 0x008C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightStickSensitivityX;                            // 0x0090(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightStickSensitivityY;                            // 0x0094(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0xA8];                                      // 0x0098(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBRInputBindingExport_Action>   ExportedActionOverrides;                           // 0x0140(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FBRInputBindingExport_Axis>     ExportedAxisOverrides;                             // 0x0150(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x20];                                     // 0x0160(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UInspectorPropertyDescriptorList* AppendInputBindingDescriptors(TSubclassOf<class UInspectorPropertyDescriptorList> BaseDescriptorListClass, TSubclassOf<class UInspectorPropertyWidgetBase> PropertyWidgetClass_Action, TSubclassOf<class UInspectorPropertyWidgetBase> PropertyWidgetClass_Axis, TSubclassOf<class UInspectorCategoryRowBase> CategoryWidgetClass, class UBRInputBindingDescriptorList* InputBindingDescriptorList);
	void SetActionBindingDetails(class FName ActionName, const struct FBRInputBindingDetails_Action& NewDetails);
	void SetAxisBindingDetails(class FName AxisName, const struct FBRInputBindingDetails_Axis& NewDetails);
	void SetEnableMouseSmoothing(bool bEnabled);
	void SetLeftStickSensitivityX(float NewSensitivity);
	void SetLeftStickSensitivityY(float NewSensitivity);
	void SetMouseSensitivityX(float NewSensitivity);
	void SetMouseSensitivityY(float NewSensitivity);
	void SetRightStickSensitivityX(float NewSensitivity);
	void SetRightStickSensitivityY(float NewSensitivity);
	void SetTapToSprint(bool bNewTapToSprint);

	struct FBRInputBindingDetails_Action GetActionBindingDetails(class FName ActionName) const;
	struct FBRInputBindingDetails_Axis GetAxisBindingDetails(class FName AxisName) const;
	EBRInputDeviceType GetControllerInputDeviceType() const;
	EBRInputDeviceType GetCurrentInputDeviceType() const;
	bool IsActionCurrentlyBound(class FName ActionName) const;
	bool IsAxisCurrentlyBound(class FName ActionName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameSettingsBase_Controls">();
	}
	static class UBRGameSettingsBase_Controls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameSettingsBase_Controls>();
	}
};
static_assert(alignof(UBRGameSettingsBase_Controls) == 0x000008, "Wrong alignment on UBRGameSettingsBase_Controls");
static_assert(sizeof(UBRGameSettingsBase_Controls) == 0x000180, "Wrong size on UBRGameSettingsBase_Controls");
static_assert(offsetof(UBRGameSettingsBase_Controls, bTapToSprint) == 0x000078, "Member 'UBRGameSettingsBase_Controls::bTapToSprint' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, MouseSensitivityX) == 0x00007C, "Member 'UBRGameSettingsBase_Controls::MouseSensitivityX' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, MouseSensitivityY) == 0x000080, "Member 'UBRGameSettingsBase_Controls::MouseSensitivityY' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, bEnableMouseSmoothing) == 0x000084, "Member 'UBRGameSettingsBase_Controls::bEnableMouseSmoothing' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, LeftStickSensitivityX) == 0x000088, "Member 'UBRGameSettingsBase_Controls::LeftStickSensitivityX' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, LeftStickSensitivityY) == 0x00008C, "Member 'UBRGameSettingsBase_Controls::LeftStickSensitivityY' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, RightStickSensitivityX) == 0x000090, "Member 'UBRGameSettingsBase_Controls::RightStickSensitivityX' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, RightStickSensitivityY) == 0x000094, "Member 'UBRGameSettingsBase_Controls::RightStickSensitivityY' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, ExportedActionOverrides) == 0x000140, "Member 'UBRGameSettingsBase_Controls::ExportedActionOverrides' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_Controls, ExportedAxisOverrides) == 0x000150, "Member 'UBRGameSettingsBase_Controls::ExportedAxisOverrides' has a wrong offset!");

// Class Brickadia.BrickComponentType_Clock
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Clock final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Clock">();
	}
	static class UBrickComponentType_Clock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Clock>();
	}
};
static_assert(alignof(UBrickComponentType_Clock) == 0x000008, "Wrong alignment on UBrickComponentType_Clock");
static_assert(sizeof(UBrickComponentType_Clock) == 0x0001D8, "Wrong size on UBrickComponentType_Clock");

// Class Brickadia.BRGameSettingsBase_General
// 0x0050 (0x0098 - 0x0048)
class UBRGameSettingsBase_General : public UBRGameSettingsBase
{
public:
	bool                                          bForceThirdPersonOnDeath;                          // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableChatMessages;                              // 0x0049(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RecentBricksLimit;                                 // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRotateWithMovementBase;                           // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBRGuid>                        BlockedPlayers;                                    // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bHideHints;                                        // 0x0068(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePrecisionMode;                              // 0x0069(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSwitchToPrecisionModeOnPaste;                     // 0x006A(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMergePaintStrokes;                                // 0x006B(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BuildingGridColor;                                 // 0x006C(0x0010)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickLoadColorCorrectionMode                 BrickLoadColorCorrectionMode;                      // 0x007C(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickLoadOwnershipMode                       BrickLoadOwnershipMode;                            // 0x007D(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeenCharacterEditor;                              // 0x007E(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7F[0x1];                                       // 0x007F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SeenHints;                                         // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bEnablePrivateRelays;                              // 0x0090(0x0001)(BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisableChatMessages(bool bNewDisableChatMessages);
	void SetEnablePrivateRelays(bool bNewEnablePrivateRelays);
	void SetForceThirdPersonOnDeath(bool bNewForceThirdPersonOnDeath);
	void SetRecentBrickListLimit(int32 Limit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameSettingsBase_General">();
	}
	static class UBRGameSettingsBase_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameSettingsBase_General>();
	}
};
static_assert(alignof(UBRGameSettingsBase_General) == 0x000008, "Wrong alignment on UBRGameSettingsBase_General");
static_assert(sizeof(UBRGameSettingsBase_General) == 0x000098, "Wrong size on UBRGameSettingsBase_General");
static_assert(offsetof(UBRGameSettingsBase_General, bForceThirdPersonOnDeath) == 0x000048, "Member 'UBRGameSettingsBase_General::bForceThirdPersonOnDeath' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bDisableChatMessages) == 0x000049, "Member 'UBRGameSettingsBase_General::bDisableChatMessages' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, RecentBricksLimit) == 0x00004C, "Member 'UBRGameSettingsBase_General::RecentBricksLimit' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bRotateWithMovementBase) == 0x000050, "Member 'UBRGameSettingsBase_General::bRotateWithMovementBase' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, BlockedPlayers) == 0x000058, "Member 'UBRGameSettingsBase_General::BlockedPlayers' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bHideHints) == 0x000068, "Member 'UBRGameSettingsBase_General::bHideHints' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bEnablePrecisionMode) == 0x000069, "Member 'UBRGameSettingsBase_General::bEnablePrecisionMode' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bSwitchToPrecisionModeOnPaste) == 0x00006A, "Member 'UBRGameSettingsBase_General::bSwitchToPrecisionModeOnPaste' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bMergePaintStrokes) == 0x00006B, "Member 'UBRGameSettingsBase_General::bMergePaintStrokes' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, BuildingGridColor) == 0x00006C, "Member 'UBRGameSettingsBase_General::BuildingGridColor' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, BrickLoadColorCorrectionMode) == 0x00007C, "Member 'UBRGameSettingsBase_General::BrickLoadColorCorrectionMode' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, BrickLoadOwnershipMode) == 0x00007D, "Member 'UBRGameSettingsBase_General::BrickLoadOwnershipMode' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bSeenCharacterEditor) == 0x00007E, "Member 'UBRGameSettingsBase_General::bSeenCharacterEditor' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, SeenHints) == 0x000080, "Member 'UBRGameSettingsBase_General::SeenHints' has a wrong offset!");
static_assert(offsetof(UBRGameSettingsBase_General, bEnablePrivateRelays) == 0x000090, "Member 'UBRGameSettingsBase_General::bEnablePrivateRelays' has a wrong offset!");

// Class Brickadia.BRGameStateBase
// 0x0400 (0x0708 - 0x0308)
class ABRGameStateBase final : public AGameStateBase
{
public:
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRPermissionsManager*                  PermissionsManager;                                // 0x0318(0x0008)(Edit, ExportObject, Net, ZeroConstructor, EditConst, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             LoadBricksSound;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             LegacyLoadBricksSound;                             // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ClearBricksSound;                                  // 0x0330(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PromoteSound;                                      // 0x0338(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DemoteSound;                                       // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             KickSound;                                         // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BanSound;                                          // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             JoinSound;                                         // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             LeaveSound;                                        // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             CheckpointActivateSound;                           // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             CheckpointActivateSound_Clientside;                // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             GoalpointActivateSound;                            // 0x0378(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             GoalpointActivateSound_Clientside;                 // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSpawnLocation;                                 // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SpawnLocation;                                     // 0x0390(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyWidgetBase> GameplayPermissionWidget;                          // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyWidgetBase> ServerPermissionWidget;                            // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyDescriptorList> PermissionsRoleBaseDescriptor;                     // 0x03B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         RolesGivenOnFirstJoin;                             // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x50];                                     // 0x03D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReplicatedHostName;                                // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRGuid                                ReplicatedHostId;                                  // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReplicatedServerStartTimeUTC;                      // 0x0440(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnInviteCodeChangedDelegate;                       // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetType>              PrimaryAssetTypesToPreload;                        // 0x0458(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_468[0x4];                                      // 0x0468(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDedicatedServer;                                // 0x046C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46D[0x3];                                      // 0x046D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnMinigameListUpdated;                             // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBRPresetDescriptor*                    MinigamePresetDescriptor;                          // 0x0480(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyDescriptorList> MinigameDescriptorList;                            // 0x0488(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRRuleset*                             GlobalRuleset;                                     // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ABRRuleset*>                     Minigames;                                         // 0x0498(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<struct FBrickOwnerData>                BrickOwnerTable;                                   // 0x04A8(0x0010)(Net, ZeroConstructor, Transient, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x50];                                     // 0x04B8(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FString>                           Typing;                                            // 0x0508(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnPlayerListUpdated;                               // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FBRGuid, class FString>           SavedPlayerNames;                                  // 0x0568(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FBRGuid, class FString>           SavedPlayerDisplayNames;                           // 0x05B8(0x0050)(Transient, NativeAccessSpecifierPrivate)
	TMap<struct FBRGuid, struct FSavedPlayerRoles> SavedPlayerRoles;                                  // 0x0608(0x0050)(Transient, NativeAccessSpecifierPrivate)
	bool                                          PreLoaded;                                         // 0x0658(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_659[0x7];                                      // 0x0659(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FBRGuid, struct FBan>             BanList;                                           // 0x0660(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class UBRPresetDescriptor*                    EnvironmentPresetDescriptor;                       // 0x06B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FEnvironmentObjectDescriptor> EnvironmentSettingGroups;                          // 0x06B8(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	void Ban(const struct FBRGuid& BannedId, const struct FDateTime& Expiry, const struct FBRGuid& BannerId, const class FString& Reason);
	void ChangeEnvironmentSettingsGroup(class ABRPlayerController* UpdaterController, class FName SettingsGroupName, const struct FInspectorPropertyChangelist& Changelist);
	void CheckBans();
	int32 CreateMinigame(class ABRPlayerController* MinigameOwner);
	int32 CreateMinigameForId(const struct FBRGuid& MinigameOwnerId);
	void DestroyMinigame(int32 MinigameId);
	bool FindUserId(const class FString& Name_0, struct FBRGuid* OutId);
	struct FBan GetBan(const struct FBRGuid& ID);
	TArray<class UBRPermissionsRole*> GetLastKnownCustomRoles(const struct FBRGuid& ID);
	class FString GetLastKnownDisplayName(const struct FBRGuid& ID);
	bool GetLastKnownHadPermission(const struct FBRGuid& ID, class FName Permission);
	bool GetLastKnownHadRole(const struct FBRGuid& ID, const class FString& RoleId);
	class UBRPermissionsRole* GetLastKnownHighestRole(const struct FBRGuid& ID);
	class FString GetLastKnownName(const struct FBRGuid& ID);
	struct FColor GetLastKnownNameColor(const struct FBRGuid& ID);
	TArray<class UBRPermissionsRole*> GetLastKnownRoles(const struct FBRGuid& ID);
	class FString GetLastKnownUserName(const struct FBRGuid& ID);
	int32 IdOrRegisterBrickOwner(const class ABRPlayerController* BrickOwner);
	int32 IdOrRegisterBrickOwner_NotPresent(const struct FBrickOwnerData& BrickOwnerData);
	bool IsBanned(const struct FBRGuid& ID);
	void LoadPlayerData(class ABRPlayerState* TARGET);
	void LoadSavedPlayerDataMapFromJSON();
	void MulticastPlaySound2D(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings);
	void MulticastPlaySoundAtLocation(class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor);
	void MulticastPlaySoundAttached(class USoundBase* Sound, class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings, class USoundConcurrency* ConcurrencySettings, class AActor* OwningActor);
	void MulticastPlaySoundAttached2(class USoundBase* Sound, class USceneComponent* AttachToComponent, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, const struct FSoundAttenuationSettings& AttenuationSettings, const struct FSoundConcurrencySettings& ConcurrencySettings, class AActor* OwningActor);
	void MulticastPushChatMessage(const class FString& ChatMessage, const struct FBRGuid& SenderId);
	void MulticastSetNameTyping(const class FString& Name_0, bool bIsTyping);
	void MulticastUpdatePlayerList();
	void OnRep_BrickOwnerTable();
	void OnRep_Minigames();
	void RequestNewInviteCode();
	void SavePlayerData(class ABRPlayerState* TARGET);
	void SaveSavedPlayerDataMapToJSON();
	bool SetHasRoleOffline(const struct FBRGuid& ID, const class FString& RoleId, bool bGrant);
	void Unban(const struct FBRGuid& ID);
	void UpdateReplicatedServerData(const class FString& InviteCode);
	void UpdateReplicatedUserData();

	class ABRPlayerController* FindClient(const class FString& Name_0) const;
	class ABRPlayerController* FindClientByUserId(const struct FBRGuid& ID) const;
	class ABRPlayerState* FindClientState(const class FString& Name_0) const;
	class ABRPlayerState* FindClientStateByUserId(const struct FBRGuid& ID) const;
	int32 GetAllKnownPlayerGuids(TArray<struct FBRGuid>* inArray) const;
	const TMap<struct FBRGuid, struct FBan> GetBanList() const;
	const struct FBrickOwnerData GetBrickOwnerData(int32 Index_0) const;
	int32 GetBrickOwnerTableSize() const;
	class FString GetCurrentInviteCode() const;
	const struct FBrickOwnerData GetDefaultBrickOwnerData() const;
	class ABRRuleset* GetMinigame(int32 MinigameId) const;
	int32 GetMinigameCount() const;
	int32 GetMinigameID(class ABRRuleset* Minigame) const;
	const TArray<class ABRRuleset*> GetMinigames() const;
	int32 IdBrickOwner_NotPresent(const struct FBRGuid& OwnerGuid) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameStateBase">();
	}
	static class ABRGameStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRGameStateBase>();
	}
};
static_assert(alignof(ABRGameStateBase) == 0x000008, "Wrong alignment on ABRGameStateBase");
static_assert(sizeof(ABRGameStateBase) == 0x000708, "Wrong size on ABRGameStateBase");
static_assert(offsetof(ABRGameStateBase, PermissionsManager) == 0x000318, "Member 'ABRGameStateBase::PermissionsManager' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, LoadBricksSound) == 0x000320, "Member 'ABRGameStateBase::LoadBricksSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, LegacyLoadBricksSound) == 0x000328, "Member 'ABRGameStateBase::LegacyLoadBricksSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, ClearBricksSound) == 0x000330, "Member 'ABRGameStateBase::ClearBricksSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, PromoteSound) == 0x000338, "Member 'ABRGameStateBase::PromoteSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, DemoteSound) == 0x000340, "Member 'ABRGameStateBase::DemoteSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, KickSound) == 0x000348, "Member 'ABRGameStateBase::KickSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, BanSound) == 0x000350, "Member 'ABRGameStateBase::BanSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, JoinSound) == 0x000358, "Member 'ABRGameStateBase::JoinSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, LeaveSound) == 0x000360, "Member 'ABRGameStateBase::LeaveSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, CheckpointActivateSound) == 0x000368, "Member 'ABRGameStateBase::CheckpointActivateSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, CheckpointActivateSound_Clientside) == 0x000370, "Member 'ABRGameStateBase::CheckpointActivateSound_Clientside' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, GoalpointActivateSound) == 0x000378, "Member 'ABRGameStateBase::GoalpointActivateSound' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, GoalpointActivateSound_Clientside) == 0x000380, "Member 'ABRGameStateBase::GoalpointActivateSound_Clientside' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, bUseSpawnLocation) == 0x000388, "Member 'ABRGameStateBase::bUseSpawnLocation' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, SpawnLocation) == 0x000390, "Member 'ABRGameStateBase::SpawnLocation' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, GameplayPermissionWidget) == 0x0003A8, "Member 'ABRGameStateBase::GameplayPermissionWidget' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, ServerPermissionWidget) == 0x0003B0, "Member 'ABRGameStateBase::ServerPermissionWidget' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, PermissionsRoleBaseDescriptor) == 0x0003B8, "Member 'ABRGameStateBase::PermissionsRoleBaseDescriptor' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, RolesGivenOnFirstJoin) == 0x0003C0, "Member 'ABRGameStateBase::RolesGivenOnFirstJoin' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, ReplicatedHostName) == 0x000420, "Member 'ABRGameStateBase::ReplicatedHostName' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, ReplicatedHostId) == 0x000430, "Member 'ABRGameStateBase::ReplicatedHostId' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, ReplicatedServerStartTimeUTC) == 0x000440, "Member 'ABRGameStateBase::ReplicatedServerStartTimeUTC' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, OnInviteCodeChangedDelegate) == 0x000448, "Member 'ABRGameStateBase::OnInviteCodeChangedDelegate' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, PrimaryAssetTypesToPreload) == 0x000458, "Member 'ABRGameStateBase::PrimaryAssetTypesToPreload' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, bIsDedicatedServer) == 0x00046C, "Member 'ABRGameStateBase::bIsDedicatedServer' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, OnMinigameListUpdated) == 0x000470, "Member 'ABRGameStateBase::OnMinigameListUpdated' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, MinigamePresetDescriptor) == 0x000480, "Member 'ABRGameStateBase::MinigamePresetDescriptor' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, MinigameDescriptorList) == 0x000488, "Member 'ABRGameStateBase::MinigameDescriptorList' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, GlobalRuleset) == 0x000490, "Member 'ABRGameStateBase::GlobalRuleset' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, Minigames) == 0x000498, "Member 'ABRGameStateBase::Minigames' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, BrickOwnerTable) == 0x0004A8, "Member 'ABRGameStateBase::BrickOwnerTable' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, Typing) == 0x000508, "Member 'ABRGameStateBase::Typing' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, OnPlayerListUpdated) == 0x000558, "Member 'ABRGameStateBase::OnPlayerListUpdated' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, SavedPlayerNames) == 0x000568, "Member 'ABRGameStateBase::SavedPlayerNames' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, SavedPlayerDisplayNames) == 0x0005B8, "Member 'ABRGameStateBase::SavedPlayerDisplayNames' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, SavedPlayerRoles) == 0x000608, "Member 'ABRGameStateBase::SavedPlayerRoles' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, PreLoaded) == 0x000658, "Member 'ABRGameStateBase::PreLoaded' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, BanList) == 0x000660, "Member 'ABRGameStateBase::BanList' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, EnvironmentPresetDescriptor) == 0x0006B0, "Member 'ABRGameStateBase::EnvironmentPresetDescriptor' has a wrong offset!");
static_assert(offsetof(ABRGameStateBase, EnvironmentSettingGroups) == 0x0006B8, "Member 'ABRGameStateBase::EnvironmentSettingGroups' has a wrong offset!");

// Class Brickadia.BrickComponentType_ConstantInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_ConstantInt final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_ConstantInt">();
	}
	static class UBrickComponentType_ConstantInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_ConstantInt>();
	}
};
static_assert(alignof(UBrickComponentType_ConstantInt) == 0x000008, "Wrong alignment on UBrickComponentType_ConstantInt");
static_assert(sizeof(UBrickComponentType_ConstantInt) == 0x0001D8, "Wrong size on UBrickComponentType_ConstantInt");

// Class Brickadia.BRRulesetGameType
// 0x0098 (0x00C0 - 0x0028)
class UBRRulesetGameType : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UInspectorPropertyDescriptorList> PropertyDescriptorList;                            // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRRulesetTeam>             TeamClass;                                         // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameTypeTeamPolicy                           TeamPolicy;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRQuickUnassignedTeamSettings         UnassignedTeamSettings;                            // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBRQuickTeamSettings>           TeamSettings;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bHonorAlwaysSwitchTeam;                            // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UUserWidget>>        HUDWidgets;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UActorComponent>>    PlayerControllerComponents;                        // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FBRLeaderboardColumn>           LeaderboardColumns;                                // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisabledGameplayPermissions;                       // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bUseSeparatedBrickTransactionContext;              // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIrisDummy;                                        // 0x00B1(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UInspectorPropertyDescriptorList*       CachedDescriptorList;                              // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UInspectorPropertyDescriptorList* GetCombinedPropertyDescriptor();
	int32 GetLeaderboardColumnIndex(class FName Name_0);
	TArray<class AActor*> GetSpectatorTargets(class ABRPlayerState* Spectator);
	void HandleDie(const TScriptInterface<class IBRRulesetMemberDestructable>& DeadMember, float FinalDamage, const class UDamageType* DeathType, class AController* InstigatedBy, class AActor* DeathCauser);
	void HandleEditSettings(class ABRPlayerState* MinigameEditor, const struct FInspectorPropertyChangelist& Settings, bool bTellPlayers);
	void HandlePlayerChatMessage(class ABRPlayerState* TriggerPlayer, const class FString& ChatMessage);
	void HandlePlayerReachCheckPoint(class ABRPlayerState* TriggeredBy, const struct FBrickHandle& BrickHandle);
	void HandlePlayerReachGoalPoint(class ABRPlayerState* TriggeredBy, const struct FBrickHandle& BrickHandle);
	void HandlePlayerRestart(class ABRPlayerState* State);
	void HandlePlayerSwitchTeam(class ABRPlayerState* Member, const int32& NewTeamId, bool bRespawn, bool bMessage);
	void HandlePlayerTeamChatMessage(class ABRPlayerState* TriggerPlayer, const class FString& ChatMessage);
	void NotifyDeselected();
	void NotifyEditTeamSettings(class ABRPlayerState* MinigameEditor, const class FString& TeamName, const struct FInspectorPropertyChangelist& Settings, bool bTellPlayers);
	void NotifyEndSession(class ABRPlayerState* TriggeredBy);
	void NotifyJoinRuleset(class ABRPlayerState* NewMember);
	void NotifyLeaveRuleset(class ABRPlayerState* OldMember);
	void NotifyMemberGameTypeInit(class ABRPlayerState* Member);
	void NotifyNewRound(const int32& round);
	void NotifyReset();
	void NotifySelected();
	void NotifyStartSession();
	void OnRep_InspectorSetting();

	bool CanMemberBeDamagedBy(const TScriptInterface<class IBRRulesetMember>& Member, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass) const;
	bool GetCanEnableGameplayPermission(class FName Permission) const;
	float GetNextRoundDelay() const;
	int32 GetNextRoundNumber() const;
	bool GetPlayerCanRestart(class ABRPlayerState* State) const;
	bool GetPlayerCanSwitchTeam(class ABRPlayerState* State, const int32& TeamId) const;
	bool GetPlayerHasGameplayPermission(class ABRPlayerState* State, class FName Permission) const;
	struct FLinearColor GetPlayerNameColor(class ABRPlayerState* Member) const;
	struct FTransform GetPlayerStartTransform(class ABRPlayerState* State) const;
	class ABRRuleset* GetRuleset() const;
	bool IsLeaderboardColumnVisible(class FName ColumnName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRulesetGameType">();
	}
	static class UBRRulesetGameType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRRulesetGameType>();
	}
};
static_assert(alignof(UBRRulesetGameType) == 0x000008, "Wrong alignment on UBRRulesetGameType");
static_assert(sizeof(UBRRulesetGameType) == 0x0000C0, "Wrong size on UBRRulesetGameType");
static_assert(offsetof(UBRRulesetGameType, PropertyDescriptorList) == 0x000030, "Member 'UBRRulesetGameType::PropertyDescriptorList' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, TeamClass) == 0x000038, "Member 'UBRRulesetGameType::TeamClass' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, TeamPolicy) == 0x000040, "Member 'UBRRulesetGameType::TeamPolicy' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, UnassignedTeamSettings) == 0x000048, "Member 'UBRRulesetGameType::UnassignedTeamSettings' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, TeamSettings) == 0x000058, "Member 'UBRRulesetGameType::TeamSettings' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, bHonorAlwaysSwitchTeam) == 0x000068, "Member 'UBRRulesetGameType::bHonorAlwaysSwitchTeam' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, HUDWidgets) == 0x000070, "Member 'UBRRulesetGameType::HUDWidgets' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, PlayerControllerComponents) == 0x000080, "Member 'UBRRulesetGameType::PlayerControllerComponents' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, LeaderboardColumns) == 0x000090, "Member 'UBRRulesetGameType::LeaderboardColumns' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, DisabledGameplayPermissions) == 0x0000A0, "Member 'UBRRulesetGameType::DisabledGameplayPermissions' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, bUseSeparatedBrickTransactionContext) == 0x0000B0, "Member 'UBRRulesetGameType::bUseSeparatedBrickTransactionContext' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, bIrisDummy) == 0x0000B1, "Member 'UBRRulesetGameType::bIrisDummy' has a wrong offset!");
static_assert(offsetof(UBRRulesetGameType, CachedDescriptorList) == 0x0000B8, "Member 'UBRRulesetGameType::CachedDescriptorList' has a wrong offset!");

// Class Brickadia.BRGameTypeComponent_Sandbox
// 0x0008 (0x00C8 - 0x00C0)
class UBRGameTypeComponent_Sandbox final : public UBRRulesetGameType
{
public:
	float                                         Sandboxiness;                                      // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSandboxiness(float SandboxinessIn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameTypeComponent_Sandbox">();
	}
	static class UBRGameTypeComponent_Sandbox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameTypeComponent_Sandbox>();
	}
};
static_assert(alignof(UBRGameTypeComponent_Sandbox) == 0x000008, "Wrong alignment on UBRGameTypeComponent_Sandbox");
static_assert(sizeof(UBRGameTypeComponent_Sandbox) == 0x0000C8, "Wrong size on UBRGameTypeComponent_Sandbox");
static_assert(offsetof(UBRGameTypeComponent_Sandbox, Sandboxiness) == 0x0000C0, "Member 'UBRGameTypeComponent_Sandbox::Sandboxiness' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_Joint_Slider
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_Slider : public UBrickComponentType_Internal_ConstraintJointBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_Slider">();
	}
	static class UBrickComponentType_Internal_Joint_Slider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_Slider>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_Slider) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_Slider");
static_assert(sizeof(UBrickComponentType_Internal_Joint_Slider) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_Slider");

// Class Brickadia.BrickComponentType_Internal_Joint_ServoSlider
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_ServoSlider final : public UBrickComponentType_Internal_Joint_Slider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_ServoSlider">();
	}
	static class UBrickComponentType_Internal_Joint_ServoSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_ServoSlider>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_ServoSlider) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_ServoSlider");
static_assert(sizeof(UBrickComponentType_Internal_Joint_ServoSlider) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_ServoSlider");

// Class Brickadia.BRGameTypeDescriptor
// 0x0040 (0x0070 - 0x0030)
class UBRGameTypeDescriptor final : public UPrimaryDataAsset
{
public:
	class FName                                   DescriptorName;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   UiName;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRRulesetGameType>         GameType;                                          // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MenuPriority;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameTypeDescriptor">();
	}
	static class UBRGameTypeDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameTypeDescriptor>();
	}
};
static_assert(alignof(UBRGameTypeDescriptor) == 0x000008, "Wrong alignment on UBRGameTypeDescriptor");
static_assert(sizeof(UBRGameTypeDescriptor) == 0x000070, "Wrong size on UBRGameTypeDescriptor");
static_assert(offsetof(UBRGameTypeDescriptor, DescriptorName) == 0x000030, "Member 'UBRGameTypeDescriptor::DescriptorName' has a wrong offset!");
static_assert(offsetof(UBRGameTypeDescriptor, UiName) == 0x000038, "Member 'UBRGameTypeDescriptor::UiName' has a wrong offset!");
static_assert(offsetof(UBRGameTypeDescriptor, Description) == 0x000048, "Member 'UBRGameTypeDescriptor::Description' has a wrong offset!");
static_assert(offsetof(UBRGameTypeDescriptor, Icon) == 0x000058, "Member 'UBRGameTypeDescriptor::Icon' has a wrong offset!");
static_assert(offsetof(UBRGameTypeDescriptor, GameType) == 0x000060, "Member 'UBRGameTypeDescriptor::GameType' has a wrong offset!");
static_assert(offsetof(UBRGameTypeDescriptor, MenuPriority) == 0x000068, "Member 'UBRGameTypeDescriptor::MenuPriority' has a wrong offset!");

// Class Brickadia.BRGameUserSettings
// 0x0048 (0x0190 - 0x0148)
class UBRGameUserSettings final : public UGameUserSettings
{
public:
	TMulticastInlineDelegate<void()>              OnApplyNonResolutionSettings;                      // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EBRRenderingMode                              RenderingMode;                                     // 0x0158(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportRayTracing;                                // 0x0159(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleShadingSupportLocalLights;                  // 0x015A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRAntiAliasingMode                           AntiAliasingMode;                                  // 0x015B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRResolutionScalePreset                      ResolutionScalePreset;                             // 0x015C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReflexEnabled;                                    // 0x015D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFrameGenerationEnabled;                           // 0x015E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRGlobalIlluminationMode                     GlobalIlluminationMode;                            // 0x015F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseVirtualShadowMaps;                             // 0x0160(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VerticalFieldOfView;                               // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraShakeScale;                                  // 0x0168(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRMotionBlurMode                             MotionBlurMode;                                    // 0x016C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableOIT;                                        // 0x016D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGizmoPass;                                  // 0x016E(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGizmoMSAA;                                  // 0x016F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBR_HDREnabled;                                    // 0x0170(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x3];                                      // 0x0171(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BR_HDRNits;                                        // 0x0174(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BR_HDR_UI_Nits;                                    // 0x0178(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunAutosettings;                                  // 0x017C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17D[0x2];                                      // 0x017D(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	EUDLSSMode                                    DLSSMode;                                          // 0x017F(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_180[0x10];                                     // 0x0180(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class FString> GetAllowedScreenResolutionStringList();
	static class UBRGameUserSettings* GetBRGameUserSettings();

	void BR_SetHDR_UI_Nits(int32 Value);
	void BR_SetHDREnabled(bool bValue);
	void BR_SetHDRNits(int32 Value);
	void PreviewApplySettings(bool bCheckForCommandLineOverrides);
	void PreviewDiscardSettings();
	void SetAntiAliasingMode(EBRAntiAliasingMode Value);
	void SetCameraShakeScale(float Value);
	void SetEnableGizmoMSAA(bool bValue);
	void SetEnableGizmoPass(bool bValue);
	void SetEnableOIT(bool bValue);
	void SetFieldOfView(float Value);
	void SetFrameGenerationEnabled(bool bValue);
	void SetGlobalIlluminationMode(EBRGlobalIlluminationMode Value);
	void SetMotionBlurMode(EBRMotionBlurMode Mode);
	void SetReflexEnabled(bool bValue);
	void SetRenderingMode(EBRRenderingMode Value);
	void SetResolutionScalePreset(EBRResolutionScalePreset Value);
	void SetScreenResolutionById(int32 ID);
	void SetSimpleShadingSupportLocalLights(bool bValue);
	void SetSupportRayTracing(bool bValue);
	void SetUseVirtualShadowMaps(bool bValue);

	int32 BR_GetHDR_UI_Nits() const;
	bool BR_GetHDREnabled() const;
	int32 BR_GetHDRNits() const;
	bool BR_GetHDRSupported() const;
	EBRResolutionScalePreset ComputeAutoResolutionScalePreset() const;
	EBRAntiAliasingMode GetAntiAliasingMode() const;
	float GetCameraShakeScale() const;
	bool GetCanChangeScreenResolution() const;
	bool GetEnableGizmoMSAA() const;
	bool GetEnableGizmoPass() const;
	bool GetEnableOIT() const;
	float GetFieldOfView() const;
	bool GetFrameGenerationDisabled() const;
	bool GetFrameGenerationEnabled() const;
	EBRGlobalIlluminationMode GetGlobalIlluminationMode() const;
	EBRMotionBlurMode GetMotionBlurMode() const;
	bool GetReflexDisabled() const;
	bool GetReflexEnabled() const;
	EBRRenderingMode GetRenderingMode() const;
	EBRResolutionScalePreset GetResolutionScalePreset() const;
	float GetResolutionScalePresetScaleFactor(EBRResolutionScalePreset Preset) const;
	float GetResolutionScaleValueEx() const;
	int32 GetScreenResolutionById() const;
	bool GetSimpleShadingSupportLocalLights() const;
	bool GetSupportRayTracing() const;
	bool GetUseVirtualShadowMaps() const;
	bool IsAntiAliasingModeCustom() const;
	bool IsAntiAliasingModeNotCustom() const;
	bool IsAntiAliasingModeSupported(EBRAntiAliasingMode Mode) const;
	bool IsFrameGenerationSupported() const;
	bool IsGlobalIlluminationModeNotNone() const;
	bool IsGlobalIlluminationQualitySupported() const;
	bool IsOITSupported() const;
	bool IsReflexSupported() const;
	bool IsRenderingModeDirectX12() const;
	bool IsRenderingModeNotSimpleShading() const;
	bool IsRenderingModeSimpleShading() const;
	bool IsResolutionScalePresetCustom() const;
	bool IsResolutionScalePresetNotCustom() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameUserSettings">();
	}
	static class UBRGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameUserSettings>();
	}
};
static_assert(alignof(UBRGameUserSettings) == 0x000008, "Wrong alignment on UBRGameUserSettings");
static_assert(sizeof(UBRGameUserSettings) == 0x000190, "Wrong size on UBRGameUserSettings");
static_assert(offsetof(UBRGameUserSettings, OnApplyNonResolutionSettings) == 0x000148, "Member 'UBRGameUserSettings::OnApplyNonResolutionSettings' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, RenderingMode) == 0x000158, "Member 'UBRGameUserSettings::RenderingMode' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bSupportRayTracing) == 0x000159, "Member 'UBRGameUserSettings::bSupportRayTracing' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bSimpleShadingSupportLocalLights) == 0x00015A, "Member 'UBRGameUserSettings::bSimpleShadingSupportLocalLights' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, AntiAliasingMode) == 0x00015B, "Member 'UBRGameUserSettings::AntiAliasingMode' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, ResolutionScalePreset) == 0x00015C, "Member 'UBRGameUserSettings::ResolutionScalePreset' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bReflexEnabled) == 0x00015D, "Member 'UBRGameUserSettings::bReflexEnabled' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bFrameGenerationEnabled) == 0x00015E, "Member 'UBRGameUserSettings::bFrameGenerationEnabled' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, GlobalIlluminationMode) == 0x00015F, "Member 'UBRGameUserSettings::GlobalIlluminationMode' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bUseVirtualShadowMaps) == 0x000160, "Member 'UBRGameUserSettings::bUseVirtualShadowMaps' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, VerticalFieldOfView) == 0x000164, "Member 'UBRGameUserSettings::VerticalFieldOfView' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, CameraShakeScale) == 0x000168, "Member 'UBRGameUserSettings::CameraShakeScale' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, MotionBlurMode) == 0x00016C, "Member 'UBRGameUserSettings::MotionBlurMode' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bEnableOIT) == 0x00016D, "Member 'UBRGameUserSettings::bEnableOIT' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bEnableGizmoPass) == 0x00016E, "Member 'UBRGameUserSettings::bEnableGizmoPass' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bEnableGizmoMSAA) == 0x00016F, "Member 'UBRGameUserSettings::bEnableGizmoMSAA' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bBR_HDREnabled) == 0x000170, "Member 'UBRGameUserSettings::bBR_HDREnabled' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, BR_HDRNits) == 0x000174, "Member 'UBRGameUserSettings::BR_HDRNits' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, BR_HDR_UI_Nits) == 0x000178, "Member 'UBRGameUserSettings::BR_HDR_UI_Nits' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, bRunAutosettings) == 0x00017C, "Member 'UBRGameUserSettings::bRunAutosettings' has a wrong offset!");
static_assert(offsetof(UBRGameUserSettings, DLSSMode) == 0x00017F, "Member 'UBRGameUserSettings::DLSSMode' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateTimer
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateTimer final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateTimer">();
	}
	static class UBrickComponentType_GateTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateTimer>();
	}
};
static_assert(alignof(UBrickComponentType_GateTimer) == 0x000008, "Wrong alignment on UBrickComponentType_GateTimer");
static_assert(sizeof(UBrickComponentType_GateTimer) == 0x0001D8, "Wrong size on UBrickComponentType_GateTimer");

// Class Brickadia.BRGameViewportClient
// 0x0018 (0x03D8 - 0x03C0)
class UBRGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyGizmoSettingValue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGameViewportClient">();
	}
	static class UBRGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGameViewportClient>();
	}
};
static_assert(alignof(UBRGameViewportClient) == 0x000008, "Wrong alignment on UBRGameViewportClient");
static_assert(sizeof(UBRGameViewportClient) == 0x0003D8, "Wrong size on UBRGameViewportClient");

// Class Brickadia.BRGenericCatalogCategoryWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRGenericCatalogCategoryWidget : public UUserWidget
{
public:
	class UTextBlock*                             Label;                                             // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           ItemsContainer;                                    // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogCategoryWidget">();
	}
	static class UBRGenericCatalogCategoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogCategoryWidget>();
	}
};
static_assert(alignof(UBRGenericCatalogCategoryWidget) == 0x000008, "Wrong alignment on UBRGenericCatalogCategoryWidget");
static_assert(sizeof(UBRGenericCatalogCategoryWidget) == 0x0002E0, "Wrong size on UBRGenericCatalogCategoryWidget");
static_assert(offsetof(UBRGenericCatalogCategoryWidget, Label) == 0x0002D0, "Member 'UBRGenericCatalogCategoryWidget::Label' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogCategoryWidget, ItemsContainer) == 0x0002D8, "Member 'UBRGenericCatalogCategoryWidget::ItemsContainer' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateLessThanOrEqualInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateLessThanOrEqualInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateLessThanOrEqualInt">();
	}
	static class UBrickComponentType_GateLessThanOrEqualInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateLessThanOrEqualInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateLessThanOrEqualInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateLessThanOrEqualInt");
static_assert(sizeof(UBrickComponentType_GateLessThanOrEqualInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateLessThanOrEqualInt");

// Class Brickadia.BRGenericCatalogTabWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRGenericCatalogTabWidget : public UUserWidget
{
public:
	class UPanelWidget*                           CategoriesContainer;                               // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScrollBox*                             CategoriesScrollBox;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogTabWidget">();
	}
	static class UBRGenericCatalogTabWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogTabWidget>();
	}
};
static_assert(alignof(UBRGenericCatalogTabWidget) == 0x000008, "Wrong alignment on UBRGenericCatalogTabWidget");
static_assert(sizeof(UBRGenericCatalogTabWidget) == 0x0002E0, "Wrong size on UBRGenericCatalogTabWidget");
static_assert(offsetof(UBRGenericCatalogTabWidget, CategoriesContainer) == 0x0002D0, "Member 'UBRGenericCatalogTabWidget::CategoriesContainer' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogTabWidget, CategoriesScrollBox) == 0x0002D8, "Member 'UBRGenericCatalogTabWidget::CategoriesScrollBox' has a wrong offset!");

// Class Brickadia.BRGenericCatalogEntryDragVisual
// 0x0018 (0x02E8 - 0x02D0)
class UBRGenericCatalogEntryDragVisual : public UUserWidget
{
public:
	class UTextBlock*                             Label;                                             // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGenericThumbnailWidget*                Thumbnail;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Payload;                                           // 0x02E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogEntryDragVisual">();
	}
	static class UBRGenericCatalogEntryDragVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogEntryDragVisual>();
	}
};
static_assert(alignof(UBRGenericCatalogEntryDragVisual) == 0x000008, "Wrong alignment on UBRGenericCatalogEntryDragVisual");
static_assert(sizeof(UBRGenericCatalogEntryDragVisual) == 0x0002E8, "Wrong size on UBRGenericCatalogEntryDragVisual");
static_assert(offsetof(UBRGenericCatalogEntryDragVisual, Label) == 0x0002D0, "Member 'UBRGenericCatalogEntryDragVisual::Label' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryDragVisual, Thumbnail) == 0x0002D8, "Member 'UBRGenericCatalogEntryDragVisual::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryDragVisual, Payload) == 0x0002E0, "Member 'UBRGenericCatalogEntryDragVisual::Payload' has a wrong offset!");

// Class Brickadia.BRGenericCatalogDragDropOperation
// 0x0008 (0x0098 - 0x0090)
class UBRGenericCatalogDragDropOperation final : public UDragDropOperation
{
public:
	class UObject*                                CatalogPayload;                                    // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogDragDropOperation">();
	}
	static class UBRGenericCatalogDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogDragDropOperation>();
	}
};
static_assert(alignof(UBRGenericCatalogDragDropOperation) == 0x000008, "Wrong alignment on UBRGenericCatalogDragDropOperation");
static_assert(sizeof(UBRGenericCatalogDragDropOperation) == 0x000098, "Wrong size on UBRGenericCatalogDragDropOperation");
static_assert(offsetof(UBRGenericCatalogDragDropOperation, CatalogPayload) == 0x000090, "Member 'UBRGenericCatalogDragDropOperation::CatalogPayload' has a wrong offset!");

// Class Brickadia.BRGenericCatalogEntryWidget
// 0x00B0 (0x0380 - 0x02D0)
class UBRGenericCatalogEntryWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnLeftClicked;                                     // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnMiddleClicked;                                   // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnRightClicked;                                    // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnDragStarted;                                     // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnDragEnded;                                       // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnHoverStarted;                                    // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRGenericCatalogEntryWidget* EntrySelected)> OnHoverEnded;                                      // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogEntryDragVisual> EntryDragVisualOverride;                           // 0x0340(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USizeBox*                               SizeBox;                                           // 0x0348(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Label;                                             // 0x0350(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGenericThumbnailWidget*                Thumbnail;                                         // 0x0358(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                Button;                                            // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       FlashEntry;                                        // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Payload;                                           // 0x0370(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRGenericCatalogWidget*                Catalog;                                           // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleClicked();
	void HandleDropped(class UDragDropOperation* Operation);
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogEntryWidget">();
	}
	static class UBRGenericCatalogEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogEntryWidget>();
	}
};
static_assert(alignof(UBRGenericCatalogEntryWidget) == 0x000008, "Wrong alignment on UBRGenericCatalogEntryWidget");
static_assert(sizeof(UBRGenericCatalogEntryWidget) == 0x000380, "Wrong size on UBRGenericCatalogEntryWidget");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnLeftClicked) == 0x0002D0, "Member 'UBRGenericCatalogEntryWidget::OnLeftClicked' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnMiddleClicked) == 0x0002E0, "Member 'UBRGenericCatalogEntryWidget::OnMiddleClicked' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnRightClicked) == 0x0002F0, "Member 'UBRGenericCatalogEntryWidget::OnRightClicked' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnDragStarted) == 0x000300, "Member 'UBRGenericCatalogEntryWidget::OnDragStarted' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnDragEnded) == 0x000310, "Member 'UBRGenericCatalogEntryWidget::OnDragEnded' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnHoverStarted) == 0x000320, "Member 'UBRGenericCatalogEntryWidget::OnHoverStarted' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, OnHoverEnded) == 0x000330, "Member 'UBRGenericCatalogEntryWidget::OnHoverEnded' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, EntryDragVisualOverride) == 0x000340, "Member 'UBRGenericCatalogEntryWidget::EntryDragVisualOverride' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, SizeBox) == 0x000348, "Member 'UBRGenericCatalogEntryWidget::SizeBox' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, Label) == 0x000350, "Member 'UBRGenericCatalogEntryWidget::Label' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, Thumbnail) == 0x000358, "Member 'UBRGenericCatalogEntryWidget::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, Button) == 0x000360, "Member 'UBRGenericCatalogEntryWidget::Button' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, FlashEntry) == 0x000368, "Member 'UBRGenericCatalogEntryWidget::FlashEntry' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, Payload) == 0x000370, "Member 'UBRGenericCatalogEntryWidget::Payload' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogEntryWidget, Catalog) == 0x000378, "Member 'UBRGenericCatalogEntryWidget::Catalog' has a wrong offset!");

// Class Brickadia.BrickComponentType_OneShotAudioEmitter
// 0x0008 (0x01E0 - 0x01D8)
class UBrickComponentType_OneShotAudioEmitter final : public UBrickComponentTypeBase
{
public:
	class UBrickOneShotAudioDescriptor*           DefaultBrickOneShotAudioDescriptor;                // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_OneShotAudioEmitter">();
	}
	static class UBrickComponentType_OneShotAudioEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_OneShotAudioEmitter>();
	}
};
static_assert(alignof(UBrickComponentType_OneShotAudioEmitter) == 0x000008, "Wrong alignment on UBrickComponentType_OneShotAudioEmitter");
static_assert(sizeof(UBrickComponentType_OneShotAudioEmitter) == 0x0001E0, "Wrong size on UBrickComponentType_OneShotAudioEmitter");
static_assert(offsetof(UBrickComponentType_OneShotAudioEmitter, DefaultBrickOneShotAudioDescriptor) == 0x0001D8, "Member 'UBrickComponentType_OneShotAudioEmitter::DefaultBrickOneShotAudioDescriptor' has a wrong offset!");

// Class Brickadia.BRGenericCatalogTabButtonWidget
// 0x0030 (0x0300 - 0x02D0)
class UBRGenericCatalogTabButtonWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class UBRGenericCatalogTabButtonWidget* TabSelected)> OnSelected;                                        // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UButton*                                Button;                                            // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGenericThumbnailWidget*                Thumbnail;                                         // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             Label;                                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Payload;                                           // 0x02F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleClicked();
	void SetShowSelected(bool Selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogTabButtonWidget">();
	}
	static class UBRGenericCatalogTabButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogTabButtonWidget>();
	}
};
static_assert(alignof(UBRGenericCatalogTabButtonWidget) == 0x000008, "Wrong alignment on UBRGenericCatalogTabButtonWidget");
static_assert(sizeof(UBRGenericCatalogTabButtonWidget) == 0x000300, "Wrong size on UBRGenericCatalogTabButtonWidget");
static_assert(offsetof(UBRGenericCatalogTabButtonWidget, OnSelected) == 0x0002D0, "Member 'UBRGenericCatalogTabButtonWidget::OnSelected' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogTabButtonWidget, Button) == 0x0002E0, "Member 'UBRGenericCatalogTabButtonWidget::Button' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogTabButtonWidget, Thumbnail) == 0x0002E8, "Member 'UBRGenericCatalogTabButtonWidget::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogTabButtonWidget, Label) == 0x0002F0, "Member 'UBRGenericCatalogTabButtonWidget::Label' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogTabButtonWidget, Payload) == 0x0002F8, "Member 'UBRGenericCatalogTabButtonWidget::Payload' has a wrong offset!");

// Class Brickadia.BRGenericCatalogWidget
// 0x0120 (0x03F0 - 0x02D0)
class UBRGenericCatalogWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class UObject* EntryPayload)> OnLeftClickEntry;                                  // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* EntryPayload)> OnMiddleClickEntry;                                // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* EntryPayload)> OnEntryDragStarted;                                // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* EntryPayload)> OnEntryDragEnded;                                  // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* EntryPayload)> OnEntryHoverStarted;                               // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UObject* EntryPayload)> OnEntryHoverEnded;                                 // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllowDraggingEntries;                             // 0x0330(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_331[0x7];                                      // 0x0331(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DragDropOperationTag;                              // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogTabWidget> TabWidget;                                         // 0x0348(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogCategoryWidget> CategoryWidget;                                    // 0x0350(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogEntryWidget> EntryWidget;                                       // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogTabButtonWidget> TabButtonWidget;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRGenericCatalogEntryDragVisual> EntryDragVisual;                                   // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UThumbnailProcessor>        DefaultOverrideThumbnailProcessorClass;            // 0x0370(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           TabButtonsContainer;                               // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               TabsContainer;                                     // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UObject*, struct FBRCatalogWidgetsForObject> ObjectLookup;                                      // 0x0388(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UObject*                                CatalogPayloadForDrag;                             // 0x03D8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0x10];                                     // 0x03E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BringObjectIntoView(class UObject* TARGET);
	void Clear();
	class UBRGenericCatalogEntryWidget* CreateEntryWidget(const struct FBRCatalogEntry& CatalogEntry, TSubclassOf<class UBRGenericCatalogEntryWidget> UsedEntryWidget);
	void HandleEntryDragEnded(class UBRGenericCatalogEntryWidget* Entry);
	void HandleEntryDragStarted(class UBRGenericCatalogEntryWidget* Entry);
	void HandleEntryHoverEnded(class UBRGenericCatalogEntryWidget* Entry);
	void HandleEntryHoverStarted(class UBRGenericCatalogEntryWidget* Entry);
	void HandleEntryLeftClick(class UBRGenericCatalogEntryWidget* Entry);
	void HandleEntryMiddleClick(class UBRGenericCatalogEntryWidget* Entry);
	void HandleTabSelection(class UBRGenericCatalogTabButtonWidget* Button);
	void InsertCustomTab(const struct FBRCatalogCustomTab& TabData);
	void Rebuild(class UBRCatalog* InCatalog);
	void RebuildAdv(class UBRCatalog* InCatalog, const TArray<struct FBRCatalogCustomTab>& CustomTabsAtStart, const TArray<struct FBRCatalogCustomTab>& CustomTabsAtEnd);
	void SelectTab(int32 TabIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGenericCatalogWidget">();
	}
	static class UBRGenericCatalogWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGenericCatalogWidget>();
	}
};
static_assert(alignof(UBRGenericCatalogWidget) == 0x000008, "Wrong alignment on UBRGenericCatalogWidget");
static_assert(sizeof(UBRGenericCatalogWidget) == 0x0003F0, "Wrong size on UBRGenericCatalogWidget");
static_assert(offsetof(UBRGenericCatalogWidget, OnLeftClickEntry) == 0x0002D0, "Member 'UBRGenericCatalogWidget::OnLeftClickEntry' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, OnMiddleClickEntry) == 0x0002E0, "Member 'UBRGenericCatalogWidget::OnMiddleClickEntry' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, OnEntryDragStarted) == 0x0002F0, "Member 'UBRGenericCatalogWidget::OnEntryDragStarted' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, OnEntryDragEnded) == 0x000300, "Member 'UBRGenericCatalogWidget::OnEntryDragEnded' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, OnEntryHoverStarted) == 0x000310, "Member 'UBRGenericCatalogWidget::OnEntryHoverStarted' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, OnEntryHoverEnded) == 0x000320, "Member 'UBRGenericCatalogWidget::OnEntryHoverEnded' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, bAllowDraggingEntries) == 0x000330, "Member 'UBRGenericCatalogWidget::bAllowDraggingEntries' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, DragDropOperationTag) == 0x000338, "Member 'UBRGenericCatalogWidget::DragDropOperationTag' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, TabWidget) == 0x000348, "Member 'UBRGenericCatalogWidget::TabWidget' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, CategoryWidget) == 0x000350, "Member 'UBRGenericCatalogWidget::CategoryWidget' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, EntryWidget) == 0x000358, "Member 'UBRGenericCatalogWidget::EntryWidget' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, TabButtonWidget) == 0x000360, "Member 'UBRGenericCatalogWidget::TabButtonWidget' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, EntryDragVisual) == 0x000368, "Member 'UBRGenericCatalogWidget::EntryDragVisual' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, DefaultOverrideThumbnailProcessorClass) == 0x000370, "Member 'UBRGenericCatalogWidget::DefaultOverrideThumbnailProcessorClass' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, TabButtonsContainer) == 0x000378, "Member 'UBRGenericCatalogWidget::TabButtonsContainer' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, TabsContainer) == 0x000380, "Member 'UBRGenericCatalogWidget::TabsContainer' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, ObjectLookup) == 0x000388, "Member 'UBRGenericCatalogWidget::ObjectLookup' has a wrong offset!");
static_assert(offsetof(UBRGenericCatalogWidget, CatalogPayloadForDrag) == 0x0003D8, "Member 'UBRGenericCatalogWidget::CatalogPayloadForDrag' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_Socket
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_Socket final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Socket">();
	}
	static class UBrickComponentType_Internal_Socket* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Socket>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Socket) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Socket");
static_assert(sizeof(UBrickComponentType_Internal_Socket) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_Socket");

// Class Brickadia.BRPositionedGizmoElementGroup
// 0x0018 (0x0188 - 0x0170)
class UBRPositionedGizmoElementGroup final : public UGizmoElementGroup
{
public:
	uint8                                         Pad_170[0x18];                                     // 0x0170(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPositionedGizmoElementGroup">();
	}
	static class UBRPositionedGizmoElementGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPositionedGizmoElementGroup>();
	}
};
static_assert(alignof(UBRPositionedGizmoElementGroup) == 0x000008, "Wrong alignment on UBRPositionedGizmoElementGroup");
static_assert(sizeof(UBRPositionedGizmoElementGroup) == 0x000188, "Wrong size on UBRPositionedGizmoElementGroup");

// Class Brickadia.BRGizmoElementAxisLineSegment
// 0x0038 (0x0190 - 0x0158)
class UBRGizmoElementAxisLineSegment final : public UGizmoElementLineBase
{
public:
	uint8                                         Pad_158[0x38];                                     // 0x0158(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoElementAxisLineSegment">();
	}
	static class UBRGizmoElementAxisLineSegment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmoElementAxisLineSegment>();
	}
};
static_assert(alignof(UBRGizmoElementAxisLineSegment) == 0x000008, "Wrong alignment on UBRGizmoElementAxisLineSegment");
static_assert(sizeof(UBRGizmoElementAxisLineSegment) == 0x000190, "Wrong size on UBRGizmoElementAxisLineSegment");

// Class Brickadia.BrickComponentType_Internal_Rerouter
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_Rerouter final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Rerouter">();
	}
	static class UBrickComponentType_Internal_Rerouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Rerouter>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Rerouter) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Rerouter");
static_assert(sizeof(UBrickComponentType_Internal_Rerouter) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_Rerouter");

// Class Brickadia.BRGizmoText
// 0x0000 (0x02B0 - 0x02B0)
class ABRGizmoText final : public AActor
{
public:
	void Setup(const class FText& InCount, const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoText">();
	}
	static class ABRGizmoText* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRGizmoText>();
	}
};
static_assert(alignof(ABRGizmoText) == 0x000008, "Wrong alignment on ABRGizmoText");
static_assert(sizeof(ABRGizmoText) == 0x0002B0, "Wrong size on ABRGizmoText");

// Class Brickadia.BRInteractiveToolsContext
// 0x0000 (0x0330 - 0x0330)
class UBRInteractiveToolsContext final : public UInteractiveToolsContext
{
public:
	class UBRGizmoManagerComponent*               GizmoManagerComponent;                             // 0x0328(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInteractiveToolsContext">();
	}
	static class UBRInteractiveToolsContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInteractiveToolsContext>();
	}
};
static_assert(alignof(UBRInteractiveToolsContext) == 0x000010, "Wrong alignment on UBRInteractiveToolsContext");
static_assert(sizeof(UBRInteractiveToolsContext) == 0x000330, "Wrong size on UBRInteractiveToolsContext");
static_assert(offsetof(UBRInteractiveToolsContext, GizmoManagerComponent) == 0x000328, "Member 'UBRInteractiveToolsContext::GizmoManagerComponent' has a wrong offset!");

// Class Brickadia.BRGizmoStorage
// 0x0048 (0x0108 - 0x00C0)
class UBRGizmoStorage final : public UInteractiveGizmoManager
{
public:
	class UMaterialInstanceDynamic*               AxisMaterialX;                                     // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               AxisMaterialY;                                     // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               AxisMaterialZ;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CurrentAxisMaterial;                               // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               GreyMaterial;                                      // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               WhiteMaterial;                                     // 0x00E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               OpaquePlaneMaterialXY;                             // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRGameSettingsBase_General*            GeneralSettings;                                   // 0x00F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRGizmoManagerComponent*               GizmoManagerComponent;                             // 0x0100(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoStorage">();
	}
	static class UBRGizmoStorage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmoStorage>();
	}
};
static_assert(alignof(UBRGizmoStorage) == 0x000008, "Wrong alignment on UBRGizmoStorage");
static_assert(sizeof(UBRGizmoStorage) == 0x000108, "Wrong size on UBRGizmoStorage");
static_assert(offsetof(UBRGizmoStorage, AxisMaterialX) == 0x0000C0, "Member 'UBRGizmoStorage::AxisMaterialX' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, AxisMaterialY) == 0x0000C8, "Member 'UBRGizmoStorage::AxisMaterialY' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, AxisMaterialZ) == 0x0000D0, "Member 'UBRGizmoStorage::AxisMaterialZ' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, CurrentAxisMaterial) == 0x0000D8, "Member 'UBRGizmoStorage::CurrentAxisMaterial' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, GreyMaterial) == 0x0000E0, "Member 'UBRGizmoStorage::GreyMaterial' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, WhiteMaterial) == 0x0000E8, "Member 'UBRGizmoStorage::WhiteMaterial' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, OpaquePlaneMaterialXY) == 0x0000F0, "Member 'UBRGizmoStorage::OpaquePlaneMaterialXY' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, GeneralSettings) == 0x0000F8, "Member 'UBRGizmoStorage::GeneralSettings' has a wrong offset!");
static_assert(offsetof(UBRGizmoStorage, GizmoManagerComponent) == 0x000100, "Member 'UBRGizmoStorage::GizmoManagerComponent' has a wrong offset!");

// Class Brickadia.BRGizmoElementHitMultiTarget
// 0x0010 (0x00A0 - 0x0090)
class UBRGizmoElementHitMultiTarget final : public UGizmoElementHitMultiTarget
{
public:
	class UBRGizmoBase*                           Gizmo;                                             // 0x0090(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoElementHitMultiTarget">();
	}
	static class UBRGizmoElementHitMultiTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmoElementHitMultiTarget>();
	}
};
static_assert(alignof(UBRGizmoElementHitMultiTarget) == 0x000010, "Wrong alignment on UBRGizmoElementHitMultiTarget");
static_assert(sizeof(UBRGizmoElementHitMultiTarget) == 0x0000A0, "Wrong size on UBRGizmoElementHitMultiTarget");
static_assert(offsetof(UBRGizmoElementHitMultiTarget, Gizmo) == 0x000090, "Member 'UBRGizmoElementHitMultiTarget::Gizmo' has a wrong offset!");

// Class Brickadia.BrickDebugComponent
// 0x0020 (0x05A0 - 0x0580)
class UBrickDebugComponent : public UProceduralMeshComponent
{
public:
	struct FColor                                 PreviewColor;                                      // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickMaterialCollection*               PreviewMaterialCollection;                         // 0x0580(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideAll;                                   // 0x0588(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideNorth;                                 // 0x0589(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideSouth;                                 // 0x058A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideEast;                                  // 0x058B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideWest;                                  // 0x058C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideTop;                                   // 0x058D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewHideBottom;                                // 0x058E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58F[0x1];                                      // 0x058F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickType*                             BrickType;                                         // 0x0590(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_598[0x8];                                      // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBrickColor(const struct FColor& NewColor);
	void SetBrickType(class UBrickType* NewBrickType);

	struct FColor GetBrickColor() const;
	class UBrickType* GetBrickType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickDebugComponent">();
	}
	static class UBrickDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickDebugComponent>();
	}
};
static_assert(alignof(UBrickDebugComponent) == 0x000010, "Wrong alignment on UBrickDebugComponent");
static_assert(sizeof(UBrickDebugComponent) == 0x0005A0, "Wrong size on UBrickDebugComponent");
static_assert(offsetof(UBrickDebugComponent, PreviewColor) == 0x000578, "Member 'UBrickDebugComponent::PreviewColor' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, PreviewMaterialCollection) == 0x000580, "Member 'UBrickDebugComponent::PreviewMaterialCollection' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideAll) == 0x000588, "Member 'UBrickDebugComponent::bPreviewHideAll' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideNorth) == 0x000589, "Member 'UBrickDebugComponent::bPreviewHideNorth' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideSouth) == 0x00058A, "Member 'UBrickDebugComponent::bPreviewHideSouth' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideEast) == 0x00058B, "Member 'UBrickDebugComponent::bPreviewHideEast' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideWest) == 0x00058C, "Member 'UBrickDebugComponent::bPreviewHideWest' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideTop) == 0x00058D, "Member 'UBrickDebugComponent::bPreviewHideTop' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, bPreviewHideBottom) == 0x00058E, "Member 'UBrickDebugComponent::bPreviewHideBottom' has a wrong offset!");
static_assert(offsetof(UBrickDebugComponent, BrickType) == 0x000590, "Member 'UBrickDebugComponent::BrickType' has a wrong offset!");

// Class Brickadia.BasicBrickDebugComponent
// 0x0010 (0x05B0 - 0x05A0)
class UBasicBrickDebugComponent final : public UBrickDebugComponent
{
public:
	class UBasicBrick*                            PreviewBrick;                                      // 0x05A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x8];                                      // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBrick(class UBasicBrick* NewBrick);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasicBrickDebugComponent">();
	}
	static class UBasicBrickDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasicBrickDebugComponent>();
	}
};
static_assert(alignof(UBasicBrickDebugComponent) == 0x000010, "Wrong alignment on UBasicBrickDebugComponent");
static_assert(sizeof(UBasicBrickDebugComponent) == 0x0005B0, "Wrong size on UBasicBrickDebugComponent");
static_assert(offsetof(UBasicBrickDebugComponent, PreviewBrick) == 0x0005A0, "Member 'UBasicBrickDebugComponent::PreviewBrick' has a wrong offset!");

// Class Brickadia.BrickComponentType_PointLight
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_PointLight final : public UBrickComponentType_LightBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_PointLight">();
	}
	static class UBrickComponentType_PointLight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_PointLight>();
	}
};
static_assert(alignof(UBrickComponentType_PointLight) == 0x000008, "Wrong alignment on UBrickComponentType_PointLight");
static_assert(sizeof(UBrickComponentType_PointLight) == 0x0001D8, "Wrong size on UBrickComponentType_PointLight");

// Class Brickadia.BRGizmoBuilder
// 0x0008 (0x0030 - 0x0028)
class UBRGizmoBuilder final : public UInteractiveGizmoBuilder
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoBuilder">();
	}
	static class UBRGizmoBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmoBuilder>();
	}
};
static_assert(alignof(UBRGizmoBuilder) == 0x000008, "Wrong alignment on UBRGizmoBuilder");
static_assert(sizeof(UBRGizmoBuilder) == 0x000030, "Wrong size on UBRGizmoBuilder");

// Class Brickadia.BrickWheelEngineAudioDescriptor
// 0x0058 (0x0088 - 0x0030)
class UBrickWheelEngineAudioDescriptor final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRCatalogData                         CatalogData;                                       // 0x0038(0x0048)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class USoundBase*                             EngineSound;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickWheelEngineAudioDescriptor">();
	}
	static class UBrickWheelEngineAudioDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickWheelEngineAudioDescriptor>();
	}
};
static_assert(alignof(UBrickWheelEngineAudioDescriptor) == 0x000008, "Wrong alignment on UBrickWheelEngineAudioDescriptor");
static_assert(sizeof(UBrickWheelEngineAudioDescriptor) == 0x000088, "Wrong size on UBrickWheelEngineAudioDescriptor");
static_assert(offsetof(UBrickWheelEngineAudioDescriptor, CatalogData) == 0x000038, "Member 'UBrickWheelEngineAudioDescriptor::CatalogData' has a wrong offset!");
static_assert(offsetof(UBrickWheelEngineAudioDescriptor, EngineSound) == 0x000080, "Member 'UBrickWheelEngineAudioDescriptor::EngineSound' has a wrong offset!");

// Class Brickadia.BRGizmoManagerComponent
// 0x01B8 (0x0260 - 0x00A8)
class alignas(0x10) UBRGizmoManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRInteractiveToolsContext*             ToolsContext;                                      // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UBRGizmoBase>>       GizmoClasses;                                      // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     TransparentVertexColorMaterial;                    // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x138];                                    // 0x0128(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmoManagerComponent">();
	}
	static class UBRGizmoManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmoManagerComponent>();
	}
};
static_assert(alignof(UBRGizmoManagerComponent) == 0x000010, "Wrong alignment on UBRGizmoManagerComponent");
static_assert(sizeof(UBRGizmoManagerComponent) == 0x000260, "Wrong size on UBRGizmoManagerComponent");
static_assert(offsetof(UBRGizmoManagerComponent, ToolsContext) == 0x0000B8, "Member 'UBRGizmoManagerComponent::ToolsContext' has a wrong offset!");
static_assert(offsetof(UBRGizmoManagerComponent, GizmoClasses) == 0x000110, "Member 'UBRGizmoManagerComponent::GizmoClasses' has a wrong offset!");
static_assert(offsetof(UBRGizmoManagerComponent, TransparentVertexColorMaterial) == 0x000120, "Member 'UBRGizmoManagerComponent::TransparentVertexColorMaterial' has a wrong offset!");

// Class Brickadia.BRGizmo_PlacerGrid
// 0x0010 (0x0160 - 0x0150)
class UBRGizmo_PlacerGrid final : public UBRGizmoBase
{
public:
	TSubclassOf<class ABRPlacerGrid>              GridActorClass;                                    // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABRPlacerGrid*                          GridActor;                                         // 0x0158(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmo_PlacerGrid">();
	}
	static class UBRGizmo_PlacerGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmo_PlacerGrid>();
	}
};
static_assert(alignof(UBRGizmo_PlacerGrid) == 0x000008, "Wrong alignment on UBRGizmo_PlacerGrid");
static_assert(sizeof(UBRGizmo_PlacerGrid) == 0x000160, "Wrong size on UBRGizmo_PlacerGrid");
static_assert(offsetof(UBRGizmo_PlacerGrid, GridActorClass) == 0x000150, "Member 'UBRGizmo_PlacerGrid::GridActorClass' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerGrid, GridActor) == 0x000158, "Member 'UBRGizmo_PlacerGrid::GridActor' has a wrong offset!");

// Class Brickadia.BRGizmo_PlacerReorient
// 0x0060 (0x0220 - 0x01C0)
class UBRGizmo_PlacerReorient final : public UBRDecorativeGizmoBase
{
public:
	float                                         ScreenSpaceIndicatorHalfSize;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceAxisIndicatorTailLength;                // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceAxisIndicatorTailRadius;                // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceAxisIndicatorConeLength;                // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScreenSpaceAxisIndicatorConeRadius;                // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0x4];                                      // 0x01D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AxisTextOffset;                                    // 0x01D8(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ABRGizmoText>               AxisTextActorClass;                                // 0x01F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8[0x8];                                      // 0x01F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UGizmoElementRectangle*                 OriginIndicatorElement;                            // 0x0200(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGizmoElementArrow*                     DirectionIndicatorElement;                         // 0x0208(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRGizmoText*                           AxisTextActor;                                     // 0x0210(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGizmo_PlacerReorient">();
	}
	static class UBRGizmo_PlacerReorient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGizmo_PlacerReorient>();
	}
};
static_assert(alignof(UBRGizmo_PlacerReorient) == 0x000010, "Wrong alignment on UBRGizmo_PlacerReorient");
static_assert(sizeof(UBRGizmo_PlacerReorient) == 0x000220, "Wrong size on UBRGizmo_PlacerReorient");
static_assert(offsetof(UBRGizmo_PlacerReorient, ScreenSpaceIndicatorHalfSize) == 0x0001C0, "Member 'UBRGizmo_PlacerReorient::ScreenSpaceIndicatorHalfSize' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, ScreenSpaceAxisIndicatorTailLength) == 0x0001C4, "Member 'UBRGizmo_PlacerReorient::ScreenSpaceAxisIndicatorTailLength' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, ScreenSpaceAxisIndicatorTailRadius) == 0x0001C8, "Member 'UBRGizmo_PlacerReorient::ScreenSpaceAxisIndicatorTailRadius' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, ScreenSpaceAxisIndicatorConeLength) == 0x0001CC, "Member 'UBRGizmo_PlacerReorient::ScreenSpaceAxisIndicatorConeLength' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, ScreenSpaceAxisIndicatorConeRadius) == 0x0001D0, "Member 'UBRGizmo_PlacerReorient::ScreenSpaceAxisIndicatorConeRadius' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, AxisTextOffset) == 0x0001D8, "Member 'UBRGizmo_PlacerReorient::AxisTextOffset' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, AxisTextActorClass) == 0x0001F0, "Member 'UBRGizmo_PlacerReorient::AxisTextActorClass' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, OriginIndicatorElement) == 0x000200, "Member 'UBRGizmo_PlacerReorient::OriginIndicatorElement' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, DirectionIndicatorElement) == 0x000208, "Member 'UBRGizmo_PlacerReorient::DirectionIndicatorElement' has a wrong offset!");
static_assert(offsetof(UBRGizmo_PlacerReorient, AxisTextActor) == 0x000210, "Member 'UBRGizmo_PlacerReorient::AxisTextActor' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptorList
// 0x00B8 (0x00E0 - 0x0028)
class UInspectorPropertyDescriptorList : public UObject
{
public:
	TSubclassOf<class UObject>                    ApplicableClass;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UScriptStruct*                          ApplicableStruct;                                  // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInspectorPropertyDescriptorListCategory> Categories;                                        // 0x0038(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TMap<class FName, class UInspectorPropertyDescriptor*> DescriptorLookup;                                  // 0x0088(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UInspectorPropertyDescriptor* FindDescriptor(class FName Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList">();
	}
	static class UInspectorPropertyDescriptorList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList");
static_assert(sizeof(UInspectorPropertyDescriptorList) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList");
static_assert(offsetof(UInspectorPropertyDescriptorList, ApplicableClass) == 0x000028, "Member 'UInspectorPropertyDescriptorList::ApplicableClass' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptorList, ApplicableStruct) == 0x000030, "Member 'UInspectorPropertyDescriptorList::ApplicableStruct' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptorList, Categories) == 0x000038, "Member 'UInspectorPropertyDescriptorList::Categories' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptorList, DescriptorLookup) == 0x000088, "Member 'UInspectorPropertyDescriptorList::DescriptorLookup' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptorList_IntVector
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_IntVector final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_IntVector">();
	}
	static class UInspectorPropertyDescriptorList_IntVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_IntVector>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_IntVector) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_IntVector");
static_assert(sizeof(UInspectorPropertyDescriptorList_IntVector) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_IntVector");

// Class Brickadia.BRGuidLibrary
// 0x0000 (0x0028 - 0x0028)
class UBRGuidLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_BRGuidToString(const struct FBRGuid& InGuid);
	static bool EqualEqual_BRGuidBRGuid(const struct FBRGuid& A, const struct FBRGuid& B);
	static void Invalidate_BRGuid(struct FBRGuid& InGuid);
	static bool IsValid_BRGuid(const struct FBRGuid& InGuid);
	static struct FBRGuid MakePublicBrickOwnerId();
	static bool NotEqual_BRGuidBRGuid(const struct FBRGuid& A, const struct FBRGuid& B);
	static void Parse_StringToBRGuid(const class FString& GuidString, struct FBRGuid* OutGuid, bool* bOutSuccess);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRGuidLibrary">();
	}
	static class UBRGuidLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRGuidLibrary>();
	}
};
static_assert(alignof(UBRGuidLibrary) == 0x000008, "Wrong alignment on UBRGuidLibrary");
static_assert(sizeof(UBRGuidLibrary) == 0x000028, "Wrong size on UBRGuidLibrary");

// Class Brickadia.BRHintSubsystem
// 0x0028 (0x0058 - 0x0030)
class UBRHintSubsystem final : public UGameInstanceSubsystem
{
public:
	TMulticastInlineDelegate<void(const struct FHintInfoTableRow& Hint)> HintSetDelegate;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllowCloseHints();
	void CloseHints();
	TArray<struct FHintInfoTableRow> GetAllHints();
	void NextHint();
	void PrevHint();
	void RequestHintCategory(EHintCategory Category, bool ForceDisplay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRHintSubsystem">();
	}
	static class UBRHintSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRHintSubsystem>();
	}
};
static_assert(alignof(UBRHintSubsystem) == 0x000008, "Wrong alignment on UBRHintSubsystem");
static_assert(sizeof(UBRHintSubsystem) == 0x000058, "Wrong size on UBRHintSubsystem");
static_assert(offsetof(UBRHintSubsystem, HintSetDelegate) == 0x000030, "Member 'UBRHintSubsystem::HintSetDelegate' has a wrong offset!");

// Class Brickadia.HUDWidgetBase
// 0x0020 (0x02F0 - 0x02D0)
class UHUDWidgetBase : public UUserWidget
{
public:
	class UCanvasPanel*                           HUDRootPanelBack;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           HUDRootPanelFront;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               DialogRootPanel;                                   // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogBackdropBase*                    DialogBackdrop;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnBackdropBlurDisabled();
	void OnBackdropBlurEnabled();
	void OnBackdropClickCatcherDisabled();
	void OnBackdropClickCatcherEnabled();
	void OnDialogsHideHUD();
	void OnDialogsShowHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDWidgetBase">();
	}
	static class UHUDWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDWidgetBase>();
	}
};
static_assert(alignof(UHUDWidgetBase) == 0x000008, "Wrong alignment on UHUDWidgetBase");
static_assert(sizeof(UHUDWidgetBase) == 0x0002F0, "Wrong size on UHUDWidgetBase");
static_assert(offsetof(UHUDWidgetBase, HUDRootPanelBack) == 0x0002D0, "Member 'UHUDWidgetBase::HUDRootPanelBack' has a wrong offset!");
static_assert(offsetof(UHUDWidgetBase, HUDRootPanelFront) == 0x0002D8, "Member 'UHUDWidgetBase::HUDRootPanelFront' has a wrong offset!");
static_assert(offsetof(UHUDWidgetBase, DialogRootPanel) == 0x0002E0, "Member 'UHUDWidgetBase::DialogRootPanel' has a wrong offset!");
static_assert(offsetof(UHUDWidgetBase, DialogBackdrop) == 0x0002E8, "Member 'UHUDWidgetBase::DialogBackdrop' has a wrong offset!");

// Class Brickadia.HUDWidgetIngameBase
// 0x0028 (0x0318 - 0x02F0)
class UHUDWidgetIngameBase final : public UHUDWidgetBase
{
public:
	class UBRQuickbarWidget*                      Quickbar;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRToolBindHintsWidget*                 ToolBindsWidget;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           ToolWidgetSlot;                                    // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPanelWidget*                           ToolCrosshairWidgetSlot;                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWeaponAmmoCollectionWidget*          AmmoDisplay;                                       // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUDWidgetIngameBase">();
	}
	static class UHUDWidgetIngameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUDWidgetIngameBase>();
	}
};
static_assert(alignof(UHUDWidgetIngameBase) == 0x000008, "Wrong alignment on UHUDWidgetIngameBase");
static_assert(sizeof(UHUDWidgetIngameBase) == 0x000318, "Wrong size on UHUDWidgetIngameBase");
static_assert(offsetof(UHUDWidgetIngameBase, Quickbar) == 0x0002F0, "Member 'UHUDWidgetIngameBase::Quickbar' has a wrong offset!");
static_assert(offsetof(UHUDWidgetIngameBase, ToolBindsWidget) == 0x0002F8, "Member 'UHUDWidgetIngameBase::ToolBindsWidget' has a wrong offset!");
static_assert(offsetof(UHUDWidgetIngameBase, ToolWidgetSlot) == 0x000300, "Member 'UHUDWidgetIngameBase::ToolWidgetSlot' has a wrong offset!");
static_assert(offsetof(UHUDWidgetIngameBase, ToolCrosshairWidgetSlot) == 0x000308, "Member 'UHUDWidgetIngameBase::ToolCrosshairWidgetSlot' has a wrong offset!");
static_assert(offsetof(UHUDWidgetIngameBase, AmmoDisplay) == 0x000310, "Member 'UHUDWidgetIngameBase::AmmoDisplay' has a wrong offset!");

// Class Brickadia.BasicBrick
// 0x0008 (0x0078 - 0x0070)
class UBasicBrick final : public UBrickAsset
{
public:
	class UBrickType*                             BrickType;                                         // 0x0070(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UBrickType* GetBrickType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasicBrick">();
	}
	static class UBasicBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasicBrick>();
	}
};
static_assert(alignof(UBasicBrick) == 0x000008, "Wrong alignment on UBasicBrick");
static_assert(sizeof(UBasicBrick) == 0x000078, "Wrong size on UBasicBrick");
static_assert(offsetof(UBasicBrick, BrickType) == 0x000070, "Member 'UBasicBrick::BrickType' has a wrong offset!");

// Class Brickadia.BrickComponentLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrickComponentLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EBrickComponentAttachResult AttachComponent(class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* ComponentType, bool bCheckQuota);
	static EBrickComponentDetachResult DetachComponent(class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* ComponentType);
	static void GetAllComponentTypes(const class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle, TArray<class UBrickComponentTypeBase*>* OutComponentTypes);
	static void GetAllRegisteredComponentTypes(class UObject* WorldContextObject, TArray<class UBrickComponentTypeBase*>* OutComponentTypes, bool bIncludeTombstones);
	static class UBrickComponentTypeBase* GetComponentType(class UObject* WorldContextObject, TSubclassOf<class UBrickComponentTypeBase> ComponentTypeClass);
	static class UBrickComponentTypeBase* GetComponentTypeByName(class UObject* WorldContextObject, class FName Name_0);
	static class UBrickComponentTypeBase* GetComponentTypeDerivedFrom(class UObject* WorldContextObject, TSubclassOf<class UBrickComponentTypeBase> ComponentTypeClass);
	static int32 GetNumRegisteredComponentClasses(class UObject* WorldContextObject);
	static bool HasAnyComponents(const class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle);
	static bool HasComponent(const class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* ComponentType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentLibrary">();
	}
	static class UBrickComponentLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentLibrary>();
	}
};
static_assert(alignof(UBrickComponentLibrary) == 0x000008, "Wrong alignment on UBrickComponentLibrary");
static_assert(sizeof(UBrickComponentLibrary) == 0x000028, "Wrong size on UBrickComponentLibrary");

// Class Brickadia.InspectorPropertyDescriptor_Struct
// 0x0000 (0x0088 - 0x0088)
class UInspectorPropertyDescriptor_Struct : public UInspectorPropertyDescriptor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Struct">();
	}
	static class UInspectorPropertyDescriptor_Struct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Struct>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Struct) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Struct");
static_assert(sizeof(UInspectorPropertyDescriptor_Struct) == 0x000088, "Wrong size on UInspectorPropertyDescriptor_Struct");

// Class Brickadia.InspectorPropertyDescriptor_DescriptorStruct
// 0x0010 (0x0098 - 0x0088)
class UInspectorPropertyDescriptor_DescriptorStruct : public UInspectorPropertyDescriptor_Struct
{
public:
	TSubclassOf<class UInspectorPropertyDescriptorList> DescriptorList;                                    // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInspectorPropertyDescriptorList*       DescriptorListInstance;                            // 0x0090(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_DescriptorStruct">();
	}
	static class UInspectorPropertyDescriptor_DescriptorStruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_DescriptorStruct>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_DescriptorStruct) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_DescriptorStruct");
static_assert(sizeof(UInspectorPropertyDescriptor_DescriptorStruct) == 0x000098, "Wrong size on UInspectorPropertyDescriptor_DescriptorStruct");
static_assert(offsetof(UInspectorPropertyDescriptor_DescriptorStruct, DescriptorList) == 0x000088, "Member 'UInspectorPropertyDescriptor_DescriptorStruct::DescriptorList' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_DescriptorStruct, DescriptorListInstance) == 0x000090, "Member 'UInspectorPropertyDescriptor_DescriptorStruct::DescriptorListInstance' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Rotator3f
// 0x0008 (0x00A0 - 0x0098)
class UInspectorPropertyDescriptor_Rotator3f final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	uint8                                         bLiveSlider : 1;                                   // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Rotator3f">();
	}
	static class UInspectorPropertyDescriptor_Rotator3f* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Rotator3f>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Rotator3f) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Rotator3f");
static_assert(sizeof(UInspectorPropertyDescriptor_Rotator3f) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_Rotator3f");

// Class Brickadia.BrickComponentType_AudioEmitter
// 0x0008 (0x01E0 - 0x01D8)
class UBrickComponentType_AudioEmitter final : public UBrickComponentTypeBase
{
public:
	class UBrickAudioDescriptor*                  DefaultBrickAudioDescriptor;                       // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_AudioEmitter">();
	}
	static class UBrickComponentType_AudioEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_AudioEmitter>();
	}
};
static_assert(alignof(UBrickComponentType_AudioEmitter) == 0x000008, "Wrong alignment on UBrickComponentType_AudioEmitter");
static_assert(sizeof(UBrickComponentType_AudioEmitter) == 0x0001E0, "Wrong size on UBrickComponentType_AudioEmitter");
static_assert(offsetof(UBrickComponentType_AudioEmitter, DefaultBrickAudioDescriptor) == 0x0001D8, "Member 'UBrickComponentType_AudioEmitter::DefaultBrickAudioDescriptor' has a wrong offset!");

// Class Brickadia.BrickComponentType_CheckPoint
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_CheckPoint final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_CheckPoint">();
	}
	static class UBrickComponentType_CheckPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_CheckPoint>();
	}
};
static_assert(alignof(UBrickComponentType_CheckPoint) == 0x000008, "Wrong alignment on UBrickComponentType_CheckPoint");
static_assert(sizeof(UBrickComponentType_CheckPoint) == 0x0001D8, "Wrong size on UBrickComponentType_CheckPoint");

// Class Brickadia.BrickComponentType_Damage
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Damage final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Damage">();
	}
	static class UBrickComponentType_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Damage>();
	}
};
static_assert(alignof(UBrickComponentType_Damage) == 0x000008, "Wrong alignment on UBrickComponentType_Damage");
static_assert(sizeof(UBrickComponentType_Damage) == 0x0001D8, "Wrong size on UBrickComponentType_Damage");

// Class Brickadia.InspectorPropertyValueLibrary
// 0x0000 (0x0028 - 0x0028)
class UInspectorPropertyValueLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FInspectorPropertyValue BoxPropertyValue_AnyStruct(int32 InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Boolean(bool InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Byte(uint8 InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Double(double InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Float(float InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Int(int32 InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Int64(int64 InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Name(class FName InValue);
	static struct FInspectorPropertyValue BoxPropertyValue_Null();
	static struct FInspectorPropertyValue BoxPropertyValue_String(const class FString& InValue);
	static EInspectorPropertyValueType GetPropertyValueType(const struct FInspectorPropertyValue& Value);
	static class FString Int64ToString(int64 Input);
	static class FString PropertyValueToString(const struct FInspectorPropertyValue& Value);
	static int64 StringToInt64(const class FString& Input);
	static void UnboxPropertyValue_AnyStruct(const struct FInspectorPropertyValue& Value, bool* bIsValid, int32* Unboxed);
	static void UnboxPropertyValue_Boolean(const struct FInspectorPropertyValue& Value, bool* bIsValid, bool* Unboxed);
	static void UnboxPropertyValue_Byte(const struct FInspectorPropertyValue& Value, bool* bIsValid, uint8* Unboxed);
	static void UnboxPropertyValue_Double(const struct FInspectorPropertyValue& Value, bool* bIsValid, double* Unboxed);
	static void UnboxPropertyValue_Float(const struct FInspectorPropertyValue& Value, bool* bIsValid, float* Unboxed);
	static void UnboxPropertyValue_Int(const struct FInspectorPropertyValue& Value, bool* bIsValid, int32* Unboxed);
	static void UnboxPropertyValue_Int64(const struct FInspectorPropertyValue& Value, bool* bIsValid, int64* Unboxed);
	static void UnboxPropertyValue_Name(const struct FInspectorPropertyValue& Value, bool* bIsValid, class FName* Unboxed);
	static void UnboxPropertyValue_String(const struct FInspectorPropertyValue& Value, bool* bIsValid, class FString* Unboxed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyValueLibrary">();
	}
	static class UInspectorPropertyValueLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyValueLibrary>();
	}
};
static_assert(alignof(UInspectorPropertyValueLibrary) == 0x000008, "Wrong alignment on UInspectorPropertyValueLibrary");
static_assert(sizeof(UInspectorPropertyValueLibrary) == 0x000028, "Wrong size on UInspectorPropertyValueLibrary");

// Class Brickadia.BrickComponentType_Interact
// 0x0008 (0x01F0 - 0x01E8)
class UBrickComponentType_Interact final : public UBrickComponentType_InteractableBase
{
public:
	class UBrickOneShotAudioDescriptor*           DefaultInteractSound;                              // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Interact">();
	}
	static class UBrickComponentType_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Interact>();
	}
};
static_assert(alignof(UBrickComponentType_Interact) == 0x000008, "Wrong alignment on UBrickComponentType_Interact");
static_assert(sizeof(UBrickComponentType_Interact) == 0x0001F0, "Wrong size on UBrickComponentType_Interact");
static_assert(offsetof(UBrickComponentType_Interact, DefaultInteractSound) == 0x0001E8, "Member 'UBrickComponentType_Interact::DefaultInteractSound' has a wrong offset!");

// Class Brickadia.BrickComponentType_AnimatedButton
// 0x0030 (0x0238 - 0x0208)
class UBrickComponentType_AnimatedButton final : public UBrickComponentType_Button
{
public:
	struct FBrickAnimatedAssetPairCollection      AnimatedAssets;                                    // 0x0208(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_AnimatedButton">();
	}
	static class UBrickComponentType_AnimatedButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_AnimatedButton>();
	}
};
static_assert(alignof(UBrickComponentType_AnimatedButton) == 0x000008, "Wrong alignment on UBrickComponentType_AnimatedButton");
static_assert(sizeof(UBrickComponentType_AnimatedButton) == 0x000238, "Wrong size on UBrickComponentType_AnimatedButton");
static_assert(offsetof(UBrickComponentType_AnimatedButton, AnimatedAssets) == 0x000208, "Member 'UBrickComponentType_AnimatedButton::AnimatedAssets' has a wrong offset!");

// Class Brickadia.BrickComponentType_AnimatedPressurePlate
// 0x0030 (0x0228 - 0x01F8)
class UBrickComponentType_AnimatedPressurePlate final : public UBrickComponentType_Touch
{
public:
	struct FBrickAnimatedAssetPairCollection      AnimatedAssets;                                    // 0x01F8(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_AnimatedPressurePlate">();
	}
	static class UBrickComponentType_AnimatedPressurePlate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_AnimatedPressurePlate>();
	}
};
static_assert(alignof(UBrickComponentType_AnimatedPressurePlate) == 0x000008, "Wrong alignment on UBrickComponentType_AnimatedPressurePlate");
static_assert(sizeof(UBrickComponentType_AnimatedPressurePlate) == 0x000228, "Wrong size on UBrickComponentType_AnimatedPressurePlate");
static_assert(offsetof(UBrickComponentType_AnimatedPressurePlate, AnimatedAssets) == 0x0001F8, "Member 'UBrickComponentType_AnimatedPressurePlate::AnimatedAssets' has a wrong offset!");

// Class Brickadia.BrickComponentType_AnimatedSwitch
// 0x0030 (0x0230 - 0x0200)
class UBrickComponentType_AnimatedSwitch final : public UBrickComponentType_Switch
{
public:
	struct FBrickAnimatedAssetPairCollection      AnimatedAssets;                                    // 0x0200(0x0030)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_AnimatedSwitch">();
	}
	static class UBrickComponentType_AnimatedSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_AnimatedSwitch>();
	}
};
static_assert(alignof(UBrickComponentType_AnimatedSwitch) == 0x000008, "Wrong alignment on UBrickComponentType_AnimatedSwitch");
static_assert(sizeof(UBrickComponentType_AnimatedSwitch) == 0x000230, "Wrong size on UBrickComponentType_AnimatedSwitch");
static_assert(offsetof(UBrickComponentType_AnimatedSwitch, AnimatedAssets) == 0x000200, "Member 'UBrickComponentType_AnimatedSwitch::AnimatedAssets' has a wrong offset!");

// Class Brickadia.BRWorldSettings
// 0x0018 (0x04F0 - 0x04D8)
class ABRWorldSettings final : public AWorldSettings
{
public:
	EBRWorldType                                  WorldType;                                         // 0x04D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D9[0x7];                                      // 0x04D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MapPackageName;                                    // 0x04E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldSettings">();
	}
	static class ABRWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRWorldSettings>();
	}
};
static_assert(alignof(ABRWorldSettings) == 0x000008, "Wrong alignment on ABRWorldSettings");
static_assert(sizeof(ABRWorldSettings) == 0x0004F0, "Wrong size on ABRWorldSettings");
static_assert(offsetof(ABRWorldSettings, WorldType) == 0x0004D8, "Member 'ABRWorldSettings::WorldType' has a wrong offset!");
static_assert(offsetof(ABRWorldSettings, MapPackageName) == 0x0004E0, "Member 'ABRWorldSettings::MapPackageName' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_Joint_Motor
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_Motor final : public UBrickComponentType_Internal_Joint_Bearing
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_Motor">();
	}
	static class UBrickComponentType_Internal_Joint_Motor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_Motor>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_Motor) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_Motor");
static_assert(sizeof(UBrickComponentType_Internal_Joint_Motor) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_Motor");

// Class Brickadia.BrickComponentType_Internal_Destination
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_Destination final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Destination">();
	}
	static class UBrickComponentType_Internal_Destination* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Destination>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Destination) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Destination");
static_assert(sizeof(UBrickComponentType_Internal_Destination) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_Destination");

// Class Brickadia.BrickComponentType_Internal_RelativeTeleporter
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_RelativeTeleporter final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_RelativeTeleporter">();
	}
	static class UBrickComponentType_Internal_RelativeTeleporter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_RelativeTeleporter>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_RelativeTeleporter) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_RelativeTeleporter");
static_assert(sizeof(UBrickComponentType_Internal_RelativeTeleporter) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_RelativeTeleporter");

// Class Brickadia.BrickComponentType_Internal_EntityGate_SetLocation
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_SetLocation final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_SetLocation">();
	}
	static class UBrickComponentType_Internal_EntityGate_SetLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_SetLocation>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_SetLocation) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_SetLocation");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_SetLocation) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_SetLocation");

// Class Brickadia.InspectorPropertyDescriptorList_Rotator3f
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_Rotator3f final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_Rotator3f">();
	}
	static class UInspectorPropertyDescriptorList_Rotator3f* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_Rotator3f>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_Rotator3f) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_Rotator3f");
static_assert(sizeof(UInspectorPropertyDescriptorList_Rotator3f) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_Rotator3f");

// Class Brickadia.BRWeaponStateBehavior_FiringProjectile
// 0x0010 (0x0060 - 0x0050)
class UBRWeaponStateBehavior_FiringProjectile final : public UBRWeaponStateBehavior_Firing
{
public:
	TSubclassOf<class ABRWeaponProjectile>        ProjectileClass;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyHomingTarget;                                // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_FiringProjectile">();
	}
	static class UBRWeaponStateBehavior_FiringProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_FiringProjectile>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_FiringProjectile) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_FiringProjectile");
static_assert(sizeof(UBRWeaponStateBehavior_FiringProjectile) == 0x000060, "Wrong size on UBRWeaponStateBehavior_FiringProjectile");
static_assert(offsetof(UBRWeaponStateBehavior_FiringProjectile, ProjectileClass) == 0x000050, "Member 'UBRWeaponStateBehavior_FiringProjectile::ProjectileClass' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringProjectile, bApplyHomingTarget) == 0x000058, "Member 'UBRWeaponStateBehavior_FiringProjectile::bApplyHomingTarget' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_EntityGate_AddLocationAndRotation
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_AddLocationAndRotation final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_AddLocationAndRotation">();
	}
	static class UBrickComponentType_Internal_EntityGate_AddLocationAndRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_AddLocationAndRotation>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_AddLocationAndRotation) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_AddLocationAndRotation");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_AddLocationAndRotation) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_AddLocationAndRotation");

// Class Brickadia.InspectorPropertyDescriptor_TextListToInt
// 0x0018 (0x00A0 - 0x0088)
class UInspectorPropertyDescriptor_TextListToInt final : public UInspectorPropertyDescriptor
{
public:
	TArray<class FText>                           TextList;                                          // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ValueOffset;                                       // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_TextListToInt">();
	}
	static class UInspectorPropertyDescriptor_TextListToInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_TextListToInt>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_TextListToInt) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_TextListToInt");
static_assert(sizeof(UInspectorPropertyDescriptor_TextListToInt) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_TextListToInt");
static_assert(offsetof(UInspectorPropertyDescriptor_TextListToInt, TextList) == 0x000088, "Member 'UInspectorPropertyDescriptor_TextListToInt::TextList' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_TextListToInt, ValueOffset) == 0x000098, "Member 'UInspectorPropertyDescriptor_TextListToInt::ValueOffset' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_EntityGate_AddVelocity
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_AddVelocity final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_AddVelocity">();
	}
	static class UBrickComponentType_Internal_EntityGate_AddVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_AddVelocity>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_AddVelocity) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_AddVelocity");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_AddVelocity) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_AddVelocity");

// Class Brickadia.BrickComponentType_Internal_EntityGate_ReadBrickGrid
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Internal_EntityGate_ReadBrickGrid final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_EntityGate_ReadBrickGrid">();
	}
	static class UBrickComponentType_Internal_EntityGate_ReadBrickGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_EntityGate_ReadBrickGrid>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_EntityGate_ReadBrickGrid) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_EntityGate_ReadBrickGrid");
static_assert(sizeof(UBrickComponentType_Internal_EntityGate_ReadBrickGrid) == 0x0001D8, "Wrong size on UBrickComponentType_Internal_EntityGate_ReadBrickGrid");

// Class Brickadia.BRDraggableListEntryBase
// 0x0038 (0x0308 - 0x02D0)
class UBRDraggableListEntryBase : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x8];                                      // 0x02D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBorder*                                Background;                                        // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCachedIsHovered;                                  // 0x0300(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCachedIsSelected;                                 // 0x0301(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bViewHasDragDropInProgress;                        // 0x0302(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_303[0x5];                                      // 0x0303(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRDraggableListEntryBase">();
	}
	static class UBRDraggableListEntryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRDraggableListEntryBase>();
	}
};
static_assert(alignof(UBRDraggableListEntryBase) == 0x000008, "Wrong alignment on UBRDraggableListEntryBase");
static_assert(sizeof(UBRDraggableListEntryBase) == 0x000308, "Wrong size on UBRDraggableListEntryBase");
static_assert(offsetof(UBRDraggableListEntryBase, Background) == 0x0002D8, "Member 'UBRDraggableListEntryBase::Background' has a wrong offset!");
static_assert(offsetof(UBRDraggableListEntryBase, bCachedIsHovered) == 0x000300, "Member 'UBRDraggableListEntryBase::bCachedIsHovered' has a wrong offset!");
static_assert(offsetof(UBRDraggableListEntryBase, bCachedIsSelected) == 0x000301, "Member 'UBRDraggableListEntryBase::bCachedIsSelected' has a wrong offset!");
static_assert(offsetof(UBRDraggableListEntryBase, bViewHasDragDropInProgress) == 0x000302, "Member 'UBRDraggableListEntryBase::bViewHasDragDropInProgress' has a wrong offset!");

// Class Brickadia.BRWorldFolderEntryWidget
// 0x0030 (0x0338 - 0x0308)
class UBRWorldFolderEntryWidget : public UBRDraggableListEntryBase
{
public:
	class UTextBlock*                             NameText;                                          // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             FolderCountText;                                   // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             WorldCountText;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DragHoverOutline;                                  // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldFolderEntryWidget">();
	}
	static class UBRWorldFolderEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldFolderEntryWidget>();
	}
};
static_assert(alignof(UBRWorldFolderEntryWidget) == 0x000008, "Wrong alignment on UBRWorldFolderEntryWidget");
static_assert(sizeof(UBRWorldFolderEntryWidget) == 0x000338, "Wrong size on UBRWorldFolderEntryWidget");
static_assert(offsetof(UBRWorldFolderEntryWidget, NameText) == 0x000308, "Member 'UBRWorldFolderEntryWidget::NameText' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderEntryWidget, FolderCountText) == 0x000310, "Member 'UBRWorldFolderEntryWidget::FolderCountText' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderEntryWidget, WorldCountText) == 0x000318, "Member 'UBRWorldFolderEntryWidget::WorldCountText' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderEntryWidget, DragHoverOutline) == 0x000320, "Member 'UBRWorldFolderEntryWidget::DragHoverOutline' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateOrBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateOrBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateOrBool">();
	}
	static class UBrickComponentType_GateOrBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateOrBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateOrBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateOrBool");
static_assert(sizeof(UBrickComponentType_GateOrBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateOrBool");

// Class Brickadia.MetasoundTest
// 0x0020 (0x02D0 - 0x02B0)
class AMetasoundTest final : public AActor
{
public:
	class UMetaSoundSource*                       Metasound;                                         // 0x02B0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            Mesh;                                              // 0x02B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAudioComponent*>                AudioComponents;                                   // 0x02C0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MetasoundTest">();
	}
	static class AMetasoundTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMetasoundTest>();
	}
};
static_assert(alignof(AMetasoundTest) == 0x000008, "Wrong alignment on AMetasoundTest");
static_assert(sizeof(AMetasoundTest) == 0x0002D0, "Wrong size on AMetasoundTest");
static_assert(offsetof(AMetasoundTest, Metasound) == 0x0002B0, "Member 'AMetasoundTest::Metasound' has a wrong offset!");
static_assert(offsetof(AMetasoundTest, Mesh) == 0x0002B8, "Member 'AMetasoundTest::Mesh' has a wrong offset!");
static_assert(offsetof(AMetasoundTest, AudioComponents) == 0x0002C0, "Member 'AMetasoundTest::AudioComponents' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateXorBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateXorBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateXorBool">();
	}
	static class UBrickComponentType_GateXorBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateXorBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateXorBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateXorBool");
static_assert(sizeof(UBrickComponentType_GateXorBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateXorBool");

// Class Brickadia.BrickComponentType_GateNandBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateNandBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateNandBool">();
	}
	static class UBrickComponentType_GateNandBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateNandBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateNandBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateNandBool");
static_assert(sizeof(UBrickComponentType_GateNandBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateNandBool");

// Class Brickadia.BrickComponentType_GateOrInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateOrInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateOrInt">();
	}
	static class UBrickComponentType_GateOrInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateOrInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateOrInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateOrInt");
static_assert(sizeof(UBrickComponentType_GateOrInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateOrInt");

// Class Brickadia.BRWorldCreationMapEntry
// 0x0020 (0x0328 - 0x0308)
class UBRWorldCreationMapEntry : public UBRDraggableListEntryBase
{
public:
	class UTextBlock*                             NameText;                                          // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DescriptionText;                                   // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Thumbnail;                                         // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Screenshot;                                        // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldCreationMapEntry">();
	}
	static class UBRWorldCreationMapEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldCreationMapEntry>();
	}
};
static_assert(alignof(UBRWorldCreationMapEntry) == 0x000008, "Wrong alignment on UBRWorldCreationMapEntry");
static_assert(sizeof(UBRWorldCreationMapEntry) == 0x000328, "Wrong size on UBRWorldCreationMapEntry");
static_assert(offsetof(UBRWorldCreationMapEntry, NameText) == 0x000308, "Member 'UBRWorldCreationMapEntry::NameText' has a wrong offset!");
static_assert(offsetof(UBRWorldCreationMapEntry, DescriptionText) == 0x000310, "Member 'UBRWorldCreationMapEntry::DescriptionText' has a wrong offset!");
static_assert(offsetof(UBRWorldCreationMapEntry, Thumbnail) == 0x000318, "Member 'UBRWorldCreationMapEntry::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRWorldCreationMapEntry, Screenshot) == 0x000320, "Member 'UBRWorldCreationMapEntry::Screenshot' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateAndInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateAndInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateAndInt">();
	}
	static class UBrickComponentType_GateAndInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateAndInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateAndInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateAndInt");
static_assert(sizeof(UBrickComponentType_GateAndInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateAndInt");

// Class Brickadia.BrickComponentType_GateXorInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateXorInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateXorInt">();
	}
	static class UBrickComponentType_GateXorInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateXorInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateXorInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateXorInt");
static_assert(sizeof(UBrickComponentType_GateXorInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateXorInt");

// Class Brickadia.BrickComponentType_GateShiftRightInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateShiftRightInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateShiftRightInt">();
	}
	static class UBrickComponentType_GateShiftRightInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateShiftRightInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateShiftRightInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateShiftRightInt");
static_assert(sizeof(UBrickComponentType_GateShiftRightInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateShiftRightInt");

// Class Brickadia.BrickComponentType_GateSubtractFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateSubtractFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateSubtractFloat">();
	}
	static class UBrickComponentType_GateSubtractFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateSubtractFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateSubtractFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateSubtractFloat");
static_assert(sizeof(UBrickComponentType_GateSubtractFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateSubtractFloat");

// Class Brickadia.BrickComponentType_GateDivideFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateDivideFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateDivideFloat">();
	}
	static class UBrickComponentType_GateDivideFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateDivideFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateDivideFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateDivideFloat");
static_assert(sizeof(UBrickComponentType_GateDivideFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateDivideFloat");

// Class Brickadia.BrickComponentType_GateModFloatFloored
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateModFloatFloored final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateModFloatFloored">();
	}
	static class UBrickComponentType_GateModFloatFloored* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateModFloatFloored>();
	}
};
static_assert(alignof(UBrickComponentType_GateModFloatFloored) == 0x000008, "Wrong alignment on UBrickComponentType_GateModFloatFloored");
static_assert(sizeof(UBrickComponentType_GateModFloatFloored) == 0x0001D8, "Wrong size on UBrickComponentType_GateModFloatFloored");

// Class Brickadia.BrickComponentType_GateCeilFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateCeilFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateCeilFloat">();
	}
	static class UBrickComponentType_GateCeilFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateCeilFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateCeilFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateCeilFloat");
static_assert(sizeof(UBrickComponentType_GateCeilFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateCeilFloat");

// Class Brickadia.BrickComponentType_GateAddInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateAddInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateAddInt">();
	}
	static class UBrickComponentType_GateAddInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateAddInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateAddInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateAddInt");
static_assert(sizeof(UBrickComponentType_GateAddInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateAddInt");

// Class Brickadia.BrickComponentType_GateMultiplyInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateMultiplyInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateMultiplyInt">();
	}
	static class UBrickComponentType_GateMultiplyInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateMultiplyInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateMultiplyInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateMultiplyInt");
static_assert(sizeof(UBrickComponentType_GateMultiplyInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateMultiplyInt");

// Class Brickadia.BrickComponentType_GateDivideIntFloored
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateDivideIntFloored final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateDivideIntFloored">();
	}
	static class UBrickComponentType_GateDivideIntFloored* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateDivideIntFloored>();
	}
};
static_assert(alignof(UBrickComponentType_GateDivideIntFloored) == 0x000008, "Wrong alignment on UBrickComponentType_GateDivideIntFloored");
static_assert(sizeof(UBrickComponentType_GateDivideIntFloored) == 0x0001D8, "Wrong size on UBrickComponentType_GateDivideIntFloored");

// Class Brickadia.BrickComponentType_GateModIntFloored
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateModIntFloored final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateModIntFloored">();
	}
	static class UBrickComponentType_GateModIntFloored* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateModIntFloored>();
	}
};
static_assert(alignof(UBrickComponentType_GateModIntFloored) == 0x000008, "Wrong alignment on UBrickComponentType_GateModIntFloored");
static_assert(sizeof(UBrickComponentType_GateModIntFloored) == 0x0001D8, "Wrong size on UBrickComponentType_GateModIntFloored");

// Class Brickadia.BrickComponentType_GateEqualsBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateEqualsBool final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateEqualsBool">();
	}
	static class UBrickComponentType_GateEqualsBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateEqualsBool>();
	}
};
static_assert(alignof(UBrickComponentType_GateEqualsBool) == 0x000008, "Wrong alignment on UBrickComponentType_GateEqualsBool");
static_assert(sizeof(UBrickComponentType_GateEqualsBool) == 0x0001D8, "Wrong size on UBrickComponentType_GateEqualsBool");

// Class Brickadia.BrickComponentType_GateEqualsFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateEqualsFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateEqualsFloat">();
	}
	static class UBrickComponentType_GateEqualsFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateEqualsFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateEqualsFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateEqualsFloat");
static_assert(sizeof(UBrickComponentType_GateEqualsFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateEqualsFloat");

// Class Brickadia.BrickComponentType_GateGreaterThanFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateGreaterThanFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateGreaterThanFloat">();
	}
	static class UBrickComponentType_GateGreaterThanFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateGreaterThanFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateGreaterThanFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateGreaterThanFloat");
static_assert(sizeof(UBrickComponentType_GateGreaterThanFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateGreaterThanFloat");

// Class Brickadia.BRPlayerPartComponent
// 0x0040 (0x05E0 - 0x05A0)
class UBRPlayerPartComponent final : public UStaticMeshComponent
{
public:
	class UBRPlayerPartDescriptor*                PartDescriptor;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPlayerDecalDescriptor*               DecalDescriptor;                                   // 0x05A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MaterialInstance;                                  // 0x05A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMirrored;                                       // 0x05B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TreeIndex;                                         // 0x05B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B8[0x28];                                     // 0x05B8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyMeshColors();
	void ClearDescriptor();
	int32 GetMeshColorSectionIndex(int32 FaceIndex);
	void SetDecal(class UBRPlayerDecalDescriptor* NewDecal);
	void SetDescriptor(class UBRPlayerPartDescriptor* NewDescriptor);
	void SetMeshColor(int32 Index_0, const struct FColor& Value);
	void SetMirrored(bool bMirror);

	struct FColor GetMeshColor(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerPartComponent">();
	}
	static class UBRPlayerPartComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlayerPartComponent>();
	}
};
static_assert(alignof(UBRPlayerPartComponent) == 0x000010, "Wrong alignment on UBRPlayerPartComponent");
static_assert(sizeof(UBRPlayerPartComponent) == 0x0005E0, "Wrong size on UBRPlayerPartComponent");
static_assert(offsetof(UBRPlayerPartComponent, PartDescriptor) == 0x000598, "Member 'UBRPlayerPartComponent::PartDescriptor' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartComponent, DecalDescriptor) == 0x0005A0, "Member 'UBRPlayerPartComponent::DecalDescriptor' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartComponent, MaterialInstance) == 0x0005A8, "Member 'UBRPlayerPartComponent::MaterialInstance' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartComponent, bIsMirrored) == 0x0005B0, "Member 'UBRPlayerPartComponent::bIsMirrored' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartComponent, TreeIndex) == 0x0005B4, "Member 'UBRPlayerPartComponent::TreeIndex' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateLessThanFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateLessThanFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateLessThanFloat">();
	}
	static class UBrickComponentType_GateLessThanFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateLessThanFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateLessThanFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateLessThanFloat");
static_assert(sizeof(UBrickComponentType_GateLessThanFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateLessThanFloat");

// Class Brickadia.BrickComponentType_GateGreaterThanOrEqualFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateGreaterThanOrEqualFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateGreaterThanOrEqualFloat">();
	}
	static class UBrickComponentType_GateGreaterThanOrEqualFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateGreaterThanOrEqualFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateGreaterThanOrEqualFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateGreaterThanOrEqualFloat");
static_assert(sizeof(UBrickComponentType_GateGreaterThanOrEqualFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateGreaterThanOrEqualFloat");

// Class Brickadia.BrickComponentType_GateLessThanOrEqualFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateLessThanOrEqualFloat final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateLessThanOrEqualFloat">();
	}
	static class UBrickComponentType_GateLessThanOrEqualFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateLessThanOrEqualFloat>();
	}
};
static_assert(alignof(UBrickComponentType_GateLessThanOrEqualFloat) == 0x000008, "Wrong alignment on UBrickComponentType_GateLessThanOrEqualFloat");
static_assert(sizeof(UBrickComponentType_GateLessThanOrEqualFloat) == 0x0001D8, "Wrong size on UBrickComponentType_GateLessThanOrEqualFloat");

// Class Brickadia.BRPainterScrollPalette
// 0x0010 (0x02E8 - 0x02D8)
class UBRPainterScrollPalette final : public UBRPaletteToolWidget
{
public:
	uint8                                         Pad_2D8[0x8];                                      // 0x02D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRColorSelectorColorsWidget*           ColorSelectorColors;                               // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ColorSelected(const struct FColor& Color);
	void ScrollDown();
	void ScrollLeft();
	void ScrollRight();
	void ScrollUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPainterScrollPalette">();
	}
	static class UBRPainterScrollPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPainterScrollPalette>();
	}
};
static_assert(alignof(UBRPainterScrollPalette) == 0x000008, "Wrong alignment on UBRPainterScrollPalette");
static_assert(sizeof(UBRPainterScrollPalette) == 0x0002E8, "Wrong size on UBRPainterScrollPalette");
static_assert(offsetof(UBRPainterScrollPalette, ColorSelectorColors) == 0x0002E0, "Member 'UBRPainterScrollPalette::ColorSelectorColors' has a wrong offset!");

// Class Brickadia.BrickComponentType_GateEqualsInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateEqualsInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateEqualsInt">();
	}
	static class UBrickComponentType_GateEqualsInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateEqualsInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateEqualsInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateEqualsInt");
static_assert(sizeof(UBrickComponentType_GateEqualsInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateEqualsInt");

// Class Brickadia.BrickComponentType_GateGreaterThanInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateGreaterThanInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateGreaterThanInt">();
	}
	static class UBrickComponentType_GateGreaterThanInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateGreaterThanInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateGreaterThanInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateGreaterThanInt");
static_assert(sizeof(UBrickComponentType_GateGreaterThanInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateGreaterThanInt");

// Class Brickadia.BrickComponentType_GateLessThanInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateLessThanInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateLessThanInt">();
	}
	static class UBrickComponentType_GateLessThanInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateLessThanInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateLessThanInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateLessThanInt");
static_assert(sizeof(UBrickComponentType_GateLessThanInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateLessThanInt");

// Class Brickadia.BrickComponentType_GateGreaterThanOrEqualInt
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateGreaterThanOrEqualInt final : public UBrickComponentType_GateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateGreaterThanOrEqualInt">();
	}
	static class UBrickComponentType_GateGreaterThanOrEqualInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateGreaterThanOrEqualInt>();
	}
};
static_assert(alignof(UBrickComponentType_GateGreaterThanOrEqualInt) == 0x000008, "Wrong alignment on UBrickComponentType_GateGreaterThanOrEqualInt");
static_assert(sizeof(UBrickComponentType_GateGreaterThanOrEqualInt) == 0x0001D8, "Wrong size on UBrickComponentType_GateGreaterThanOrEqualInt");

// Class Brickadia.BrickComponentType_ConstantBool
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_ConstantBool final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_ConstantBool">();
	}
	static class UBrickComponentType_ConstantBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_ConstantBool>();
	}
};
static_assert(alignof(UBrickComponentType_ConstantBool) == 0x000008, "Wrong alignment on UBrickComponentType_ConstantBool");
static_assert(sizeof(UBrickComponentType_ConstantBool) == 0x0001D8, "Wrong size on UBrickComponentType_ConstantBool");

// Class Brickadia.SpinBoxInteger
// 0x0648 (0x07B0 - 0x0168)
class USpinBoxInteger : public UWidget
{
public:
	int32                                         Value;                                             // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueDelegate;                                     // 0x016C(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17C[0x4];                                      // 0x017C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSpinBoxStyle                          WidgetStyle;                                       // 0x0180(0x0520)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         MinFractionalDigits;                               // 0x06A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFractionalDigits;                               // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlwaysUsesDeltaSnap;                              // 0x06A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSlider;                                     // 0x06A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6AA[0x2];                                      // 0x06AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Delta;                                             // 0x06AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SliderExponent;                                    // 0x06B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftMouseMovePixelPerDelta;                       // 0x06B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x06B8(0x0060)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextJustify                                  Justification;                                     // 0x0718(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_719[0x3];                                      // 0x0719(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinDesiredWidth;                                   // 0x071C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVirtualKeyboardType                          KeyboardType;                                      // 0x0720(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ClearKeyboardFocusOnCommit;                        // 0x0721(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SelectAllTextOnCommit;                             // 0x0722(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_723[0x1];                                      // 0x0723(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateColor                            ForegroundColor;                                   // 0x0724(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 InValue)> OnValueChanged;                                    // 0x0738(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 InValue, ETextCommit CommitMethod)> OnValueCommitted;                                  // 0x0748(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnBeginSliderMovement;                             // 0x0758(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 InValue)> OnEndSliderMovement;                               // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         bOverride_MinValue : 1;                            // 0x0778(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MaxValue : 1;                            // 0x0778(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MinSliderValue : 1;                      // 0x0778(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_MaxSliderValue : 1;                      // 0x0778(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         bOverride_DisplayUnit : 1;                         // 0x0778(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_779[0x3];                                      // 0x0779(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinValue;                                          // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxValue;                                          // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinSliderValue;                                    // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxSliderValue;                                    // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUnit                                         UnderlyingUnit;                                    // 0x078C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUnit                                         DisplayUnit;                                       // 0x078D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_78E[0x22];                                     // 0x078E(0x0022)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearDisplayUnit();
	void ClearMaxSliderValue();
	void ClearMaxValue();
	void ClearMinSliderValue();
	void ClearMinValue();
	void SetAlwaysUsesDeltaSnap(bool bNewValue);
	void SetDelta(int32 NewValue);
	void SetDisplayUnit(EUnit NewValue);
	void SetForegroundColor(const struct FSlateColor& InForegroundColor);
	void SetMaxFractionalDigits(int32 NewValue);
	void SetMaxSliderValue(int32 NewValue);
	void SetMaxValue(int32 NewValue);
	void SetMinFractionalDigits(int32 NewValue);
	void SetMinSliderValue(int32 NewValue);
	void SetMinValue(int32 NewValue);
	void SetUnderlyingUnit(EUnit NewValue);
	void SetValue(int32 NewValue);

	bool GetAlwaysUsesDeltaSnap() const;
	int32 GetDelta() const;
	EUnit GetDisplayUnit() const;
	int32 GetMaxFractionalDigits() const;
	int32 GetMaxSliderValue() const;
	int32 GetMaxValue() const;
	int32 GetMinFractionalDigits() const;
	int32 GetMinSliderValue() const;
	int32 GetMinValue() const;
	EUnit GetUnderlyingUnit() const;
	int32 GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpinBoxInteger">();
	}
	static class USpinBoxInteger* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpinBoxInteger>();
	}
};
static_assert(alignof(USpinBoxInteger) == 0x000010, "Wrong alignment on USpinBoxInteger");
static_assert(sizeof(USpinBoxInteger) == 0x0007B0, "Wrong size on USpinBoxInteger");
static_assert(offsetof(USpinBoxInteger, Value) == 0x000168, "Member 'USpinBoxInteger::Value' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, ValueDelegate) == 0x00016C, "Member 'USpinBoxInteger::ValueDelegate' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, WidgetStyle) == 0x000180, "Member 'USpinBoxInteger::WidgetStyle' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MinFractionalDigits) == 0x0006A0, "Member 'USpinBoxInteger::MinFractionalDigits' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MaxFractionalDigits) == 0x0006A4, "Member 'USpinBoxInteger::MaxFractionalDigits' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, bAlwaysUsesDeltaSnap) == 0x0006A8, "Member 'USpinBoxInteger::bAlwaysUsesDeltaSnap' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, bEnableSlider) == 0x0006A9, "Member 'USpinBoxInteger::bEnableSlider' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, Delta) == 0x0006AC, "Member 'USpinBoxInteger::Delta' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, SliderExponent) == 0x0006B0, "Member 'USpinBoxInteger::SliderExponent' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, ShiftMouseMovePixelPerDelta) == 0x0006B4, "Member 'USpinBoxInteger::ShiftMouseMovePixelPerDelta' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, Font) == 0x0006B8, "Member 'USpinBoxInteger::Font' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, Justification) == 0x000718, "Member 'USpinBoxInteger::Justification' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MinDesiredWidth) == 0x00071C, "Member 'USpinBoxInteger::MinDesiredWidth' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, KeyboardType) == 0x000720, "Member 'USpinBoxInteger::KeyboardType' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, ClearKeyboardFocusOnCommit) == 0x000721, "Member 'USpinBoxInteger::ClearKeyboardFocusOnCommit' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, SelectAllTextOnCommit) == 0x000722, "Member 'USpinBoxInteger::SelectAllTextOnCommit' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, ForegroundColor) == 0x000724, "Member 'USpinBoxInteger::ForegroundColor' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, OnValueChanged) == 0x000738, "Member 'USpinBoxInteger::OnValueChanged' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, OnValueCommitted) == 0x000748, "Member 'USpinBoxInteger::OnValueCommitted' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, OnBeginSliderMovement) == 0x000758, "Member 'USpinBoxInteger::OnBeginSliderMovement' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, OnEndSliderMovement) == 0x000768, "Member 'USpinBoxInteger::OnEndSliderMovement' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MinValue) == 0x00077C, "Member 'USpinBoxInteger::MinValue' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MaxValue) == 0x000780, "Member 'USpinBoxInteger::MaxValue' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MinSliderValue) == 0x000784, "Member 'USpinBoxInteger::MinSliderValue' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, MaxSliderValue) == 0x000788, "Member 'USpinBoxInteger::MaxSliderValue' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, UnderlyingUnit) == 0x00078C, "Member 'USpinBoxInteger::UnderlyingUnit' has a wrong offset!");
static_assert(offsetof(USpinBoxInteger, DisplayUnit) == 0x00078D, "Member 'USpinBoxInteger::DisplayUnit' has a wrong offset!");

// Class Brickadia.BrickComponentType_ConstantFloat
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_ConstantFloat final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_ConstantFloat">();
	}
	static class UBrickComponentType_ConstantFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_ConstantFloat>();
	}
};
static_assert(alignof(UBrickComponentType_ConstantFloat) == 0x000008, "Wrong alignment on UBrickComponentType_ConstantFloat");
static_assert(sizeof(UBrickComponentType_ConstantFloat) == 0x0001D8, "Wrong size on UBrickComponentType_ConstantFloat");

// Class Brickadia.BrickComponentType_GateEdgeDetector
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateEdgeDetector final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateEdgeDetector">();
	}
	static class UBrickComponentType_GateEdgeDetector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateEdgeDetector>();
	}
};
static_assert(alignof(UBrickComponentType_GateEdgeDetector) == 0x000008, "Wrong alignment on UBrickComponentType_GateEdgeDetector");
static_assert(sizeof(UBrickComponentType_GateEdgeDetector) == 0x0001D8, "Wrong size on UBrickComponentType_GateEdgeDetector");

// Class Brickadia.BrickComponentType_GateTimer_Tick
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_GateTimer_Tick final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_GateTimer_Tick">();
	}
	static class UBrickComponentType_GateTimer_Tick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_GateTimer_Tick>();
	}
};
static_assert(alignof(UBrickComponentType_GateTimer_Tick) == 0x000008, "Wrong alignment on UBrickComponentType_GateTimer_Tick");
static_assert(sizeof(UBrickComponentType_GateTimer_Tick) == 0x0001D8, "Wrong size on UBrickComponentType_GateTimer_Tick");

// Class Brickadia.BrickComponentType_Internal_Seat
// 0x0030 (0x0218 - 0x01E8)
class UBrickComponentType_Internal_Seat final : public UBrickComponentType_InteractableBase
{
public:
	struct FVector                                Offset;                                            // 0x01E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0200(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Seat">();
	}
	static class UBrickComponentType_Internal_Seat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Seat>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Seat) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Seat");
static_assert(sizeof(UBrickComponentType_Internal_Seat) == 0x000218, "Wrong size on UBrickComponentType_Internal_Seat");
static_assert(offsetof(UBrickComponentType_Internal_Seat, Offset) == 0x0001E8, "Member 'UBrickComponentType_Internal_Seat::Offset' has a wrong offset!");
static_assert(offsetof(UBrickComponentType_Internal_Seat, Rotation) == 0x000200, "Member 'UBrickComponentType_Internal_Seat::Rotation' has a wrong offset!");

// Class Brickadia.BrickComponentType_Internal_Joint_MotorSlider
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_MotorSlider final : public UBrickComponentType_Internal_Joint_Slider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_MotorSlider">();
	}
	static class UBrickComponentType_Internal_Joint_MotorSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_MotorSlider>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_MotorSlider) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_MotorSlider");
static_assert(sizeof(UBrickComponentType_Internal_Joint_MotorSlider) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_MotorSlider");

// Class Brickadia.BrickComponentType_Internal_Joint_OldServoSlider
// 0x0000 (0x01E0 - 0x01E0)
class UBrickComponentType_Internal_Joint_OldServoSlider final : public UBrickComponentType_Internal_Joint_Slider
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_Joint_OldServoSlider">();
	}
	static class UBrickComponentType_Internal_Joint_OldServoSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_Joint_OldServoSlider>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_Joint_OldServoSlider) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_Joint_OldServoSlider");
static_assert(sizeof(UBrickComponentType_Internal_Joint_OldServoSlider) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_Joint_OldServoSlider");

// Class Brickadia.BrickComponentType_Internal_WheelEngine
// 0x0008 (0x01E0 - 0x01D8)
class UBrickComponentType_Internal_WheelEngine : public UBrickComponentTypeBase
{
public:
	class UBrickWheelEngineAudioDescriptor*       DefaultWheelEngineAudioDescriptor;                 // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Effects_OnEngineAttached(const struct FBrickComponentInstanceRef& InstanceRef, const struct FBrickComponentData_WheelEngine& EngineState, EBrickComponentAttachReason Reason);
	void Effects_OnEngineAudioDescriptorUpdated(const struct FBrickComponentInstanceRef& InstanceRef, const struct FBrickComponentData_WheelEngine& EngineState, EBrickComponentPropertyChangeReason Reason);
	void Effects_OnEngineOnStateChanged(const struct FBrickComponentInstanceRef& InstanceRef, const struct FBrickComponentData_WheelEngine& EngineState, const struct FBrickWheelEngineUpdateContext& EngineContext);
	void Effects_OnEngineUpdate(const struct FBrickComponentInstanceRef& InstanceRef, const struct FBrickComponentData_WheelEngine& EngineState, const struct FBrickWheelEngineUpdateContext& EngineContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Internal_WheelEngine">();
	}
	static class UBrickComponentType_Internal_WheelEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Internal_WheelEngine>();
	}
};
static_assert(alignof(UBrickComponentType_Internal_WheelEngine) == 0x000008, "Wrong alignment on UBrickComponentType_Internal_WheelEngine");
static_assert(sizeof(UBrickComponentType_Internal_WheelEngine) == 0x0001E0, "Wrong size on UBrickComponentType_Internal_WheelEngine");
static_assert(offsetof(UBrickComponentType_Internal_WheelEngine, DefaultWheelEngineAudioDescriptor) == 0x0001D8, "Member 'UBrickComponentType_Internal_WheelEngine::DefaultWheelEngineAudioDescriptor' has a wrong offset!");

// Class Brickadia.BrickComponentType_ItemSpawn
// 0x0008 (0x01E0 - 0x01D8)
class UBrickComponentType_ItemSpawn final : public UBrickComponentTypeBase
{
public:
	TSubclassOf<class ABRPickupBase>              DefaultPickup;                                     // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_ItemSpawn">();
	}
	static class UBrickComponentType_ItemSpawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_ItemSpawn>();
	}
};
static_assert(alignof(UBrickComponentType_ItemSpawn) == 0x000008, "Wrong alignment on UBrickComponentType_ItemSpawn");
static_assert(sizeof(UBrickComponentType_ItemSpawn) == 0x0001E0, "Wrong size on UBrickComponentType_ItemSpawn");
static_assert(offsetof(UBrickComponentType_ItemSpawn, DefaultPickup) == 0x0001D8, "Member 'UBrickComponentType_ItemSpawn::DefaultPickup' has a wrong offset!");

// Class Brickadia.BrickOneShotAudioDescriptor
// 0x0068 (0x0098 - 0x0030)
class UBrickOneShotAudioDescriptor final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRCatalogData                         CatalogData;                                       // 0x0038(0x0048)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             WidgetIconOverride;                                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoudnessWarning;                              // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickOneShotAudioDescriptor">();
	}
	static class UBrickOneShotAudioDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickOneShotAudioDescriptor>();
	}
};
static_assert(alignof(UBrickOneShotAudioDescriptor) == 0x000008, "Wrong alignment on UBrickOneShotAudioDescriptor");
static_assert(sizeof(UBrickOneShotAudioDescriptor) == 0x000098, "Wrong size on UBrickOneShotAudioDescriptor");
static_assert(offsetof(UBrickOneShotAudioDescriptor, CatalogData) == 0x000038, "Member 'UBrickOneShotAudioDescriptor::CatalogData' has a wrong offset!");
static_assert(offsetof(UBrickOneShotAudioDescriptor, WidgetIconOverride) == 0x000080, "Member 'UBrickOneShotAudioDescriptor::WidgetIconOverride' has a wrong offset!");
static_assert(offsetof(UBrickOneShotAudioDescriptor, bShowLoudnessWarning) == 0x000088, "Member 'UBrickOneShotAudioDescriptor::bShowLoudnessWarning' has a wrong offset!");
static_assert(offsetof(UBrickOneShotAudioDescriptor, Sound) == 0x000090, "Member 'UBrickOneShotAudioDescriptor::Sound' has a wrong offset!");

// Class Brickadia.BRParticleSystemDescriptor
// 0x0028 (0x0058 - 0x0030)
class UBRParticleSystemDescriptor final : public UPrimaryDataAsset
{
public:
	class UNiagaraSystem*                         ParticleSystem;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   CategoryName;                                      // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRParticleSystemDescriptor">();
	}
	static class UBRParticleSystemDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRParticleSystemDescriptor>();
	}
};
static_assert(alignof(UBRParticleSystemDescriptor) == 0x000008, "Wrong alignment on UBRParticleSystemDescriptor");
static_assert(sizeof(UBRParticleSystemDescriptor) == 0x000058, "Wrong size on UBRParticleSystemDescriptor");
static_assert(offsetof(UBRParticleSystemDescriptor, ParticleSystem) == 0x000030, "Member 'UBRParticleSystemDescriptor::ParticleSystem' has a wrong offset!");
static_assert(offsetof(UBRParticleSystemDescriptor, DisplayName) == 0x000038, "Member 'UBRParticleSystemDescriptor::DisplayName' has a wrong offset!");
static_assert(offsetof(UBRParticleSystemDescriptor, CategoryName) == 0x000048, "Member 'UBRParticleSystemDescriptor::CategoryName' has a wrong offset!");

// Class Brickadia.BrickComponentType_SpawnPoint
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_SpawnPoint final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_SpawnPoint">();
	}
	static class UBrickComponentType_SpawnPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_SpawnPoint>();
	}
};
static_assert(alignof(UBrickComponentType_SpawnPoint) == 0x000008, "Wrong alignment on UBrickComponentType_SpawnPoint");
static_assert(sizeof(UBrickComponentType_SpawnPoint) == 0x0001D8, "Wrong size on UBrickComponentType_SpawnPoint");

// Class Brickadia.BrickComponentType_Target
// 0x0000 (0x01D8 - 0x01D8)
class UBrickComponentType_Target final : public UBrickComponentTypeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickComponentType_Target">();
	}
	static class UBrickComponentType_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickComponentType_Target>();
	}
};
static_assert(alignof(UBrickComponentType_Target) == 0x000008, "Wrong alignment on UBrickComponentType_Target");
static_assert(sizeof(UBrickComponentType_Target) == 0x0001D8, "Wrong size on UBrickComponentType_Target");

// Class Brickadia.ProceduralBrickDebugComponent
// 0x0020 (0x05C0 - 0x05A0)
class UProceduralBrickDebugComponent final : public UBrickDebugComponent
{
public:
	struct FIntVector                             PreviewSize;                                       // 0x05A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreviewSizeValid;                                 // 0x05AC(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5AD[0x3];                                      // 0x05AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UProceduralBrick*                       PreviewBrick;                                      // 0x05B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B8[0x8];                                      // 0x05B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetCache();
	void SetBrick(class UProceduralBrick* NewBrick);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProceduralBrickDebugComponent">();
	}
	static class UProceduralBrickDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProceduralBrickDebugComponent>();
	}
};
static_assert(alignof(UProceduralBrickDebugComponent) == 0x000010, "Wrong alignment on UProceduralBrickDebugComponent");
static_assert(sizeof(UProceduralBrickDebugComponent) == 0x0005C0, "Wrong size on UProceduralBrickDebugComponent");
static_assert(offsetof(UProceduralBrickDebugComponent, PreviewSize) == 0x0005A0, "Member 'UProceduralBrickDebugComponent::PreviewSize' has a wrong offset!");
static_assert(offsetof(UProceduralBrickDebugComponent, bPreviewSizeValid) == 0x0005AC, "Member 'UProceduralBrickDebugComponent::bPreviewSizeValid' has a wrong offset!");
static_assert(offsetof(UProceduralBrickDebugComponent, PreviewBrick) == 0x0005B0, "Member 'UProceduralBrickDebugComponent::PreviewBrick' has a wrong offset!");

// Class Brickadia.BrickBuildingTemplate
// 0x0080 (0x00A8 - 0x0028)
class UBrickBuildingTemplate final : public UObject
{
public:
	TArray<struct FBrickInstanceTemplate>         InstanceTemplates;                                 // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBrickComponentTemplate>        ComponentTemplates;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FBrickComponentInternalWireTemplate> InternalWireTemplates;                             // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FIntVector                             MinPosition;                                       // 0x0058(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             MaxPosition;                                       // 0x0064(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             MinBounds;                                         // 0x0070(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             MaxBounds;                                         // 0x007C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Center;                                            // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             Extent;                                            // 0x0094(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBREntityPersistentHandle              OriginalGridHandle;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickBuildingTemplate">();
	}
	static class UBrickBuildingTemplate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickBuildingTemplate>();
	}
};
static_assert(alignof(UBrickBuildingTemplate) == 0x000008, "Wrong alignment on UBrickBuildingTemplate");
static_assert(sizeof(UBrickBuildingTemplate) == 0x0000A8, "Wrong size on UBrickBuildingTemplate");
static_assert(offsetof(UBrickBuildingTemplate, InstanceTemplates) == 0x000028, "Member 'UBrickBuildingTemplate::InstanceTemplates' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, ComponentTemplates) == 0x000038, "Member 'UBrickBuildingTemplate::ComponentTemplates' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, InternalWireTemplates) == 0x000048, "Member 'UBrickBuildingTemplate::InternalWireTemplates' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, MinPosition) == 0x000058, "Member 'UBrickBuildingTemplate::MinPosition' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, MaxPosition) == 0x000064, "Member 'UBrickBuildingTemplate::MaxPosition' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, MinBounds) == 0x000070, "Member 'UBrickBuildingTemplate::MinBounds' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, MaxBounds) == 0x00007C, "Member 'UBrickBuildingTemplate::MaxBounds' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, Center) == 0x000088, "Member 'UBrickBuildingTemplate::Center' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, Extent) == 0x000094, "Member 'UBrickBuildingTemplate::Extent' has a wrong offset!");
static_assert(offsetof(UBrickBuildingTemplate, OriginalGridHandle) == 0x0000A0, "Member 'UBrickBuildingTemplate::OriginalGridHandle' has a wrong offset!");

// Class Brickadia.BrickDuplicatorLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrickDuplicatorLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UBrickSelection* CaptureSelectionFromBox(class UBrickGridComponent* BrickGrid, const struct FIntBox& Box, int32 MaxBricks, bool* bOutOverflow, bool bRequireTrust, class ABRPlayerController* ControllerForTrustCheck, int32* OutNumTrustFails);
	static class UBrickSelection* CaptureSelectionFromGrid(class UBrickGridComponent* BrickGrid);
	static class UBrickBuildingTemplate* CaptureTemplateFromBox(class UBrickGridComponent* BrickGrid, const struct FIntBox& Box, int32 MaxBricks, bool* bOutOverflow, bool bRequireTrust, class ABRPlayerController* ControllerForTrustCheck, int32* OutNumTrustFails);
	static class UBrickBuildingTemplate* CreateTemplateFromSelection(class UObject* WorldContextObject, class UBrickSelection* Selection, bool bIgnoreWires);
	static struct FBrickTemplatePlacementInfo GetTemplatePlacementInfo(class UBrickRegistry* Registry, class UBrickBuildingTemplate* Template);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickDuplicatorLibrary">();
	}
	static class UBrickDuplicatorLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickDuplicatorLibrary>();
	}
};
static_assert(alignof(UBrickDuplicatorLibrary) == 0x000008, "Wrong alignment on UBrickDuplicatorLibrary");
static_assert(sizeof(UBrickDuplicatorLibrary) == 0x000028, "Wrong size on UBrickDuplicatorLibrary");

// Class Brickadia.BRTickableEngineSubsystem
// 0x0010 (0x0040 - 0x0030)
class UBRTickableEngineSubsystem : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTickableEngineSubsystem">();
	}
	static class UBRTickableEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTickableEngineSubsystem>();
	}
};
static_assert(alignof(UBRTickableEngineSubsystem) == 0x000008, "Wrong alignment on UBRTickableEngineSubsystem");
static_assert(sizeof(UBRTickableEngineSubsystem) == 0x000040, "Wrong size on UBRTickableEngineSubsystem");

// Class Brickadia.BrickEngineSubsystem
// 0x0010 (0x0050 - 0x0040)
class UBrickEngineSubsystem final : public UBRTickableEngineSubsystem
{
public:
	TArray<class UBrickType*>                     UsedBrickTypes;                                    // 0x0040(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickEngineSubsystem">();
	}
	static class UBrickEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickEngineSubsystem>();
	}
};
static_assert(alignof(UBrickEngineSubsystem) == 0x000008, "Wrong alignment on UBrickEngineSubsystem");
static_assert(sizeof(UBrickEngineSubsystem) == 0x000050, "Wrong size on UBrickEngineSubsystem");
static_assert(offsetof(UBrickEngineSubsystem, UsedBrickTypes) == 0x000040, "Member 'UBrickEngineSubsystem::UsedBrickTypes' has a wrong offset!");

// Class Brickadia.BRServerSettingsManagerComponent
// 0x0050 (0x00F8 - 0x00A8)
class UBRServerSettingsManagerComponent final : public UActorComponent
{
public:
	TMap<TSubclassOf<class UBRServerSettingsBase>, TSubclassOf<class UInspectorPropertyDescriptorList>> SettingsDescriptorLists;                           // 0x00A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	void ServerAddColorPalette(const struct FBRColorPaletteData& Data);
	void ServerChangeMap(class UBRMapInfo* NewMap);
	void ServerChangeRoleName(const class FString& RoleId, const class FString& Name_0, bool bAnnounce);
	void ServerChangeRoleSettings(const class FString& RoleId, const struct FInspectorPropertyChangelist& Changelist, bool bAnnounce);
	void ServerChangeSettings(TSubclassOf<class UBRServerSettingsBase> ServerSettingsClass, const struct FInspectorPropertyChangelist& Changelist, bool bAnnounce);
	void ServerCreateRole(const class FString& RoleId, const class FString& CreateAfterRoleId, const struct FInspectorPropertyChangelist& Changelist, bool bAnnounce);
	void ServerDeleteRole(const class FString& RoleId, bool bAnnounce);
	void ServerMigrateColorsInPalette(const struct FBRColorPaletteData& OldPalette, const struct FBRColorPaletteData& NewPalette, EBRColorMigrationMode Mode);
	void ServerRemoveColorPalette(int32 Index_0);
	void ServerReorderRoles(const class FString& RoleToMove, const class FString& RoleToMoveAfter);
	void ServerSetColorPalette(const struct FBRColorPaletteData& Data, int32 Index_0);
	void ServerSetHasRole(class ABRPlayerState* PlayerState, const class FString& Role, bool bHas);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettingsManagerComponent">();
	}
	static class UBRServerSettingsManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerSettingsManagerComponent>();
	}
};
static_assert(alignof(UBRServerSettingsManagerComponent) == 0x000008, "Wrong alignment on UBRServerSettingsManagerComponent");
static_assert(sizeof(UBRServerSettingsManagerComponent) == 0x0000F8, "Wrong size on UBRServerSettingsManagerComponent");
static_assert(offsetof(UBRServerSettingsManagerComponent, SettingsDescriptorLists) == 0x0000A8, "Member 'UBRServerSettingsManagerComponent::SettingsDescriptorLists' has a wrong offset!");

// Class Brickadia.BrickGridActor
// 0x0010 (0x02C0 - 0x02B0)
class ABrickGridActor : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickGridComponent*                    BrickGridComponent;                                // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBrickGridComponent* GetBrickGrid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridActor">();
	}
	static class ABrickGridActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGridActor>();
	}
};
static_assert(alignof(ABrickGridActor) == 0x000008, "Wrong alignment on ABrickGridActor");
static_assert(sizeof(ABrickGridActor) == 0x0002C0, "Wrong size on ABrickGridActor");
static_assert(offsetof(ABrickGridActor, BrickGridComponent) == 0x0002B8, "Member 'ABrickGridActor::BrickGridComponent' has a wrong offset!");

// Class Brickadia.BRWeaponResource
// 0x0038 (0x0068 - 0x0030)
class UBRWeaponResource final : public UPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bPlayerHas;                                        // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerMin;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerMax;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerStarting;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PlayerPickupSound;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRWeaponResourceUsageOverride                ResourceUsageOverride;                             // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             HudIcon;                                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponResource">();
	}
	static class UBRWeaponResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponResource>();
	}
};
static_assert(alignof(UBRWeaponResource) == 0x000008, "Wrong alignment on UBRWeaponResource");
static_assert(sizeof(UBRWeaponResource) == 0x000068, "Wrong size on UBRWeaponResource");
static_assert(offsetof(UBRWeaponResource, DisplayName) == 0x000030, "Member 'UBRWeaponResource::DisplayName' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, bPlayerHas) == 0x000040, "Member 'UBRWeaponResource::bPlayerHas' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, PlayerMin) == 0x000044, "Member 'UBRWeaponResource::PlayerMin' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, PlayerMax) == 0x000048, "Member 'UBRWeaponResource::PlayerMax' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, PlayerStarting) == 0x00004C, "Member 'UBRWeaponResource::PlayerStarting' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, PlayerPickupSound) == 0x000050, "Member 'UBRWeaponResource::PlayerPickupSound' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, ResourceUsageOverride) == 0x000058, "Member 'UBRWeaponResource::ResourceUsageOverride' has a wrong offset!");
static_assert(offsetof(UBRWeaponResource, HudIcon) == 0x000060, "Member 'UBRWeaponResource::HudIcon' has a wrong offset!");

// Class Brickadia.GlobalBrickGridActor
// 0x0000 (0x02C0 - 0x02C0)
class AGlobalBrickGridActor final : public ABrickGridActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalBrickGridActor">();
	}
	static class AGlobalBrickGridActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGlobalBrickGridActor>();
	}
};
static_assert(alignof(AGlobalBrickGridActor) == 0x000008, "Wrong alignment on AGlobalBrickGridActor");
static_assert(sizeof(AGlobalBrickGridActor) == 0x0002C0, "Wrong size on AGlobalBrickGridActor");

// Class Brickadia.BrickGridComponent
// 0x0390 (0x0860 - 0x04D0)
class UBrickGridComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_4C8[0x338];                                    // 0x04C8(0x0338)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0800(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_808[0x44];                                     // 0x0808(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        NetworkId;                                         // 0x084C(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_850[0x10];                                     // 0x0850(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool ContainsPoint(const struct FIntVector& Point);

	int32 BulkInsertOrDeleteBricks(const TArray<struct FBrickHandle>& BrickHandles, EBrickInsertFlags Flags_0);
	void BulkRemoveAndDeleteBricks(const TArray<struct FBrickHandle>& BrickHandles);
	int32 ClearAndDeleteBricks();
	int32 ClearAndDeleteBricksByUser(const struct FBRGuid& UserId);
	void CollectAllBricks(TArray<struct FBrickHandle>* OutBrickHandles);
	void CollectAllBricksForOwner(TArray<struct FBrickHandle>* OutBrickHandles, const struct FBRGuid& Owner);
	void CollectAllBricksForOwnerInRegion(TArray<struct FBrickHandle>* OutBrickHandles, const struct FBRGuid& Owner, const struct FIntBox& Range);
	void GetBrickAndComponentCount(int32* OutBricks, int32* OutComponents);
	int32 GetBrickCount();
	bool InsertOrDeleteBrick(const struct FBrickHandle& BrickHandle, EBrickInsertFlags Flags_0);
	void PrintChunkReport();
	void PropagateCustomDepthSettings();
	bool RemoveAndDeleteBrick(const struct FBrickHandle& BrickHandle);
	bool SetChunkOffset(const struct FIntVector& Offset);
	bool SetChunkSize(int32 Size);
	void SetInstancing(const struct FIntVector& Offset, const struct FIntVector& Counts);

	void BrickBoxSearchMulti(TArray<struct FBrickHandle>* Results, const struct FIntBox& Range, bool bRequireContains, int32 MaxResults) const;
	struct FBrickHandle BrickBoxSearchSingle(const struct FIntBox& Range, bool bRequireContains) const;
	bool CanInsertBrick(const struct FBrickHandle& BrickHandle, EBrickInsertFlags Flags_0) const;
	bool CanInsertBrickType(const class UBrickType* Type, const struct FIntVector& position, EBrickOrientation Orientation, EBrickInsertFlags Flags_0, const TArray<struct FBrickHandle>& IgnoredBricks) const;
	const struct FIntVector GetChunkOffset() const;
	int32 GetChunkSize() const;
	void GetInstancing(struct FIntVector* OutOffset, struct FIntVector* OutCounts) const;
	struct FIntVector GetRowInstancingOffset() const;
	bool IsModificationAllowed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridComponent">();
	}
	static class UBrickGridComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickGridComponent>();
	}
};
static_assert(alignof(UBrickGridComponent) == 0x000010, "Wrong alignment on UBrickGridComponent");
static_assert(sizeof(UBrickGridComponent) == 0x000860, "Wrong size on UBrickGridComponent");
static_assert(offsetof(UBrickGridComponent, BodySetup) == 0x000800, "Member 'UBrickGridComponent::BodySetup' has a wrong offset!");
static_assert(offsetof(UBrickGridComponent, NetworkId) == 0x00084C, "Member 'UBrickGridComponent::NetworkId' has a wrong offset!");

// Class Brickadia.BrickGridDynamicActor
// 0x0018 (0x02D8 - 0x02C0)
class ABrickGridDynamicActor final : public ABrickGridActor
{
public:
	int32                                         OwnerId;                                           // 0x02C0(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x14];                                     // 0x02C4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridDynamicActor">();
	}
	static class ABrickGridDynamicActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGridDynamicActor>();
	}
};
static_assert(alignof(ABrickGridDynamicActor) == 0x000008, "Wrong alignment on ABrickGridDynamicActor");
static_assert(sizeof(ABrickGridDynamicActor) == 0x0002D8, "Wrong size on ABrickGridDynamicActor");
static_assert(offsetof(ABrickGridDynamicActor, OwnerId) == 0x0002C0, "Member 'ABrickGridDynamicActor::OwnerId' has a wrong offset!");

// Class Brickadia.BRTool_Placer
// 0x0340 (0x0940 - 0x0600)
class ABRTool_Placer final : public ABRColorPaletteToolBase
{
public:
	uint8                                         Pad_600[0x1C];                                     // 0x0600(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRPlacerPreviewInfo                   DesiredPreview;                                    // 0x061C(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_630[0x10];                                     // 0x0630(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRPlacementContext                    CurrentPlacementContext;                           // 0x0640(0x0080)(Transient, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UTransformProxy*                        CurrentBrickGridTransformProxy;                    // 0x06C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBRPlacerPlaceable                     CurrentPlaceable;                                  // 0x06C8(0x0090)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_758[0x64];                                     // 0x0758(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultControlModeName;                            // 0x07BC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachedControlModeName;                           // 0x07C4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultPlacementModeName;                          // 0x07CC(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultAlignmentModeName;                          // 0x07D4(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7DC[0x4];                                      // 0x07DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UBRPlacerControlModeBase*> ControlModes;                                      // 0x07E0(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   CurrentControlModeName;                            // 0x0830(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UBRPlacerPlacementModeBase*> PlacementModes;                                    // 0x0838(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   CurrentPlacementModeName;                          // 0x0888(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UBRPlacerAlignmentModeBase*> AlignmentModes;                                    // 0x0890(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   CurrentAlignmentModeName;                          // 0x08E0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E8[0x30];                                     // 0x08E8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SuperAlignmentModeName;                            // 0x0918(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_920[0x20];                                     // 0x0920(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Audio_AlignmentMode_Change(class UBRPlacerAlignmentModeBase* NewAlignmentMode);
	void Audio_ControlMode_Change(class UBRPlacerControlModeBase* NewControlMode);
	void Audio_KeyboardMode_MoveBrick(const struct FVector& OldLocation, const struct FVector& NewLocation, bool bIsRepeating);
	void Audio_KeyboardMode_StateChange(EBRPlacerKeyboardModeState OldState, EBRPlacerKeyboardModeState NewState);
	void Audio_Mouse_Float_ChangeDistance(int32 NewDistance);
	void Audio_Mouse_Float_Start(int32 StartingDistance);
	void Audio_Mouse_Float_Stop();
	void Audio_Mouse_Locking_ChangeDistance(int32 NewDistance);
	void Audio_Mouse_Locking_Start(int32 StartingDistance);
	void Audio_Mouse_Locking_Stop();
	void Audio_Mouse_StateChange(EBRPlacerMouseModeState OldState, EBRPlacerMouseModeState NewState);
	void Audio_PlacementMode_Change(class UBRPlacerPlacementModeBase* NewPlacementMode);
	void Audio_Placing_ChangePlacementSize(const struct FIntVector& NewPlacementSize, EBrickAxis ChangedAxis);
	void Audio_Placing_ChangePlacementSpacing(const struct FIntVector& NewPlacementSpacing, EBrickAxis ChangedSpacingAxis);
	void Audio_Placing_Commit(const struct FVector& PlacementStartBrickPos, const struct FVector& PlacementEndBrickPos, const struct FIntVector& PlacementBounds);
	void Audio_Placing_Start(const struct FVector& Location);
	void Audio_ReorientBrick(const struct FVector& Location, EBrickDirection OldDirection, EBrickDirection NewDirection);
	void Audio_RotateBrick(const struct FVector& Location, EBrickOrientation OldOrientation, EBrickAxis AboutAxis, bool bIsRepeating);
	void OnCurrentBrickGridDestroyed(class AActor* DestroyedActor);
	void ServerPlaceAsPhysics();
	void ServerPlaceCurrentTemplateVolume(const struct FBRPlacementContext& Context, const struct FIntVector& position, const struct FVector& JointStartPosition, EBrickOrientation Orientation, const struct FIntVector& InstanceSize, const struct FIntVector& InstanceSpacing, const struct FIntVector& VolumeSize, const struct FIntVector& VolumeSigns, bool bWithPhysics);
	void ServerPlaceSimpleBrickVolume(const struct FBRPlacementContext& Context, const struct FBrickTypeNetWrapper& BrickType, const struct FColor& ColorAndAlpha, int32 MaterialIndex, const struct FIntVector& position, const struct FVector& JointStartPosition, EBrickOrientation Orientation, const struct FIntVector& InstanceSize, const struct FIntVector& InstanceSpacing, const struct FIntVector& VolumeSize, const struct FIntVector& VolumeSigns);
	void ServerPlaceSimpleEntityVolume(const struct FBRPlacementContext& Context, class UBREntityTypeBase* EntityType, const struct FColor& ColorAndAlpha, const struct FIntVector& position, const struct FVector& JointStartPosition, EBrickOrientation Orientation, const struct FIntVector& InstanceSize, const struct FIntVector& InstanceSpacing, const struct FIntVector& VolumeSize, const struct FIntVector& VolumeSigns);
	void SwitchAlignmentMode(class FName NewAlignmentMode);
	void SwitchAlignmentMode_Default();
	void SwitchControlMode(class FName NewControlMode);
	void SwitchControlMode_Default();
	void SwitchPlacementMode(class FName NewPlacementMode);
	void SwitchPlacementMode_Default();
	void Visuals_ChangeScreen(TSubclassOf<class UThumbnailProcessor> ThumbnailProcessor, class UObject* ThumbnailObject);

	const TMap<class FName, class UBRPlacerAlignmentModeBase*> GetAlignmentModes_BP() const;
	const TMap<class FName, class UBRPlacerControlModeBase*> GetControlModes_BP() const;
	class UBRPlacerAlignmentModeBase* GetCurrentAlignmentMode() const;
	class UBRPlacerControlModeBase* GetCurrentControlMode() const;
	struct FBrickPlacementPivots GetCurrentPivots() const;
	class UBRPlacerPlacementModeBase* GetCurrentPlacementMode() const;
	struct FVector GetPlacementAudioLocation() const;
	const TMap<class FName, class UBRPlacerPlacementModeBase*> GetPlacementModes_BP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Placer">();
	}
	static class ABRTool_Placer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Placer>();
	}
};
static_assert(alignof(ABRTool_Placer) == 0x000010, "Wrong alignment on ABRTool_Placer");
static_assert(sizeof(ABRTool_Placer) == 0x000940, "Wrong size on ABRTool_Placer");
static_assert(offsetof(ABRTool_Placer, DesiredPreview) == 0x00061C, "Member 'ABRTool_Placer::DesiredPreview' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, CurrentPlacementContext) == 0x000640, "Member 'ABRTool_Placer::CurrentPlacementContext' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, CurrentBrickGridTransformProxy) == 0x0006C0, "Member 'ABRTool_Placer::CurrentBrickGridTransformProxy' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, CurrentPlaceable) == 0x0006C8, "Member 'ABRTool_Placer::CurrentPlaceable' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, DefaultControlModeName) == 0x0007BC, "Member 'ABRTool_Placer::DefaultControlModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, DetachedControlModeName) == 0x0007C4, "Member 'ABRTool_Placer::DetachedControlModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, DefaultPlacementModeName) == 0x0007CC, "Member 'ABRTool_Placer::DefaultPlacementModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, DefaultAlignmentModeName) == 0x0007D4, "Member 'ABRTool_Placer::DefaultAlignmentModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, ControlModes) == 0x0007E0, "Member 'ABRTool_Placer::ControlModes' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, CurrentControlModeName) == 0x000830, "Member 'ABRTool_Placer::CurrentControlModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, PlacementModes) == 0x000838, "Member 'ABRTool_Placer::PlacementModes' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, CurrentPlacementModeName) == 0x000888, "Member 'ABRTool_Placer::CurrentPlacementModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, AlignmentModes) == 0x000890, "Member 'ABRTool_Placer::AlignmentModes' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, CurrentAlignmentModeName) == 0x0008E0, "Member 'ABRTool_Placer::CurrentAlignmentModeName' has a wrong offset!");
static_assert(offsetof(ABRTool_Placer, SuperAlignmentModeName) == 0x000918, "Member 'ABRTool_Placer::SuperAlignmentModeName' has a wrong offset!");

// Class Brickadia.BrickInstanceStatics
// 0x0000 (0x0028 - 0x0028)
class UBrickInstanceStatics final : public UBlueprintFunctionLibrary
{
public:
	static uint8 CompressMaterialAlpha(uint8 MaterialAlpha);
	static uint8 DecompressMaterialAlpha(uint8 MaterialAlphaCompressed);
	static bool EqualEqual_BrickHandle(const struct FBrickHandle& A, const struct FBrickHandle& B);
	static bool EqualEqual_BrickPersistentHandle(const struct FBrickPersistentHandle& A, const struct FBrickPersistentHandle& B);
	static class ABRPlayerController* FindOwner(const class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle);
	static class UBasicBrick* GetBasicBrick(const struct FBrickHandle& BrickHandle);
	static class UBrickAsset* GetBrickAsset(const struct FBrickHandle& BrickHandle);
	static class UBrickGridComponent* GetBrickGrid(const struct FBrickHandle& BrickHandle);
	static struct FBrickOwnerData GetBrickOwnerData(const class UObject* WorldContextObject, const struct FBrickHandle& BrickHandle);
	static class UBrickType* GetBrickType(const struct FBrickHandle& BrickHandle);
	static bool GetCollisionChannel(const struct FBrickHandle& BrickHandle, EBrickCollisionChannels Channel);
	static EBrickCollisionChannels GetCollisionChannels(const struct FBrickHandle& BrickHandle);
	static struct FColor GetColor(const struct FBrickHandle& BrickHandle);
	static struct FColor GetColorAndAlpha(const struct FBrickHandle& BrickHandle);
	static EBrickDirection GetDirection(const struct FBrickHandle& BrickHandle);
	static struct FIntVector GetHalfSize(const struct FBrickHandle& BrickHandle);
	static struct FIntBox GetIntBox(const struct FBrickHandle& BrickHandle);
	static uint8 GetMaterialAlpha(const struct FBrickHandle& BrickHandle);
	static int32 GetMaterialIndex(const struct FBrickHandle& BrickHandle);
	static EBrickOrientation GetOrientation(const struct FBrickHandle& BrickHandle);
	static int32 GetOwnerId(const struct FBrickHandle& BrickHandle);
	static struct FIntVector GetPosition(const struct FBrickHandle& BrickHandle);
	static class UProceduralBrick* GetProceduralBrick(const struct FBrickHandle& BrickHandle);
	static struct FIntVector GetRotatedHalfSize(const struct FBrickHandle& BrickHandle);
	static EBrickRotation GetRotation(const struct FBrickHandle& BrickHandle);
	static bool GetSelectionLayer(const struct FBrickHandle& BrickHandle, EBrickSelectionLayers Layer);
	static EBrickSelectionLayers GetSelectionLayers(const struct FBrickHandle& BrickHandle);
	static struct FTransform GetSpawnTransformAboveBrick(const struct FBrickHandle& BrickHandle, float CharacterHalfHeight);
	static bool GetVisibility(const struct FBrickHandle& BrickHandle);
	static bool HasTrustToModifyBrick(const struct FBrickHandle& BrickHandle, const class ABRPlayerController* Controller);
	static bool IsHandleValid(const struct FBrickHandle& BrickHandle);
	static bool IsPersistentHandleValid(const struct FBrickPersistentHandle& BrickPersistentHandle);
	static EBrickCollisionChannels MergeCollisionChannels(bool bPlayer, bool bWeapon, bool bInteraction, bool bTool);
	static bool NotEqual_BrickHandle(const struct FBrickHandle& A, const struct FBrickHandle& B);
	static bool NotEqual_BrickPersistentHandle(const struct FBrickPersistentHandle& A, const struct FBrickPersistentHandle& B);
	static uint8 QuantizeMaterialAlpha(uint8 MaterialAlpha);
	static struct FBrickHandle ResolvePersistentHandle(const struct FBrickPersistentHandle& BrickPersistentHandle);
	static void ResolvePersistentHandleArray(const TArray<struct FBrickPersistentHandle>& BrickPersistentHandles, TArray<struct FBrickHandle>* OutHandles, bool bExcludeInvalid);
	static void SetBrickType(const struct FBrickHandle& BrickHandle, class UBrickType* NewBrickType, const class UObject* WorldContextObject);
	static void SetBrickTypeFromBasicBrick(const struct FBrickHandle& BrickHandle, class UBasicBrick* NewBasicBrick, const class UObject* WorldContextObject);
	static void SetBrickTypeFromProceduralBrick(const struct FBrickHandle& BrickHandle, class UProceduralBrick* NewProceduralBrick, const struct FIntVector& NewSize, const class UObject* WorldContextObject);
	static void SetCollisionChannel(const struct FBrickHandle& BrickHandle, EBrickCollisionChannels Channel, bool bValue, const class UObject* WorldContextObject);
	static void SetCollisionChannels(const struct FBrickHandle& BrickHandle, EBrickCollisionChannels NewCollisionChannels, const class UObject* WorldContextObject);
	static void SetColor(const struct FBrickHandle& BrickHandle, const struct FColor& NewColor, const class UObject* WorldContextObject);
	static void SetDirection(const struct FBrickHandle& BrickHandle, EBrickDirection NewDirection, const class UObject* WorldContextObject);
	static void SetMaterialAlpha(const struct FBrickHandle& BrickHandle, uint8 NewMaterialAlpha, const class UObject* WorldContextObject);
	static void SetMaterialIndex(const struct FBrickHandle& BrickHandle, int32 NewMaterialIndex, const class UObject* WorldContextObject);
	static void SetOrientation(const struct FBrickHandle& BrickHandle, EBrickOrientation NewOrientation, const class UObject* WorldContextObject);
	static void SetOwnerId(const struct FBrickHandle& BrickHandle, int32 NewId, const class UObject* WorldContextObject);
	static void SetPosition(const struct FBrickHandle& BrickHandle, const struct FIntVector& NewPosition, const class UObject* WorldContextObject);
	static void SetRotation(const struct FBrickHandle& BrickHandle, EBrickRotation NewRotation, const class UObject* WorldContextObject);
	static void SetSelectionLayer(const struct FBrickHandle& BrickHandle, EBrickSelectionLayers Layer, bool bValue, const class UObject* WorldContextObject);
	static void SetSelectionLayers(const struct FBrickHandle& BrickHandle, EBrickSelectionLayers NewSelectionLayers, const class UObject* WorldContextObject);
	static void SetVisibility(const struct FBrickHandle& BrickHandle, bool bNewVisibility, const class UObject* WorldContextObject);
	static void SplitCollisionChannels(EBrickCollisionChannels CollisionChannels, bool* bOutPlayer, bool* bOutWeapon, bool* bOutInteraction, bool* bOutTool);
	static struct FBrickPersistentHandle ToPersistentHandle(const struct FBrickHandle& BrickHandle);
	static void ToPersistentHandleArray(const TArray<struct FBrickHandle>& BrickHandles, TArray<struct FBrickPersistentHandle>* OutPersistentHandles, bool bExcludeInvalid);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickInstanceStatics">();
	}
	static class UBrickInstanceStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickInstanceStatics>();
	}
};
static_assert(alignof(UBrickInstanceStatics) == 0x000008, "Wrong alignment on UBrickInstanceStatics");
static_assert(sizeof(UBrickInstanceStatics) == 0x000028, "Wrong size on UBrickInstanceStatics");

// Class Brickadia.BrickGlobalGridMapRules
// 0x0008 (0x02B8 - 0x02B0)
class ABrickGlobalGridMapRules : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGlobalGridMapRules">();
	}
	static class ABrickGlobalGridMapRules* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGlobalGridMapRules>();
	}
};
static_assert(alignof(ABrickGlobalGridMapRules) == 0x000008, "Wrong alignment on ABrickGlobalGridMapRules");
static_assert(sizeof(ABrickGlobalGridMapRules) == 0x0002B8, "Wrong size on ABrickGlobalGridMapRules");

// Class Brickadia.BrickGlobalGridMapRules_ZFloor
// 0x0000 (0x02B8 - 0x02B8)
class ABrickGlobalGridMapRules_ZFloor final : public ABrickGlobalGridMapRules
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGlobalGridMapRules_ZFloor">();
	}
	static class ABrickGlobalGridMapRules_ZFloor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGlobalGridMapRules_ZFloor>();
	}
};
static_assert(alignof(ABrickGlobalGridMapRules_ZFloor) == 0x000008, "Wrong alignment on ABrickGlobalGridMapRules_ZFloor");
static_assert(sizeof(ABrickGlobalGridMapRules_ZFloor) == 0x0002B8, "Wrong size on ABrickGlobalGridMapRules_ZFloor");

// Class Brickadia.BrickMaterialCollection
// 0x0110 (0x0140 - 0x0030)
class UBrickMaterialCollection final : public UDataAsset
{
public:
	uint8                                         CoverageLayer;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOpaqueMaterial;                                   // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenMaterial;                                   // 0x0033(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SingleDrawMaterial;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LowDetailMaterial;                                 // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     BevelMaterialInstance;                             // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     StudMaterialInstance;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     BumpyMaterialInstance;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     InletBorderMaterialInstance;                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     InletCenterMaterialInstance;                       // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PaintToolIcon;                                     // 0x0070(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   PaintToolName;                                     // 0x0120(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bUsableForPainting;                                // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseMaterialAlpha;                                 // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0xE];                                      // 0x0132(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInterface* GetMaterial(EBrickTextureGroup Texture) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickMaterialCollection">();
	}
	static class UBrickMaterialCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickMaterialCollection>();
	}
};
static_assert(alignof(UBrickMaterialCollection) == 0x000010, "Wrong alignment on UBrickMaterialCollection");
static_assert(sizeof(UBrickMaterialCollection) == 0x000140, "Wrong size on UBrickMaterialCollection");
static_assert(offsetof(UBrickMaterialCollection, CoverageLayer) == 0x000030, "Member 'UBrickMaterialCollection::CoverageLayer' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, bOpaqueMaterial) == 0x000031, "Member 'UBrickMaterialCollection::bOpaqueMaterial' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, bCastShadow) == 0x000032, "Member 'UBrickMaterialCollection::bCastShadow' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, bHiddenMaterial) == 0x000033, "Member 'UBrickMaterialCollection::bHiddenMaterial' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, SingleDrawMaterial) == 0x000038, "Member 'UBrickMaterialCollection::SingleDrawMaterial' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, LowDetailMaterial) == 0x000040, "Member 'UBrickMaterialCollection::LowDetailMaterial' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, BevelMaterialInstance) == 0x000048, "Member 'UBrickMaterialCollection::BevelMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, StudMaterialInstance) == 0x000050, "Member 'UBrickMaterialCollection::StudMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, BumpyMaterialInstance) == 0x000058, "Member 'UBrickMaterialCollection::BumpyMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, InletBorderMaterialInstance) == 0x000060, "Member 'UBrickMaterialCollection::InletBorderMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, InletCenterMaterialInstance) == 0x000068, "Member 'UBrickMaterialCollection::InletCenterMaterialInstance' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, PaintToolIcon) == 0x000070, "Member 'UBrickMaterialCollection::PaintToolIcon' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, PaintToolName) == 0x000120, "Member 'UBrickMaterialCollection::PaintToolName' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, bUsableForPainting) == 0x000130, "Member 'UBrickMaterialCollection::bUsableForPainting' has a wrong offset!");
static_assert(offsetof(UBrickMaterialCollection, bUseMaterialAlpha) == 0x000131, "Member 'UBrickMaterialCollection::bUseMaterialAlpha' has a wrong offset!");

// Class Brickadia.BRToolPreviewPartBase
// 0x00C8 (0x00F0 - 0x0028)
#pragma pack(push, 0x1)
class alignas(0x10) UBRToolPreviewPartBase : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRToolPreviewActor*                    PreviewActor;                                      // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38[0x1];                                       // 0x0038(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUnrealEngineIsRuiningVideoGames;                  // 0x0039(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRToolPreviewPartTransformParameters  TransformParameters;                               // 0x0040(0x0060)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FBRToolPreviewPartDisplayParameters    DisplayParameters;                                 // 0x00A0(0x0048)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyDisplayParameters();
	void ApplyTransformParameters();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolPreviewPartBase">();
	}
	static class UBRToolPreviewPartBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolPreviewPartBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(UBRToolPreviewPartBase) == 0x000010, "Wrong alignment on UBRToolPreviewPartBase");
static_assert(sizeof(UBRToolPreviewPartBase) == 0x0000F0, "Wrong size on UBRToolPreviewPartBase");
static_assert(offsetof(UBRToolPreviewPartBase, PreviewActor) == 0x000030, "Member 'UBRToolPreviewPartBase::PreviewActor' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewPartBase, bUnrealEngineIsRuiningVideoGames) == 0x000039, "Member 'UBRToolPreviewPartBase::bUnrealEngineIsRuiningVideoGames' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewPartBase, TransformParameters) == 0x000040, "Member 'UBRToolPreviewPartBase::TransformParameters' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewPartBase, DisplayParameters) == 0x0000A0, "Member 'UBRToolPreviewPartBase::DisplayParameters' has a wrong offset!");

// Class Brickadia.BrickMathLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrickMathLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AlignGhostBrickToHitResult(class UBrickGridComponent* TargetGrid, class UBrickType* BrickType, const struct FHitResult& HitResult, EBrickRotation DesiredRotation, struct FIntVector* OutPosition, EBrickOrientation* OutOrientation);
	static bool CheckOrientation(EBrickOrientation Orientation);
	static struct FIntBox CombineIntBoxes(const struct FIntBox& BoxA, const struct FIntBox& BoxB);
	static struct FIntBox CombineIntBoxesWithLimit(const struct FIntBox& BoxA, const struct FIntBox& BoxB, const struct FIntVector& MaxExtent, bool* bOutLimitExceeded);
	static EBrickOrientation CombineOrientation(EBrickDirection Direction, EBrickRotation Rotation);
	static EBrickOrientation ComputeDesiredOrientation(const struct FBrickPlacementPivots& Pivots, EBrickDirection OtherStudDirection, EBrickAnchorType OtherStudType, EBrickRotation DesiredRotation);
	static void ComputeExpandedPivot(const struct FIntBox& Pivot, const struct FIntVector& HalfSize, EBrickDirection Direction, struct FIntBox* OutResult);
	static float ComputeGeneralResizeDraggingStartOffset(const struct FTransform& GridTransform, const struct FIntVector& CurrentCenter, const struct FIntVector& CurrentSize, const struct FVector& RayStart, const struct FVector& RayEnd, EBrickDirection HandleDirection, float HandleMargin);
	static struct FIntVector ComputeGridAlignment3D(const struct FIntVector& GridOrigin, const struct FIntVector& GridCellSize, const struct FIntVector& PivotExtent, const struct FVector& HitPosition, EBrickDirection AlignmentDirection);
	static struct FIntVector ComputeGridAlignmentOffset3D(const struct FIntVector& GridOrigin, const struct FIntVector& GridCellSize, const struct FIntVector& PivotExtent, const struct FVector& HitPosition, EBrickDirection AlignmentDirection);
	static struct FIntVector ComputeGridOriginBelowPivot(const struct FIntBox& Pivot, const struct FIntVector& position, const struct FIntVector& GridCellSize, EBrickOrientation PivotOrientation, EBrickDirection BottomDirection);
	static int32 ComputeGridSideAlignment1D(int32 GridCellSize, int32 PivotExtent, float HitCell);
	static int32 ComputeGridSideAlignmentOffset1D(int32 GridCellSize, int32 PivotExtent, float HitCell);
	static int32 ComputeGridTopAlignment1D(int32 GridCellSize, float HitCell, bool bAlignUp);
	static int32 ComputeGridTopAlignmentOffset1D(int32 GridCellSize, int32 PivotExtent, float HitCell, bool bAlignUp);
	static void ComputeOptimalGridFromHitResult(const class UObject* WorldContextObject, const struct FHitResult& HitResult, class UBrickGridComponent** OutBrickGrid, struct FIntVector* OutGridOrigin, struct FIntVector* OutGridCellSize, EBrickDirection* OutStudDirection, EBrickAnchorType* OutStudType, bool* bOutHitStuds);
	static void ComputeOptimalGridFromStudGroup(const struct FBrickStudGroup& Studs, const struct FIntVector& BrickPosition, EBrickOrientation BrickOrientation, struct FIntVector* OutGridOrigin, struct FIntVector* OutGridCellSize, EBrickDirection* OutStudDirection, EBrickAnchorType* OutStudType);
	static void ComputePivotForStudGroup(const struct FBrickStudGroup& Studs, struct FIntBox* OutPivot, EBrickDirection* OutDirection);
	static struct FBrickPlacementPivots ComputePivotsForBrickType(class UBrickType* BrickType);
	static struct FBrickPlacementPivots ComputePivotsForEntity(class AActor* ENTITY);
	static struct FBrickPlacementPivots ComputePivotsForEntityType(class UBREntityTypeBase* EntityType);
	static bool ComputeRowDragging(const struct FTransform& GridTransform, const struct FVector& GridRelativeRoot, const struct FVector& WorldRayStart, const struct FVector& WorldRayDirection, const struct FIntVector& OrientedPivotExtent, const struct FIntVector& OrientedSpacing, const struct FIntVector& OrientedDragCellExtent, bool bAllowXAxis, bool bAllowYAxis, bool bAllowZAxis, EBrickDirection* OutRowDirection, int32* OutRowLength);
	static bool ComputeRowDraggingV2(const class APlayerController* PlayerController, const struct FTransform& GridTransform, const struct FVector& GridRelativeRoot, const struct FVector& WorldRayStart, const struct FVector& WorldRayDirection, const struct FVector2D& ScreenPosition, const struct FIntVector& OrientedPivotExtent, const struct FIntVector& OrientedSpacing, const struct FIntVector& OrientedDragCellExtent, bool bAllowXAxis, bool bAllowYAxis, bool bAllowZAxis, EBrickDirection* OutRowDirection, int32* OutRowLength);
	static void ComputeRowEndPositions(const struct FIntVector& OriginPosition, const struct FIntVector& OrientedPivotExtent, const struct FIntVector& OrientedSpacing, const struct FIntVector& OrientedDragCellExtent, EBrickDirection RowDirection, int32 RowLength, struct FIntVector* OutRowStartPosition, struct FIntVector* OutRowEndPosition);
	static struct FIntVector FindOptimalPlacement(class UBrickGridComponent* TargetGrid, class UBrickType* BrickType, EBrickDirection Direction, EBrickRotation Rotation, const struct FVector& HitLocation, const struct FVector& HitNormal);
	static EBrickDirection FlipDirection(EBrickDirection Direction);
	static EBrickRotation FlipRotation(EBrickRotation Rotation);
	static struct FIntVector GetAxisIntVector(EBrickAxis Axis);
	static EBrickDirection GetAxisNegativeDirection(EBrickAxis Axis);
	static EBrickDirection GetAxisPositiveDirection(EBrickAxis Axis);
	static struct FVector GetAxisVector(EBrickAxis Axis);
	static EBrickAxis GetDirectionAxis(EBrickDirection Direction);
	static struct FIntVector GetDirectionIntVector(EBrickDirection Direction);
	static struct FQuat GetDirectionQuat(EBrickDirection Direction);
	static struct FRotator GetDirectionRotator(EBrickDirection Direction);
	static int32 GetDirectionSign(EBrickDirection Direction);
	static struct FVector GetDirectionVector(EBrickDirection Direction);
	static int32 GetIntVectorAxisValue(const struct FIntVector& Vector, EBrickDirection AxisDirection);
	static struct FVector GetLargestComponentNormal(const struct FVector& Vector);
	static struct FVector GetLargestComponentVector(const struct FVector& Vector);
	static EBrickDirection GetNearestDirection(const struct FVector& Vector);
	static EBrickDirection GetNearestDirectionIgnoringZ(const struct FVector& Vector);
	static struct FIntVector GetNearestDirectionIntVector(const struct FVector& Vector, bool bIgnoreZ);
	static struct FVector GetNearestDirectionVector(const struct FVector& Vector, bool bIgnoreZ);
	static EBrickRotation GetNearestRotation(const struct FVector2D& Vector2D);
	static float GetOptimalBoxViewDistance(float InFOVDegrees, const struct FBox& Box);
	static EBrickOrientation GetOrientationFromQuat(const struct FQuat& Quat);
	static EBrickOrientation GetOrientationFromRotator(const struct FRotator& Rotator);
	static struct FQuat GetOrientationQuat(EBrickOrientation Orientation);
	static struct FRotator GetOrientationRotator(EBrickOrientation Orientation);
	static struct FPlane GetPlaneFromIntVector(const struct FIntVector& Origin, EBrickDirection Direction);
	static float GetPointDistanceToBoxFrame(const struct FBox& Box, const struct FVector& Point);
	static EBrickAxis GetRemainingAxis(EBrickAxis AxisA, EBrickAxis AxisB);
	static struct FQuat GetRotationQuat(EBrickRotation Rotation);
	static struct FRotator GetRotationRotator(EBrickRotation Rotation);
	static struct FIntVector GetRowEndOffset(EBrickDirection RowDirection, int32 RowLength, int32 RowSpacing, const struct FIntVector& BrickSize, EBrickOrientation BrickOrientation);
	static struct FTransform GetWorldTransform(const struct FBrickHandle& BrickHandle);
	static bool HandleGeneralResizeDragging(const struct FTransform& GridTransform, const struct FIntVector& CurrentCenter, const struct FIntVector& CurrentSize, const struct FIntVector& MinSize, const struct FIntVector& MaxSize, const struct FIntVector& GridIncrements, const struct FVector& RayStart, const struct FVector& RayEnd, EBrickDirection HandleDirection, float HandleMargin, float StartOffset, struct FIntVector* OutNewCenter, struct FIntVector* OutNewSize);
	static EBrickOrientation InverseMultiplyOrientation(EBrickOrientation OrientationA, EBrickOrientation OrientationB);
	static EBrickOrientation InverseOrientation(EBrickOrientation Orientation);
	static EBrickOrientation MultiplyOrientation(EBrickOrientation OrientationA, EBrickOrientation OrientationB);
	static struct FIntVector ProjectIntVectorOntoAxis(const struct FIntVector& Vector, EBrickDirection AxisDirection);
	static struct FIntVector ProjectIntVectorOntoPlane(const struct FIntVector& Vector, const struct FIntVector& PointOnPlane, EBrickDirection PlaneNormalDirection);
	static struct FIntVector ProjectIntVectorOntoZeroPlane(const struct FIntVector& Vector, EBrickDirection PlaneNormalDirection);
	static EBrickDirection RotateDirection(EBrickDirection Direction, EBrickOrientation Orientation);
	static struct FIntBox RotateIntBox(const struct FIntBox& Box, EBrickOrientation Orientation);
	static struct FIntVector RotateIntVector(const struct FIntVector& Vector, EBrickOrientation Orientation);
	static struct FIntVector RotateSize(const struct FIntVector& Size, EBrickOrientation Orientation);
	static struct FVector3f RotateSize3f(const struct FVector3f& Size, EBrickOrientation Orientation);
	static struct FVector RotateVector(const struct FVector& Vector, EBrickOrientation Orientation);
	static struct FVector3f RotateVector3f(const struct FVector3f& Vector, EBrickOrientation Orientation);
	static struct FIntVector SetIntVectorAxisValue(const struct FIntVector& Vector, int32 Value, EBrickDirection AxisDirection);
	static void SplitOrientation(EBrickOrientation Orientation, EBrickDirection* OutDirection, EBrickRotation* OutRotation);
	static struct FIntBox TransformIntBox(const struct FIntBox& Box, const struct FIntVector& position, EBrickOrientation Orientation);
	static EBrickDirection UnrotateDirection(EBrickDirection Direction, EBrickOrientation Orientation);
	static struct FIntBox UnrotateIntBox(const struct FIntBox& Box, EBrickOrientation Orientation);
	static struct FIntVector UnrotateIntVector(const struct FIntVector& Vector, EBrickOrientation Orientation);
	static struct FIntVector UnrotateSize(const struct FIntVector& Size, EBrickOrientation Orientation);
	static struct FVector3f UnrotateSize3f(const struct FVector3f& Size, EBrickOrientation Orientation);
	static struct FVector UnrotateVector(const struct FVector& Vector, EBrickOrientation Orientation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickMathLibrary">();
	}
	static class UBrickMathLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickMathLibrary>();
	}
};
static_assert(alignof(UBrickMathLibrary) == 0x000008, "Wrong alignment on UBrickMathLibrary");
static_assert(sizeof(UBrickMathLibrary) == 0x000028, "Wrong size on UBrickMathLibrary");

// Class Brickadia.BRPlayerAvatarManagerComponent
// 0x0010 (0x00B8 - 0x00A8)
class UBRPlayerAvatarManagerComponent final : public UActorComponent
{
public:
	struct FBRPlayerAvatarCustomizationV3         CustomizedAvatar;                                  // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UBRPlayerPartDescriptor* FindPlayerPartDescriptor(const class FText& InCategory, const class FText& InDisplayName);
	static void FixupOldColorsToLinear(struct FBRPlayerAvatarCustomizationV2& Avatar);
	static struct FBRPlayerAvatarCustomizationV3 UpgradeCustomization(const struct FBRPlayerAvatarCustomizationV2& Old);

	void ServerUpdatePlayerAvatar(const struct FBRPlayerAvatarCustomizationV3& NewAvatar);
	void UpdatePlayerAvatar(const struct FBRPlayerAvatarCustomizationV3& NewAvatar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerAvatarManagerComponent">();
	}
	static class UBRPlayerAvatarManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlayerAvatarManagerComponent>();
	}
};
static_assert(alignof(UBRPlayerAvatarManagerComponent) == 0x000008, "Wrong alignment on UBRPlayerAvatarManagerComponent");
static_assert(sizeof(UBRPlayerAvatarManagerComponent) == 0x0000B8, "Wrong size on UBRPlayerAvatarManagerComponent");
static_assert(offsetof(UBRPlayerAvatarManagerComponent, CustomizedAvatar) == 0x0000A8, "Member 'UBRPlayerAvatarManagerComponent::CustomizedAvatar' has a wrong offset!");

// Class Brickadia.BrickHelpers
// 0x0000 (0x0028 - 0x0028)
class UBrickHelpers final : public UBlueprintFunctionLibrary
{
public:
	static struct FBrickHandle GetBrickFromHitResult(const struct FHitResult& HitResult);
	static class UBrickType* GetBrickTypeFromBrickAsset(class UBrickAsset* Brick, const struct FIntVector& ProceduralSize);
	static class UBrickGridComponent* GetGlobalBrickGrid(const class UObject* WorldContextObject);
	static class ABrickGridActor* GetGlobalBrickGridActor(const class UObject* WorldContextObject);
	static struct FBREntityPersistentHandle GetGlobalBrickGridEntityHandle(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickHelpers">();
	}
	static class UBrickHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickHelpers>();
	}
};
static_assert(alignof(UBrickHelpers) == 0x000008, "Wrong alignment on UBrickHelpers");
static_assert(sizeof(UBrickHelpers) == 0x000028, "Wrong size on UBrickHelpers");

// Class Brickadia.BrickGridMovablePreviewComponent
// 0x0000 (0x0860 - 0x0860)
class UBrickGridMovablePreviewComponent final : public UBrickGridComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridMovablePreviewComponent">();
	}
	static class UBrickGridMovablePreviewComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickGridMovablePreviewComponent>();
	}
};
static_assert(alignof(UBrickGridMovablePreviewComponent) == 0x000010, "Wrong alignment on UBrickGridMovablePreviewComponent");
static_assert(sizeof(UBrickGridMovablePreviewComponent) == 0x000860, "Wrong size on UBrickGridMovablePreviewComponent");

// Class Brickadia.BrickGridPreviewActor
// 0x0110 (0x03C0 - 0x02B0)
class alignas(0x10) ABrickGridPreviewActor final : public AActor
{
public:
	class UBrickGridMovablePreviewComponent*      SimpleBrickGridComponent;                          // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickGridMovablePreviewComponent*      ReplicatedBrickGridComponent;                      // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreviewVisible;                                   // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBrickPreviewMode                             PreviewMode;                                       // 0x02C1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C2[0x6];                                      // 0x02C2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickPreviewTransformParameters       TransformParameters;                               // 0x02C8(0x0018)(Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FBrickPreviewVolumeParameters          VolumeParameters;                                  // 0x02E0(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FBrickPreviewSimpleParameters          SimpleParameters;                                  // 0x0310(0x0030)(Net, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x80];                                     // 0x0340(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyPreviewMode();
	void ApplyPreviewSimpleParameters();
	void ApplyPreviewTransformParameters();
	void ApplyPreviewVisible();
	void ApplyPreviewVolumeParameters();

	class UBrickGridComponent* GetActiveBrickGrid() const;
	class UBrickGridComponent* GetFreeBrickGrid() const;
	class UBrickGridComponent* GetSimpleBrickGrid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridPreviewActor">();
	}
	static class ABrickGridPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGridPreviewActor>();
	}
};
static_assert(alignof(ABrickGridPreviewActor) == 0x000010, "Wrong alignment on ABrickGridPreviewActor");
static_assert(sizeof(ABrickGridPreviewActor) == 0x0003C0, "Wrong size on ABrickGridPreviewActor");
static_assert(offsetof(ABrickGridPreviewActor, SimpleBrickGridComponent) == 0x0002B0, "Member 'ABrickGridPreviewActor::SimpleBrickGridComponent' has a wrong offset!");
static_assert(offsetof(ABrickGridPreviewActor, ReplicatedBrickGridComponent) == 0x0002B8, "Member 'ABrickGridPreviewActor::ReplicatedBrickGridComponent' has a wrong offset!");
static_assert(offsetof(ABrickGridPreviewActor, bPreviewVisible) == 0x0002C0, "Member 'ABrickGridPreviewActor::bPreviewVisible' has a wrong offset!");
static_assert(offsetof(ABrickGridPreviewActor, PreviewMode) == 0x0002C1, "Member 'ABrickGridPreviewActor::PreviewMode' has a wrong offset!");
static_assert(offsetof(ABrickGridPreviewActor, TransformParameters) == 0x0002C8, "Member 'ABrickGridPreviewActor::TransformParameters' has a wrong offset!");
static_assert(offsetof(ABrickGridPreviewActor, VolumeParameters) == 0x0002E0, "Member 'ABrickGridPreviewActor::VolumeParameters' has a wrong offset!");
static_assert(offsetof(ABrickGridPreviewActor, SimpleParameters) == 0x000310, "Member 'ABrickGridPreviewActor::SimpleParameters' has a wrong offset!");

// Class Brickadia.BRWeaponProjectile
// 0x0150 (0x0400 - 0x02B0)
class ABRWeaponProjectile final : public AActor
{
public:
	class USphereComponent*                       CollisionComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWeaponProjectileMovementComponent*   MovementComponent;                                 // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   MeshComponent;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               ParticleComponent;                                 // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         BounceExplosion;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         ImpactExplosion;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         DirectHitExplosion;                                // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         HeadshotExplosion;                                 // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         TimeoutExplosion;                                  // 0x02F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRDamageType>              DirectDamageType;                                  // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectDamage;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRDamageType>              HeadshotDamageType;                                // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadshotDamage;                                    // 0x0310(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     DirectDamageScaleCurve;                            // 0x0318(0x0088)(Edit, NativeAccessSpecifierPublic)
	bool                                          bExplodeOnDirectHit;                               // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExplodeOnSlide;                                   // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExcludeDirectHitsFromExplosions;                  // 0x03A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRWeaponProjectileReplicationMode            ReplicationMode;                                   // 0x03A3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 MeshColors[0x8];                                   // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRPlayerController*                    InstigatorController;                              // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRPlayerState*                         InstigatorState;                                   // 0x03D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRWeaponBase*                          InstigatorWeapon;                                  // 0x03D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        SequenceNumber;                                    // 0x03E0(0x0002)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SourceStateIndex;                                  // 0x03E2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClientPredicted;                                // 0x03E3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitialLocation;                                   // 0x03E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyMeshColors();
	void ProcessBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity);
	bool ProcessImpactDamageableObject(const struct FHitResult& ImpactResult);
	void ProcessStop(const struct FHitResult& ImpactResult);
	void ProcessTimeout();
	void SetMeshColor(int32 Index_0, const struct FColor& Value);

	TSubclassOf<class UBRWeaponExplosion> GetImpactExplosion(bool bDirectHit, bool bHeadshot) const;
	struct FColor GetMeshColor(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponProjectile">();
	}
	static class ABRWeaponProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRWeaponProjectile>();
	}
};
static_assert(alignof(ABRWeaponProjectile) == 0x000008, "Wrong alignment on ABRWeaponProjectile");
static_assert(sizeof(ABRWeaponProjectile) == 0x000400, "Wrong size on ABRWeaponProjectile");
static_assert(offsetof(ABRWeaponProjectile, CollisionComponent) == 0x0002B0, "Member 'ABRWeaponProjectile::CollisionComponent' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, MovementComponent) == 0x0002B8, "Member 'ABRWeaponProjectile::MovementComponent' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, MeshComponent) == 0x0002C0, "Member 'ABRWeaponProjectile::MeshComponent' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, ParticleComponent) == 0x0002C8, "Member 'ABRWeaponProjectile::ParticleComponent' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, BounceExplosion) == 0x0002D0, "Member 'ABRWeaponProjectile::BounceExplosion' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, ImpactExplosion) == 0x0002D8, "Member 'ABRWeaponProjectile::ImpactExplosion' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, DirectHitExplosion) == 0x0002E0, "Member 'ABRWeaponProjectile::DirectHitExplosion' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, HeadshotExplosion) == 0x0002E8, "Member 'ABRWeaponProjectile::HeadshotExplosion' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, TimeoutExplosion) == 0x0002F0, "Member 'ABRWeaponProjectile::TimeoutExplosion' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, DirectDamageType) == 0x0002F8, "Member 'ABRWeaponProjectile::DirectDamageType' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, DirectDamage) == 0x000300, "Member 'ABRWeaponProjectile::DirectDamage' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, HeadshotDamageType) == 0x000308, "Member 'ABRWeaponProjectile::HeadshotDamageType' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, HeadshotDamage) == 0x000310, "Member 'ABRWeaponProjectile::HeadshotDamage' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, DirectDamageScaleCurve) == 0x000318, "Member 'ABRWeaponProjectile::DirectDamageScaleCurve' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, bExplodeOnDirectHit) == 0x0003A0, "Member 'ABRWeaponProjectile::bExplodeOnDirectHit' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, bExplodeOnSlide) == 0x0003A1, "Member 'ABRWeaponProjectile::bExplodeOnSlide' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, bExcludeDirectHitsFromExplosions) == 0x0003A2, "Member 'ABRWeaponProjectile::bExcludeDirectHitsFromExplosions' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, ReplicationMode) == 0x0003A3, "Member 'ABRWeaponProjectile::ReplicationMode' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, MeshColors) == 0x0003A4, "Member 'ABRWeaponProjectile::MeshColors' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, InstigatorController) == 0x0003C8, "Member 'ABRWeaponProjectile::InstigatorController' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, InstigatorState) == 0x0003D0, "Member 'ABRWeaponProjectile::InstigatorState' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, InstigatorWeapon) == 0x0003D8, "Member 'ABRWeaponProjectile::InstigatorWeapon' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, SequenceNumber) == 0x0003E0, "Member 'ABRWeaponProjectile::SequenceNumber' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, SourceStateIndex) == 0x0003E2, "Member 'ABRWeaponProjectile::SourceStateIndex' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, bIsClientPredicted) == 0x0003E3, "Member 'ABRWeaponProjectile::bIsClientPredicted' has a wrong offset!");
static_assert(offsetof(ABRWeaponProjectile, InitialLocation) == 0x0003E8, "Member 'ABRWeaponProjectile::InitialLocation' has a wrong offset!");

// Class Brickadia.BrickPreviewManagerComponent
// 0x0098 (0x0140 - 0x00A8)
class UBrickPreviewManagerComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(class ABrickGridPreviewActor* BrickGridPreviewActor)> OnBrickGridPreviewActorAvailable;                  // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABrickGridPreviewActor*                 BrickGridPreviewActor;                             // 0x00B8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C0[0x80];                                      // 0x00C0(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_BrickGridPreviewActor();
	void ServerSetPreviewMode_TEMP(EBrickPreviewMode NewMode);
	void ServerSetPreviewSimpleParameters(const struct FBrickPreviewSimpleParameters& NewParameters);
	void ServerSetPreviewTransformParameters(const struct FBrickPreviewTransformParameters& NewParameters);
	void ServerSetPreviewVisible(bool bNewVisible);
	void ServerSetPreviewVolumeParameters(const struct FBrickPreviewVolumeParameters& NewParameters);
	void SetPreviewMode(EBrickPreviewMode NewMode);
	void SetPreviewSimpleParameters(const struct FBrickPreviewSimpleParameters& NewParameters, bool bKillPreview);
	void SetPreviewTransformParameters(const struct FBrickPreviewTransformParameters& NewParameters);
	void SetPreviewVisible(bool bNewVisible);
	void SetPreviewVolumeParameters(const struct FBrickPreviewVolumeParameters& NewParameters, bool bKillPreview);

	class ABrickGridPreviewActor* GetBrickGridPreviewActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickPreviewManagerComponent">();
	}
	static class UBrickPreviewManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickPreviewManagerComponent>();
	}
};
static_assert(alignof(UBrickPreviewManagerComponent) == 0x000008, "Wrong alignment on UBrickPreviewManagerComponent");
static_assert(sizeof(UBrickPreviewManagerComponent) == 0x000140, "Wrong size on UBrickPreviewManagerComponent");
static_assert(offsetof(UBrickPreviewManagerComponent, OnBrickGridPreviewActorAvailable) == 0x0000A8, "Member 'UBrickPreviewManagerComponent::OnBrickGridPreviewActorAvailable' has a wrong offset!");
static_assert(offsetof(UBrickPreviewManagerComponent, BrickGridPreviewActor) == 0x0000B8, "Member 'UBrickPreviewManagerComponent::BrickGridPreviewActor' has a wrong offset!");

// Class Brickadia.BRTickableWorldSubsystem
// 0x0008 (0x0048 - 0x0040)
class UBRTickableWorldSubsystem : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTickableWorldSubsystem">();
	}
	static class UBRTickableWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTickableWorldSubsystem>();
	}
};
static_assert(alignof(UBRTickableWorldSubsystem) == 0x000008, "Wrong alignment on UBRTickableWorldSubsystem");
static_assert(sizeof(UBRTickableWorldSubsystem) == 0x000048, "Wrong size on UBRTickableWorldSubsystem");

// Class Brickadia.BrickRegistry
// 0x0678 (0x06C0 - 0x0048)
class UBrickRegistry final : public UBRTickableWorldSubsystem
{
public:
	uint8                                         Pad_48[0xA8];                                      // 0x0048(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickGridActor*                        CachedGlobalBrickGridActor;                        // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickGridComponent*                    CachedGlobalBrickGrid;                             // 0x00F8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBrickMaterialCollection*>       MaterialCollections;                               // 0x0100(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_110[0x20];                                     // 0x0110(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBrickAsset*>                    BrickAssetNetworkLookup;                           // 0x0130(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_140[0x198];                                    // 0x0140(0x0198)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBrickComponentTypeBase*>        ComponentTypes;                                    // 0x02D8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E8[0x28];                                     // 0x02E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBrickReplicationClient*>        AllReplicationClients;                             // 0x0310(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x2A8];                                    // 0x0320(0x02A8)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBREntityTypeBase*>              EntityTypes;                                       // 0x05C8(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0xE0];                                     // 0x05D8(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	class ABrickRegistryExternalTicker*           ExternalTicker;                                    // 0x06B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool CanConnectWire(const struct FBrickComponentWirePortRef& SourcePortRef, const struct FBrickComponentWirePortRef& TargetPortRef);
	EBrickComponentWireConnectResult ConnectComponentWire(const struct FBrickComponentWirePortRef& SourcePortRef, const struct FBrickComponentWirePortRef& TargetPortRef);
	EBrickComponentWireDisconnectResult DisconnectComponentWire(const struct FBrickComponentWirePortRef& SourcePortRef, const struct FBrickComponentWirePortRef& TargetPortRef);
	EBrickComponentWireDisconnectResult DisconnectComponentWireByIndex(int32 WireIndex);
	EBrickComponentWireDisconnectResult DisconnectComponentWireByPort(const struct FBrickComponentWirePortRef& PortRef, bool bAsOutput);
	void DisconnectComponentWiresByComponent(const struct FBrickComponentInstanceRef& Component);
	void ForceLastModifyTime(double Time);
	bool IsComponentInstanceRefValid(const struct FBrickComponentInstanceRef& ComponentRef);
	bool IsComponentLatentInstanceRefValid(const struct FBrickComponentLatentInstanceRef& ComponentRef);
	bool IsComponentLatentWirePortRefValid(const struct FBrickComponentLatentWirePortRef& PortRef, bool bAsOutput);
	bool IsComponentWirePortRefValid(const struct FBrickComponentWirePortRef& PortRef, bool bAsOutput);
	void NotifyBrickChange();
	void SetHiddenBrickRenderingEnabled(bool bEnabled);
	void SetWireRenderingEnabled(bool bEnabled);

	struct FBrickLatentHandle CreateBrickLatentHandle(const struct FBrickHandle& BrickHandle) const;
	struct FBrickHandle FindBrickByLatentHandle(const struct FBrickLatentHandle& LatentHandle) const;
	bool GetHiddenBrickRenderingEnabled() const;
	float GetLastBrickModificationTime() const;
	bool GetWireRenderingEnabled() const;
	bool HasWiresConnectedToPort(const struct FBrickComponentWirePortRef& PortRef, bool bAsOutput) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickRegistry">();
	}
	static class UBrickRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickRegistry>();
	}
};
static_assert(alignof(UBrickRegistry) == 0x000008, "Wrong alignment on UBrickRegistry");
static_assert(sizeof(UBrickRegistry) == 0x0006C0, "Wrong size on UBrickRegistry");
static_assert(offsetof(UBrickRegistry, CachedGlobalBrickGridActor) == 0x0000F0, "Member 'UBrickRegistry::CachedGlobalBrickGridActor' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, CachedGlobalBrickGrid) == 0x0000F8, "Member 'UBrickRegistry::CachedGlobalBrickGrid' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, MaterialCollections) == 0x000100, "Member 'UBrickRegistry::MaterialCollections' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, BrickAssetNetworkLookup) == 0x000130, "Member 'UBrickRegistry::BrickAssetNetworkLookup' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, ComponentTypes) == 0x0002D8, "Member 'UBrickRegistry::ComponentTypes' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, AllReplicationClients) == 0x000310, "Member 'UBrickRegistry::AllReplicationClients' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, EntityTypes) == 0x0005C8, "Member 'UBrickRegistry::EntityTypes' has a wrong offset!");
static_assert(offsetof(UBrickRegistry, ExternalTicker) == 0x0006B8, "Member 'UBrickRegistry::ExternalTicker' has a wrong offset!");

// Class Brickadia.BrickRegistryExternalTicker
// 0x0000 (0x02B0 - 0x02B0)
class ABrickRegistryExternalTicker final : public AInfo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickRegistryExternalTicker">();
	}
	static class ABrickRegistryExternalTicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickRegistryExternalTicker>();
	}
};
static_assert(alignof(ABrickRegistryExternalTicker) == 0x000008, "Wrong alignment on ABrickRegistryExternalTicker");
static_assert(sizeof(ABrickRegistryExternalTicker) == 0x0002B0, "Wrong size on ABrickRegistryExternalTicker");

// Class Brickadia.ThumbnailProcessor
// 0x0030 (0x0058 - 0x0028)
class UThumbnailProcessor : public UObject
{
public:
	class UStaticMesh*                            PlaneMesh;                                         // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     GridMaterial;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   PlaneComponent;                                    // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureCube*                           SkyTextureCube;                                    // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               SceneCaptureComponent;                             // 0x0050(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThumbnailProcessor">();
	}
	static class UThumbnailProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThumbnailProcessor>();
	}
};
static_assert(alignof(UThumbnailProcessor) == 0x000008, "Wrong alignment on UThumbnailProcessor");
static_assert(sizeof(UThumbnailProcessor) == 0x000058, "Wrong size on UThumbnailProcessor");
static_assert(offsetof(UThumbnailProcessor, PlaneMesh) == 0x000028, "Member 'UThumbnailProcessor::PlaneMesh' has a wrong offset!");
static_assert(offsetof(UThumbnailProcessor, GridMaterial) == 0x000030, "Member 'UThumbnailProcessor::GridMaterial' has a wrong offset!");
static_assert(offsetof(UThumbnailProcessor, PlaneComponent) == 0x000038, "Member 'UThumbnailProcessor::PlaneComponent' has a wrong offset!");
static_assert(offsetof(UThumbnailProcessor, SkyTextureCube) == 0x000048, "Member 'UThumbnailProcessor::SkyTextureCube' has a wrong offset!");
static_assert(offsetof(UThumbnailProcessor, SceneCaptureComponent) == 0x000050, "Member 'UThumbnailProcessor::SceneCaptureComponent' has a wrong offset!");

// Class Brickadia.BrickClusterRenderComponent
// 0x0010 (0x0510 - 0x0500)
class UBrickClusterRenderComponent final : public UMeshComponent
{
public:
	uint8                                         Pad_4F8[0x18];                                     // 0x04F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickClusterRenderComponent">();
	}
	static class UBrickClusterRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickClusterRenderComponent>();
	}
};
static_assert(alignof(UBrickClusterRenderComponent) == 0x000010, "Wrong alignment on UBrickClusterRenderComponent");
static_assert(sizeof(UBrickClusterRenderComponent) == 0x000510, "Wrong size on UBrickClusterRenderComponent");

// Class Brickadia.BRPlayerState
// 0x0108 (0x0470 - 0x0368)
class ABRPlayerState final : public APlayerState
{
public:
	uint8                                         Pad_368[0x8];                                      // 0x0368(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRRuleset*                             Ruleset;                                           // 0x0370(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRRulesetTeam*                         Team;                                              // 0x0378(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrickPersistentHandle                 CheckPoint;                                        // 0x0380(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReplicatedOwnerIndex;                              // 0x0384(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReplicatedJoinTime;                                // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayLeaveSound;                                    // 0x0390(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRGuid                                UserId;                                            // 0x0394(0x0010)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserName;                                          // 0x03A8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBRPermissionsRole*>             CustomPermissionsRoles;                            // 0x03B8(0x0010)(ExportObject, Net, ZeroConstructor, RepNotify, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bIsOwner;                                          // 0x03C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 LeaderboardData;                                   // 0x03D0(0x0010)(Net, ZeroConstructor, NativeAccessSpecifierPrivate)
	TSet<class ABRWeaponProjectile*>              TrackedProjectiles;                                // 0x03E0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UBRInventoryComponent*                  ToolsInventory;                                    // 0x0430(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ABRTool_Placer>             PlacerToolClass;                                   // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class ABRToolBase>>        DefaultTools;                                      // 0x0440(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class ABRTool_Placer*                         PlacerTool;                                        // 0x0450(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRColorSelectionState                 ColorSelectionState;                               // 0x0458(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_464[0xC];                                      // 0x0464(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTrackedProjectile(class ABRWeaponProjectile* Projectile);
	void ClearRoles();
	void DestroyTrackedProjectiles();
	void IncLeaderboardValue(class FName ValueName, int32 Value);
	void IncLeaderboardValueByIndex(int32 Index_0, int32 Value);
	void OnRep_CustomPermissionsRoles();
	void OnRep_Ruleset();
	void OnRep_Team();
	void RemoveTrackedProjectile(class ABRWeaponProjectile* Projectile);
	void ResetLeaderboardValues();
	void ServerSetColorSelectionState(const struct FBRColorSelectionState& SelectionState);
	void SetColorSelectionState(const struct FBRColorSelectionState& SelectionState);
	void SetHasRole(const class FString& RoleId, bool Has);
	void SetHasRoles(const TArray<class FString>& RoleIds);
	void SetLeaderboardValue(class FName ValueName, int32 Value);
	void SetLeaderboardValueByIndex(int32 Index_0, int32 Value);

	void CountBricksAndComponents(int32* OutNumBricks, int32* OutNumComponents) const;
	class UBRRulesetTeam* GetAffiliatedTeamFor(const class ABRPlayerState* OtherPlayer) const;
	struct FColor GetChatNameColor() const;
	struct FColor GetChatNameColorFor(class ABRPlayerState* OtherPlayer) const;
	TArray<class UBRPermissionsRole*> GetCustomPermissionsRoles() const;
	struct FColor GetDefaultRoleColor() const;
	bool GetHasChatNameColor() const;
	bool GetHasRole(const class FString& PermissionsRoleIn) const;
	class UBRPermissionsRole* GetHighestRole() const;
	struct FColor GetHighestRoleColor() const;
	struct FColor GetHUDNameColor() const;
	bool GetIsOwner() const;
	int32 GetLeaderboardValue(class FName ValueName) const;
	int32 GetLeaderboardValueByIndex(int32 Index_0) const;
	class ABRPlayerController* GetOwnerBRPlayerController() const;
	class ABRTool_Placer* GetPlacerTool() const;
	TArray<class UBRPermissionsRole*> GetRoles() const;
	TArray<class UBRPermissionsRole*> GetRolesExcludingDefault() const;
	class ABRToolBase* GetToolByClass(TSubclassOf<class ABRToolBase> ToolClass) const;
	class UBRInventoryEntryBase* GetToolInventoryEntry(int32 Slot) const;
	class UBRInventoryComponent* GetToolsInventory() const;
	struct FBRGuid GetUserId() const;
	class FString GetUserName() const;
	bool HasAnyRoles() const;
	bool HasLivingCharacter() const;
	bool HasPermission(class FName Permission) const;
	bool HasToolInventoryEntry(int32 Slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerState">();
	}
	static class ABRPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlayerState>();
	}
};
static_assert(alignof(ABRPlayerState) == 0x000008, "Wrong alignment on ABRPlayerState");
static_assert(sizeof(ABRPlayerState) == 0x000470, "Wrong size on ABRPlayerState");
static_assert(offsetof(ABRPlayerState, Ruleset) == 0x000370, "Member 'ABRPlayerState::Ruleset' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, Team) == 0x000378, "Member 'ABRPlayerState::Team' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, CheckPoint) == 0x000380, "Member 'ABRPlayerState::CheckPoint' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, ReplicatedOwnerIndex) == 0x000384, "Member 'ABRPlayerState::ReplicatedOwnerIndex' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, ReplicatedJoinTime) == 0x000388, "Member 'ABRPlayerState::ReplicatedJoinTime' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, PlayLeaveSound) == 0x000390, "Member 'ABRPlayerState::PlayLeaveSound' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, UserId) == 0x000394, "Member 'ABRPlayerState::UserId' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, UserName) == 0x0003A8, "Member 'ABRPlayerState::UserName' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, CustomPermissionsRoles) == 0x0003B8, "Member 'ABRPlayerState::CustomPermissionsRoles' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, bIsOwner) == 0x0003C8, "Member 'ABRPlayerState::bIsOwner' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, LeaderboardData) == 0x0003D0, "Member 'ABRPlayerState::LeaderboardData' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, TrackedProjectiles) == 0x0003E0, "Member 'ABRPlayerState::TrackedProjectiles' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, ToolsInventory) == 0x000430, "Member 'ABRPlayerState::ToolsInventory' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, PlacerToolClass) == 0x000438, "Member 'ABRPlayerState::PlacerToolClass' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, DefaultTools) == 0x000440, "Member 'ABRPlayerState::DefaultTools' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, PlacerTool) == 0x000450, "Member 'ABRPlayerState::PlacerTool' has a wrong offset!");
static_assert(offsetof(ABRPlayerState, ColorSelectionState) == 0x000458, "Member 'ABRPlayerState::ColorSelectionState' has a wrong offset!");

// Class Brickadia.BrickReplicationChannel
// 0x00D8 (0x0140 - 0x0068)
class UBrickReplicationChannel final : public UChannel
{
public:
	class UBrickReplicationClient*                ReplicationClient;                                 // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0xD0];                                      // 0x0070(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickReplicationChannel">();
	}
	static class UBrickReplicationChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickReplicationChannel>();
	}
};
static_assert(alignof(UBrickReplicationChannel) == 0x000008, "Wrong alignment on UBrickReplicationChannel");
static_assert(sizeof(UBrickReplicationChannel) == 0x000140, "Wrong size on UBrickReplicationChannel");
static_assert(offsetof(UBrickReplicationChannel, ReplicationClient) == 0x000068, "Member 'UBrickReplicationChannel::ReplicationClient' has a wrong offset!");

// Class Brickadia.BrickReplicationClient
// 0x00E0 (0x0108 - 0x0028)
class UBrickReplicationClient final : public UObject
{
public:
	class ABRPlayerController*                    Controller;                                        // 0x0028(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickReplicationChannel*               DataChannel;                                       // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0xD0];                                      // 0x0038(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickReplicationClient">();
	}
	static class UBrickReplicationClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickReplicationClient>();
	}
};
static_assert(alignof(UBrickReplicationClient) == 0x000008, "Wrong alignment on UBrickReplicationClient");
static_assert(sizeof(UBrickReplicationClient) == 0x000108, "Wrong size on UBrickReplicationClient");
static_assert(offsetof(UBrickReplicationClient, Controller) == 0x000028, "Member 'UBrickReplicationClient::Controller' has a wrong offset!");
static_assert(offsetof(UBrickReplicationClient, DataChannel) == 0x000030, "Member 'UBrickReplicationClient::DataChannel' has a wrong offset!");

// Class Brickadia.BrickSaveFileItem
// 0x0028 (0x0050 - 0x0028)
class UBrickSaveFileItem final : public UObject
{
public:
	struct FBrickSaveFileInfo                     SaveFileInfo;                                      // 0x0028(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSaveFileItem">();
	}
	static class UBrickSaveFileItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSaveFileItem>();
	}
};
static_assert(alignof(UBrickSaveFileItem) == 0x000008, "Wrong alignment on UBrickSaveFileItem");
static_assert(sizeof(UBrickSaveFileItem) == 0x000050, "Wrong size on UBrickSaveFileItem");
static_assert(offsetof(UBrickSaveFileItem, SaveFileInfo) == 0x000028, "Member 'UBrickSaveFileItem::SaveFileInfo' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_FiringHitscan
// 0x0040 (0x0090 - 0x0050)
class UBRWeaponStateBehavior_FiringHitscan final : public UBRWeaponStateBehavior_Firing
{
public:
	TSubclassOf<class UBRWeaponExplosion>         HitExplosion;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         HeadshotExplosion;                                 // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponExplosion>         MissExplosion;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRDamageType>              DirectDamageType;                                  // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectDamage;                                      // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRDamageType>              HeadshotDamageType;                                // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeadshotDamage;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLength;                                       // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExcludeDirectHitsFromExplosions;                  // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnExplosionOnTraceMiss;                        // 0x0089(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x008A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x008B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_FiringHitscan">();
	}
	static class UBRWeaponStateBehavior_FiringHitscan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_FiringHitscan>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_FiringHitscan) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_FiringHitscan");
static_assert(sizeof(UBRWeaponStateBehavior_FiringHitscan) == 0x000090, "Wrong size on UBRWeaponStateBehavior_FiringHitscan");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, HitExplosion) == 0x000050, "Member 'UBRWeaponStateBehavior_FiringHitscan::HitExplosion' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, HeadshotExplosion) == 0x000058, "Member 'UBRWeaponStateBehavior_FiringHitscan::HeadshotExplosion' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, MissExplosion) == 0x000060, "Member 'UBRWeaponStateBehavior_FiringHitscan::MissExplosion' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, DirectDamageType) == 0x000068, "Member 'UBRWeaponStateBehavior_FiringHitscan::DirectDamageType' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, DirectDamage) == 0x000070, "Member 'UBRWeaponStateBehavior_FiringHitscan::DirectDamage' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, HeadshotDamageType) == 0x000078, "Member 'UBRWeaponStateBehavior_FiringHitscan::HeadshotDamageType' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, HeadshotDamage) == 0x000080, "Member 'UBRWeaponStateBehavior_FiringHitscan::HeadshotDamage' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, TraceLength) == 0x000084, "Member 'UBRWeaponStateBehavior_FiringHitscan::TraceLength' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, bExcludeDirectHitsFromExplosions) == 0x000088, "Member 'UBRWeaponStateBehavior_FiringHitscan::bExcludeDirectHitsFromExplosions' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, bSpawnExplosionOnTraceMiss) == 0x000089, "Member 'UBRWeaponStateBehavior_FiringHitscan::bSpawnExplosionOnTraceMiss' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, bTraceComplex) == 0x00008A, "Member 'UBRWeaponStateBehavior_FiringHitscan::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_FiringHitscan, TraceChannel) == 0x00008B, "Member 'UBRWeaponStateBehavior_FiringHitscan::TraceChannel' has a wrong offset!");

// Class Brickadia.BrickSaveFolderItem
// 0x0030 (0x0058 - 0x0028)
class UBrickSaveFolderItem final : public UObject
{
public:
	struct FBrickSaveFolderInfo                   SaveFolderInfo;                                    // 0x0028(0x0030)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSaveFolderItem">();
	}
	static class UBrickSaveFolderItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSaveFolderItem>();
	}
};
static_assert(alignof(UBrickSaveFolderItem) == 0x000008, "Wrong alignment on UBrickSaveFolderItem");
static_assert(sizeof(UBrickSaveFolderItem) == 0x000058, "Wrong size on UBrickSaveFolderItem");
static_assert(offsetof(UBrickSaveFolderItem, SaveFolderInfo) == 0x000028, "Member 'UBrickSaveFolderItem::SaveFolderInfo' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_ScriptBase
// 0x0008 (0x0040 - 0x0038)
class UBRWeaponStateBehavior_ScriptBase final : public UBRWeaponStateBehavior_ChangesResources
{
public:
	bool                                          bAdvanceStateCallbackRequired;                     // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAdvanceState(class ABRWeaponBase* Weapon, const struct FBRWeaponSimulationContext& SimContext, struct FBRWeaponSimulationFeedback* SimFeedback, float Duration);
	void OnEnterState(class ABRWeaponBase* Weapon, const struct FBRWeaponSimulationContext& SimContext, struct FBRWeaponSimulationFeedback* SimFeedback);
	void OnExitState(class ABRWeaponBase* Weapon, const struct FBRWeaponSimulationContext& SimContext, struct FBRWeaponSimulationFeedback* SimFeedback);
	void OnResumeState(class ABRWeaponBase* Weapon, const struct FBRWeaponSimulationContext& SimContext, struct FBRWeaponSimulationFeedback* SimFeedback);
	void OnSuspendState(class ABRWeaponBase* Weapon, const struct FBRWeaponSimulationContext& SimContext, struct FBRWeaponSimulationFeedback* SimFeedback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_ScriptBase">();
	}
	static class UBRWeaponStateBehavior_ScriptBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_ScriptBase>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_ScriptBase) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_ScriptBase");
static_assert(sizeof(UBRWeaponStateBehavior_ScriptBase) == 0x000040, "Wrong size on UBRWeaponStateBehavior_ScriptBase");
static_assert(offsetof(UBRWeaponStateBehavior_ScriptBase, bAdvanceStateCallbackRequired) == 0x000038, "Member 'UBRWeaponStateBehavior_ScriptBase::bAdvanceStateCallbackRequired' has a wrong offset!");

// Class Brickadia.BrickSaveFileLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrickSaveFileLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool CopySaveFile(const class FString& Path, const class FString& NewPath);
	static bool CopySaveFolder(const class FString& Path, const class FString& NewPath);
	static void CountContentItems(const TArray<class UObject*>& InItems, int32* OutNumFolders, int32* OutNumFiles, int32* OutNumIncludedFolders, int32* OutNumIncludedFiles, int64* OutSize);
	static bool CreateSaveFolder(const class FString& Path);
	static bool DeleteSaveFile(const class FString& Path);
	static bool DeleteSaveFolder(const class FString& Path, bool bRecursiveDeletion);
	static void FilterContentItems(const TArray<class UObject*>& InItems, const class FString& SearchString, TArray<class UObject*>* OutFilteredItems, int32* OutNumFolders, int32* OutNumFiles, int64* OutSize);
	static class UObject* FilterContentItemsExact(const TArray<class UObject*>& InItems, const class FString& SearchString, bool bAllowFolders, bool bAllowFiles);
	static void FilterContentItemsExactArray(const TArray<class UObject*>& InItems, const TArray<class FString>& FolderNames, const TArray<class FString>& FileNames, TArray<class UObject*>* OutFilteredItems);
	static class FString FindNextFreeSaveFileName(const class FString& Path);
	static class FString FindNextFreeSaveFolderName(const class FString& Path);
	static bool GetSaveFileDetails(const class FString& Path, struct FBrickSaveFileDetails* OutFileDetails);
	static bool GetSaveFileInfo(const class FString& Path, struct FBrickSaveFileInfo* OutFileInfo);
	static bool GetSaveFolderInfo(const class FString& Path, struct FBrickSaveFolderInfo* OutFolderInfo);
	static bool IsSaveFileValid(const class FString& Path);
	static bool IsSaveFolderValid(const class FString& Path);
	static bool ListSaveFolderContentItems(const class FString& Path, TArray<class UObject*>* OutItems, int32* OutNumFolders, int32* OutNumFiles, int64* OutSize);
	static bool ListSaveFolderContents(const class FString& Path, TArray<struct FBrickSaveFolderInfo>* OutFolders, TArray<struct FBrickSaveFileInfo>* OutFiles, int64* OutSize);
	static bool LoadBuild(const class FString& Path, class UBrickGridComponent* BrickGrid, const struct FBrickLoadParams& Params_0, class FString* OutError);
	static bool LoadTemplate(const class FString& Path, class ABRPlayerController* Controller, const struct FBrickLoadParams& Params_0, class FString* OutError);
	static bool MoveSaveFile(const class FString& Path, const class FString& NewPath);
	static bool MoveSaveFolder(const class FString& Path, const class FString& NewPath);
	static void OpenExplorerOnBackups();
	static void OpenExplorerOnSavePath(const class FString& Path);
	static bool PerformClipboardPasteOperation(bool bShouldCut, const class FString& CurrentBasePath, const class FString& ClipboardBasePath, const TArray<class FString>& ClipboardFolderPaths, const TArray<class FString>& ClipboardFilePaths, TArray<class FString>* OutMissingNames, TArray<class FString>* OutDuplicateNames, TArray<class FString>* OutFailedNames, TArray<class FString>* OutRecursiveFolderNames, TArray<class FString>* OutNewFolderNames, TArray<class FString>* OutNewFileNames);
	static bool SaveFileExists(const class FString& Path);
	static bool SaveFolderExists(const class FString& Path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSaveFileLibrary">();
	}
	static class UBrickSaveFileLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSaveFileLibrary>();
	}
};
static_assert(alignof(UBrickSaveFileLibrary) == 0x000008, "Wrong alignment on UBrickSaveFileLibrary");
static_assert(sizeof(UBrickSaveFileLibrary) == 0x000028, "Wrong size on UBrickSaveFileLibrary");

// Class Brickadia.BrickSaveBuildAsyncAction
// 0x0070 (0x00A0 - 0x0030)
class UBrickSaveBuildAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, const struct FBrickSaveResult& Result)> OnSaveComplete;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickSaveParams                       SaveParams;                                        // 0x0048(0x0058)(Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UBrickSaveBuildAsyncAction* SaveBuild(class UObject* WorldContextObject, int32 InSequence, const struct FBrickSaveParams& Params_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickSaveBuildAsyncAction">();
	}
	static class UBrickSaveBuildAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickSaveBuildAsyncAction>();
	}
};
static_assert(alignof(UBrickSaveBuildAsyncAction) == 0x000008, "Wrong alignment on UBrickSaveBuildAsyncAction");
static_assert(sizeof(UBrickSaveBuildAsyncAction) == 0x0000A0, "Wrong size on UBrickSaveBuildAsyncAction");
static_assert(offsetof(UBrickSaveBuildAsyncAction, OnSaveComplete) == 0x000030, "Member 'UBrickSaveBuildAsyncAction::OnSaveComplete' has a wrong offset!");
static_assert(offsetof(UBrickSaveBuildAsyncAction, SaveParams) == 0x000048, "Member 'UBrickSaveBuildAsyncAction::SaveParams' has a wrong offset!");

// Class Brickadia.HierarchicalRichTextBlock
// 0x03E8 (0x0570 - 0x0188)
class UHierarchicalRichTextBlock final : public UTextLayoutWidget
{
public:
	class FText                                   Text;                                              // 0x0188(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             TextStyleSet;                                      // 0x0198(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            UnderlineBrush;                                    // 0x01A0(0x00B0)(Edit, Protected, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class UHierarchicalRichTextBlockDecorator>> DecoratorClasses;                                  // 0x0250(0x0010)(Edit, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_260[0x2F0];                                    // 0x0260(0x02F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UHierarchicalRichTextBlockDecorator*> InstanceDecorators;                                // 0x0550(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_560[0x10];                                     // 0x0560(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UHierarchicalRichTextBlockDecorator* GetDecoratorByClass(TSubclassOf<class UHierarchicalRichTextBlockDecorator> DecoratorClass);
	void SetText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HierarchicalRichTextBlock">();
	}
	static class UHierarchicalRichTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHierarchicalRichTextBlock>();
	}
};
static_assert(alignof(UHierarchicalRichTextBlock) == 0x000010, "Wrong alignment on UHierarchicalRichTextBlock");
static_assert(sizeof(UHierarchicalRichTextBlock) == 0x000570, "Wrong size on UHierarchicalRichTextBlock");
static_assert(offsetof(UHierarchicalRichTextBlock, Text) == 0x000188, "Member 'UHierarchicalRichTextBlock::Text' has a wrong offset!");
static_assert(offsetof(UHierarchicalRichTextBlock, TextStyleSet) == 0x000198, "Member 'UHierarchicalRichTextBlock::TextStyleSet' has a wrong offset!");
static_assert(offsetof(UHierarchicalRichTextBlock, UnderlineBrush) == 0x0001A0, "Member 'UHierarchicalRichTextBlock::UnderlineBrush' has a wrong offset!");
static_assert(offsetof(UHierarchicalRichTextBlock, DecoratorClasses) == 0x000250, "Member 'UHierarchicalRichTextBlock::DecoratorClasses' has a wrong offset!");
static_assert(offsetof(UHierarchicalRichTextBlock, InstanceDecorators) == 0x000550, "Member 'UHierarchicalRichTextBlock::InstanceDecorators' has a wrong offset!");

// Class Brickadia.BrickLoadSaveFileScreenshotAsyncAction
// 0x0040 (0x0070 - 0x0030)
class UBrickLoadSaveFileScreenshotAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, class UTexture2DDynamic* Result)> OnWorkComplete;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBrickLoadSaveFileScreenshotAsyncAction* AsyncLoadSaveFileScreenshot(class UObject* WorldContextObject, int32 InSequence, const class FString& Path, int32 DesiredWidth, int32 DesiredHeight);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickLoadSaveFileScreenshotAsyncAction">();
	}
	static class UBrickLoadSaveFileScreenshotAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickLoadSaveFileScreenshotAsyncAction>();
	}
};
static_assert(alignof(UBrickLoadSaveFileScreenshotAsyncAction) == 0x000008, "Wrong alignment on UBrickLoadSaveFileScreenshotAsyncAction");
static_assert(sizeof(UBrickLoadSaveFileScreenshotAsyncAction) == 0x000070, "Wrong size on UBrickLoadSaveFileScreenshotAsyncAction");
static_assert(offsetof(UBrickLoadSaveFileScreenshotAsyncAction, OnWorkComplete) == 0x000030, "Member 'UBrickLoadSaveFileScreenshotAsyncAction::OnWorkComplete' has a wrong offset!");

// Class Brickadia.BrickGetSaveFileDetailsAsyncAction
// 0x00C0 (0x00F0 - 0x0030)
class UBrickGetSaveFileDetailsAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, const struct FBrickSaveFileDetails& Details)> OnWorkComplete;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0xB0];                                      // 0x0040(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBrickGetSaveFileDetailsAsyncAction* AsyncGetSaveFileDetails(class UObject* WorldContextObject, int32 InSequence, const class FString& Path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGetSaveFileDetailsAsyncAction">();
	}
	static class UBrickGetSaveFileDetailsAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickGetSaveFileDetailsAsyncAction>();
	}
};
static_assert(alignof(UBrickGetSaveFileDetailsAsyncAction) == 0x000008, "Wrong alignment on UBrickGetSaveFileDetailsAsyncAction");
static_assert(sizeof(UBrickGetSaveFileDetailsAsyncAction) == 0x0000F0, "Wrong size on UBrickGetSaveFileDetailsAsyncAction");
static_assert(offsetof(UBrickGetSaveFileDetailsAsyncAction, OnWorkComplete) == 0x000030, "Member 'UBrickGetSaveFileDetailsAsyncAction::OnWorkComplete' has a wrong offset!");

// Class Brickadia.BRServerSettingsBase_AutoSave
// 0x0018 (0x0060 - 0x0048)
class UBRServerSettingsBase_AutoSave : public UBRServerSettingsBase
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bEnableAutoSave;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnnounceAutoSave;                                 // 0x0051(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoSaveInterval;                                  // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeScreenshot;                                // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAnnounceAutoSave(bool bValue);
	void SetAutoSaveInterval(float Value);
	void SetEnableAutoSave(bool bValue);
	void SetIncludeScreenshot(bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettingsBase_AutoSave">();
	}
	static class UBRServerSettingsBase_AutoSave* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerSettingsBase_AutoSave>();
	}
};
static_assert(alignof(UBRServerSettingsBase_AutoSave) == 0x000008, "Wrong alignment on UBRServerSettingsBase_AutoSave");
static_assert(sizeof(UBRServerSettingsBase_AutoSave) == 0x000060, "Wrong size on UBRServerSettingsBase_AutoSave");
static_assert(offsetof(UBRServerSettingsBase_AutoSave, bEnableAutoSave) == 0x000050, "Member 'UBRServerSettingsBase_AutoSave::bEnableAutoSave' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_AutoSave, bAnnounceAutoSave) == 0x000051, "Member 'UBRServerSettingsBase_AutoSave::bAnnounceAutoSave' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_AutoSave, AutoSaveInterval) == 0x000054, "Member 'UBRServerSettingsBase_AutoSave::AutoSaveInterval' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_AutoSave, bIncludeScreenshot) == 0x000058, "Member 'UBRServerSettingsBase_AutoSave::bIncludeScreenshot' has a wrong offset!");

// Class Brickadia.BrickListSaveFolderContentItemsAsyncAction
// 0x0050 (0x0080 - 0x0030)
class UBrickListSaveFolderContentItemsAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void(int32 Sequence, const TArray<class UObject*>& Items, int32 NumFolders, int32 NumFiles, int64 TotalSize)> OnWorkComplete;                                    // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x40];                                      // 0x0040(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBrickListSaveFolderContentItemsAsyncAction* AsyncListSaveFolderContentItems(class UObject* WorldContextObject, int32 InSequence, const class FString& Path);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickListSaveFolderContentItemsAsyncAction">();
	}
	static class UBrickListSaveFolderContentItemsAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickListSaveFolderContentItemsAsyncAction>();
	}
};
static_assert(alignof(UBrickListSaveFolderContentItemsAsyncAction) == 0x000008, "Wrong alignment on UBrickListSaveFolderContentItemsAsyncAction");
static_assert(sizeof(UBrickListSaveFolderContentItemsAsyncAction) == 0x000080, "Wrong size on UBrickListSaveFolderContentItemsAsyncAction");
static_assert(offsetof(UBrickListSaveFolderContentItemsAsyncAction, OnWorkComplete) == 0x000030, "Member 'UBrickListSaveFolderContentItemsAsyncAction::OnWorkComplete' has a wrong offset!");

// Class Brickadia.BrickStaticMeshBuilder
// 0x0000 (0x0028 - 0x0028)
class UBrickStaticMeshBuilder final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickStaticMeshBuilder">();
	}
	static class UBrickStaticMeshBuilder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickStaticMeshBuilder>();
	}
};
static_assert(alignof(UBrickStaticMeshBuilder) == 0x000008, "Wrong alignment on UBrickStaticMeshBuilder");
static_assert(sizeof(UBrickStaticMeshBuilder) == 0x000028, "Wrong size on UBrickStaticMeshBuilder");

// Class Brickadia.BrickTransactionManagerComponent
// 0x0138 (0x01E0 - 0x00A8)
class UBrickTransactionManagerComponent final : public UActorComponent
{
public:
	int32                                         MaxTransactionHistoryLength;                       // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABRPlayerController* BrickOwner, class UBrickTransaction* Transaction, EBrickTransactionCompletionReason Reason)> OnNewTransactionComplete;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerController* BrickOwner, class UBrickTransaction* Transaction, EBrickTransactionCompletionReason Reason)> OnUndoTransactionComplete;                         // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerController* BrickOwner, class UBrickTransaction* Transaction, EBrickTransactionCompletionReason Reason)> OnRedoTransactionComplete;                         // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerController* BrickOwner, const struct FBrickHandle& BrickHandle)> OnBrickPlaced;                                     // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerController* BrickOwner)> OnBrickDeleted;                                    // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerController* BrickOwner, const struct FBrickHandle& BrickHandle)> OnBrickResized;                                    // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FBrickTransactionContext>       TransactionContexts;                               // 0x0110(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	EBrickTransactionManagerState                 State;                                             // 0x0120(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickTransaction*                      PendingTransaction;                                // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickTransaction*                      ReverseTransaction;                                // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ReverseTransactionMergeTag;                        // 0x0138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RemainingBudgetThisTick;                           // 0x0140(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickTransactionReport                PendingTransactionReport;                          // 0x0148(0x0098)(Transient, NativeAccessSpecifierPrivate)

public:
	void AbortTransaction();
	void DeleteTransactionHistory();
	void ForceCompleteTransaction();
	void ForceDiscardMostRecentUndoEntry();
	void HandleServerRemapColors(const TMap<struct FColor, struct FColor>& Mappings);
	void PopTransactionContext();
	void PushNewTransaction(class UBrickTransaction* Transaction, EBrickReverseTransactionMergeMode MergeMode, class FName OptionalMergeTag, bool bDeferInitialTick, bool bForceCompleteImmediately, EBrickTransactionTickResult* OutInitialTickResult);
	void PushTransactionContext(class FName Name_0);
	void ResetTransactionMergeTag();
	void TryRedoTransaction(bool bDeferInitialTick, bool bForceCompleteImmediately, EBrickTransactionTickResult* OutInitialTickResult);
	void TryUndoTransaction(bool bDeferInitialTick, bool bForceCompleteImmediately, EBrickTransactionTickResult* OutInitialTickResult);

	void AppendPendingCustomInformation(TArray<class FText>& OutReportLines) const;
	void AppendPendingErrorInformation(TArray<class FText>& OutReportLines) const;
	void AppendPendingStatusInformation(TArray<class FText>& OutReportLines) const;
	bool CanRedoTransaction() const;
	bool CanUndoTransaction() const;
	class FName GetCurrentTransactionContextName() const;
	EBrickTransactionManagerState GetState() const;
	bool IsIdle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTransactionManagerComponent">();
	}
	static class UBrickTransactionManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTransactionManagerComponent>();
	}
};
static_assert(alignof(UBrickTransactionManagerComponent) == 0x000008, "Wrong alignment on UBrickTransactionManagerComponent");
static_assert(sizeof(UBrickTransactionManagerComponent) == 0x0001E0, "Wrong size on UBrickTransactionManagerComponent");
static_assert(offsetof(UBrickTransactionManagerComponent, MaxTransactionHistoryLength) == 0x0000A8, "Member 'UBrickTransactionManagerComponent::MaxTransactionHistoryLength' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, OnNewTransactionComplete) == 0x0000B0, "Member 'UBrickTransactionManagerComponent::OnNewTransactionComplete' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, OnUndoTransactionComplete) == 0x0000C0, "Member 'UBrickTransactionManagerComponent::OnUndoTransactionComplete' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, OnRedoTransactionComplete) == 0x0000D0, "Member 'UBrickTransactionManagerComponent::OnRedoTransactionComplete' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, OnBrickPlaced) == 0x0000E0, "Member 'UBrickTransactionManagerComponent::OnBrickPlaced' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, OnBrickDeleted) == 0x0000F0, "Member 'UBrickTransactionManagerComponent::OnBrickDeleted' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, OnBrickResized) == 0x000100, "Member 'UBrickTransactionManagerComponent::OnBrickResized' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, TransactionContexts) == 0x000110, "Member 'UBrickTransactionManagerComponent::TransactionContexts' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, State) == 0x000120, "Member 'UBrickTransactionManagerComponent::State' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, PendingTransaction) == 0x000128, "Member 'UBrickTransactionManagerComponent::PendingTransaction' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, ReverseTransaction) == 0x000130, "Member 'UBrickTransactionManagerComponent::ReverseTransaction' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, ReverseTransactionMergeTag) == 0x000138, "Member 'UBrickTransactionManagerComponent::ReverseTransactionMergeTag' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, RemainingBudgetThisTick) == 0x000140, "Member 'UBrickTransactionManagerComponent::RemainingBudgetThisTick' has a wrong offset!");
static_assert(offsetof(UBrickTransactionManagerComponent, PendingTransactionReport) == 0x000148, "Member 'UBrickTransactionManagerComponent::PendingTransactionReport' has a wrong offset!");

// Class Brickadia.BRPlayerPartDescriptor
// 0x0140 (0x0170 - 0x0030)
class UBRPlayerPartDescriptor final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            Mesh;                                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Tab;                                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Summary;                                           // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShouldDisplayInGame;                              // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRotate;                                        // 0x0081(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDetachOnRagdoll;                                  // 0x0082(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_83[0x5];                                       // 0x0083(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           PartTags;                                          // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanMirror;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverridesConnectionTags;                          // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             OverrideConnectionTags;                            // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FColor                                 DefaultColors[0x8];                                // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsDecals;                                   // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class FName>                             AllowedDecalTags;                                  // 0x0118(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UBRPlayerDecalDescriptor*               DefaultDecalDescriptor;                            // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerPartDescriptor">();
	}
	static class UBRPlayerPartDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlayerPartDescriptor>();
	}
};
static_assert(alignof(UBRPlayerPartDescriptor) == 0x000008, "Wrong alignment on UBRPlayerPartDescriptor");
static_assert(sizeof(UBRPlayerPartDescriptor) == 0x000170, "Wrong size on UBRPlayerPartDescriptor");
static_assert(offsetof(UBRPlayerPartDescriptor, Mesh) == 0x000038, "Member 'UBRPlayerPartDescriptor::Mesh' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, Tab) == 0x000040, "Member 'UBRPlayerPartDescriptor::Tab' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, Category) == 0x000050, "Member 'UBRPlayerPartDescriptor::Category' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, DisplayName) == 0x000060, "Member 'UBRPlayerPartDescriptor::DisplayName' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, Summary) == 0x000070, "Member 'UBRPlayerPartDescriptor::Summary' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, bShouldDisplayInGame) == 0x000080, "Member 'UBRPlayerPartDescriptor::bShouldDisplayInGame' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, bCanRotate) == 0x000081, "Member 'UBRPlayerPartDescriptor::bCanRotate' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, bDetachOnRagdoll) == 0x000082, "Member 'UBRPlayerPartDescriptor::bDetachOnRagdoll' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, PartTags) == 0x000088, "Member 'UBRPlayerPartDescriptor::PartTags' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, bCanMirror) == 0x000098, "Member 'UBRPlayerPartDescriptor::bCanMirror' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, bOverridesConnectionTags) == 0x000099, "Member 'UBRPlayerPartDescriptor::bOverridesConnectionTags' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, OverrideConnectionTags) == 0x0000A0, "Member 'UBRPlayerPartDescriptor::OverrideConnectionTags' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, DefaultColors) == 0x0000F0, "Member 'UBRPlayerPartDescriptor::DefaultColors' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, bSupportsDecals) == 0x000110, "Member 'UBRPlayerPartDescriptor::bSupportsDecals' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, AllowedDecalTags) == 0x000118, "Member 'UBRPlayerPartDescriptor::AllowedDecalTags' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartDescriptor, DefaultDecalDescriptor) == 0x000168, "Member 'UBRPlayerPartDescriptor::DefaultDecalDescriptor' has a wrong offset!");

// Class Brickadia.BrickTransaction
// 0x0040 (0x0068 - 0x0028)
class UBrickTransaction final : public UObject
{
public:
	class FText                                   Description;                                       // 0x0028(0x0010)(BlueprintVisible, ExposeOnSpawn, NativeAccessSpecifierPublic)
	bool                                          bIsVerbose;                                        // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x2F];                                      // 0x0039(0x002F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAction(int32 Action);

	bool HasAnyWork() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTransaction">();
	}
	static class UBrickTransaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTransaction>();
	}
};
static_assert(alignof(UBrickTransaction) == 0x000008, "Wrong alignment on UBrickTransaction");
static_assert(sizeof(UBrickTransaction) == 0x000068, "Wrong size on UBrickTransaction");
static_assert(offsetof(UBrickTransaction, Description) == 0x000028, "Member 'UBrickTransaction::Description' has a wrong offset!");
static_assert(offsetof(UBrickTransaction, bIsVerbose) == 0x000038, "Member 'UBrickTransaction::bIsVerbose' has a wrong offset!");

// Class Brickadia.BRPresetSubsystem
// 0x0060 (0x0090 - 0x0030)
class UBRPresetSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UBRPresetDescriptor*>            Descriptors;                                       // 0x0030(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, class UBRPresetDescriptor*> DescriptorsByName;                                 // 0x0040(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static bool ValidatePresetName(const class FString& Name_0);

	class UBRPreset* CreatePreset(class UBRPresetDescriptor* Descriptor, const class FString& Name_0);
	bool DeletePreset(class UBRPreset* Preset);
	class UBRPreset* GetPreset(class UBRPresetDescriptor* Descriptor, const class FString& Name_0);
	class UBRPresetDescriptor* GetPresetDescriptor(class FName DescriptorName);
	const TArray<class UBRPresetDescriptor*> GetPresetDescriptors();
	void GetPresetsByType(class UBRPresetDescriptor* Descriptor, TArray<class UBRPreset*>* OutPresets);
	bool HasPreset(const class UBRPresetDescriptor* Descriptor, const class FString& Name_0);
	void OnPresetDescriptorsLoaded();
	bool RenamePreset(class UBRPreset* Preset, const class FString& NewName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPresetSubsystem">();
	}
	static class UBRPresetSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPresetSubsystem>();
	}
};
static_assert(alignof(UBRPresetSubsystem) == 0x000008, "Wrong alignment on UBRPresetSubsystem");
static_assert(sizeof(UBRPresetSubsystem) == 0x000090, "Wrong size on UBRPresetSubsystem");
static_assert(offsetof(UBRPresetSubsystem, Descriptors) == 0x000030, "Member 'UBRPresetSubsystem::Descriptors' has a wrong offset!");
static_assert(offsetof(UBRPresetSubsystem, DescriptorsByName) == 0x000040, "Member 'UBRPresetSubsystem::DescriptorsByName' has a wrong offset!");

// Class Brickadia.BrickTransactionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBrickTransactionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void AppendApplicatorPaste(class UObject* WorldContext, class UBrickTransaction* Transaction, const struct FBrickHandle& BrickHandle, bool bNewVisibility, EBrickCollisionChannels NewCollisionChannels, const TArray<class UBrickComponentTypeBase*>& NewComponentTypes, const TArray<struct FInspectorPropertyChangelist>& NewComponentChangelists);
	static void AppendDeletes(class UBrickTransaction* Transaction, const TArray<struct FBrickPersistentHandle>& PersistentHandles);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTransactionLibrary">();
	}
	static class UBrickTransactionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTransactionLibrary>();
	}
};
static_assert(alignof(UBrickTransactionLibrary) == 0x000008, "Wrong alignment on UBrickTransactionLibrary");
static_assert(sizeof(UBrickTransactionLibrary) == 0x000028, "Wrong size on UBrickTransactionLibrary");

// Class Brickadia.BrickType
// 0x00E0 (0x0108 - 0x0028)
class UBrickType : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Tab;                                               // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Summary;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDisplayInCatalog;                                 // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverridePlacementModeName;                         // 0x0074(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             BodySetup;                                         // 0x0080(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             HalfSize;                                          // 0x0088(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBrickStudGroup>                Studs;                                             // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	TArray<struct FBrickCoverageAABB>             CoverageAABBs;                                     // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x50];                                      // 0x00B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 FindBestStudGroupIndex(EBrickAnchorType Type) const;
	class UBrickAsset* GetBrickAsset() const;
	struct FIntVector GetBrickSize() const;
	struct FIntVector GetHalfSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickType">();
	}
	static class UBrickType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickType>();
	}
};
static_assert(alignof(UBrickType) == 0x000008, "Wrong alignment on UBrickType");
static_assert(sizeof(UBrickType) == 0x000108, "Wrong size on UBrickType");
static_assert(offsetof(UBrickType, DisplayName) == 0x000030, "Member 'UBrickType::DisplayName' has a wrong offset!");
static_assert(offsetof(UBrickType, Category) == 0x000040, "Member 'UBrickType::Category' has a wrong offset!");
static_assert(offsetof(UBrickType, Tab) == 0x000050, "Member 'UBrickType::Tab' has a wrong offset!");
static_assert(offsetof(UBrickType, Summary) == 0x000060, "Member 'UBrickType::Summary' has a wrong offset!");
static_assert(offsetof(UBrickType, bDisplayInCatalog) == 0x000070, "Member 'UBrickType::bDisplayInCatalog' has a wrong offset!");
static_assert(offsetof(UBrickType, OverridePlacementModeName) == 0x000074, "Member 'UBrickType::OverridePlacementModeName' has a wrong offset!");
static_assert(offsetof(UBrickType, BodySetup) == 0x000080, "Member 'UBrickType::BodySetup' has a wrong offset!");
static_assert(offsetof(UBrickType, HalfSize) == 0x000088, "Member 'UBrickType::HalfSize' has a wrong offset!");
static_assert(offsetof(UBrickType, Studs) == 0x000098, "Member 'UBrickType::Studs' has a wrong offset!");
static_assert(offsetof(UBrickType, CoverageAABBs) == 0x0000A8, "Member 'UBrickType::CoverageAABBs' has a wrong offset!");

// Class Brickadia.BrickTypeGenerated
// 0x0008 (0x0110 - 0x0108)
class UBrickTypeGenerated final : public UBrickType
{
public:
	class UBrickTypeGenerator*                    SourceGenerator;                                   // 0x0108(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerated">();
	}
	static class UBrickTypeGenerated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerated>();
	}
};
static_assert(alignof(UBrickTypeGenerated) == 0x000008, "Wrong alignment on UBrickTypeGenerated");
static_assert(sizeof(UBrickTypeGenerated) == 0x000110, "Wrong size on UBrickTypeGenerated");
static_assert(offsetof(UBrickTypeGenerated, SourceGenerator) == 0x000108, "Member 'UBrickTypeGenerated::SourceGenerator' has a wrong offset!");

// Class Brickadia.BRWeaponAnimInstance
// 0x0010 (0x03D0 - 0x03C0)
class UBRWeaponAnimInstance final : public UAnimInstance
{
public:
	class FName                                   LeftHandSocketName;                                // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRCharacter*                           FigureOwner;                                       // 0x03C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRWeaponBase*                          WeaponOwner;                                       // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GetFigureIsValid() const;
	struct FTransform GetLeftHandSocketTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponAnimInstance">();
	}
	static class UBRWeaponAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponAnimInstance>();
	}
};
static_assert(alignof(UBRWeaponAnimInstance) == 0x000010, "Wrong alignment on UBRWeaponAnimInstance");
static_assert(sizeof(UBRWeaponAnimInstance) == 0x0003D0, "Wrong size on UBRWeaponAnimInstance");
static_assert(offsetof(UBRWeaponAnimInstance, LeftHandSocketName) == 0x0003B8, "Member 'UBRWeaponAnimInstance::LeftHandSocketName' has a wrong offset!");
static_assert(offsetof(UBRWeaponAnimInstance, FigureOwner) == 0x0003C0, "Member 'UBRWeaponAnimInstance::FigureOwner' has a wrong offset!");
static_assert(offsetof(UBRWeaponAnimInstance, WeaponOwner) == 0x0003C8, "Member 'UBRWeaponAnimInstance::WeaponOwner' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_Composed
// 0x0070 (0x00C0 - 0x0050)
class UBrickTypeGenerator_Composed final : public UBrickTypeGenerator
{
public:
	class FText                                   DisplayName;                                       // 0x0050(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0060(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Tab;                                               // 0x0070(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FText                                   Summary;                                           // 0x0080(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FName                                   OverridePlacementModeName;                         // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBrickComposedGeneratorLayer>   Layers;                                            // 0x0098(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EBrickComposedNameStyle                       NameStyle;                                         // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMultipleCategories;                               // 0x00A9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FIntVector                             NameBaseSize;                                      // 0x00AC(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNameBaseSize;                                  // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_Composed">();
	}
	static class UBrickTypeGenerator_Composed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_Composed>();
	}
};
static_assert(alignof(UBrickTypeGenerator_Composed) == 0x000008, "Wrong alignment on UBrickTypeGenerator_Composed");
static_assert(sizeof(UBrickTypeGenerator_Composed) == 0x0000C0, "Wrong size on UBrickTypeGenerator_Composed");
static_assert(offsetof(UBrickTypeGenerator_Composed, DisplayName) == 0x000050, "Member 'UBrickTypeGenerator_Composed::DisplayName' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, Category) == 0x000060, "Member 'UBrickTypeGenerator_Composed::Category' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, Tab) == 0x000070, "Member 'UBrickTypeGenerator_Composed::Tab' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, Summary) == 0x000080, "Member 'UBrickTypeGenerator_Composed::Summary' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, OverridePlacementModeName) == 0x000090, "Member 'UBrickTypeGenerator_Composed::OverridePlacementModeName' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, Layers) == 0x000098, "Member 'UBrickTypeGenerator_Composed::Layers' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, NameStyle) == 0x0000A8, "Member 'UBrickTypeGenerator_Composed::NameStyle' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, bMultipleCategories) == 0x0000A9, "Member 'UBrickTypeGenerator_Composed::bMultipleCategories' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, NameBaseSize) == 0x0000AC, "Member 'UBrickTypeGenerator_Composed::NameBaseSize' has a wrong offset!");
static_assert(offsetof(UBrickTypeGenerator_Composed, bHasNameBaseSize) == 0x0000B8, "Member 'UBrickTypeGenerator_Composed::bHasNameBaseSize' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultArch
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultArch : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultArch">();
	}
	static class UBrickTypeGenerator_DefaultArch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultArch>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultArch) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultArch");
static_assert(sizeof(UBrickTypeGenerator_DefaultArch) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultArch");

// Class Brickadia.BrickTypeGenerator_DefaultArchInverted
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultArchInverted final : public UBrickTypeGenerator_DefaultArch
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultArchInverted">();
	}
	static class UBrickTypeGenerator_DefaultArchInverted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultArchInverted>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultArchInverted) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultArchInverted");
static_assert(sizeof(UBrickTypeGenerator_DefaultArchInverted) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultArchInverted");

// Class Brickadia.BrickTypeGenerator_DefaultBrick
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultBrick final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultBrick">();
	}
	static class UBrickTypeGenerator_DefaultBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultBrick>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultBrick) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultBrick");
static_assert(sizeof(UBrickTypeGenerator_DefaultBrick) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultBrick");

// Class Brickadia.BRTabWidget
// 0x0088 (0x0358 - 0x02D0)
class UBRTabWidget : public UUserWidget
{
public:
	class UButton*                                Button;                                            // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ButtonText;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconImage;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UButton>                    SelectedButtonStyle;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UButton>                    DeselectedButtonStyle;                             // 0x02F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnSelected;                                        // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0x10];                                     // 0x0308(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnHovered;                                         // 0x0318(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_328[0x10];                                     // 0x0328(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUnhovered;                                       // 0x0338(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleClicked();
	void HandleHovered();
	void HandleUnhovered();
	void SetTabEnabled(bool bEnabled);
	void SetTabIcon(class UTexture2D* Icon);
	void SetTabText(const class FText& Text);
	void SetTabVisiblySelected(bool bSelected);

	bool GetTabEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTabWidget">();
	}
	static class UBRTabWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTabWidget>();
	}
};
static_assert(alignof(UBRTabWidget) == 0x000008, "Wrong alignment on UBRTabWidget");
static_assert(sizeof(UBRTabWidget) == 0x000358, "Wrong size on UBRTabWidget");
static_assert(offsetof(UBRTabWidget, Button) == 0x0002D0, "Member 'UBRTabWidget::Button' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, ButtonText) == 0x0002D8, "Member 'UBRTabWidget::ButtonText' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, IconImage) == 0x0002E0, "Member 'UBRTabWidget::IconImage' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, SelectedButtonStyle) == 0x0002E8, "Member 'UBRTabWidget::SelectedButtonStyle' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, DeselectedButtonStyle) == 0x0002F0, "Member 'UBRTabWidget::DeselectedButtonStyle' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, OnSelected) == 0x0002F8, "Member 'UBRTabWidget::OnSelected' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, OnHovered) == 0x000318, "Member 'UBRTabWidget::OnHovered' has a wrong offset!");
static_assert(offsetof(UBRTabWidget, OnUnhovered) == 0x000338, "Member 'UBRTabWidget::OnUnhovered' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultMicroBrick
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroBrick final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroBrick">();
	}
	static class UBrickTypeGenerator_DefaultMicroBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroBrick>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroBrick) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroBrick");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroBrick) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroBrick");

// Class Brickadia.BrickTypeGenerator_DefaultMicroRamp
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroRamp final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroRamp">();
	}
	static class UBrickTypeGenerator_DefaultMicroRamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroRamp>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroRamp) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroRamp");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroRamp) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroRamp");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedge
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedge final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedge">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedge>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedge) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedge");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedge) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedge");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeCorner">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeCorner");

// Class Brickadia.BRApplicatorHoverWidget
// 0x0000 (0x02D0 - 0x02D0)
class UBRApplicatorHoverWidget final : public UUserWidget
{
public:
	void Setup(const struct FBrickHandle& BrickHandle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRApplicatorHoverWidget">();
	}
	static class UBRApplicatorHoverWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRApplicatorHoverWidget>();
	}
};
static_assert(alignof(UBRApplicatorHoverWidget) == 0x000008, "Wrong alignment on UBRApplicatorHoverWidget");
static_assert(sizeof(UBRApplicatorHoverWidget) == 0x0002D0, "Wrong size on UBRApplicatorHoverWidget");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCorner");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeHalfInnerCornerInverted");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeHalfOuterCorner");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeInnerCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeInnerCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeInnerCorner">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeInnerCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeInnerCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeInnerCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeInnerCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeInnerCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeInnerCorner");

// Class Brickadia.BRToolPreviewPart_SimpleEntity
// 0x0010 (0x0100 - 0x00F0)
class UBRToolPreviewPart_SimpleEntity final : public UBRToolPreviewPartBase
{
public:
	class UInstancedStaticMeshComponent*          InstancedStaticMesh;                               // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<int32>                                 Instances;                                         // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolPreviewPart_SimpleEntity">();
	}
	static class UBRToolPreviewPart_SimpleEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolPreviewPart_SimpleEntity>();
	}
};
static_assert(alignof(UBRToolPreviewPart_SimpleEntity) == 0x000010, "Wrong alignment on UBRToolPreviewPart_SimpleEntity");
static_assert(sizeof(UBRToolPreviewPart_SimpleEntity) == 0x000100, "Wrong size on UBRToolPreviewPart_SimpleEntity");
static_assert(offsetof(UBRToolPreviewPart_SimpleEntity, InstancedStaticMesh) == 0x0000E8, "Member 'UBRToolPreviewPart_SimpleEntity::InstancedStaticMesh' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewPart_SimpleEntity, Instances) == 0x0000F0, "Member 'UBRToolPreviewPart_SimpleEntity::Instances' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeOuterCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeOuterCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeOuterCorner">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeOuterCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeOuterCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeOuterCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeOuterCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeOuterCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeOuterCorner");

// Class Brickadia.BrickTypeGenerator_DefaultMicroWedgeTriangleCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultMicroWedgeTriangleCorner">();
	}
	static class UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultMicroWedgeTriangleCorner");

// Class Brickadia.BrickTypeGenerator_DefaultPole
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultPole final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultPole">();
	}
	static class UBrickTypeGenerator_DefaultPole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultPole>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultPole) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultPole");
static_assert(sizeof(UBrickTypeGenerator_DefaultPole) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultPole");

// Class Brickadia.BRPlayerController
// 0x0308 (0x0B60 - 0x0858)
class ABRPlayerController final : public APlayerController
{
public:
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(float Damage, bool bContainsHeadshot, bool bContainsKill, bool bContainsBlocked)> OnLocalInstigatedAccumulatedDamage;                // 0x0860(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Damage, bool bContainsHeadshot, const struct FVector& Direction)> OnLocalReceivedAccumulatedDamage;                  // 0x0870(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_880[0x38];                                     // 0x0880(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABRRuleset* Ruleset)> OnJoinRuleset;                                     // 0x08B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                GameTypeComponents;                                // 0x08C8(0x0010)(ExportObject, Net, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8D8[0x10];                                     // 0x08D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bWasFirstPerson;                                   // 0x08E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E9[0x3];                                      // 0x08E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastClearOwnBricksTime;                            // 0x08EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraIsInWater;                                  // 0x08F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F1[0x7];                                      // 0x08F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BackTeleportPosition;                              // 0x08F8(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerState* DeadPlayerState, const class UDamageType* DeathType, class ABRPlayerState* KillerPlayerState)> OnDeathNotification;                               // 0x0910(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerState* RespawnedPlayerState)> OnRespawnNotification;                             // 0x0920(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBrickPreviewManagerComponent*          BrickPreviewManager;                               // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRToolPreviewManagerComponent*         ToolPreviewManager;                                // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickTransactionManagerComponent*      BrickTransactionManager;                           // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRGizmoManagerComponent*               GizmoManagerComponent;                             // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBRGuid& OtherUserId, bool bTrusted)> OnClientSideTrustCacheModified;                    // 0x0950(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_960[0xC0];                                     // 0x0960(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnReceiveTypingInfo;                               // 0x0A20(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FBRGuid& SenderId, const class FString& FormattedMessage, const class FString& UnformattedMessage)> OnReceiveChat;                                     // 0x0A30(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerState* SenderPlayerState, const class FString& Message)> OnPlayerChatMessage;                               // 0x0A40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& NewName)> OnChangeName;                                      // 0x0A50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& StatusMessage, bool bFlashIfUnchanged, bool bAutoClear)> OnReceiveStatusMessage;                            // 0x0A60(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBrickReplicationClient*                BrickReplicationClient;                            // 0x0A70(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBrickReplicationChannel*               BrickReplicationChannel;                           // 0x0A78(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A80[0x20];                                     // 0x0A80(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUploadStart;                                     // 0x0AA0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnUploadDone;                                      // 0x0AB0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(float Progress)> OnUploadProgress;                                  // 0x0AC0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD0[0x70];                                     // 0x0AD0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UBREnvironmentManagerComponent*         EnvironmentSettingsComponent;                      // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRMinigameManagerComponent*            MinigameSettingsComponent;                         // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRServerSettingsManagerComponent*      ServerSettingsComponent;                           // 0x0B50(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRPlayerAvatarManagerComponent*        PlayerAvatarComponent;                             // 0x0B58(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CancelSaveFileUpload();
	bool CheckBrickPermission(const struct FBrickHandle& Brick, class FName Permission, const class FText& NoPermissionMessage, const class FText& NoTrustMessage, bool bMessageUnreliable);
	bool CheckEntityPermission(class AActor* ENTITY, class FName Permission, const class FText& NoPermissionMessage, const class FText& NoTrustMessage, bool bMessageUnreliable);
	bool CheckPermission(class FName Permission, const class FText& NoPermissionMessage, bool bMessageUnreliable);
	void ClearCheckPoint();
	void ClientAckSaveFileUpload(bool bBeginUpload);
	void ClientInstigatedAccumulatedDamage(float Damage, bool bContainsHeadshot, bool bContainsKill, bool bContainsBlocked);
	void ClientModifyTrustCacheEntry(const struct FBRGuid& OtherUserId, bool bTrusted);
	void ClientModifyTrustedByCacheEntry(const struct FBRGuid& OtherUserId, bool bTrustedBy);
	void ClientPlaySound2D(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings);
	void ClientPushChatMessage(const class FString& ChatMessage);
	void ClientPushPlayerChatMessage(const class FString& FormattedChatMessage, const class FString& RawChatMessage, class ABRPlayerState* SenderState);
	void ClientPushStatusMessage(const class FString& StatusMessage, bool bFlashIfUnchanged, bool bAutoClear);
	void ClientPushUnreliableStatusMessage(const class FString& StatusMessage, bool bFlashIfUnchanged, bool bAutoClear);
	void ClientReceivedAccumulatedDamage(float Damage, bool bContainsHeadshot, const struct FVector& Direction);
	void ClientReceiveDeathNotification(class ABRPlayerState* DeadPlayerState, const class UDamageType* DeathType, class ABRPlayerState* KillerPlayerState);
	void ClientReceiveRespawnNotification(class ABRPlayerState* RespawnedPlayerState);
	void ClientReplaceTrustCache(const TArray<struct FBRGuid>& inArray);
	void ClientReplaceTrustedByCache(const TArray<struct FBRGuid>& inArray);
	void ClientRotateControlRotation(const struct FQuat& DeltaQuat);
	void ClientSetControlRotation(const struct FRotator& NewControlRotation);
	void ClientSetIsSpectator(bool bIsSpectator);
	class UActorComponent* GetGameTypeAddedComponent(int32 Index_0);
	void HandlePossessedPawnTakePointDamage(class AActor* DamagedActor, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, class UPrimitiveComponent* HitComponent, class FName BoneName, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser);
	void HandlePossessedPawnTakeRadialDamage(class AActor* DamagedActor, float Damage, const class UDamageType* DamageType, const struct FVector& Origin, const struct FHitResult& HitInfo, class AController* InstigatedBy, class AActor* DamageCauser);
	void JoinMinigame(int32 MinigameId);
	void JoinRuleset(class ABRRuleset* Ruleset, bool bRespawn, bool bAutomatic);
	void JoinRulesetTeam(int32 TeamId, bool bRespawn, bool bMessage);
	void LocalInstigatedAccumulatedDamage(float Damage, bool bContainsHeadshot, bool bContainsKill, bool bContainsBlocked);
	void LocalReceivedAccumulatedDamage(float Damage, bool bContainsHeadshot, const struct FVector& Direction);
	void NotifyCameraEnterWater();
	void NotifyCameraExitWater();
	void OnBrickTemplateLoadReady(class UBrickBuildingTemplate* Template);
	void OnSpectatorStateChange(bool bIsSpectator);
	void ReachGoalPoint(const struct FBrickHandle& GoalPoint);
	void RestartPlayer(bool bRemoveOldCharacter);
	void ServerAddBrickTypeToInventory(const struct FBrickTypeNetWrapper& BrickType, int32 QuickbarRange);
	void ServerAddEntityTypeToInventory(TSubclassOf<class UBREntityTypeBase> EntityType, int32 QuickbarRange);
	void ServerAddItemToInventory(TSubclassOf<class ABRItemBase> ItemType, int32 QuickbarRange);
	void ServerAdminAction_BanPlayer(const struct FBRGuid& VictimId, const struct FDateTime& Expiry, const class FString& Reason);
	void ServerAdminAction_ClearObjects(const struct FBRGuid& VictimId);
	void ServerAdminAction_KickPlayer(const struct FBRGuid& VictimId, const class FString& Reason);
	void ServerAdminAction_Teleport(class ABRPlayerState* From, class ABRPlayerState* To);
	void ServerBeginSaveFileUpload(const class FString& SaveFile, const struct FBrickLoadParams& Params_0, bool bForTemplate, int64 ExpectedTotalSize);
	void ServerCancelSaveFileUpload();
	void ServerClearInventorySlot(int32 Slot);
	void ServerClearInventoryTempSlot();
	void ServerJoinMinigame(int32 MinigameId);
	void ServerJoinRuleset(class ABRRuleset* Ruleset);
	void ServerJoinRulesetTeam(int32 TeamId);
	void ServerNotifyTrustLevelChange(const struct FBRGuid& OtherUserId, bool bTrusted);
	void ServerPushChatMessage(const class FString& ChatMessage);
	void ServerSetInventorySlotBrickType(int32 Slot, const struct FBrickTypeNetWrapper& BrickType);
	void ServerSetInventorySlotEntityType(int32 Slot, TSubclassOf<class UBREntityTypeBase> EntityType);
	void ServerSetInventorySlotItem(int32 Slot, TSubclassOf<class ABRItemBase> ItemType);
	void ServerSetInventoryTempSlotBrickType(const struct FBrickTypeNetWrapper& BrickType);
	void ServerSetInventoryTempSlotEntityType(TSubclassOf<class UBREntityTypeBase> EntityType);
	void ServerSetInventoryTempSlotItem(TSubclassOf<class ABRItemBase> ItemType);
	void ServerSetTyping(bool bTyping);
	void ServerSwapInventorySlots(int32 SlotA, int32 SlotB);
	void SetCheckPoint(const struct FBrickHandle& CheckPoint);
	void SetFreezeCamera(bool bFreeze);
	void SetGlobalTrust(const struct FBRGuid& OtherUserId, bool bTrusted);
	void SetIsSpectator(bool bIsSpectator);
	void SetLoadingIconEnabled(bool bEnabled);
	void SetLoadingIconStatus(const class FText& Text, bool ProgressBar, float Progress);
	bool UploadSaveFile(const class FString& SaveFile, const struct FBrickLoadParams& Params_0, bool bForTemplate, class FString* OutError);

	TArray<class AActor*> GetActorsThisControllerCanSpectate() const;
	class UBRPlayerInput* GetBRPlayerInput() const;
	class ABRPlayerState* GetBRPlayerState() const;
	struct FBrickHandle GetCheckPoint() const;
	bool GetFreezeCamera() const;
	bool GetIsSpectator() const;
	float GetSaveFileUploadProgress() const;
	bool HasLivingCharacter() const;
	bool IsActuallyTrustedBy(const struct FBRGuid& OtherUserId) const;
	bool IsTrustedBy(const struct FBRGuid& OtherUserId) const;
	bool IsTrustedByEveryone() const;
	bool IsUploadingSaveFile() const;
	bool TrustsUserOnServer(const struct FBRGuid& OtherUserId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerController">();
	}
	static class ABRPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlayerController>();
	}
};
static_assert(alignof(ABRPlayerController) == 0x000008, "Wrong alignment on ABRPlayerController");
static_assert(sizeof(ABRPlayerController) == 0x000B60, "Wrong size on ABRPlayerController");
static_assert(offsetof(ABRPlayerController, OnLocalInstigatedAccumulatedDamage) == 0x000860, "Member 'ABRPlayerController::OnLocalInstigatedAccumulatedDamage' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnLocalReceivedAccumulatedDamage) == 0x000870, "Member 'ABRPlayerController::OnLocalReceivedAccumulatedDamage' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnJoinRuleset) == 0x0008B8, "Member 'ABRPlayerController::OnJoinRuleset' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, GameTypeComponents) == 0x0008C8, "Member 'ABRPlayerController::GameTypeComponents' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, bWasFirstPerson) == 0x0008E8, "Member 'ABRPlayerController::bWasFirstPerson' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, LastClearOwnBricksTime) == 0x0008EC, "Member 'ABRPlayerController::LastClearOwnBricksTime' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, bCameraIsInWater) == 0x0008F0, "Member 'ABRPlayerController::bCameraIsInWater' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, BackTeleportPosition) == 0x0008F8, "Member 'ABRPlayerController::BackTeleportPosition' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnDeathNotification) == 0x000910, "Member 'ABRPlayerController::OnDeathNotification' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnRespawnNotification) == 0x000920, "Member 'ABRPlayerController::OnRespawnNotification' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, BrickPreviewManager) == 0x000930, "Member 'ABRPlayerController::BrickPreviewManager' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, ToolPreviewManager) == 0x000938, "Member 'ABRPlayerController::ToolPreviewManager' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, BrickTransactionManager) == 0x000940, "Member 'ABRPlayerController::BrickTransactionManager' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, GizmoManagerComponent) == 0x000948, "Member 'ABRPlayerController::GizmoManagerComponent' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnClientSideTrustCacheModified) == 0x000950, "Member 'ABRPlayerController::OnClientSideTrustCacheModified' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnReceiveTypingInfo) == 0x000A20, "Member 'ABRPlayerController::OnReceiveTypingInfo' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnReceiveChat) == 0x000A30, "Member 'ABRPlayerController::OnReceiveChat' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnPlayerChatMessage) == 0x000A40, "Member 'ABRPlayerController::OnPlayerChatMessage' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnChangeName) == 0x000A50, "Member 'ABRPlayerController::OnChangeName' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnReceiveStatusMessage) == 0x000A60, "Member 'ABRPlayerController::OnReceiveStatusMessage' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, BrickReplicationClient) == 0x000A70, "Member 'ABRPlayerController::BrickReplicationClient' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, BrickReplicationChannel) == 0x000A78, "Member 'ABRPlayerController::BrickReplicationChannel' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnUploadStart) == 0x000AA0, "Member 'ABRPlayerController::OnUploadStart' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnUploadDone) == 0x000AB0, "Member 'ABRPlayerController::OnUploadDone' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, OnUploadProgress) == 0x000AC0, "Member 'ABRPlayerController::OnUploadProgress' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, EnvironmentSettingsComponent) == 0x000B40, "Member 'ABRPlayerController::EnvironmentSettingsComponent' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, MinigameSettingsComponent) == 0x000B48, "Member 'ABRPlayerController::MinigameSettingsComponent' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, ServerSettingsComponent) == 0x000B50, "Member 'ABRPlayerController::ServerSettingsComponent' has a wrong offset!");
static_assert(offsetof(ABRPlayerController, PlayerAvatarComponent) == 0x000B58, "Member 'ABRPlayerController::PlayerAvatarComponent' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultRamp
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRamp final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRamp">();
	}
	static class UBrickTypeGenerator_DefaultRamp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRamp>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRamp) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRamp");
static_assert(sizeof(UBrickTypeGenerator_DefaultRamp) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRamp");

// Class Brickadia.BRManipulatorInputCapturer
// 0x0010 (0x02C0 - 0x02B0)
class ABRManipulatorInputCapturer final : public AActor
{
public:
	TWeakObjectPtr<class ABRTool_Manipulator>     OwnerManipulator;                                  // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class ABRCharacter>            OwnerCharacter;                                    // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void LookUp(float Axis);
	void LookUpRate(float Axis);
	void Turn(float Axis);
	void TurnRate(float Axis);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRManipulatorInputCapturer">();
	}
	static class ABRManipulatorInputCapturer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRManipulatorInputCapturer>();
	}
};
static_assert(alignof(ABRManipulatorInputCapturer) == 0x000008, "Wrong alignment on ABRManipulatorInputCapturer");
static_assert(sizeof(ABRManipulatorInputCapturer) == 0x0002C0, "Wrong size on ABRManipulatorInputCapturer");
static_assert(offsetof(ABRManipulatorInputCapturer, OwnerManipulator) == 0x0002B0, "Member 'ABRManipulatorInputCapturer::OwnerManipulator' has a wrong offset!");
static_assert(offsetof(ABRManipulatorInputCapturer, OwnerCharacter) == 0x0002B8, "Member 'ABRManipulatorInputCapturer::OwnerCharacter' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultRampCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampCorner">();
	}
	static class UBrickTypeGenerator_DefaultRampCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampCorner");

// Class Brickadia.BrickTypeGenerator_DefaultRampCornerInverted
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampCornerInverted final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampCornerInverted">();
	}
	static class UBrickTypeGenerator_DefaultRampCornerInverted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampCornerInverted>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampCornerInverted) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampCornerInverted");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampCornerInverted) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampCornerInverted");

// Class Brickadia.BrickTypeGenerator_DefaultRampCrest
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampCrest final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampCrest">();
	}
	static class UBrickTypeGenerator_DefaultRampCrest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampCrest>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampCrest) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampCrest");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampCrest) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampCrest");

// Class Brickadia.BrickTypeGenerator_DefaultRampCrestCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampCrestCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampCrestCorner">();
	}
	static class UBrickTypeGenerator_DefaultRampCrestCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampCrestCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampCrestCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampCrestCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampCrestCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampCrestCorner");

// Class Brickadia.BrickTypeThumbnailProcessor
// 0x0008 (0x0060 - 0x0058)
class UBrickTypeThumbnailProcessor : public UThumbnailProcessor
{
public:
	class UBrickDebugComponent*                   BrickComponent;                                    // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeThumbnailProcessor">();
	}
	static class UBrickTypeThumbnailProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeThumbnailProcessor>();
	}
};
static_assert(alignof(UBrickTypeThumbnailProcessor) == 0x000008, "Wrong alignment on UBrickTypeThumbnailProcessor");
static_assert(sizeof(UBrickTypeThumbnailProcessor) == 0x000060, "Wrong size on UBrickTypeThumbnailProcessor");
static_assert(offsetof(UBrickTypeThumbnailProcessor, BrickComponent) == 0x000058, "Member 'UBrickTypeThumbnailProcessor::BrickComponent' has a wrong offset!");

// Class Brickadia.BrickAssetThumbnailProcessor
// 0x0000 (0x0060 - 0x0060)
class UBrickAssetThumbnailProcessor final : public UBrickTypeThumbnailProcessor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickAssetThumbnailProcessor">();
	}
	static class UBrickAssetThumbnailProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickAssetThumbnailProcessor>();
	}
};
static_assert(alignof(UBrickAssetThumbnailProcessor) == 0x000008, "Wrong alignment on UBrickAssetThumbnailProcessor");
static_assert(sizeof(UBrickAssetThumbnailProcessor) == 0x000060, "Wrong size on UBrickAssetThumbnailProcessor");

// Class Brickadia.BrickTypeGenerator_DefaultRampCrestEnd
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampCrestEnd final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampCrestEnd">();
	}
	static class UBrickTypeGenerator_DefaultRampCrestEnd* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampCrestEnd>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampCrestEnd) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampCrestEnd");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampCrestEnd) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampCrestEnd");

// Class Brickadia.BrickTypeGenerator_DefaultRampInnerCorner
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampInnerCorner final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampInnerCorner">();
	}
	static class UBrickTypeGenerator_DefaultRampInnerCorner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampInnerCorner>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampInnerCorner) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampInnerCorner");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampInnerCorner) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampInnerCorner");

// Class Brickadia.BrickTypeGenerator_DefaultRampInnerCornerInverted
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampInnerCornerInverted final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampInnerCornerInverted">();
	}
	static class UBrickTypeGenerator_DefaultRampInnerCornerInverted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampInnerCornerInverted>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampInnerCornerInverted) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampInnerCornerInverted");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampInnerCornerInverted) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampInnerCornerInverted");

// Class Brickadia.BRPresetDescriptor
// 0x0020 (0x0050 - 0x0030)
class UBRPresetDescriptor final : public UPrimaryDataAsset
{
public:
	class FName                                   PresetTypeName;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavePath;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Version;                                           // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OpenExplorerOnPath();

	class FString GetPresetPath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPresetDescriptor">();
	}
	static class UBRPresetDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPresetDescriptor>();
	}
};
static_assert(alignof(UBRPresetDescriptor) == 0x000008, "Wrong alignment on UBRPresetDescriptor");
static_assert(sizeof(UBRPresetDescriptor) == 0x000050, "Wrong size on UBRPresetDescriptor");
static_assert(offsetof(UBRPresetDescriptor, PresetTypeName) == 0x000030, "Member 'UBRPresetDescriptor::PresetTypeName' has a wrong offset!");
static_assert(offsetof(UBRPresetDescriptor, SavePath) == 0x000038, "Member 'UBRPresetDescriptor::SavePath' has a wrong offset!");
static_assert(offsetof(UBRPresetDescriptor, Version) == 0x000048, "Member 'UBRPresetDescriptor::Version' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultRampInverted
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultRampInverted final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultRampInverted">();
	}
	static class UBrickTypeGenerator_DefaultRampInverted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultRampInverted>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultRampInverted) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultRampInverted");
static_assert(sizeof(UBrickTypeGenerator_DefaultRampInverted) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultRampInverted");

// Class Brickadia.BRWeaponAmmoWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRWeaponAmmoWidget final : public UUserWidget
{
public:
	class UBRWeaponResource*                      Resource;                                          // 0x02D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlayerSupply;                                  // 0x02D8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Setup(class UBRWeaponResource* InResource, bool bInUsePlayerSupply);
	void UpdateAmmo(int32 Loaded, int32 Loadable, int32 Supply, int32 Supplyable, EBRWeaponResourceUsageOverride ResourceUsageOverride, bool bHideSupply);
	void UpdateWeaponIcon(class UTexture2D* Icon);
	void UpdateWeaponResourceIcon(class UTexture2D* Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponAmmoWidget">();
	}
	static class UBRWeaponAmmoWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponAmmoWidget>();
	}
};
static_assert(alignof(UBRWeaponAmmoWidget) == 0x000008, "Wrong alignment on UBRWeaponAmmoWidget");
static_assert(sizeof(UBRWeaponAmmoWidget) == 0x0002E0, "Wrong size on UBRWeaponAmmoWidget");
static_assert(offsetof(UBRWeaponAmmoWidget, Resource) == 0x0002D0, "Member 'UBRWeaponAmmoWidget::Resource' has a wrong offset!");
static_assert(offsetof(UBRWeaponAmmoWidget, bUsePlayerSupply) == 0x0002D8, "Member 'UBRWeaponAmmoWidget::bUsePlayerSupply' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultSideWedge
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultSideWedge final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultSideWedge">();
	}
	static class UBrickTypeGenerator_DefaultSideWedge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultSideWedge>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultSideWedge) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultSideWedge");
static_assert(sizeof(UBrickTypeGenerator_DefaultSideWedge) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultSideWedge");

// Class Brickadia.BrickTypeGenerator_DefaultSideWedgeTile
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultSideWedgeTile final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultSideWedgeTile">();
	}
	static class UBrickTypeGenerator_DefaultSideWedgeTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultSideWedgeTile>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultSideWedgeTile) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultSideWedgeTile");
static_assert(sizeof(UBrickTypeGenerator_DefaultSideWedgeTile) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultSideWedgeTile");

// Class Brickadia.BrickTypeGenerator_DefaultSmoothTile
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultSmoothTile final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultSmoothTile">();
	}
	static class UBrickTypeGenerator_DefaultSmoothTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultSmoothTile>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultSmoothTile) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultSmoothTile");
static_assert(sizeof(UBrickTypeGenerator_DefaultSmoothTile) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultSmoothTile");

// Class Brickadia.BRTool_Connector
// 0x0148 (0x0738 - 0x05F0)
class ABRTool_Connector final : public ABRToolBase
{
public:
	float                                         Range;                                             // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5F4[0x4];                                      // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRConnectorPortSelectDialog> PortSelectDialogClass;                             // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Audio_CurrentPreviewWireStartLocation;             // 0x0600(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                Audio_CurrentPreviewWireEndLocation;               // 0x0618(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_630[0xF0];                                     // 0x0630(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRConnectorPortSelectDialog*           OpenPortSelectDialog;                              // 0x0720(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_728[0x10];                                     // 0x0728(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Audio_OnClosePortSelector();
	void Audio_OnCreateConnection(const struct FVector& EndPortPos, const struct FVector& EndPortNormal, EBRConnectorDisplayedPortType EndPortType);
	void Audio_OnFinishConnecting();
	void Audio_OnMouseOverPort(const struct FVector& PortPos, const struct FVector& PortNormal, EBRConnectorDisplayedPortType PortType);
	void Audio_OnOpenPortSelector();
	void Audio_OnRemoveConnection(const struct FVector& EndPortPos, const struct FVector& EndPortNormal, EBRConnectorDisplayedPortType EndPortType);
	void Audio_OnStartConnecting(const struct FVector& PortPos, const struct FVector& PortNormal, EBRConnectorDisplayedPortType PortType, const struct FLinearColor& PortColor);
	void ServerConnectOrDisconnectComponentWire(const struct FBrickComponentWirePortRef& SourcePortRef, const struct FBrickComponentWirePortRef& TargetPortRef);
	void ServerDisconnectComponentWirePort(const struct FBrickComponentWirePortRef& PortRef, bool bIsOutputPort);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Connector">();
	}
	static class ABRTool_Connector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Connector>();
	}
};
static_assert(alignof(ABRTool_Connector) == 0x000008, "Wrong alignment on ABRTool_Connector");
static_assert(sizeof(ABRTool_Connector) == 0x000738, "Wrong size on ABRTool_Connector");
static_assert(offsetof(ABRTool_Connector, Range) == 0x0005F0, "Member 'ABRTool_Connector::Range' has a wrong offset!");
static_assert(offsetof(ABRTool_Connector, PortSelectDialogClass) == 0x0005F8, "Member 'ABRTool_Connector::PortSelectDialogClass' has a wrong offset!");
static_assert(offsetof(ABRTool_Connector, Audio_CurrentPreviewWireStartLocation) == 0x000600, "Member 'ABRTool_Connector::Audio_CurrentPreviewWireStartLocation' has a wrong offset!");
static_assert(offsetof(ABRTool_Connector, Audio_CurrentPreviewWireEndLocation) == 0x000618, "Member 'ABRTool_Connector::Audio_CurrentPreviewWireEndLocation' has a wrong offset!");
static_assert(offsetof(ABRTool_Connector, OpenPortSelectDialog) == 0x000720, "Member 'ABRTool_Connector::OpenPortSelectDialog' has a wrong offset!");

// Class Brickadia.BrickTypeGenerator_DefaultStudded
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultStudded final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultStudded">();
	}
	static class UBrickTypeGenerator_DefaultStudded* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultStudded>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultStudded) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultStudded");
static_assert(sizeof(UBrickTypeGenerator_DefaultStudded) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultStudded");

// Class Brickadia.BrickTypeGenerator_DefaultTile
// 0x0000 (0x0050 - 0x0050)
class UBrickTypeGenerator_DefaultTile final : public UBrickTypeGenerator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeGenerator_DefaultTile">();
	}
	static class UBrickTypeGenerator_DefaultTile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeGenerator_DefaultTile>();
	}
};
static_assert(alignof(UBrickTypeGenerator_DefaultTile) == 0x000008, "Wrong alignment on UBrickTypeGenerator_DefaultTile");
static_assert(sizeof(UBrickTypeGenerator_DefaultTile) == 0x000050, "Wrong size on UBrickTypeGenerator_DefaultTile");

// Class Brickadia.BrickTypeNetWrapperStatics
// 0x0000 (0x0028 - 0x0028)
class UBrickTypeNetWrapperStatics final : public UBlueprintFunctionLibrary
{
public:
	static class UBrickType* BreakBrickTypeNetWrapper(const struct FBrickTypeNetWrapper& Wrapper);
	static struct FBrickTypeNetWrapper MakeBrickTypeNetWrapper(class UBrickType* BrickType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickTypeNetWrapperStatics">();
	}
	static class UBrickTypeNetWrapperStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBrickTypeNetWrapperStatics>();
	}
};
static_assert(alignof(UBrickTypeNetWrapperStatics) == 0x000008, "Wrong alignment on UBrickTypeNetWrapperStatics");
static_assert(sizeof(UBrickTypeNetWrapperStatics) == 0x000028, "Wrong size on UBrickTypeNetWrapperStatics");

// Class Brickadia.BRChatCommandWorldSubsystem
// 0x0070 (0x00A8 - 0x0038)
class UBRChatCommandWorldSubsystem final : public UBRWorldSubsystem
{
public:
	TArray<TSubclassOf<class UObject>>            LibraryClasses;                                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, struct FBRRuntimeChatCommandOverloads> ChatCommandTable;                                  // 0x0048(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_98[0x10];                                      // 0x0098(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CheckArgumentTypes(const TArray<class FString>& Arguments, TArray<EBRChatCommandArgType>* ArgTypesOut);
	static void SplitArguments(const class FString& Source, TArray<class FString>* ArgumentsOut);

	void CallChatCommand(class ABRPlayerController* Caller, class FName Command, const class FString& ArgsString);
	void CallChatCommandWithArgs(const struct FBRChatCommandContext& Context, class FName Command, const TArray<class FString>& Args);
	void ShowHelpStringsForCommand(class FName Command, const struct FBRChatCommandContext& Context, bool bAdvanced);

	bool ChatCommandExists(class FName Command) const;
	void GetChatCommandList(TArray<class FName>* Array) const;
	void GetChatCommandMetaDataForAllOverloads(class FName Command, TArray<struct FBRChatCommandMetaData>* Array) const;
	void GetCommandFormatHelpStrings(class FName Command, TArray<class FString>* HelpStrings) const;
	int32 GetNumOverloadsForCommand(class FName Command) const;
	void IsChatCommandCallableForAllOverloads(class FName Command, const class ABRPlayerController* Controller, TArray<bool>* Array) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRChatCommandWorldSubsystem">();
	}
	static class UBRChatCommandWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRChatCommandWorldSubsystem>();
	}
};
static_assert(alignof(UBRChatCommandWorldSubsystem) == 0x000008, "Wrong alignment on UBRChatCommandWorldSubsystem");
static_assert(sizeof(UBRChatCommandWorldSubsystem) == 0x0000A8, "Wrong size on UBRChatCommandWorldSubsystem");
static_assert(offsetof(UBRChatCommandWorldSubsystem, LibraryClasses) == 0x000038, "Member 'UBRChatCommandWorldSubsystem::LibraryClasses' has a wrong offset!");
static_assert(offsetof(UBRChatCommandWorldSubsystem, ChatCommandTable) == 0x000048, "Member 'UBRChatCommandWorldSubsystem::ChatCommandTable' has a wrong offset!");

// Class Brickadia.BRImageCacheSubsystem
// 0x0050 (0x0080 - 0x0030)
class UBRImageCacheSubsystem final : public UEngineSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InvalidateAll();
	void InvalidateImage(const struct FBRImageCacheKey& Key);
	void InvalidateTag(const class FString& Tag);
	class UTexture* RetrieveImage(const struct FBRImageCacheKey& Key);
	void StoreImage(const struct FBRImageCacheKey& Key, class UTexture* Image);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRImageCacheSubsystem">();
	}
	static class UBRImageCacheSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRImageCacheSubsystem>();
	}
};
static_assert(alignof(UBRImageCacheSubsystem) == 0x000008, "Wrong alignment on UBRImageCacheSubsystem");
static_assert(sizeof(UBRImageCacheSubsystem) == 0x000080, "Wrong size on UBRImageCacheSubsystem");

// Class Brickadia.BRImguiSubsystem
// 0x0000 (0x0048 - 0x0048)
class UBRImguiSubsystem final : public UBRTickableWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRImguiSubsystem">();
	}
	static class UBRImguiSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRImguiSubsystem>();
	}
};
static_assert(alignof(UBRImguiSubsystem) == 0x000008, "Wrong alignment on UBRImguiSubsystem");
static_assert(sizeof(UBRImguiSubsystem) == 0x000048, "Wrong size on UBRImguiSubsystem");

// Class Brickadia.BRRulesetMember
// 0x0000 (0x0028 - 0x0028)
class IBRRulesetMember : public IInterface
{
public:
	class UBRRulesetTeam* GetAffiliatedTeam() const;
	class ABRPlayerState* GetOwningMemberState() const;
	class ABRRuleset* GetRuleset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRulesetMember">();
	}
	static class IBRRulesetMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBRRulesetMember>();
	}
};
static_assert(alignof(IBRRulesetMember) == 0x000008, "Wrong alignment on IBRRulesetMember");
static_assert(sizeof(IBRRulesetMember) == 0x000028, "Wrong size on IBRRulesetMember");

// Class Brickadia.BRInputIconConfig
// 0x0058 (0x0088 - 0x0030)
class UBRInputIconConfig final : public UDataAsset
{
public:
	TMap<EBRInputDeviceType, class UBRInputIconSet*> IconSets;                                          // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBRInputKeyDisplayNames*                FallbackDisplayNames;                              // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputIconConfig">();
	}
	static class UBRInputIconConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputIconConfig>();
	}
};
static_assert(alignof(UBRInputIconConfig) == 0x000008, "Wrong alignment on UBRInputIconConfig");
static_assert(sizeof(UBRInputIconConfig) == 0x000088, "Wrong size on UBRInputIconConfig");
static_assert(offsetof(UBRInputIconConfig, IconSets) == 0x000030, "Member 'UBRInputIconConfig::IconSets' has a wrong offset!");
static_assert(offsetof(UBRInputIconConfig, FallbackDisplayNames) == 0x000080, "Member 'UBRInputIconConfig::FallbackDisplayNames' has a wrong offset!");

// Class Brickadia.BRInputIconPartWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRInputIconPartWidget final : public UUserWidget
{
public:
	class UTexture2D*                             Icon;                                              // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 IconImage;                                         // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetIcon(class UTexture2D* InIcon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputIconPartWidget">();
	}
	static class UBRInputIconPartWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputIconPartWidget>();
	}
};
static_assert(alignof(UBRInputIconPartWidget) == 0x000008, "Wrong alignment on UBRInputIconPartWidget");
static_assert(sizeof(UBRInputIconPartWidget) == 0x0002E0, "Wrong size on UBRInputIconPartWidget");
static_assert(offsetof(UBRInputIconPartWidget, Icon) == 0x0002D0, "Member 'UBRInputIconPartWidget::Icon' has a wrong offset!");
static_assert(offsetof(UBRInputIconPartWidget, IconImage) == 0x0002D8, "Member 'UBRInputIconPartWidget::IconImage' has a wrong offset!");

// Class Brickadia.BRInputIconWidget
// 0x0110 (0x03E0 - 0x02D0)
class UBRInputIconWidget final : public UUserWidget
{
public:
	class UBRInputIconConfig*                     IconConfig;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceFallbackDisplayNames;                        // 0x02D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D9[0x7];                                      // 0x02D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRInputIconFallbackPartWidget> FallbackPartClass;                                 // 0x02E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRInputIconPartWidget>     IconPartClass;                                     // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRInputDeviceType                            InputDeviceType;                                   // 0x02F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUpdateInputDeviceType;                        // 0x02F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoUpdateControllerInputDeviceType;              // 0x02F2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F3[0x1];                                      // 0x02F3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InputName;                                         // 0x02F4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAxis;                                           // 0x02FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2FD[0x3];                                      // 0x02FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           PartsPanel;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_308[0xD8];                                     // 0x0308(0x00D8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleInputBindingsChanged(class UBRGameSettingsBase* SettingsObject);
	void SetInput(class FName InInputName, bool bInIsAxis);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInputIconWidget">();
	}
	static class UBRInputIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInputIconWidget>();
	}
};
static_assert(alignof(UBRInputIconWidget) == 0x000008, "Wrong alignment on UBRInputIconWidget");
static_assert(sizeof(UBRInputIconWidget) == 0x0003E0, "Wrong size on UBRInputIconWidget");
static_assert(offsetof(UBRInputIconWidget, IconConfig) == 0x0002D0, "Member 'UBRInputIconWidget::IconConfig' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, bForceFallbackDisplayNames) == 0x0002D8, "Member 'UBRInputIconWidget::bForceFallbackDisplayNames' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, FallbackPartClass) == 0x0002E0, "Member 'UBRInputIconWidget::FallbackPartClass' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, IconPartClass) == 0x0002E8, "Member 'UBRInputIconWidget::IconPartClass' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, InputDeviceType) == 0x0002F0, "Member 'UBRInputIconWidget::InputDeviceType' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, bAutoUpdateInputDeviceType) == 0x0002F1, "Member 'UBRInputIconWidget::bAutoUpdateInputDeviceType' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, bAutoUpdateControllerInputDeviceType) == 0x0002F2, "Member 'UBRInputIconWidget::bAutoUpdateControllerInputDeviceType' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, InputName) == 0x0002F4, "Member 'UBRInputIconWidget::InputName' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, bIsAxis) == 0x0002FC, "Member 'UBRInputIconWidget::bIsAxis' has a wrong offset!");
static_assert(offsetof(UBRInputIconWidget, PartsPanel) == 0x000300, "Member 'UBRInputIconWidget::PartsPanel' has a wrong offset!");

// Class Brickadia.BRInventoryEntryBase
// 0x0008 (0x0030 - 0x0028)
class UBRInventoryEntryBase : public UObject
{
public:
	class UBRInventoryComponent*                  OwningInventory;                                   // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClientEntryReady();

	class ABRItemBase* GetItemInstance() const;
	class ABRCharacter* GetOwningBRCharacter() const;
	class ABRPlayerController* GetOwningBRPlayerController() const;
	class ABRPlayerState* GetOwningBRPlayerState() const;
	class UBRInventoryComponent* GetOwningInventory() const;
	class UObject* GetSubType() const;
	class UObject* GetThumbnailObject() const;
	TSubclassOf<class UThumbnailProcessor> GetThumbnailProcessor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryEntryBase">();
	}
	static class UBRInventoryEntryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryEntryBase>();
	}
};
static_assert(alignof(UBRInventoryEntryBase) == 0x000008, "Wrong alignment on UBRInventoryEntryBase");
static_assert(sizeof(UBRInventoryEntryBase) == 0x000030, "Wrong size on UBRInventoryEntryBase");
static_assert(offsetof(UBRInventoryEntryBase, OwningInventory) == 0x000028, "Member 'UBRInventoryEntryBase::OwningInventory' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptorList_Color
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_Color final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_Color">();
	}
	static class UInspectorPropertyDescriptorList_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_Color>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_Color) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_Color");
static_assert(sizeof(UInspectorPropertyDescriptorList_Color) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_Color");

// Class Brickadia.BRInventoryEntry_Item
// 0x0010 (0x0040 - 0x0030)
class UBRInventoryEntry_Item final : public UBRInventoryEntryBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRItemBase*                            ItemInstance;                                      // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class ABRItemBase> GetItemType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryEntry_Item">();
	}
	static class UBRInventoryEntry_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryEntry_Item>();
	}
};
static_assert(alignof(UBRInventoryEntry_Item) == 0x000008, "Wrong alignment on UBRInventoryEntry_Item");
static_assert(sizeof(UBRInventoryEntry_Item) == 0x000040, "Wrong size on UBRInventoryEntry_Item");
static_assert(offsetof(UBRInventoryEntry_Item, ItemInstance) == 0x000038, "Member 'UBRInventoryEntry_Item::ItemInstance' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_MeleeBase
// 0x0060 (0x0088 - 0x0028)
class UBRWeaponStateBehavior_MeleeBase : public UBRWeaponStateBehavior
{
public:
	class FName                                   ColliderComponentTag;                              // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRWeaponMeleeResponse                 MissResponse;                                      // 0x0031(0x0001)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRWeaponMeleeOverlapResponse          NonDamageableOverlapResponse;                      // 0x0038(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRWeaponMeleeOverlapResponseDamageable DamageableOverlapResponse;                         // 0x0050(0x0038)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_MeleeBase">();
	}
	static class UBRWeaponStateBehavior_MeleeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_MeleeBase>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_MeleeBase) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_MeleeBase");
static_assert(sizeof(UBRWeaponStateBehavior_MeleeBase) == 0x000088, "Wrong size on UBRWeaponStateBehavior_MeleeBase");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeBase, ColliderComponentTag) == 0x000028, "Member 'UBRWeaponStateBehavior_MeleeBase::ColliderComponentTag' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeBase, bTraceComplex) == 0x000030, "Member 'UBRWeaponStateBehavior_MeleeBase::bTraceComplex' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeBase, MissResponse) == 0x000031, "Member 'UBRWeaponStateBehavior_MeleeBase::MissResponse' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeBase, NonDamageableOverlapResponse) == 0x000038, "Member 'UBRWeaponStateBehavior_MeleeBase::NonDamageableOverlapResponse' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeBase, DamageableOverlapResponse) == 0x000050, "Member 'UBRWeaponStateBehavior_MeleeBase::DamageableOverlapResponse' has a wrong offset!");

// Class Brickadia.BRInventoryEntry_BrickType
// 0x0020 (0x0050 - 0x0030)
class UBRInventoryEntry_BrickType final : public UBRInventoryEntryBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickTypeNetWrapper                   BrickType;                                         // 0x0038(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBrickType* GetBrickType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryEntry_BrickType">();
	}
	static class UBRInventoryEntry_BrickType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryEntry_BrickType>();
	}
};
static_assert(alignof(UBRInventoryEntry_BrickType) == 0x000008, "Wrong alignment on UBRInventoryEntry_BrickType");
static_assert(sizeof(UBRInventoryEntry_BrickType) == 0x000050, "Wrong size on UBRInventoryEntry_BrickType");
static_assert(offsetof(UBRInventoryEntry_BrickType, BrickType) == 0x000038, "Member 'UBRInventoryEntry_BrickType::BrickType' has a wrong offset!");

// Class Brickadia.BRInventoryEntry_EntityType
// 0x0010 (0x0040 - 0x0030)
class UBRInventoryEntry_EntityType final : public UBRInventoryEntryBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBREntityTypeBase*                      EntityType;                                        // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UBREntityTypeBase* GetEntityType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryEntry_EntityType">();
	}
	static class UBRInventoryEntry_EntityType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryEntry_EntityType>();
	}
};
static_assert(alignof(UBRInventoryEntry_EntityType) == 0x000008, "Wrong alignment on UBRInventoryEntry_EntityType");
static_assert(sizeof(UBRInventoryEntry_EntityType) == 0x000040, "Wrong size on UBRInventoryEntry_EntityType");
static_assert(offsetof(UBRInventoryEntry_EntityType, EntityType) == 0x000038, "Member 'UBRInventoryEntry_EntityType::EntityType' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Int64
// 0x0018 (0x00A0 - 0x0088)
class UInspectorPropertyDescriptor_Int64 final : public UInspectorPropertyDescriptor
{
public:
	int64                                         ClampMin;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         ClampMax;                                          // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseClampMin;                                      // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseClampMax;                                      // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Int64">();
	}
	static class UInspectorPropertyDescriptor_Int64* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Int64>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Int64) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Int64");
static_assert(sizeof(UInspectorPropertyDescriptor_Int64) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_Int64");
static_assert(offsetof(UInspectorPropertyDescriptor_Int64, ClampMin) == 0x000088, "Member 'UInspectorPropertyDescriptor_Int64::ClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int64, ClampMax) == 0x000090, "Member 'UInspectorPropertyDescriptor_Int64::ClampMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int64, bUseClampMin) == 0x000098, "Member 'UInspectorPropertyDescriptor_Int64::bUseClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int64, bUseClampMax) == 0x000099, "Member 'UInspectorPropertyDescriptor_Int64::bUseClampMax' has a wrong offset!");

// Class Brickadia.BRInventoryEntry_Template
// 0x0098 (0x00C8 - 0x0030)
class UBRInventoryEntry_Template final : public UBRInventoryEntryBase
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBrickBuildingTemplate*                 Template;                                          // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBrickTemplatePlacementInfo            PlacementInfo;                                     // 0x0040(0x0088)(Net, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryEntry_Template">();
	}
	static class UBRInventoryEntry_Template* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryEntry_Template>();
	}
};
static_assert(alignof(UBRInventoryEntry_Template) == 0x000008, "Wrong alignment on UBRInventoryEntry_Template");
static_assert(sizeof(UBRInventoryEntry_Template) == 0x0000C8, "Wrong size on UBRInventoryEntry_Template");
static_assert(offsetof(UBRInventoryEntry_Template, Template) == 0x000038, "Member 'UBRInventoryEntry_Template::Template' has a wrong offset!");
static_assert(offsetof(UBRInventoryEntry_Template, PlacementInfo) == 0x000040, "Member 'UBRInventoryEntry_Template::PlacementInfo' has a wrong offset!");

// Class Brickadia.BRInventoryComponent
// 0x0060 (0x0108 - 0x00A8)
class UBRInventoryComponent final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void(int32 Size)>    OnSizeChanged;                                     // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Slot, class UBRInventoryEntryBase* Entry)> OnSlotChanged;                                     // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRInventoryEntryBase* Entry)> OnTempSlotChanged;                                 // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBRInventoryEntryBase*                  TempSlot;                                          // 0x00D8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UBRInventoryEntryBase*>          Entries;                                           // 0x00E0(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	int32                                         DefaultSize;                                       // 0x00F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRPlayerController*                    OwningPlayerController;                            // 0x00F8(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ABRPlayerState*                         OwningPlayerState;                                 // 0x0100(0x0008)(Net, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UBRInventoryEntryBase* AddEntry(TSubclassOf<class UBRInventoryEntryBase> Type, class UObject* SubType, int32 QuickbarRange);
	class UBRInventoryEntryBase* AddEntry2(TSubclassOf<class UBRInventoryEntryBase> Type, class UClass* SubType, int32 QuickbarRange);
	void Clear();
	void OnClientEntryReady(class UBRInventoryEntryBase* Entry);
	void OnRep_Items(const TArray<class UBRInventoryEntryBase*>& OldItems);
	void OnRep_TempSlot();
	int32 PushbackQuickbarRange(int32 Range);
	void SetNum(int32 NewSize);
	class UBRInventoryEntryBase* SetSlotEntry(int32 Slot, TSubclassOf<class UBRInventoryEntryBase> Type, class UObject* SubType);
	class UBRInventoryEntryBase* SetSlotEntry2(int32 Slot, TSubclassOf<class UBRInventoryEntryBase> Type, class UClass* SubType);
	class UBRInventoryEntryBase* SetTempSlotEntry(TSubclassOf<class UBRInventoryEntryBase> Type, class UObject* SubType);
	class UBRInventoryEntryBase* SetTempSlotEntry2(TSubclassOf<class UBRInventoryEntryBase> Type, class UClass* SubType);
	void SwapSlots(int32 SlotA, int32 SlotB);

	bool Contains(class UBRInventoryEntryBase* Item) const;
	class ABRCharacter* GetOwningBRCharacter() const;
	class ABRPlayerController* GetOwningBRPlayerController() const;
	class ABRPlayerState* GetOwningBRPlayerState() const;
	class UBRInventoryEntryBase* GetSlotEntry(int32 Slot) const;
	class UBRInventoryEntryBase* GetTempSlot() const;
	int32 IndexOf(class UBRInventoryEntryBase* Item) const;
	int32 IndexOfInQuickbarRange(const class UBRInventoryEntryBase* Item, int32 Range) const;
	int32 Num() const;
	bool QuickbarRangeContains(const class UBRInventoryEntryBase* Item, int32 Range) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryComponent">();
	}
	static class UBRInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryComponent>();
	}
};
static_assert(alignof(UBRInventoryComponent) == 0x000008, "Wrong alignment on UBRInventoryComponent");
static_assert(sizeof(UBRInventoryComponent) == 0x000108, "Wrong size on UBRInventoryComponent");
static_assert(offsetof(UBRInventoryComponent, OnSizeChanged) == 0x0000A8, "Member 'UBRInventoryComponent::OnSizeChanged' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, OnSlotChanged) == 0x0000B8, "Member 'UBRInventoryComponent::OnSlotChanged' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, OnTempSlotChanged) == 0x0000C8, "Member 'UBRInventoryComponent::OnTempSlotChanged' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, TempSlot) == 0x0000D8, "Member 'UBRInventoryComponent::TempSlot' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, Entries) == 0x0000E0, "Member 'UBRInventoryComponent::Entries' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, DefaultSize) == 0x0000F0, "Member 'UBRInventoryComponent::DefaultSize' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, OwningPlayerController) == 0x0000F8, "Member 'UBRInventoryComponent::OwningPlayerController' has a wrong offset!");
static_assert(offsetof(UBRInventoryComponent, OwningPlayerState) == 0x000100, "Member 'UBRInventoryComponent::OwningPlayerState' has a wrong offset!");

// Class Brickadia.BRInventoryEntryDragVisual
// 0x0008 (0x02D8 - 0x02D0)
class UBRInventoryEntryDragVisual final : public UUserWidget
{
public:
	class UGenericThumbnailWidget*                Thumbnail;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryEntryDragVisual">();
	}
	static class UBRInventoryEntryDragVisual* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryEntryDragVisual>();
	}
};
static_assert(alignof(UBRInventoryEntryDragVisual) == 0x000008, "Wrong alignment on UBRInventoryEntryDragVisual");
static_assert(sizeof(UBRInventoryEntryDragVisual) == 0x0002D8, "Wrong size on UBRInventoryEntryDragVisual");
static_assert(offsetof(UBRInventoryEntryDragVisual, Thumbnail) == 0x0002D0, "Member 'UBRInventoryEntryDragVisual::Thumbnail' has a wrong offset!");

// Class Brickadia.BRInventorySlotWidget
// 0x0058 (0x0328 - 0x02D0)
class UBRInventorySlotWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x30];                                     // 0x02D0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x0300(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRInventoryEntryBase*                  DisplayedEntry;                                    // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             QuickbarIndexText;                                 // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGenericThumbnailWidget*                Thumbnail;                                         // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRInventoryEntryDragVisual> DragVisualClass;                                   // 0x0320(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetBeingDraggedVisual(bool bDragged);
	void SetDisplayedEntry(class UBRInventoryEntryBase* Entry);
	void SetSelectedVisual(bool bSelected);
	void Setup(int32 InSlotIndex, bool bHideQuickbarNumber);

	class UBRInventoryEntryBase* GetDisplayedEntry() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventorySlotWidget">();
	}
	static class UBRInventorySlotWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventorySlotWidget>();
	}
};
static_assert(alignof(UBRInventorySlotWidget) == 0x000008, "Wrong alignment on UBRInventorySlotWidget");
static_assert(sizeof(UBRInventorySlotWidget) == 0x000328, "Wrong size on UBRInventorySlotWidget");
static_assert(offsetof(UBRInventorySlotWidget, SlotIndex) == 0x000300, "Member 'UBRInventorySlotWidget::SlotIndex' has a wrong offset!");
static_assert(offsetof(UBRInventorySlotWidget, DisplayedEntry) == 0x000308, "Member 'UBRInventorySlotWidget::DisplayedEntry' has a wrong offset!");
static_assert(offsetof(UBRInventorySlotWidget, QuickbarIndexText) == 0x000310, "Member 'UBRInventorySlotWidget::QuickbarIndexText' has a wrong offset!");
static_assert(offsetof(UBRInventorySlotWidget, Thumbnail) == 0x000318, "Member 'UBRInventorySlotWidget::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRInventorySlotWidget, DragVisualClass) == 0x000320, "Member 'UBRInventorySlotWidget::DragVisualClass' has a wrong offset!");

// Class Brickadia.BRInventorySlotDragDropOperation
// 0x0010 (0x00A0 - 0x0090)
class UBRInventorySlotDragDropOperation final : public UDragDropOperation
{
public:
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRInventorySlotWidget*                 SlotWidget;                                        // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventorySlotDragDropOperation">();
	}
	static class UBRInventorySlotDragDropOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventorySlotDragDropOperation>();
	}
};
static_assert(alignof(UBRInventorySlotDragDropOperation) == 0x000008, "Wrong alignment on UBRInventorySlotDragDropOperation");
static_assert(sizeof(UBRInventorySlotDragDropOperation) == 0x0000A0, "Wrong size on UBRInventorySlotDragDropOperation");
static_assert(offsetof(UBRInventorySlotDragDropOperation, SlotWidget) == 0x000098, "Member 'UBRInventorySlotDragDropOperation::SlotWidget' has a wrong offset!");

// Class Brickadia.BRInventoryWidget
// 0x0028 (0x02F8 - 0x02D0)
class UBRInventoryWidget final : public UUserWidget
{
public:
	TSubclassOf<class UBRInventorySlotWidget>     SlotWidgetClass;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           InventoryContainer;                                // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBRInventorySlotWidget*>         SlotWidgets;                                       // 0x02E0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBRInventoryComponent*                  Inventory;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Setup(class UBRInventoryComponent* InInventory);
	void SetupInternal(int32 NewSize);
	void SlotChanged(int32 SlotIndex, class UBRInventoryEntryBase* ItemInstance);

	class UBRInventoryComponent* GetInventory() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRInventoryWidget">();
	}
	static class UBRInventoryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRInventoryWidget>();
	}
};
static_assert(alignof(UBRInventoryWidget) == 0x000008, "Wrong alignment on UBRInventoryWidget");
static_assert(sizeof(UBRInventoryWidget) == 0x0002F8, "Wrong size on UBRInventoryWidget");
static_assert(offsetof(UBRInventoryWidget, SlotWidgetClass) == 0x0002D0, "Member 'UBRInventoryWidget::SlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRInventoryWidget, InventoryContainer) == 0x0002D8, "Member 'UBRInventoryWidget::InventoryContainer' has a wrong offset!");
static_assert(offsetof(UBRInventoryWidget, SlotWidgets) == 0x0002E0, "Member 'UBRInventoryWidget::SlotWidgets' has a wrong offset!");
static_assert(offsetof(UBRInventoryWidget, Inventory) == 0x0002F0, "Member 'UBRInventoryWidget::Inventory' has a wrong offset!");

// Class Brickadia.BRWorldEmptyDetailsPanel
// 0x0010 (0x02E0 - 0x02D0)
class UBRWorldEmptyDetailsPanel : public UUserWidget
{
public:
	class UBRDialogFrameBase*                     DialogFrame;                                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         MetadataText;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldEmptyDetailsPanel">();
	}
	static class UBRWorldEmptyDetailsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldEmptyDetailsPanel>();
	}
};
static_assert(alignof(UBRWorldEmptyDetailsPanel) == 0x000008, "Wrong alignment on UBRWorldEmptyDetailsPanel");
static_assert(sizeof(UBRWorldEmptyDetailsPanel) == 0x0002E0, "Wrong size on UBRWorldEmptyDetailsPanel");
static_assert(offsetof(UBRWorldEmptyDetailsPanel, DialogFrame) == 0x0002D0, "Member 'UBRWorldEmptyDetailsPanel::DialogFrame' has a wrong offset!");
static_assert(offsetof(UBRWorldEmptyDetailsPanel, MetadataText) == 0x0002D8, "Member 'UBRWorldEmptyDetailsPanel::MetadataText' has a wrong offset!");

// Class Brickadia.BRQuickbarDisplayWidget
// 0x0078 (0x0348 - 0x02D0)
class UBRQuickbarDisplayWidget : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(int32 ViewSlot)> OnRangeChanged;                                    // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRCharacter* Character, int32 ViewSlot)> OnCharacterAndRangeChanged;                        // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPanelWidget*                           ToolSlot;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRInventorySlotWidget>     SlotWidgetClass;                                   // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         InventoryContainer;                                // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBRInventorySlotWidget*>         SlotWidgets;                                       // 0x0308(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UBRInventorySlotWidget*                 TempSlotWidget;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SWITCH;                                            // 0x0320(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SwitchNext;                                        // 0x0328(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetAnimation*                       SwitchPrev;                                        // 0x0330(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABRCharacter*                           Character;                                         // 0x0338(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuickbarRange;                                     // 0x0340(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuickbarRangeLength;                               // 0x0344(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CharacterInventoryEntryChanged(class UBRInventoryEntryBase* Entry);
	void SelectNextQuickbarRange();
	void SelectPreviousQuickbarRange();
	void SetQuickbarRange(int32 NewQuickbarRange);
	void Setup(class ABRCharacter* InCharacter, int32 InitialQuickbarRange);
	void SetupInternal(int32 NewSize);
	void SlotChanged(int32 SlotIndex, class UBRInventoryEntryBase* ItemInstance);
	void TempSlotChanged(class UBRInventoryEntryBase* ItemInstance);

	class ABRCharacter* GetCharacter() const;
	int32 GetQuickbarRange() const;
	bool InventoryHasNextQuickbarRange() const;
	bool InventoryHasPreviousQuickbarRange() const;
	bool InventoryHasQuickbarRange(int32 NewQuickbarRange) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRQuickbarDisplayWidget">();
	}
	static class UBRQuickbarDisplayWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRQuickbarDisplayWidget>();
	}
};
static_assert(alignof(UBRQuickbarDisplayWidget) == 0x000008, "Wrong alignment on UBRQuickbarDisplayWidget");
static_assert(sizeof(UBRQuickbarDisplayWidget) == 0x000348, "Wrong size on UBRQuickbarDisplayWidget");
static_assert(offsetof(UBRQuickbarDisplayWidget, OnRangeChanged) == 0x0002D0, "Member 'UBRQuickbarDisplayWidget::OnRangeChanged' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, OnCharacterAndRangeChanged) == 0x0002E0, "Member 'UBRQuickbarDisplayWidget::OnCharacterAndRangeChanged' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, ToolSlot) == 0x0002F0, "Member 'UBRQuickbarDisplayWidget::ToolSlot' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, SlotWidgetClass) == 0x0002F8, "Member 'UBRQuickbarDisplayWidget::SlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, InventoryContainer) == 0x000300, "Member 'UBRQuickbarDisplayWidget::InventoryContainer' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, SlotWidgets) == 0x000308, "Member 'UBRQuickbarDisplayWidget::SlotWidgets' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, TempSlotWidget) == 0x000318, "Member 'UBRQuickbarDisplayWidget::TempSlotWidget' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, SWITCH) == 0x000320, "Member 'UBRQuickbarDisplayWidget::SWITCH' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, SwitchNext) == 0x000328, "Member 'UBRQuickbarDisplayWidget::SwitchNext' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, SwitchPrev) == 0x000330, "Member 'UBRQuickbarDisplayWidget::SwitchPrev' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, Character) == 0x000338, "Member 'UBRQuickbarDisplayWidget::Character' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, QuickbarRange) == 0x000340, "Member 'UBRQuickbarDisplayWidget::QuickbarRange' has a wrong offset!");
static_assert(offsetof(UBRQuickbarDisplayWidget, QuickbarRangeLength) == 0x000344, "Member 'UBRQuickbarDisplayWidget::QuickbarRangeLength' has a wrong offset!");

// Class Brickadia.BRQuickbarWidget
// 0x0030 (0x0378 - 0x0348)
class UBRQuickbarWidget final : public UBRQuickbarDisplayWidget
{
public:
	TMulticastInlineDelegate<void(int32 ViewSlot, int32 InventorySlot)> OnSlotSelectionChanged;                            // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIgnoreScroll;                                     // 0x0358(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_359[0x3];                                      // 0x0359(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedViewSlot;                                  // 0x035C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectedInventorySlot;                             // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_364[0x4];                                      // 0x0364(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       ShowHide;                                          // 0x0368(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSelectedViewSlot();
	void InternalSelectViewSlot(int32 SlotIndex);
	void SelectNextViewSlot();
	void SelectPreviousViewSlot();
	void SelectViewSlot(int32 SlotIndex, bool bToggle);
	void SetShownInstant(bool bNewShown);
	void ToggleOpen();

	int32 GetSelectedInventorySlot() const;
	int32 GetSelectedViewSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRQuickbarWidget">();
	}
	static class UBRQuickbarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRQuickbarWidget>();
	}
};
static_assert(alignof(UBRQuickbarWidget) == 0x000008, "Wrong alignment on UBRQuickbarWidget");
static_assert(sizeof(UBRQuickbarWidget) == 0x000378, "Wrong size on UBRQuickbarWidget");
static_assert(offsetof(UBRQuickbarWidget, OnSlotSelectionChanged) == 0x000348, "Member 'UBRQuickbarWidget::OnSlotSelectionChanged' has a wrong offset!");
static_assert(offsetof(UBRQuickbarWidget, bIgnoreScroll) == 0x000358, "Member 'UBRQuickbarWidget::bIgnoreScroll' has a wrong offset!");
static_assert(offsetof(UBRQuickbarWidget, SelectedViewSlot) == 0x00035C, "Member 'UBRQuickbarWidget::SelectedViewSlot' has a wrong offset!");
static_assert(offsetof(UBRQuickbarWidget, SelectedInventorySlot) == 0x000360, "Member 'UBRQuickbarWidget::SelectedInventorySlot' has a wrong offset!");
static_assert(offsetof(UBRQuickbarWidget, ShowHide) == 0x000368, "Member 'UBRQuickbarWidget::ShowHide' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Vector3f
// 0x0028 (0x00C0 - 0x0098)
class UInspectorPropertyDescriptor_Vector3f final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	float                                         UIStep;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIMin;                                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIMax;                                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMin;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         UnderlyingUnit;                                    // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         DisplayUnit;                                       // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinFractionalDigits;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFractionalDigits;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseUIStep : 1;                                    // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMin : 1;                                     // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMax : 1;                                     // 0x00B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMin : 1;                                  // 0x00B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMax : 1;                                  // 0x00B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDisplayUnit : 1;                               // 0x00B8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLiveSlider : 1;                                   // 0x00B8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Vector3f">();
	}
	static class UInspectorPropertyDescriptor_Vector3f* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Vector3f>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Vector3f) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Vector3f");
static_assert(sizeof(UInspectorPropertyDescriptor_Vector3f) == 0x0000C0, "Wrong size on UInspectorPropertyDescriptor_Vector3f");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, UIStep) == 0x000098, "Member 'UInspectorPropertyDescriptor_Vector3f::UIStep' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, UIMin) == 0x00009C, "Member 'UInspectorPropertyDescriptor_Vector3f::UIMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, UIMax) == 0x0000A0, "Member 'UInspectorPropertyDescriptor_Vector3f::UIMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, ClampMin) == 0x0000A4, "Member 'UInspectorPropertyDescriptor_Vector3f::ClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, ClampMax) == 0x0000A8, "Member 'UInspectorPropertyDescriptor_Vector3f::ClampMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, UnderlyingUnit) == 0x0000AC, "Member 'UInspectorPropertyDescriptor_Vector3f::UnderlyingUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, DisplayUnit) == 0x0000AD, "Member 'UInspectorPropertyDescriptor_Vector3f::DisplayUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, MinFractionalDigits) == 0x0000B0, "Member 'UInspectorPropertyDescriptor_Vector3f::MinFractionalDigits' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector3f, MaxFractionalDigits) == 0x0000B4, "Member 'UInspectorPropertyDescriptor_Vector3f::MaxFractionalDigits' has a wrong offset!");

// Class Brickadia.BRLocalPlayer
// 0x0008 (0x02B8 - 0x02B0)
class UBRLocalPlayer final : public ULocalPlayer
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRLocalPlayer">();
	}
	static class UBRLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRLocalPlayer>();
	}
};
static_assert(alignof(UBRLocalPlayer) == 0x000008, "Wrong alignment on UBRLocalPlayer");
static_assert(sizeof(UBRLocalPlayer) == 0x0002B8, "Wrong size on UBRLocalPlayer");

// Class Brickadia.BRMapInfo
// 0x0080 (0x00B0 - 0x0030)
class UBRMapInfo final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  MapPackage;                                        // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapName;                                           // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CommandName;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Thumbnail;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     Screenshots;                                       // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRMapInfo">();
	}
	static class UBRMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRMapInfo>();
	}
};
static_assert(alignof(UBRMapInfo) == 0x000008, "Wrong alignment on UBRMapInfo");
static_assert(sizeof(UBRMapInfo) == 0x0000B0, "Wrong size on UBRMapInfo");
static_assert(offsetof(UBRMapInfo, MapPackage) == 0x000030, "Member 'UBRMapInfo::MapPackage' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, MapName) == 0x000058, "Member 'UBRMapInfo::MapName' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, CommandName) == 0x000060, "Member 'UBRMapInfo::CommandName' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, DisplayName) == 0x000070, "Member 'UBRMapInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, Description) == 0x000080, "Member 'UBRMapInfo::Description' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, Thumbnail) == 0x000090, "Member 'UBRMapInfo::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, Screenshots) == 0x000098, "Member 'UBRMapInfo::Screenshots' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, Priority) == 0x0000A8, "Member 'UBRMapInfo::Priority' has a wrong offset!");
static_assert(offsetof(UBRMapInfo, bHidden) == 0x0000AC, "Member 'UBRMapInfo::bHidden' has a wrong offset!");

// Class Brickadia.BRMasterCatalogDialog
// 0x0020 (0x0300 - 0x02E0)
class UBRMasterCatalogDialog final : public UBRDialogBase
{
public:
	class UBRGenericCatalogWidget*                BrickCatalogWidget;                                // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRGenericCatalogWidget*                ItemCatalogWidget;                                 // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRQuickbarDisplayWidget*               QuickbarViewWidget;                                // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRCatalogCustomizationData*            CatalogCustomization;                              // 0x02F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleBrickCatalogLeftClickEntry(class UObject* EntryPayload);
	void HandleBrickCatalogMiddleClickEntry(class UObject* EntryPayload);
	void HandleItemCatalogLeftClickEntry(class UObject* EntryPayload);
	void HandleItemCatalogMiddleClickEntry(class UObject* EntryPayload);
	void OnItemCatalogLoaded(class UBRCatalog* CreatedCatalog);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRMasterCatalogDialog">();
	}
	static class UBRMasterCatalogDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRMasterCatalogDialog>();
	}
};
static_assert(alignof(UBRMasterCatalogDialog) == 0x000008, "Wrong alignment on UBRMasterCatalogDialog");
static_assert(sizeof(UBRMasterCatalogDialog) == 0x000300, "Wrong size on UBRMasterCatalogDialog");
static_assert(offsetof(UBRMasterCatalogDialog, BrickCatalogWidget) == 0x0002E0, "Member 'UBRMasterCatalogDialog::BrickCatalogWidget' has a wrong offset!");
static_assert(offsetof(UBRMasterCatalogDialog, ItemCatalogWidget) == 0x0002E8, "Member 'UBRMasterCatalogDialog::ItemCatalogWidget' has a wrong offset!");
static_assert(offsetof(UBRMasterCatalogDialog, QuickbarViewWidget) == 0x0002F0, "Member 'UBRMasterCatalogDialog::QuickbarViewWidget' has a wrong offset!");
static_assert(offsetof(UBRMasterCatalogDialog, CatalogCustomization) == 0x0002F8, "Member 'UBRMasterCatalogDialog::CatalogCustomization' has a wrong offset!");

// Class Brickadia.BRMinigameManagerComponent
// 0x0000 (0x00A8 - 0x00A8)
class UBRMinigameManagerComponent final : public UActorComponent
{
public:
	void ServerClearMinigameTeams(int32 MinigameId);
	void ServerCreateMinigame(const struct FInspectorPropertyChangelist& Settings, class UBRGameTypeDescriptor* GameTypeDescriptor, const struct FInspectorPropertyChangelist& GameTypeSettings, const struct FInspectorPropertyChangelist& UnassignedTeamSettings, const TArray<struct FInspectorPropertyChangelist>& TeamSettings);
	void ServerCreateMinigameTeam(int32 MinigameId, const struct FInspectorPropertyChangelist& Settings, const class FString& AfterName);
	void ServerDestroyMinigame(int32 MinigameId);
	void ServerRemoveMinigameTeam(int32 MinigameId, const class FString& RemoveName);
	void ServerReorderMinigameTeam(int32 MinigameId, const class FString& MoveName, const class FString& AfterName);
	void ServerResetMinigame(int32 MinigameId);
	void ServerStartNextMinigameRound(int32 MinigameId);
	void ServerUpdateMinigameGametype(int32 MinigameId, class UBRGameTypeDescriptor* GameTypeDescriptor, const struct FInspectorPropertyChangelist& Settings);
	void ServerUpdateMinigameGametypeSettings(int32 MinigameId, const struct FInspectorPropertyChangelist& Settings);
	void ServerUpdateMinigameSettings(int32 MinigameId, const struct FInspectorPropertyChangelist& Settings);
	void ServerUpdateMinigameTeamSettings(int32 MinigameId, const class FString& UpdateName, const struct FInspectorPropertyChangelist& Settings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRMinigameManagerComponent">();
	}
	static class UBRMinigameManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRMinigameManagerComponent>();
	}
};
static_assert(alignof(UBRMinigameManagerComponent) == 0x000008, "Wrong alignment on UBRMinigameManagerComponent");
static_assert(sizeof(UBRMinigameManagerComponent) == 0x0000A8, "Wrong size on UBRMinigameManagerComponent");

// Class Brickadia.BRPermissionsRole
// 0x0058 (0x0080 - 0x0028)
class UBRPermissionsRole final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnUpdated;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnRoleIDChanged;                                   // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0050(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FBRRoleData_PermissionState>    Permissions;                                       // 0x0060(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	struct FColor                                 Color;                                             // 0x0070(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasColor;                                         // 0x0074(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75[0xB];                                       // 0x0075(0x000B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UInspectorPropertyDescriptorList* GenerateDescriptorList();
	struct FColor GetColor();
	class FString GetName();
	struct FColor GetShownColor();
	bool HasColor();
	void Inspector_SetPermissionState(class FName Permission, EBRSetPermission InState);
	void OnRep_NewName();
	void OnRep_Other();
	void SetColor(const struct FColor& ColorIn);
	void SetHasColor(bool bHasColorIn);
	void SetName(const class FString& NewName);
	void SetPermissionState(class FName Permission, EBRSetPermission InState);

	int32 GetHeight() const;
	EBRSetPermission GetPermissionState(class FName Permission) const;
	bool HasPermissionEntry(class FName Permission) const;
	bool Inspector_CanEditOtherThanColor() const;
	bool Inspector_CanEditPermission(class FName Permission, class UObject* WorldContext) const;
	EBRSetPermission Inspector_GetPermissionState(class FName Permission) const;
	bool Inspector_ShouldShowPermissionStateOption(class FName Permission, EBRSetPermission Option) const;
	bool IsDefaultRole() const;
	bool IsEditableTo(const class ABRPlayerController* Controller) const;
	bool IsOwnerRole() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPermissionsRole">();
	}
	static class UBRPermissionsRole* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPermissionsRole>();
	}
};
static_assert(alignof(UBRPermissionsRole) == 0x000008, "Wrong alignment on UBRPermissionsRole");
static_assert(sizeof(UBRPermissionsRole) == 0x000080, "Wrong size on UBRPermissionsRole");
static_assert(offsetof(UBRPermissionsRole, OnUpdated) == 0x000030, "Member 'UBRPermissionsRole::OnUpdated' has a wrong offset!");
static_assert(offsetof(UBRPermissionsRole, OnRoleIDChanged) == 0x000040, "Member 'UBRPermissionsRole::OnRoleIDChanged' has a wrong offset!");
static_assert(offsetof(UBRPermissionsRole, Name_0) == 0x000050, "Member 'UBRPermissionsRole::Name_0' has a wrong offset!");
static_assert(offsetof(UBRPermissionsRole, Permissions) == 0x000060, "Member 'UBRPermissionsRole::Permissions' has a wrong offset!");
static_assert(offsetof(UBRPermissionsRole, Color) == 0x000070, "Member 'UBRPermissionsRole::Color' has a wrong offset!");
static_assert(offsetof(UBRPermissionsRole, bHasColor) == 0x000074, "Member 'UBRPermissionsRole::bHasColor' has a wrong offset!");

// Class Brickadia.BRWorldSaveAsDialog
// 0x0040 (0x0320 - 0x02E0)
class UBRWorldSaveAsDialog final : public UBRDialogBase
{
public:
	class UEditableTextBox*                       NameEntry;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMultiLineEditableTextBox*              DescriptionEntry;                                  // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ErrorText;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                ErrorContainer;                                    // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    SaveButton;                                        // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              ScreenshotCheck;                                   // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBRBundleListingProvider> ListingProvider;                                   // 0x0310(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AssignProvider(TScriptInterface<class IBRBundleListingProvider> InListingProvider);
	void HandleSaveFailure(const class FText& Error);
	void HandleSaveSuccess(const struct FBRWorldSaveResult& Result);
	void OnNameEntryChanged(const class FText& Text);
	void OnSaveButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldSaveAsDialog">();
	}
	static class UBRWorldSaveAsDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldSaveAsDialog>();
	}
};
static_assert(alignof(UBRWorldSaveAsDialog) == 0x000008, "Wrong alignment on UBRWorldSaveAsDialog");
static_assert(sizeof(UBRWorldSaveAsDialog) == 0x000320, "Wrong size on UBRWorldSaveAsDialog");
static_assert(offsetof(UBRWorldSaveAsDialog, NameEntry) == 0x0002E0, "Member 'UBRWorldSaveAsDialog::NameEntry' has a wrong offset!");
static_assert(offsetof(UBRWorldSaveAsDialog, DescriptionEntry) == 0x0002E8, "Member 'UBRWorldSaveAsDialog::DescriptionEntry' has a wrong offset!");
static_assert(offsetof(UBRWorldSaveAsDialog, ErrorText) == 0x0002F0, "Member 'UBRWorldSaveAsDialog::ErrorText' has a wrong offset!");
static_assert(offsetof(UBRWorldSaveAsDialog, ErrorContainer) == 0x0002F8, "Member 'UBRWorldSaveAsDialog::ErrorContainer' has a wrong offset!");
static_assert(offsetof(UBRWorldSaveAsDialog, SaveButton) == 0x000300, "Member 'UBRWorldSaveAsDialog::SaveButton' has a wrong offset!");
static_assert(offsetof(UBRWorldSaveAsDialog, ScreenshotCheck) == 0x000308, "Member 'UBRWorldSaveAsDialog::ScreenshotCheck' has a wrong offset!");
static_assert(offsetof(UBRWorldSaveAsDialog, ListingProvider) == 0x000310, "Member 'UBRWorldSaveAsDialog::ListingProvider' has a wrong offset!");

// Class Brickadia.BRPermissionsManager
// 0x00E0 (0x0188 - 0x00A8)
class UBRPermissionsManager final : public UActorComponent
{
public:
	TMulticastInlineDelegate<void()>              OnUpdated;                                         // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         RoleNameLengthLimit;                               // 0x00B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBRPermissionsRole*>             CustomRoles;                                       // 0x00C0(0x0010)(Edit, ExportObject, Net, ZeroConstructor, Transient, EditConst, RepNotify, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UBRPermissionsRole*                     OwnerRole;                                         // 0x00D0(0x0008)(Edit, ExportObject, Net, ZeroConstructor, Transient, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRPermissionsRole*                     DefaultRole;                                       // 0x00D8(0x0008)(Edit, ExportObject, Net, ZeroConstructor, Transient, EditConst, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreLoaded;                                        // 0x00E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E1[0xA7];                                      // 0x00E1(0x00A7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBRPermissionsManager* Get(const class UObject* WorldContext);

	class UBRPermissionsRole* CreateOrGetPermissionsRole(const class FString& RoleName, const class FString& RoleNameToCreateAfter);
	bool DestroyPermissionsRole(const class FString& RoleName);
	void HandleRoleListChanged();
	void HandleUpdated();
	void LoadJSON(const class FString& Path);
	bool ReorderPermissionsRoles(const class FString& RoleId, const class FString& RoleIdToPutAfter);
	void SaveJSON(const class FString& Path);

	TArray<class UBRPermissionsRole*> GetAllPermissionsRoles() const;
	TArray<class UBRPermissionsRole*> GetCustomPermissionsRoles() const;
	class UBRPermissionsRole* GetDefaultPermissionsRole() const;
	class UBRPermissionsRole* GetOwnerPermissionsRole() const;
	class UBRPermissionsRole* GetPermissionsRole(const class FString& RoleName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPermissionsManager">();
	}
	static class UBRPermissionsManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPermissionsManager>();
	}
};
static_assert(alignof(UBRPermissionsManager) == 0x000008, "Wrong alignment on UBRPermissionsManager");
static_assert(sizeof(UBRPermissionsManager) == 0x000188, "Wrong size on UBRPermissionsManager");
static_assert(offsetof(UBRPermissionsManager, OnUpdated) == 0x0000A8, "Member 'UBRPermissionsManager::OnUpdated' has a wrong offset!");
static_assert(offsetof(UBRPermissionsManager, RoleNameLengthLimit) == 0x0000B8, "Member 'UBRPermissionsManager::RoleNameLengthLimit' has a wrong offset!");
static_assert(offsetof(UBRPermissionsManager, CustomRoles) == 0x0000C0, "Member 'UBRPermissionsManager::CustomRoles' has a wrong offset!");
static_assert(offsetof(UBRPermissionsManager, OwnerRole) == 0x0000D0, "Member 'UBRPermissionsManager::OwnerRole' has a wrong offset!");
static_assert(offsetof(UBRPermissionsManager, DefaultRole) == 0x0000D8, "Member 'UBRPermissionsManager::DefaultRole' has a wrong offset!");
static_assert(offsetof(UBRPermissionsManager, bPreLoaded) == 0x0000E0, "Member 'UBRPermissionsManager::bPreLoaded' has a wrong offset!");

// Class Brickadia.BRPermissionLibrary
// 0x0010 (0x0040 - 0x0030)
class UBRPermissionLibrary final : public UPrimaryDataAsset
{
public:
	TArray<struct FBRPermissionDescriptor>        PermissionDefinitions;                             // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPermissionLibrary">();
	}
	static class UBRPermissionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPermissionLibrary>();
	}
};
static_assert(alignof(UBRPermissionLibrary) == 0x000008, "Wrong alignment on UBRPermissionLibrary");
static_assert(sizeof(UBRPermissionLibrary) == 0x000040, "Wrong size on UBRPermissionLibrary");
static_assert(offsetof(UBRPermissionLibrary, PermissionDefinitions) == 0x000030, "Member 'UBRPermissionLibrary::PermissionDefinitions' has a wrong offset!");

// Class Brickadia.BRPermissionsWorldSubsystem
// 0x0020 (0x0058 - 0x0038)
class UBRPermissionsWorldSubsystem final : public UBRWorldSubsystem
{
public:
	TArray<TSubclassOf<class UObject>>            LibraryClasses;                                    // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetPermissionDescriptor(class FName Permission, struct FBRPermissionDescriptor* DescriptorFoundIfAny) const;
	void GetPermissionIdList(TArray<class FName>* Array) const;
	void GetPermissionIdListForDefaultRole(TArray<class FName>* Array, EBRPermissionDefaultForRole DefaultForRole) const;
	void GetPermissionIdListForGameplayPermissions(TArray<class FName>* Array) const;
	void GetPermissionList(TArray<struct FBRPermissionDescriptor>* Array) const;
	void GetPermissionListForDefaultRole(TArray<struct FBRPermissionDescriptor>* Array, EBRPermissionDefaultForRole DefaultForRole) const;
	void GetPermissionListForGameplayPermissions(TArray<struct FBRPermissionDescriptor>* Array) const;
	class UInspectorPropertyDescriptorList* GetRulesetEditPermissionsPDL(class UObject* Context) const;
	bool PermissionExists(class FName Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPermissionsWorldSubsystem">();
	}
	static class UBRPermissionsWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPermissionsWorldSubsystem>();
	}
};
static_assert(alignof(UBRPermissionsWorldSubsystem) == 0x000008, "Wrong alignment on UBRPermissionsWorldSubsystem");
static_assert(sizeof(UBRPermissionsWorldSubsystem) == 0x000058, "Wrong size on UBRPermissionsWorldSubsystem");
static_assert(offsetof(UBRPermissionsWorldSubsystem, LibraryClasses) == 0x000038, "Member 'UBRPermissionsWorldSubsystem::LibraryClasses' has a wrong offset!");

// Class Brickadia.BRWorldEntryWidget
// 0x0018 (0x0320 - 0x0308)
class UBRWorldEntryWidget : public UBRDraggableListEntryBase
{
public:
	class UTextBlock*                             NameText;                                          // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDynamicImage*                        Thumbnail;                                         // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NoImageOverlay;                                    // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldEntryWidget">();
	}
	static class UBRWorldEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldEntryWidget>();
	}
};
static_assert(alignof(UBRWorldEntryWidget) == 0x000008, "Wrong alignment on UBRWorldEntryWidget");
static_assert(sizeof(UBRWorldEntryWidget) == 0x000320, "Wrong size on UBRWorldEntryWidget");
static_assert(offsetof(UBRWorldEntryWidget, NameText) == 0x000308, "Member 'UBRWorldEntryWidget::NameText' has a wrong offset!");
static_assert(offsetof(UBRWorldEntryWidget, Thumbnail) == 0x000310, "Member 'UBRWorldEntryWidget::Thumbnail' has a wrong offset!");
static_assert(offsetof(UBRWorldEntryWidget, NoImageOverlay) == 0x000318, "Member 'UBRWorldEntryWidget::NoImageOverlay' has a wrong offset!");

// Class Brickadia.BRPermissionStatics
// 0x0000 (0x0028 - 0x0028)
class UBRPermissionStatics final : public UBlueprintFunctionLibrary
{
public:
	static struct FColor HighestOfRoleColors(const TArray<class UBRPermissionsRole*>& PermissionsRoles);
	static class UBRPermissionsRole* HighestOfRoles(const TArray<class UBRPermissionsRole*>& PermissionsRoles);
	static bool RolesHavePermission(const TArray<class UBRPermissionsRole*>& PermissionsRoles, class FName Permission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPermissionStatics">();
	}
	static class UBRPermissionStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPermissionStatics>();
	}
};
static_assert(alignof(UBRPermissionStatics) == 0x000008, "Wrong alignment on UBRPermissionStatics");
static_assert(sizeof(UBRPermissionStatics) == 0x000028, "Wrong size on UBRPermissionStatics");

// Class Brickadia.BRWorldBrowserContent
// 0x0088 (0x0358 - 0x02D0)
class UBRWorldBrowserContent : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x10];                                     // 0x02D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UDualTileView*                          TileView;                                          // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UListView*                              ListView;                                          // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWorldEmptyDetailsPanel*              EmptyDetailsPanel;                                 // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWorldDetailsPanel*                   WorldDetailsPanel;                                 // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWorldFolderDetailsPanel*             FolderDetailsPanel;                                // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWorldMultiDetailsPanel*              MultiDetailsPanel;                                 // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        DetailsSwitcher;                                   // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SelectionSound;                                    // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWorldFolderEntryWidget>  FolderTileClass;                                   // 0x0320(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWorldEntryWidget>        WorldTileClass;                                    // 0x0328(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWorldFolderEntryWidget>  FolderRowClass;                                    // 0x0330(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWorldEntryWidget>        WorldRowClass;                                     // 0x0338(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBRBundleListingProvider> ListingProvider;                                   // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldBrowserContent">();
	}
	static class UBRWorldBrowserContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldBrowserContent>();
	}
};
static_assert(alignof(UBRWorldBrowserContent) == 0x000008, "Wrong alignment on UBRWorldBrowserContent");
static_assert(sizeof(UBRWorldBrowserContent) == 0x000358, "Wrong size on UBRWorldBrowserContent");
static_assert(offsetof(UBRWorldBrowserContent, TileView) == 0x0002E0, "Member 'UBRWorldBrowserContent::TileView' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, ListView) == 0x0002E8, "Member 'UBRWorldBrowserContent::ListView' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, EmptyDetailsPanel) == 0x0002F0, "Member 'UBRWorldBrowserContent::EmptyDetailsPanel' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, WorldDetailsPanel) == 0x0002F8, "Member 'UBRWorldBrowserContent::WorldDetailsPanel' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, FolderDetailsPanel) == 0x000300, "Member 'UBRWorldBrowserContent::FolderDetailsPanel' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, MultiDetailsPanel) == 0x000308, "Member 'UBRWorldBrowserContent::MultiDetailsPanel' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, DetailsSwitcher) == 0x000310, "Member 'UBRWorldBrowserContent::DetailsSwitcher' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, SelectionSound) == 0x000318, "Member 'UBRWorldBrowserContent::SelectionSound' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, FolderTileClass) == 0x000320, "Member 'UBRWorldBrowserContent::FolderTileClass' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, WorldTileClass) == 0x000328, "Member 'UBRWorldBrowserContent::WorldTileClass' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, FolderRowClass) == 0x000330, "Member 'UBRWorldBrowserContent::FolderRowClass' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, WorldRowClass) == 0x000338, "Member 'UBRWorldBrowserContent::WorldRowClass' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserContent, ListingProvider) == 0x000340, "Member 'UBRWorldBrowserContent::ListingProvider' has a wrong offset!");

// Class Brickadia.BRPhysicsCollisionHandler
// 0x0070 (0x00B0 - 0x0040)
class UBRPhysicsCollisionHandler final : public UPhysicsCollisionHandler
{
public:
	class USoundAttenuation*                      BrickSoundAttenuation;                             // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      BrickSoundConcurrency;                             // 0x0048(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactVelocityVolumeMultiplier;                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactVelocityVolumeMax;                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalImpactVolumeMultiplier;                      // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x54];                                      // 0x005C(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPhysicsCollisionHandler">();
	}
	static class UBRPhysicsCollisionHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPhysicsCollisionHandler>();
	}
};
static_assert(alignof(UBRPhysicsCollisionHandler) == 0x000008, "Wrong alignment on UBRPhysicsCollisionHandler");
static_assert(sizeof(UBRPhysicsCollisionHandler) == 0x0000B0, "Wrong size on UBRPhysicsCollisionHandler");
static_assert(offsetof(UBRPhysicsCollisionHandler, BrickSoundAttenuation) == 0x000040, "Member 'UBRPhysicsCollisionHandler::BrickSoundAttenuation' has a wrong offset!");
static_assert(offsetof(UBRPhysicsCollisionHandler, BrickSoundConcurrency) == 0x000048, "Member 'UBRPhysicsCollisionHandler::BrickSoundConcurrency' has a wrong offset!");
static_assert(offsetof(UBRPhysicsCollisionHandler, ImpactVelocityVolumeMultiplier) == 0x000050, "Member 'UBRPhysicsCollisionHandler::ImpactVelocityVolumeMultiplier' has a wrong offset!");
static_assert(offsetof(UBRPhysicsCollisionHandler, ImpactVelocityVolumeMax) == 0x000054, "Member 'UBRPhysicsCollisionHandler::ImpactVelocityVolumeMax' has a wrong offset!");
static_assert(offsetof(UBRPhysicsCollisionHandler, GlobalImpactVolumeMultiplier) == 0x000058, "Member 'UBRPhysicsCollisionHandler::GlobalImpactVolumeMultiplier' has a wrong offset!");

// Class Brickadia.BRPhysicsMeshEntity
// 0x0010 (0x02F0 - 0x02E0)
class ABRPhysicsMeshEntity : public ABREntityActor
{
public:
	uint8                                         Pad_2E0[0x1];                                      // 0x02E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUseSphereWhenAttached;                            // 0x02E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTurnOffPhysicsSoundsWhenAttached;                 // 0x02E2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E3[0x5];                                      // 0x02E3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRSpherePhysicsStaticMeshComponent*    StaticMeshComponent;                               // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPhysicsMeshEntity">();
	}
	static class ABRPhysicsMeshEntity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPhysicsMeshEntity>();
	}
};
static_assert(alignof(ABRPhysicsMeshEntity) == 0x000008, "Wrong alignment on ABRPhysicsMeshEntity");
static_assert(sizeof(ABRPhysicsMeshEntity) == 0x0002F0, "Wrong size on ABRPhysicsMeshEntity");
static_assert(offsetof(ABRPhysicsMeshEntity, bUseSphereWhenAttached) == 0x0002E1, "Member 'ABRPhysicsMeshEntity::bUseSphereWhenAttached' has a wrong offset!");
static_assert(offsetof(ABRPhysicsMeshEntity, bTurnOffPhysicsSoundsWhenAttached) == 0x0002E2, "Member 'ABRPhysicsMeshEntity::bTurnOffPhysicsSoundsWhenAttached' has a wrong offset!");
static_assert(offsetof(ABRPhysicsMeshEntity, StaticMeshComponent) == 0x0002E8, "Member 'ABRPhysicsMeshEntity::StaticMeshComponent' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Bool
// 0x0000 (0x0088 - 0x0088)
class UInspectorPropertyDescriptor_Bool final : public UInspectorPropertyDescriptor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Bool">();
	}
	static class UInspectorPropertyDescriptor_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Bool>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Bool) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Bool");
static_assert(sizeof(UInspectorPropertyDescriptor_Bool) == 0x000088, "Wrong size on UInspectorPropertyDescriptor_Bool");

// Class Brickadia.BRPhysicsPlaneVolume
// 0x0008 (0x0300 - 0x02F8)
class ABRPhysicsPlaneVolume : public APhysicsVolume
{
public:
	class UBRPlaneCollisionComponent*             PlaneCollisionComponent;                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPhysicsPlaneVolume">();
	}
	static class ABRPhysicsPlaneVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPhysicsPlaneVolume>();
	}
};
static_assert(alignof(ABRPhysicsPlaneVolume) == 0x000008, "Wrong alignment on ABRPhysicsPlaneVolume");
static_assert(sizeof(ABRPhysicsPlaneVolume) == 0x000300, "Wrong size on ABRPhysicsPlaneVolume");
static_assert(offsetof(ABRPhysicsPlaneVolume, PlaneCollisionComponent) == 0x0002F8, "Member 'ABRPhysicsPlaneVolume::PlaneCollisionComponent' has a wrong offset!");

// Class Brickadia.BRPickupBase
// 0x00B0 (0x0360 - 0x02B0)
class ABRPickupBase : public AActor
{
public:
	uint8                                         Pad_2B0[0x8];                                      // 0x02B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   Mesh;                                              // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDisableOnPickup;                              // 0x02C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x3];                                      // 0x02C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBrickHandle                           SourceBrick;                                       // 0x02C4(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoRespawnTime;                                   // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x50];                                     // 0x02D0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPickupEnabled;                                    // 0x0320(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_321[0x7];                                      // 0x0321(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           PickupDisableTimeout;                              // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FColor                                 MeshColors[0x8];                                   // 0x0330(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBRPickupMaterialCollection>    OverrideMaterialCollections;                       // 0x0350(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void DisablePickupWithTimeout(float Timeout);
	class UStaticMesh* GetPickupMesh();
	TArray<struct FColor> GetPickupMeshColorArray();
	void HandleComponentOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void HandlePickupAttempt(class APawn* Pawn);
	void HandleSetPickupEnabled(bool bEnabled);
	void SetAutoRespawnTime(float Time);
	void SetPickupEnabled(bool bEnabled);

	float GetRemainingDisableTimeoutValue() const;
	bool IsPickupEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPickupBase">();
	}
	static class ABRPickupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPickupBase>();
	}
};
static_assert(alignof(ABRPickupBase) == 0x000008, "Wrong alignment on ABRPickupBase");
static_assert(sizeof(ABRPickupBase) == 0x000360, "Wrong size on ABRPickupBase");
static_assert(offsetof(ABRPickupBase, Mesh) == 0x0002B8, "Member 'ABRPickupBase::Mesh' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, bAutoDisableOnPickup) == 0x0002C0, "Member 'ABRPickupBase::bAutoDisableOnPickup' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, SourceBrick) == 0x0002C4, "Member 'ABRPickupBase::SourceBrick' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, AutoRespawnTime) == 0x0002CC, "Member 'ABRPickupBase::AutoRespawnTime' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, bPickupEnabled) == 0x000320, "Member 'ABRPickupBase::bPickupEnabled' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, PickupDisableTimeout) == 0x000328, "Member 'ABRPickupBase::PickupDisableTimeout' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, MeshColors) == 0x000330, "Member 'ABRPickupBase::MeshColors' has a wrong offset!");
static_assert(offsetof(ABRPickupBase, OverrideMaterialCollections) == 0x000350, "Member 'ABRPickupBase::OverrideMaterialCollections' has a wrong offset!");

// Class Brickadia.BRToolBindHintsWidget
// 0x0028 (0x02F8 - 0x02D0)
class UBRToolBindHintsWidget final : public UUserWidget
{
public:
	class UDynamicEntryBox*                       SimpleBindsBox;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UBRToolBindHintWidget>      InfoWidgetClass;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBRToolBindHint>                NoToolBindHints;                                   // 0x02E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ABRToolBase*                            TARGET;                                            // 0x02F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnToolBindInfosChanged();
	void SetTarget(class ABRToolBase* InTarget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolBindHintsWidget">();
	}
	static class UBRToolBindHintsWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolBindHintsWidget>();
	}
};
static_assert(alignof(UBRToolBindHintsWidget) == 0x000008, "Wrong alignment on UBRToolBindHintsWidget");
static_assert(sizeof(UBRToolBindHintsWidget) == 0x0002F8, "Wrong size on UBRToolBindHintsWidget");
static_assert(offsetof(UBRToolBindHintsWidget, SimpleBindsBox) == 0x0002D0, "Member 'UBRToolBindHintsWidget::SimpleBindsBox' has a wrong offset!");
static_assert(offsetof(UBRToolBindHintsWidget, InfoWidgetClass) == 0x0002D8, "Member 'UBRToolBindHintsWidget::InfoWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRToolBindHintsWidget, NoToolBindHints) == 0x0002E0, "Member 'UBRToolBindHintsWidget::NoToolBindHints' has a wrong offset!");
static_assert(offsetof(UBRToolBindHintsWidget, TARGET) == 0x0002F0, "Member 'UBRToolBindHintsWidget::TARGET' has a wrong offset!");

// Class Brickadia.BRAnimatedPickupBase
// 0x0020 (0x0380 - 0x0360)
class ABRAnimatedPickupBase : public ABRPickupBase
{
public:
	class USphereComponent*                       CollisionSphere;                                   // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAnimation;                                  // 0x0368(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBrickAxis                                    AnimationAxis;                                     // 0x0369(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAnimationAxisLocal;                               // 0x036A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36B[0x1];                                      // 0x036B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AnimationSpinSpeed;                                // 0x036C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationBobSpeed;                                 // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationBobHeight;                                // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimationPhase;                                    // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_AnimationData();
	void OnRep_AnimationEnabled();
	void SetAnimationData(EBrickAxis InAnimationAxis, bool bInAnimationAxisLocal, float InAnimationSpinSpeed, float InAnimationBobSpeed, float InAnimationBobHeight, float InAnimationPhase);
	void SetEnableAnimation(bool bInEnableAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRAnimatedPickupBase">();
	}
	static class ABRAnimatedPickupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRAnimatedPickupBase>();
	}
};
static_assert(alignof(ABRAnimatedPickupBase) == 0x000008, "Wrong alignment on ABRAnimatedPickupBase");
static_assert(sizeof(ABRAnimatedPickupBase) == 0x000380, "Wrong size on ABRAnimatedPickupBase");
static_assert(offsetof(ABRAnimatedPickupBase, CollisionSphere) == 0x000360, "Member 'ABRAnimatedPickupBase::CollisionSphere' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, bEnableAnimation) == 0x000368, "Member 'ABRAnimatedPickupBase::bEnableAnimation' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, AnimationAxis) == 0x000369, "Member 'ABRAnimatedPickupBase::AnimationAxis' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, bAnimationAxisLocal) == 0x00036A, "Member 'ABRAnimatedPickupBase::bAnimationAxisLocal' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, AnimationSpinSpeed) == 0x00036C, "Member 'ABRAnimatedPickupBase::AnimationSpinSpeed' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, AnimationBobSpeed) == 0x000370, "Member 'ABRAnimatedPickupBase::AnimationBobSpeed' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, AnimationBobHeight) == 0x000374, "Member 'ABRAnimatedPickupBase::AnimationBobHeight' has a wrong offset!");
static_assert(offsetof(ABRAnimatedPickupBase, AnimationPhase) == 0x000378, "Member 'ABRAnimatedPickupBase::AnimationPhase' has a wrong offset!");

// Class Brickadia.BRItemPickupBase
// 0x0010 (0x0390 - 0x0380)
class ABRItemPickupBase final : public ABRAnimatedPickupBase
{
public:
	TSubclassOf<class ABRItemBase>                ItemClass;                                         // 0x0380(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAllowMultiPickup;                                 // 0x0388(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRItemPickupBase">();
	}
	static class ABRItemPickupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRItemPickupBase>();
	}
};
static_assert(alignof(ABRItemPickupBase) == 0x000008, "Wrong alignment on ABRItemPickupBase");
static_assert(sizeof(ABRItemPickupBase) == 0x000390, "Wrong size on ABRItemPickupBase");
static_assert(offsetof(ABRItemPickupBase, ItemClass) == 0x000380, "Member 'ABRItemPickupBase::ItemClass' has a wrong offset!");
static_assert(offsetof(ABRItemPickupBase, bAllowMultiPickup) == 0x000388, "Member 'ABRItemPickupBase::bAllowMultiPickup' has a wrong offset!");

// Class Brickadia.BRWeaponResourcePickupBase
// 0x0020 (0x03A0 - 0x0380)
class ABRWeaponResourcePickupBase final : public ABRAnimatedPickupBase
{
public:
	class FText                                   DisplayName;                                       // 0x0380(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBRWeaponResourcePickup>        WeaponResourcePickups;                             // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponResourcePickupBase">();
	}
	static class ABRWeaponResourcePickupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRWeaponResourcePickupBase>();
	}
};
static_assert(alignof(ABRWeaponResourcePickupBase) == 0x000008, "Wrong alignment on ABRWeaponResourcePickupBase");
static_assert(sizeof(ABRWeaponResourcePickupBase) == 0x0003A0, "Wrong size on ABRWeaponResourcePickupBase");
static_assert(offsetof(ABRWeaponResourcePickupBase, DisplayName) == 0x000380, "Member 'ABRWeaponResourcePickupBase::DisplayName' has a wrong offset!");
static_assert(offsetof(ABRWeaponResourcePickupBase, WeaponResourcePickups) == 0x000390, "Member 'ABRWeaponResourcePickupBase::WeaponResourcePickups' has a wrong offset!");

// Class Brickadia.BRRulesetBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UBRRulesetBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ABRRuleset* GetDefaultRuleset(class UObject* WorldContextObject);
	static class ABRRuleset* GetGlobalRuleset(const class UObject* WorldContextObject);
	static class ABRRuleset* GetLocalRuleset(const class UObject* WorldContextObject);
	static struct FInspectorPropertyChangelist GetTeamSettingsFromQuickTeamSettings(const struct FBRQuickTeamSettings& Settings);
	static struct FInspectorPropertyChangelist GetTeamSettingsFromQuickUnassignedTeamSettings(const struct FBRQuickUnassignedTeamSettings& Settings);
	static bool PlayerCanEndCurrentRulesetByLeaving(const class ABRPlayerController* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRulesetBlueprintFunctionLibrary">();
	}
	static class UBRRulesetBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRRulesetBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UBRRulesetBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UBRRulesetBlueprintFunctionLibrary");
static_assert(sizeof(UBRRulesetBlueprintFunctionLibrary) == 0x000028, "Wrong size on UBRRulesetBlueprintFunctionLibrary");

// Class Brickadia.BRPieMenuEntry
// 0x0000 (0x02D0 - 0x02D0)
class UBRPieMenuEntry final : public UUserWidget
{
public:
	class FText GetDescription() const;
	class FText GetDisplayName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPieMenuEntry">();
	}
	static class UBRPieMenuEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPieMenuEntry>();
	}
};
static_assert(alignof(UBRPieMenuEntry) == 0x000008, "Wrong alignment on UBRPieMenuEntry");
static_assert(sizeof(UBRPieMenuEntry) == 0x0002D0, "Wrong size on UBRPieMenuEntry");

// Class Brickadia.BRPieMenuWidget
// 0x00D8 (0x03A8 - 0x02D0)
class UBRPieMenuWidget final : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class UBRPieMenuEntry* Widget, int32 Index, bool bIsPrevious)> OnHoverNew;                                        // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnNoHover;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRPieMenuEntry* Widget, int32 Index, bool bIsPrevious)> OnSelect;                                          // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         CenterRadius;                                      // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HoverColor_Regular;                                // 0x0304(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCenterHover;                                 // 0x0314(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CenterHoverText;                                   // 0x0318(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   CenterHoverDescription;                            // 0x0328(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            CenterTextHoverColor;                              // 0x0338(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FSlateColor                            CenterTextRegularColor;                            // 0x034C(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTextBlock*                             DisplayNameText;                                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DescriptionText;                                   // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Pie_LastSelected;                                  // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Pie_Hovered;                                       // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           Pie_IconCanvas;                                    // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 Pie_Center;                                        // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             HoverSound;                                        // 0x0390(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSlot(class UBRPieMenuEntry* Widget);
	void RemoveAllSlots();
	void RemoveSlotByIndex(int32 Index_0);
	void SelectConfirm(bool bRememberLast);
	void SelectSlot(int32 Index_0);
	void SetLastSelected(int32 NewLastSelected);

	void GetAllSlots(TArray<class UBRPieMenuEntry*>* OutSlots) const;
	class UBRPieMenuEntry* GetSlotByIndex(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPieMenuWidget">();
	}
	static class UBRPieMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPieMenuWidget>();
	}
};
static_assert(alignof(UBRPieMenuWidget) == 0x000008, "Wrong alignment on UBRPieMenuWidget");
static_assert(sizeof(UBRPieMenuWidget) == 0x0003A8, "Wrong size on UBRPieMenuWidget");
static_assert(offsetof(UBRPieMenuWidget, OnHoverNew) == 0x0002D0, "Member 'UBRPieMenuWidget::OnHoverNew' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, OnNoHover) == 0x0002E0, "Member 'UBRPieMenuWidget::OnNoHover' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, OnSelect) == 0x0002F0, "Member 'UBRPieMenuWidget::OnSelect' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, CenterRadius) == 0x000300, "Member 'UBRPieMenuWidget::CenterRadius' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, HoverColor_Regular) == 0x000304, "Member 'UBRPieMenuWidget::HoverColor_Regular' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, bAllowCenterHover) == 0x000314, "Member 'UBRPieMenuWidget::bAllowCenterHover' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, CenterHoverText) == 0x000318, "Member 'UBRPieMenuWidget::CenterHoverText' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, CenterHoverDescription) == 0x000328, "Member 'UBRPieMenuWidget::CenterHoverDescription' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, CenterTextHoverColor) == 0x000338, "Member 'UBRPieMenuWidget::CenterTextHoverColor' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, CenterTextRegularColor) == 0x00034C, "Member 'UBRPieMenuWidget::CenterTextRegularColor' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, DisplayNameText) == 0x000360, "Member 'UBRPieMenuWidget::DisplayNameText' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, DescriptionText) == 0x000368, "Member 'UBRPieMenuWidget::DescriptionText' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, Pie_LastSelected) == 0x000370, "Member 'UBRPieMenuWidget::Pie_LastSelected' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, Pie_Hovered) == 0x000378, "Member 'UBRPieMenuWidget::Pie_Hovered' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, Pie_IconCanvas) == 0x000380, "Member 'UBRPieMenuWidget::Pie_IconCanvas' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, Pie_Center) == 0x000388, "Member 'UBRPieMenuWidget::Pie_Center' has a wrong offset!");
static_assert(offsetof(UBRPieMenuWidget, HoverSound) == 0x000390, "Member 'UBRPieMenuWidget::HoverSound' has a wrong offset!");

// Class Brickadia.ForceTickUserWidget
// 0x0000 (0x02D0 - 0x02D0)
class UForceTickUserWidget : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceTickUserWidget">();
	}
	static class UForceTickUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceTickUserWidget>();
	}
};
static_assert(alignof(UForceTickUserWidget) == 0x000008, "Wrong alignment on UForceTickUserWidget");
static_assert(sizeof(UForceTickUserWidget) == 0x0002D0, "Wrong size on UForceTickUserWidget");

// Class Brickadia.BRPlaceableSlider
// 0x0000 (0x02F0 - 0x02F0)
class ABRPlaceableSlider final : public ABRPlaceableJointActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlaceableSlider">();
	}
	static class ABRPlaceableSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlaceableSlider>();
	}
};
static_assert(alignof(ABRPlaceableSlider) == 0x000008, "Wrong alignment on ABRPlaceableSlider");
static_assert(sizeof(ABRPlaceableSlider) == 0x0002F0, "Wrong size on ABRPlaceableSlider");

// Class Brickadia.BRTextFilterSubsystem
// 0x0010 (0x0040 - 0x0030)
class UBRTextFilterSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RefreshActiveRegex(const class UDataTable* TextFilterTable);

	class FString FilterText(const class FString& Input) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTextFilterSubsystem">();
	}
	static class UBRTextFilterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTextFilterSubsystem>();
	}
};
static_assert(alignof(UBRTextFilterSubsystem) == 0x000008, "Wrong alignment on UBRTextFilterSubsystem");
static_assert(sizeof(UBRTextFilterSubsystem) == 0x000040, "Wrong size on UBRTextFilterSubsystem");

// Class Brickadia.AsyncActionOneButtonDialog
// 0x0070 (0x00A0 - 0x0030)
class UAsyncActionOneButtonDialog final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnButtonClicked;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABRHUD*                                 HUD;                                               // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBROneButtonDialogBase*                 Dialog;                                            // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x40];                                      // 0x0050(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ButtonIcon;                                        // 0x0090(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBROneButtonDialogBase>     DialogClass;                                       // 0x0098(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncActionOneButtonDialog* CreateOneButtonDialog(class UObject* WorldContextObject, const class FText& Title, const class FText& Message, const class FText& ButtonMessage, EBRDialogButtonStyle ButtonStyle, class UTexture2D* ButtonIcon_0, TSubclassOf<class UBROneButtonDialogBase> DialogClass_0, bool bAllowEscapeDialog);
	static class UAsyncActionOneButtonDialog* QuickCreateOneButtonDialog(class UObject* WorldContextObject, const class FText& Title, const class FText& Message, const class FText& ButtonMessage, EBRDialogButtonStyle ButtonStyle, class UTexture2D* ButtonIcon_0, bool bAllowEscapeDialog);

	void HandleClickedButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionOneButtonDialog">();
	}
	static class UAsyncActionOneButtonDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionOneButtonDialog>();
	}
};
static_assert(alignof(UAsyncActionOneButtonDialog) == 0x000008, "Wrong alignment on UAsyncActionOneButtonDialog");
static_assert(sizeof(UAsyncActionOneButtonDialog) == 0x0000A0, "Wrong size on UAsyncActionOneButtonDialog");
static_assert(offsetof(UAsyncActionOneButtonDialog, OnButtonClicked) == 0x000030, "Member 'UAsyncActionOneButtonDialog::OnButtonClicked' has a wrong offset!");
static_assert(offsetof(UAsyncActionOneButtonDialog, HUD) == 0x000040, "Member 'UAsyncActionOneButtonDialog::HUD' has a wrong offset!");
static_assert(offsetof(UAsyncActionOneButtonDialog, Dialog) == 0x000048, "Member 'UAsyncActionOneButtonDialog::Dialog' has a wrong offset!");
static_assert(offsetof(UAsyncActionOneButtonDialog, ButtonIcon) == 0x000090, "Member 'UAsyncActionOneButtonDialog::ButtonIcon' has a wrong offset!");
static_assert(offsetof(UAsyncActionOneButtonDialog, DialogClass) == 0x000098, "Member 'UAsyncActionOneButtonDialog::DialogClass' has a wrong offset!");

// Class Brickadia.BRPlacerAlignmentMode_Regular
// 0x0010 (0x00E0 - 0x00D0)
class UBRPlacerAlignmentMode_Regular final : public UBRPlacerAlignmentModeBase
{
public:
	struct FIntVector                             GridCellSize;                                      // 0x00D0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerAlignmentMode_Regular">();
	}
	static class UBRPlacerAlignmentMode_Regular* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerAlignmentMode_Regular>();
	}
};
static_assert(alignof(UBRPlacerAlignmentMode_Regular) == 0x000008, "Wrong alignment on UBRPlacerAlignmentMode_Regular");
static_assert(sizeof(UBRPlacerAlignmentMode_Regular) == 0x0000E0, "Wrong size on UBRPlacerAlignmentMode_Regular");
static_assert(offsetof(UBRPlacerAlignmentMode_Regular, GridCellSize) == 0x0000D0, "Member 'UBRPlacerAlignmentMode_Regular::GridCellSize' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_Reloading
// 0x0010 (0x0048 - 0x0038)
class UBRWeaponStateBehavior_Reloading final : public UBRWeaponStateBehavior_ChangesResources
{
public:
	float                                         ReloadTime;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegacyAmmoReloadAmount;                            // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReloadEmptiesLegacyMagazine;                      // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_Reloading">();
	}
	static class UBRWeaponStateBehavior_Reloading* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_Reloading>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_Reloading) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_Reloading");
static_assert(sizeof(UBRWeaponStateBehavior_Reloading) == 0x000048, "Wrong size on UBRWeaponStateBehavior_Reloading");
static_assert(offsetof(UBRWeaponStateBehavior_Reloading, ReloadTime) == 0x000038, "Member 'UBRWeaponStateBehavior_Reloading::ReloadTime' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_Reloading, LegacyAmmoReloadAmount) == 0x00003C, "Member 'UBRWeaponStateBehavior_Reloading::LegacyAmmoReloadAmount' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_Reloading, bReloadEmptiesLegacyMagazine) == 0x000040, "Member 'UBRWeaponStateBehavior_Reloading::bReloadEmptiesLegacyMagazine' has a wrong offset!");

// Class Brickadia.GenericThumbnailWidget
// 0x00B0 (0x0360 - 0x02B0)
class UGenericThumbnailWidget final : public UImage
{
public:
	TSubclassOf<class UThumbnailProcessor>        ThumbnailProcessorClass;                           // 0x02A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowGrid;                                         // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x3];                                      // 0x02B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           BackgroundColor;                                   // 0x02B4(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ThumbnailObject;                                   // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 StaticThumbnailImage;                              // 0x02D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               StaticThumbnailMaterial;                           // 0x02D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RealtimeThumbnailImage;                            // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               RealtimeThumbnailMaterial;                         // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x70];                                     // 0x02F0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetThumbnailObject(class UObject* NewThumbnailObject);
	void SetThumbnailObject2(class UClass* NewThumbnailObject);
	void SetThumbnailProcessor(TSubclassOf<class UThumbnailProcessor> Processor);
	void StartRealtimeRotation(const struct FRotator& RotationPerSecond);
	void StopRealtimeRotation(float UnrotateTime);

	class UObject* GetThumbnailObject() const;
	bool IsRealtime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericThumbnailWidget">();
	}
	static class UGenericThumbnailWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericThumbnailWidget>();
	}
};
static_assert(alignof(UGenericThumbnailWidget) == 0x000010, "Wrong alignment on UGenericThumbnailWidget");
static_assert(sizeof(UGenericThumbnailWidget) == 0x000360, "Wrong size on UGenericThumbnailWidget");
static_assert(offsetof(UGenericThumbnailWidget, ThumbnailProcessorClass) == 0x0002A8, "Member 'UGenericThumbnailWidget::ThumbnailProcessorClass' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, bShowGrid) == 0x0002B0, "Member 'UGenericThumbnailWidget::bShowGrid' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, BackgroundColor) == 0x0002B4, "Member 'UGenericThumbnailWidget::BackgroundColor' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, ThumbnailObject) == 0x0002C8, "Member 'UGenericThumbnailWidget::ThumbnailObject' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, StaticThumbnailImage) == 0x0002D0, "Member 'UGenericThumbnailWidget::StaticThumbnailImage' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, StaticThumbnailMaterial) == 0x0002D8, "Member 'UGenericThumbnailWidget::StaticThumbnailMaterial' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, RealtimeThumbnailImage) == 0x0002E0, "Member 'UGenericThumbnailWidget::RealtimeThumbnailImage' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailWidget, RealtimeThumbnailMaterial) == 0x0002E8, "Member 'UGenericThumbnailWidget::RealtimeThumbnailMaterial' has a wrong offset!");

// Class Brickadia.BRPlacerMouseLockModeBase
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerMouseLockModeBase : public UBRSelectablePlacerMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerMouseLockModeBase">();
	}
	static class UBRPlacerMouseLockModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerMouseLockModeBase>();
	}
};
static_assert(alignof(UBRPlacerMouseLockModeBase) == 0x000008, "Wrong alignment on UBRPlacerMouseLockModeBase");
static_assert(sizeof(UBRPlacerMouseLockModeBase) == 0x0000D0, "Wrong size on UBRPlacerMouseLockModeBase");

// Class Brickadia.BRToolPreviewActor
// 0x0068 (0x0318 - 0x02B0)
class ABRToolPreviewActor final : public AActor
{
public:
	class UMaterialInterface*                     EntityPreviewMaterial;                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBRToolPreviewPartBase*>         PreviewParts;                                      // 0x02B8(0x0010)(Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bPreviewVisible;                                   // 0x02C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRToolPreviewTransformParameters      TransformParameters;                               // 0x02D0(0x0018)(Net, RepNotify, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FBRToolPreviewInstancingParameters     InstancingParameters;                              // 0x02E8(0x0030)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void ApplyInstancingParameters();
	void ApplyTransformParameters();
	void ApplyVisibility();
	void OnRep_PreviewParts(const TArray<class UBRToolPreviewPartBase*>& OldPreviewParts);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolPreviewActor">();
	}
	static class ABRToolPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRToolPreviewActor>();
	}
};
static_assert(alignof(ABRToolPreviewActor) == 0x000008, "Wrong alignment on ABRToolPreviewActor");
static_assert(sizeof(ABRToolPreviewActor) == 0x000318, "Wrong size on ABRToolPreviewActor");
static_assert(offsetof(ABRToolPreviewActor, EntityPreviewMaterial) == 0x0002B0, "Member 'ABRToolPreviewActor::EntityPreviewMaterial' has a wrong offset!");
static_assert(offsetof(ABRToolPreviewActor, PreviewParts) == 0x0002B8, "Member 'ABRToolPreviewActor::PreviewParts' has a wrong offset!");
static_assert(offsetof(ABRToolPreviewActor, bPreviewVisible) == 0x0002C8, "Member 'ABRToolPreviewActor::bPreviewVisible' has a wrong offset!");
static_assert(offsetof(ABRToolPreviewActor, TransformParameters) == 0x0002D0, "Member 'ABRToolPreviewActor::TransformParameters' has a wrong offset!");
static_assert(offsetof(ABRToolPreviewActor, InstancingParameters) == 0x0002E8, "Member 'ABRToolPreviewActor::InstancingParameters' has a wrong offset!");

// Class Brickadia.BRPlacerControlMode_Mouse
// 0x0240 (0x0348 - 0x0108)
class UBRPlacerControlMode_Mouse final : public UBRPlacerControlModeBase
{
public:
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRGizmo_PlacerGrid*                    GridGizmo;                                         // 0x0128(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRGizmo_PlacerReorient*                ReorientGizmo;                                     // 0x0130(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRGizmo_PlacerLockOrigin*              LockOriginGizmo;                                   // 0x0138(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FBRPlacerMouseModeAxis                 AxisInfo[0x3];                                     // 0x0140(0x0038)(NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x8C];                                     // 0x01E8(0x008C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OrbitPlacerControlModeName;                        // 0x0274(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetachedPlacerControlModeName;                     // 0x027C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeletePlacerControlModeName;                       // 0x0284(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultTargetingModeName;                          // 0x028C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DefaultLockModeName;                               // 0x0294(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x4];                                      // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UBRPlacerMouseTargetingModeBase*> TargetingModes;                                    // 0x02A0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class FName, class UBRPlacerMouseLockModeBase*> LockModes;                                         // 0x02F0(0x0050)(ExportObject, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class FName                                   CurrentLockModeName;                               // 0x0340(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SwitchPivotMode(class FName NewTargetingMode);
	void SwitchPivotMode_Default();

	class UBRPlacerMouseLockModeBase* GetCurrentLockMode() const;
	class UBRPlacerMouseTargetingModeBase* GetDefaultTargetingMode() const;
	const TMap<class FName, class UBRPlacerMouseTargetingModeBase*> GetTargetingModes_BP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerControlMode_Mouse">();
	}
	static class UBRPlacerControlMode_Mouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerControlMode_Mouse>();
	}
};
static_assert(alignof(UBRPlacerControlMode_Mouse) == 0x000008, "Wrong alignment on UBRPlacerControlMode_Mouse");
static_assert(sizeof(UBRPlacerControlMode_Mouse) == 0x000348, "Wrong size on UBRPlacerControlMode_Mouse");
static_assert(offsetof(UBRPlacerControlMode_Mouse, GridGizmo) == 0x000128, "Member 'UBRPlacerControlMode_Mouse::GridGizmo' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, ReorientGizmo) == 0x000130, "Member 'UBRPlacerControlMode_Mouse::ReorientGizmo' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, LockOriginGizmo) == 0x000138, "Member 'UBRPlacerControlMode_Mouse::LockOriginGizmo' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, AxisInfo) == 0x000140, "Member 'UBRPlacerControlMode_Mouse::AxisInfo' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, OrbitPlacerControlModeName) == 0x000274, "Member 'UBRPlacerControlMode_Mouse::OrbitPlacerControlModeName' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, DetachedPlacerControlModeName) == 0x00027C, "Member 'UBRPlacerControlMode_Mouse::DetachedPlacerControlModeName' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, DeletePlacerControlModeName) == 0x000284, "Member 'UBRPlacerControlMode_Mouse::DeletePlacerControlModeName' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, DefaultTargetingModeName) == 0x00028C, "Member 'UBRPlacerControlMode_Mouse::DefaultTargetingModeName' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, DefaultLockModeName) == 0x000294, "Member 'UBRPlacerControlMode_Mouse::DefaultLockModeName' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, TargetingModes) == 0x0002A0, "Member 'UBRPlacerControlMode_Mouse::TargetingModes' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, LockModes) == 0x0002F0, "Member 'UBRPlacerControlMode_Mouse::LockModes' has a wrong offset!");
static_assert(offsetof(UBRPlacerControlMode_Mouse, CurrentLockModeName) == 0x000340, "Member 'UBRPlacerControlMode_Mouse::CurrentLockModeName' has a wrong offset!");

// Class Brickadia.BROrbitCamera
// 0x0020 (0x02D0 - 0x02B0)
class ABROrbitCamera final : public AActor
{
public:
	class USpringArmComponent*                    SpringArmComponent;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       CameraComponent;                                   // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseArmLength;                                     // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmLengthMod;                                      // 0x02C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmInterpSpeed;                                    // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CC[0x4];                                      // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BROrbitCamera">();
	}
	static class ABROrbitCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABROrbitCamera>();
	}
};
static_assert(alignof(ABROrbitCamera) == 0x000008, "Wrong alignment on ABROrbitCamera");
static_assert(sizeof(ABROrbitCamera) == 0x0002D0, "Wrong size on ABROrbitCamera");
static_assert(offsetof(ABROrbitCamera, SpringArmComponent) == 0x0002B0, "Member 'ABROrbitCamera::SpringArmComponent' has a wrong offset!");
static_assert(offsetof(ABROrbitCamera, CameraComponent) == 0x0002B8, "Member 'ABROrbitCamera::CameraComponent' has a wrong offset!");
static_assert(offsetof(ABROrbitCamera, BaseArmLength) == 0x0002C0, "Member 'ABROrbitCamera::BaseArmLength' has a wrong offset!");
static_assert(offsetof(ABROrbitCamera, ArmLengthMod) == 0x0002C4, "Member 'ABROrbitCamera::ArmLengthMod' has a wrong offset!");
static_assert(offsetof(ABROrbitCamera, ArmInterpSpeed) == 0x0002C8, "Member 'ABROrbitCamera::ArmInterpSpeed' has a wrong offset!");

// Class Brickadia.BRPlacerMouseLockMode_PlaneLock
// 0x0028 (0x00F8 - 0x00D0)
class UBRPlacerMouseLockMode_PlaneLock final : public UBRPlacerMouseLockModeBase
{
public:
	class UBRGizmo_PlacerRowDragLine*             DragLineGizmo;                                     // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRGizmo_PlacerGrid*                    BottomGridGizmo;                                   // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRGizmo_PlacerGrid*                    TopGridGizmo;                                      // 0x00E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0x10];                                      // 0x00E8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerMouseLockMode_PlaneLock">();
	}
	static class UBRPlacerMouseLockMode_PlaneLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerMouseLockMode_PlaneLock>();
	}
};
static_assert(alignof(UBRPlacerMouseLockMode_PlaneLock) == 0x000008, "Wrong alignment on UBRPlacerMouseLockMode_PlaneLock");
static_assert(sizeof(UBRPlacerMouseLockMode_PlaneLock) == 0x0000F8, "Wrong size on UBRPlacerMouseLockMode_PlaneLock");
static_assert(offsetof(UBRPlacerMouseLockMode_PlaneLock, DragLineGizmo) == 0x0000D0, "Member 'UBRPlacerMouseLockMode_PlaneLock::DragLineGizmo' has a wrong offset!");
static_assert(offsetof(UBRPlacerMouseLockMode_PlaneLock, BottomGridGizmo) == 0x0000D8, "Member 'UBRPlacerMouseLockMode_PlaneLock::BottomGridGizmo' has a wrong offset!");
static_assert(offsetof(UBRPlacerMouseLockMode_PlaneLock, TopGridGizmo) == 0x0000E0, "Member 'UBRPlacerMouseLockMode_PlaneLock::TopGridGizmo' has a wrong offset!");

// Class Brickadia.BRWorldFolderDetailsPanel
// 0x0038 (0x0308 - 0x02D0)
class UBRWorldFolderDetailsPanel : public UUserWidget
{
public:
	class UBRDialogFrameBase*                     DialogFrame;                                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         MetadataText;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    OpenButton;                                        // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    DeleteButton;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    ExplorerButton;                                    // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBRBundleFolderInfoProvider> FolderProvider;                                    // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldFolderDetailsPanel">();
	}
	static class UBRWorldFolderDetailsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldFolderDetailsPanel>();
	}
};
static_assert(alignof(UBRWorldFolderDetailsPanel) == 0x000008, "Wrong alignment on UBRWorldFolderDetailsPanel");
static_assert(sizeof(UBRWorldFolderDetailsPanel) == 0x000308, "Wrong size on UBRWorldFolderDetailsPanel");
static_assert(offsetof(UBRWorldFolderDetailsPanel, DialogFrame) == 0x0002D0, "Member 'UBRWorldFolderDetailsPanel::DialogFrame' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderDetailsPanel, MetadataText) == 0x0002D8, "Member 'UBRWorldFolderDetailsPanel::MetadataText' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderDetailsPanel, OpenButton) == 0x0002E0, "Member 'UBRWorldFolderDetailsPanel::OpenButton' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderDetailsPanel, DeleteButton) == 0x0002E8, "Member 'UBRWorldFolderDetailsPanel::DeleteButton' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderDetailsPanel, ExplorerButton) == 0x0002F0, "Member 'UBRWorldFolderDetailsPanel::ExplorerButton' has a wrong offset!");
static_assert(offsetof(UBRWorldFolderDetailsPanel, FolderProvider) == 0x0002F8, "Member 'UBRWorldFolderDetailsPanel::FolderProvider' has a wrong offset!");

// Class Brickadia.BRPlacerMouseTargetingMode_Joint
// 0x0000 (0x00D0 - 0x00D0)
class UBRPlacerMouseTargetingMode_Joint final : public UBRPlacerMouseTargetingModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlacerMouseTargetingMode_Joint">();
	}
	static class UBRPlacerMouseTargetingMode_Joint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlacerMouseTargetingMode_Joint>();
	}
};
static_assert(alignof(UBRPlacerMouseTargetingMode_Joint) == 0x000008, "Wrong alignment on UBRPlacerMouseTargetingMode_Joint");
static_assert(sizeof(UBRPlacerMouseTargetingMode_Joint) == 0x0000D0, "Wrong size on UBRPlacerMouseTargetingMode_Joint");

// Class Brickadia.PlayerPartThumbnailProcessor
// 0x0008 (0x0060 - 0x0058)
class UPlayerPartThumbnailProcessor final : public UThumbnailProcessor
{
public:
	class UBRPlayerPartComponent*                 PartComponent;                                     // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerPartThumbnailProcessor">();
	}
	static class UPlayerPartThumbnailProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerPartThumbnailProcessor>();
	}
};
static_assert(alignof(UPlayerPartThumbnailProcessor) == 0x000008, "Wrong alignment on UPlayerPartThumbnailProcessor");
static_assert(sizeof(UPlayerPartThumbnailProcessor) == 0x000060, "Wrong size on UPlayerPartThumbnailProcessor");
static_assert(offsetof(UPlayerPartThumbnailProcessor, PartComponent) == 0x000058, "Member 'UPlayerPartThumbnailProcessor::PartComponent' has a wrong offset!");

// Class Brickadia.BRPlaneCollisionComponent
// 0x0000 (0x04D0 - 0x04D0)
class UBRPlaneCollisionComponent final : public UPrimitiveComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlaneCollisionComponent">();
	}
	static class UBRPlaneCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlaneCollisionComponent>();
	}
};
static_assert(alignof(UBRPlaneCollisionComponent) == 0x000010, "Wrong alignment on UBRPlaneCollisionComponent");
static_assert(sizeof(UBRPlaneCollisionComponent) == 0x0004D0, "Wrong size on UBRPlaneCollisionComponent");

// Class Brickadia.BRPlayerCameraManager
// 0x0040 (0x25E0 - 0x25A0)
class ABRPlayerCameraManager final : public APlayerCameraManager
{
public:
	class UMaterialInterface*                     CameraBlockedMaterial;                             // 0x2598(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               CameraBlockedMaterialInstance;                     // 0x25A0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_25A8[0x2C];                                    // 0x25A8(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomScalar;                                        // 0x25D4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25D8[0x8];                                     // 0x25D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyFieldOfViewFromSettings();
	void SetCameraBlockedCheckEnabled(bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerCameraManager">();
	}
	static class ABRPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRPlayerCameraManager>();
	}
};
static_assert(alignof(ABRPlayerCameraManager) == 0x000010, "Wrong alignment on ABRPlayerCameraManager");
static_assert(sizeof(ABRPlayerCameraManager) == 0x0025E0, "Wrong size on ABRPlayerCameraManager");
static_assert(offsetof(ABRPlayerCameraManager, CameraBlockedMaterial) == 0x002598, "Member 'ABRPlayerCameraManager::CameraBlockedMaterial' has a wrong offset!");
static_assert(offsetof(ABRPlayerCameraManager, CameraBlockedMaterialInstance) == 0x0025A0, "Member 'ABRPlayerCameraManager::CameraBlockedMaterialInstance' has a wrong offset!");
static_assert(offsetof(ABRPlayerCameraManager, ZoomScalar) == 0x0025D4, "Member 'ABRPlayerCameraManager::ZoomScalar' has a wrong offset!");

// Class Brickadia.BRPlayerInput
// 0x0000 (0x0498 - 0x0498)
class UBRPlayerInput final : public UPlayerInput
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerInput">();
	}
	static class UBRPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlayerInput>();
	}
};
static_assert(alignof(UBRPlayerInput) == 0x000008, "Wrong alignment on UBRPlayerInput");
static_assert(sizeof(UBRPlayerInput) == 0x000498, "Wrong size on UBRPlayerInput");

// Class Brickadia.BRPlayerDecalDescriptor
// 0x0058 (0x0088 - 0x0030)
class UBRPlayerDecalDescriptor final : public UPrimaryDataAsset
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Texture;                                           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Category;                                          // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Summary;                                           // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bShouldDisplayInGame;                              // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DecalTags;                                         // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerDecalDescriptor">();
	}
	static class UBRPlayerDecalDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlayerDecalDescriptor>();
	}
};
static_assert(alignof(UBRPlayerDecalDescriptor) == 0x000008, "Wrong alignment on UBRPlayerDecalDescriptor");
static_assert(sizeof(UBRPlayerDecalDescriptor) == 0x000088, "Wrong size on UBRPlayerDecalDescriptor");
static_assert(offsetof(UBRPlayerDecalDescriptor, Texture) == 0x000038, "Member 'UBRPlayerDecalDescriptor::Texture' has a wrong offset!");
static_assert(offsetof(UBRPlayerDecalDescriptor, Category) == 0x000040, "Member 'UBRPlayerDecalDescriptor::Category' has a wrong offset!");
static_assert(offsetof(UBRPlayerDecalDescriptor, DisplayName) == 0x000050, "Member 'UBRPlayerDecalDescriptor::DisplayName' has a wrong offset!");
static_assert(offsetof(UBRPlayerDecalDescriptor, Summary) == 0x000060, "Member 'UBRPlayerDecalDescriptor::Summary' has a wrong offset!");
static_assert(offsetof(UBRPlayerDecalDescriptor, bShouldDisplayInGame) == 0x000070, "Member 'UBRPlayerDecalDescriptor::bShouldDisplayInGame' has a wrong offset!");
static_assert(offsetof(UBRPlayerDecalDescriptor, DecalTags) == 0x000078, "Member 'UBRPlayerDecalDescriptor::DecalTags' has a wrong offset!");

// Class Brickadia.BRPlayerPartSocketTree
// 0x0018 (0x0040 - 0x0028)
class UBRPlayerPartSocketTree : public UObject
{
public:
	class USkeleton*                              Skeleton;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBRPlayerPartSocketNode>        SocketNodes;                                       // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	int32 FindSocketNode(class FName SocketName) const;
	int32 FindSymmetricalNode(int32 Index_0) const;
	TArray<int32> GetChildSocketNodes(int32 ParentIndex) const;
	class FName GetSocketNameAtTreeIndex(int32 TreeIndex) const;
	bool IsNodeChildOf(int32 ChildIndex, int32 ParentIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPlayerPartSocketTree">();
	}
	static class UBRPlayerPartSocketTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPlayerPartSocketTree>();
	}
};
static_assert(alignof(UBRPlayerPartSocketTree) == 0x000008, "Wrong alignment on UBRPlayerPartSocketTree");
static_assert(sizeof(UBRPlayerPartSocketTree) == 0x000040, "Wrong size on UBRPlayerPartSocketTree");
static_assert(offsetof(UBRPlayerPartSocketTree, Skeleton) == 0x000028, "Member 'UBRPlayerPartSocketTree::Skeleton' has a wrong offset!");
static_assert(offsetof(UBRPlayerPartSocketTree, SocketNodes) == 0x000030, "Member 'UBRPlayerPartSocketTree::SocketNodes' has a wrong offset!");

// Class Brickadia.BRPocketWorldHelpers
// 0x0000 (0x0028 - 0x0028)
class UBRPocketWorldHelpers final : public UBlueprintFunctionLibrary
{
public:
	static bool DeprojectMousePositionToPocketWorld(class UViewport* Viewport, struct FVector* PocketWorldLocation, struct FVector* PocketWorldDirection);
	static bool DeprojectScreenPositionToPocketWorld(class UViewport* Viewport, const struct FVector2D& ScreenPosition, struct FVector* PocketWorldLocation, struct FVector* PocketWorldDirection);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPocketWorldHelpers">();
	}
	static class UBRPocketWorldHelpers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPocketWorldHelpers>();
	}
};
static_assert(alignof(UBRPocketWorldHelpers) == 0x000008, "Wrong alignment on UBRPocketWorldHelpers");
static_assert(sizeof(UBRPocketWorldHelpers) == 0x000028, "Wrong size on UBRPocketWorldHelpers");

// Class Brickadia.BRPreset
// 0x0028 (0x0050 - 0x0028)
class UBRPreset final : public UObject
{
public:
	class UBRPresetDescriptor*                    Descriptor;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilePath;                                          // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetPresetVersion(int32* PresetVersion);
	bool LoadInspectorChangelist(class UObject* WorldContext, struct FInspectorPropertyChangelist* OutChangelist, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	bool LoadInspectorChangelist2(class UObject* WorldContext, struct FInspectorPropertyChangelist* OutChangelist, class UInspectorPropertyDescriptorList* View);
	bool LoadStruct(class UObject* WorldContext, int32* struct_0);
	void SaveInspectorChangelist(class UObject* WorldContext, const struct FInspectorPropertyChangelist& Changelist, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	void SaveInspectorChangelist2(class UObject* WorldContext, const struct FInspectorPropertyChangelist& Changelist, class UInspectorPropertyDescriptorList* View);
	void SaveStruct(class UObject* WorldContext, int32 struct_0);

	class FString GetPresetName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRPreset">();
	}
	static class UBRPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRPreset>();
	}
};
static_assert(alignof(UBRPreset) == 0x000008, "Wrong alignment on UBRPreset");
static_assert(sizeof(UBRPreset) == 0x000050, "Wrong size on UBRPreset");
static_assert(offsetof(UBRPreset, Descriptor) == 0x000028, "Member 'UBRPreset::Descriptor' has a wrong offset!");
static_assert(offsetof(UBRPreset, FilePath) == 0x000030, "Member 'UBRPreset::FilePath' has a wrong offset!");

// Class Brickadia.BRRuleset
// 0x0220 (0x04D0 - 0x02B0)
class ABRRuleset final : public AActor
{
public:
	TMulticastInlineDelegate<void()>              OnSettingsChanged;                                 // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnGameTypeSettingsChanged;                         // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const class FString& TeamName)> OnTeamSettingsChanged;                             // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyDescriptorList> PropertyDescriptorList;                            // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerState* State)> OnRespawnPlayer;                                   // 0x02E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F8[0x20];                                     // 0x02F8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class ABRPlayerState* State)> OnPlayerJoinRuleset;                               // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerState* State)> OnPlayerLeaveRuleset;                              // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class ABRPlayerState* State, class UBRRulesetTeam* Team1, class UBRRulesetTeam* Team2)> OnPlayerSwitchTeam;                                // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 round)>   OnRoundStart;                                      // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 round, class ABRPlayerState* State)> OnRoundEnd;                                        // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnReset;                                           // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBRGuid                                OwnerId;                                           // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerName;                                         // 0x0388(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OwnerDisplayName;                                  // 0x0398(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBRPermissionsRole*>             OwnerRoles;                                        // 0x03A8(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class ABRPlayerState*                         OwnerStateCached;                                  // 0x03B8(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x50];                                     // 0x03C0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentRound;                                      // 0x0410(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInSession;                                        // 0x0414(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_415[0x13];                                     // 0x0415(0x0013)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class ABRPlayerState*>                 MemberStates;                                      // 0x0428(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_438[0x18];                                     // 0x0438(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RulesetName;                                       // 0x0450(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RulesetDescription;                                // 0x0460(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetJoinPolicy                            RulesetJoinPolicy;                                 // 0x0470(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_471[0x3];                                      // 0x0471(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 RulesetColor;                                      // 0x0474(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetType                                  RulesetType;                                       // 0x0478(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetEntryPolicy                           RulesetEntryPolicy;                                // 0x0479(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetRelevantBricks                        RelevantBricks;                                    // 0x047A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetBrickRespawnMode                      BrickRespawnMode;                                  // 0x047B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTrustForBricksInMinigame;                   // 0x047C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47D[0x3];                                      // 0x047D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void()>              OnTeamsUpdated;                                    // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBRRulesetTeam*                         UnaffiliatedTeam;                                  // 0x0490(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UBRRulesetTeam*>                 CustomTeams;                                       // 0x0498(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, UObjectWrapper, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UBRRulesetGameType* GameTypeComponent)> OnGameTypeChanged;                                 // 0x04A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UBRRulesetGameType*                     GameType;                                          // 0x04B8(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBRRulesetGameType>         DefaultGameType;                                   // 0x04C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RulesetNameMaxCharacters;                          // 0x04C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4CC[0x4];                                      // 0x04CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeGameType(class UBRGameTypeDescriptor* GameTypeDescriptor, const struct FInspectorPropertyChangelist& NewGameTypeSettings, class ABRPlayerState* TriggerPlayer, bool bTellPlayers);
	void ClearTeams(class ABRPlayerState* TriggerPlayer);
	void EditGameTypeSettings(const struct FInspectorPropertyChangelist& NewGameTypeSettings, class ABRPlayerState* TriggerPlayer, bool bTellPlayers);
	void EditSettings(const struct FInspectorPropertyChangelist& Settings, class ABRPlayerState* MinigameEditor, bool bTellPlayers);
	void EditTeamSettings(const class FString& TeamName, const struct FInspectorPropertyChangelist& NewTeamSettings, class ABRPlayerState* TriggerPlayer, bool bTellPlayers);
	void GlobalRuleset_HandleServerSettingsUpdate(class UBRGameSettingsBase* Settings);
	void HandlePlayerReachCheckPoint(class ABRPlayerState* TriggeredBy, const struct FBrickHandle& BrickHandle);
	void HandlePlayerReachGoalPoint(class ABRPlayerState* TriggeredBy, const struct FBrickHandle& BrickHandle);
	void MoveTeam(const class FString& TeamName, const class FString& TeamNameMoveAfter, class ABRPlayerState* TriggerPlayer);
	void MulticastHandleStartSession();
	void NewRound(const int32& round, bool bImmediate, class ABRPlayerState* TriggeredBy);
	void NextRound(bool bImmediate);
	void OnRep_GameType(const class UBRRulesetGameType* Old);
	void OnRep_Teams();
	void PlaySound2D(class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings);
	void PushChatMessage(const class FString& Message);
	void PushStatusMessage(const class FString& Message, bool bFlashIfUnchanged);
	class UBRRulesetTeam* QuickCreateTeam(const struct FBRQuickTeamSettings& TeamSettings, class ABRPlayerState* TriggerPlayer, bool bTellPlayers);
	void RemoveTeam(const class FString& TeamName, class ABRPlayerState* TriggerPlayer, bool bTellPlayers);
	void ResetRuleset(class ABRPlayerState* TriggeredBy);
	void SetBrickRespawnMode(const ERulesetBrickRespawnMode& BrickRespawnModeIn);
	void SetRelevantBricks(const ERulesetRelevantBricks& BricksIncludedIn);
	void SetRulesetColor(const struct FColor& ColorIn);
	void SetRulesetDescription(const class FString& RulesetDescriptionIn);
	void SetRulesetEntryPolicy(const ERulesetEntryPolicy& EntryPolicyIn);
	void SetRulesetJoinPolicy(ERulesetJoinPolicy JoinPolicyIn);
	void SetRulesetName(const class FString& RulesetNameIn);
	void SetRulesetType(const ERulesetType& RulesetTypeIn);

	bool CanMemberBeDamagedBy(const TScriptInterface<class IBRRulesetMember>& Member, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass) const;
	class UBRRulesetTeam* FindTeamByName(const class FString& Name_0, int32* TeamIndex) const;
	bool GetCanEnableGameplayPermission(class FName Permission) const;
	int32 GetCurrentRound() const;
	class UBRRulesetGameType* GetGameType() const;
	TSubclassOf<class UBRRulesetGameType> GetGameTypeClass() const;
	bool GetIsEmpty() const;
	class ABRPlayerState* GetMember(int32 Index_0) const;
	class ABRPlayerController* GetMemberController(int32 Index_0) const;
	TArray<class ABRPlayerState*> GetMembersOrderedByLeaderboardValue(class FName ValueName) const;
	int32 GetNextRoundNumber() const;
	int32 GetNumMembers() const;
	int32 GetNumTeams() const;
	bool GetPlayerCanJoinRuleset(const class ABRPlayerState* State) const;
	bool GetPlayerCanLeaveRuleset(const class ABRPlayerState* State) const;
	bool GetPlayerCanRestart(class ABRPlayerState* State) const;
	bool GetPlayerCanSwitchTeam(class ABRPlayerState* State, int32 TeamId) const;
	bool GetPlayerHasGameplayPermission(class ABRPlayerState* State, class FName Permission) const;
	struct FLinearColor GetPlayerNameColor(class ABRPlayerState* Member) const;
	struct FTransform GetPlayerStartTransform(class ABRPlayerState* State) const;
	class ABRPlayerState* GetRandomMember() const;
	bool GetSessionIsRunning() const;
	bool GetSessionJustStarted() const;
	bool GetShouldEnableType(const class UObject* WorldContext) const;
	bool GetShouldShowBricksIncludedOption(ERulesetRelevantBricks Op, const class UObject* WorldContext) const;
	bool GetShouldShowTypeOption(ERulesetType Type, class UObject* WorldContext) const;
	TArray<class AActor*> GetSpectatorTargets(class ABRPlayerState* Spectator) const;
	class UBRRulesetTeam* GetTeam(int32 TeamId) const;
	int32 GetTeamId(const class UBRRulesetTeam* Team) const;
	TArray<class UBRRulesetTeam*> GetTeamsOrderedByLeaderboardValue(class FName ValueName, bool bIncludeUnaffiliated) const;
	class UBRRulesetTeam* GetUnaffiliatedTeam() const;
	bool IsBrickRelevant(const struct FBrickHandle& BrickHandle) const;
	bool IsBrickRelevantToMember(const struct FBrickHandle& BrickHandle, const class ABRPlayerState* Member) const;
	bool IsEntityRelevant(class AActor* ENTITY) const;
	bool IsEntityRelevantToMember(class AActor* ENTITY, const class ABRPlayerState* Member) const;
	bool ShouldShowDeathNotification(class ABRPlayerController* ShowingController, const class ABRPlayerState* VictimState, class ABRPlayerState* InstigatedByState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRuleset">();
	}
	static class ABRRuleset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRRuleset>();
	}
};
static_assert(alignof(ABRRuleset) == 0x000008, "Wrong alignment on ABRRuleset");
static_assert(sizeof(ABRRuleset) == 0x0004D0, "Wrong size on ABRRuleset");
static_assert(offsetof(ABRRuleset, OnSettingsChanged) == 0x0002B0, "Member 'ABRRuleset::OnSettingsChanged' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnGameTypeSettingsChanged) == 0x0002C0, "Member 'ABRRuleset::OnGameTypeSettingsChanged' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnTeamSettingsChanged) == 0x0002D0, "Member 'ABRRuleset::OnTeamSettingsChanged' has a wrong offset!");
static_assert(offsetof(ABRRuleset, PropertyDescriptorList) == 0x0002E0, "Member 'ABRRuleset::PropertyDescriptorList' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnRespawnPlayer) == 0x0002E8, "Member 'ABRRuleset::OnRespawnPlayer' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnPlayerJoinRuleset) == 0x000318, "Member 'ABRRuleset::OnPlayerJoinRuleset' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnPlayerLeaveRuleset) == 0x000328, "Member 'ABRRuleset::OnPlayerLeaveRuleset' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnPlayerSwitchTeam) == 0x000338, "Member 'ABRRuleset::OnPlayerSwitchTeam' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnRoundStart) == 0x000348, "Member 'ABRRuleset::OnRoundStart' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnRoundEnd) == 0x000358, "Member 'ABRRuleset::OnRoundEnd' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnReset) == 0x000368, "Member 'ABRRuleset::OnReset' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OwnerId) == 0x000378, "Member 'ABRRuleset::OwnerId' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OwnerName) == 0x000388, "Member 'ABRRuleset::OwnerName' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OwnerDisplayName) == 0x000398, "Member 'ABRRuleset::OwnerDisplayName' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OwnerRoles) == 0x0003A8, "Member 'ABRRuleset::OwnerRoles' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OwnerStateCached) == 0x0003B8, "Member 'ABRRuleset::OwnerStateCached' has a wrong offset!");
static_assert(offsetof(ABRRuleset, CurrentRound) == 0x000410, "Member 'ABRRuleset::CurrentRound' has a wrong offset!");
static_assert(offsetof(ABRRuleset, bInSession) == 0x000414, "Member 'ABRRuleset::bInSession' has a wrong offset!");
static_assert(offsetof(ABRRuleset, MemberStates) == 0x000428, "Member 'ABRRuleset::MemberStates' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetName) == 0x000450, "Member 'ABRRuleset::RulesetName' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetDescription) == 0x000460, "Member 'ABRRuleset::RulesetDescription' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetJoinPolicy) == 0x000470, "Member 'ABRRuleset::RulesetJoinPolicy' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetColor) == 0x000474, "Member 'ABRRuleset::RulesetColor' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetType) == 0x000478, "Member 'ABRRuleset::RulesetType' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetEntryPolicy) == 0x000479, "Member 'ABRRuleset::RulesetEntryPolicy' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RelevantBricks) == 0x00047A, "Member 'ABRRuleset::RelevantBricks' has a wrong offset!");
static_assert(offsetof(ABRRuleset, BrickRespawnMode) == 0x00047B, "Member 'ABRRuleset::BrickRespawnMode' has a wrong offset!");
static_assert(offsetof(ABRRuleset, bIgnoreTrustForBricksInMinigame) == 0x00047C, "Member 'ABRRuleset::bIgnoreTrustForBricksInMinigame' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnTeamsUpdated) == 0x000480, "Member 'ABRRuleset::OnTeamsUpdated' has a wrong offset!");
static_assert(offsetof(ABRRuleset, UnaffiliatedTeam) == 0x000490, "Member 'ABRRuleset::UnaffiliatedTeam' has a wrong offset!");
static_assert(offsetof(ABRRuleset, CustomTeams) == 0x000498, "Member 'ABRRuleset::CustomTeams' has a wrong offset!");
static_assert(offsetof(ABRRuleset, OnGameTypeChanged) == 0x0004A8, "Member 'ABRRuleset::OnGameTypeChanged' has a wrong offset!");
static_assert(offsetof(ABRRuleset, GameType) == 0x0004B8, "Member 'ABRRuleset::GameType' has a wrong offset!");
static_assert(offsetof(ABRRuleset, DefaultGameType) == 0x0004C0, "Member 'ABRRuleset::DefaultGameType' has a wrong offset!");
static_assert(offsetof(ABRRuleset, RulesetNameMaxCharacters) == 0x0004C8, "Member 'ABRRuleset::RulesetNameMaxCharacters' has a wrong offset!");

// Class Brickadia.BRRulesetTeam
// 0x0300 (0x0328 - 0x0028)
class UBRRulesetTeam final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class FName Name, bool Allowed)> OnGameplayPermissionUpdated;                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       GameplayPermissionsLookup;                         // 0x0048(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FBRTeamGameplayPermissionData>  GameplayPermissions;                               // 0x0098(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ABRPlayerState*>                 MemberStates;                                      // 0x00A8(0x0010)(Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	bool                                          bIsUnaffiliatedTeam;                               // 0x00B8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUndeletable;                                    // 0x00B9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGameTypeTeam;                                     // 0x00BA(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TeamName;                                          // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TeamColor;                                         // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendlyDamage;                                   // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelfDamageMode;                                   // 0x00D5(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPhysicsDamageMode;                                // 0x00D6(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeaponDamageMode;                                 // 0x00D7(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnvironmentDamageMode;                            // 0x00D8(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBrickDamageMode;                                  // 0x00D9(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DA[0x2];                                       // 0x00DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaterDamagePerSecond;                              // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRespawnTime;                                 // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETeamSpawnMode                                TeamSpawnMode;                                     // 0x00E4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E5[0x3];                                       // 0x00E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeamHealthMultiplier;                              // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamSpeedMultiplier;                               // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamJumpHeightMultiplier;                          // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamCollision;                                    // 0x00F4(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeamCanStack;                                     // 0x00F5(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F6[0x2];                                       // 0x00F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeamNameDistance;                                  // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyNameDistanceMultiplier;                       // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnInvincibilityTime;                          // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnSelfDestructPreventionTime;                 // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTeamHealthRegeneration;                     // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TeamHealthRegenStartTime;                          // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamHealthRegenPerSecond;                          // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialBrickUsePolicy                        SpecialBrickUsePolicy;                             // 0x0114(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanUseCheckPoints;                                // 0x0115(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanReachGoalPoints;                               // 0x0116(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRememberCheckPointBetweenJoins;                   // 0x0117(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControlModePolicy                            ControlModeOverride;                               // 0x0118(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCameraBlockedEffects;                       // 0x0119(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSpectatorMode;                               // 0x011A(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetSpectatePolicy                        PlayersSpectatorsCanView;                          // 0x011B(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowSpectatorFreeCamera;                         // 0x011C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeathNotifications;                               // 0x011D(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetTeamSpectatorChat                     SpectatorChat;                                     // 0x011E(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitChatRange;                                   // 0x011F(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChatRange;                                         // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERulesetTeamVisibility                        Visibility;                                        // 0x0124(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UBRRulesetTeam>          FakeTeamWhenHidden;                                // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterBaseRotationOverride                CharacterBaseRotationOverride;                     // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepInventoryOnRespawn;                           // 0x0131(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxItemSlots;                                      // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem0;                                     // 0x0138(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem1;                                     // 0x0168(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem2;                                     // 0x0198(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem3;                                     // 0x01C8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem4;                                     // 0x01F8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem5;                                     // 0x0228(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem6;                                     // 0x0258(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem7;                                     // 0x0288(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem8;                                     // 0x02B8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	struct FBRInventoryEntryPlan                  StartingItem9;                                     // 0x02E8(0x0030)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyDescriptorList> PropertyDescriptorList;                            // 0x0318(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInspectorPropertyDescriptorList*       CachedDescriptorList;                              // 0x0320(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UInspectorPropertyDescriptorList* GetCombinedPropertyDescriptor(const class UObject* WorldContext);
	class FString GetFakeTeamWhenHidden();
	void HandleDie(const TScriptInterface<class IBRRulesetMemberDestructable>& DeadMember, float FinalDamage, const class UDamageType* DeathType, class AController* InstigatedBy, class AActor* DeathCauser);
	void HandleEditSettings(class ABRPlayerState* MinigameEditor, const struct FInspectorPropertyChangelist& Settings, bool bTellPlayers);
	void HandleJoinTeam(class ABRPlayerState* Member, bool bMessage);
	void HandleLeaveTeam(class ABRPlayerState* Member);
	void HandlePlayerChatMessage(class ABRPlayerState* TriggerPlayer, const class FString& ChatMessage);
	void HandlePlayerRestart(class ABRPlayerState* State);
	void HandlePlayerTeamChatMessage(class ABRPlayerState* TriggerPlayer, const class FString& ChatMessage);
	void HandleSetupUnaffiliatedTeam();
	void Inspector_SetPermissionState(class FName Permission, bool InState);
	void NotifyCreated();
	void NotifyDestroyed();
	void OnRep_ControlModeOverride();
	void OnRep_InspectorSetting();
	void PushChatMessage(const class FString& Message);
	void PushStatusMessage(const class FString& Message, bool bFlashIfUnchanged);
	void RebuildPermissionLookup();
	void RemoveAllMembers();
	void SetAllowSpectatorFreeCamera(bool bYes);
	void SetBrickDamageMode(bool bEnvironmentDamageModeIn);
	void SetCanReachGoalPoints(bool bYes);
	void SetCanUseCheckPoints(bool bYes);
	void SetCharacterBaseRotationOverride(ECharacterBaseRotationOverride Override);
	void SetChatRange(float Range);
	void SetControlModeOverride(EControlModePolicy ControlModeOverrideIn);
	void SetDeathNotifications(bool bEnabled);
	void SetEnableCameraBlockedEffects(bool bYes);
	void SetEnableTeamHealthRegeneration(bool Regen);
	void SetEnemyNameDistanceMultiplier(float DistanceMultiplier);
	void SetEnvironmentDamageMode(bool bEnvironmentDamageModeIn);
	void SetFakeTeamWhenHidden(const class FString& TeamName_0);
	void SetForceSpectatorMode(bool bYes);
	void SetFriendlyDamage(bool Enabled);
	void SetGameplayPermission(class FName Permission, EBRSetPermission State);
	void SetGameplayPermissions(const TArray<struct FBRTeamGameplayPermissionData>& Permissions);
	void SetKeepInventoryOnRespawn(bool bKeep);
	void SetLimitChatRange(bool bLimited);
	void SetMaxItemSlots(int32 MaxSlots);
	void SetPhysicsDamageMode(bool bPhysicsDamageModeIn);
	void SetPlayerRespawnTime(float NewPlayerRespawnTime);
	void SetPlayersSpectatorsCanView(ERulesetSpectatePolicy SpectatePolicy);
	void SetRememberCheckPointBetweenJoins(bool bRemember);
	void SetRespawnInvincibilityTime(float TimeSeconds);
	void SetRespawnSelfDestructPreventionTime(float TimeSeconds);
	void SetSelfDamageMode(bool bSelfDamageModeIn);
	void SetSpecialBrickUsePolicy(const ESpecialBrickUsePolicy& SpecialBrickUsePolicyIn);
	void SetSpectatorChat(ERulesetTeamSpectatorChat Mode);
	void SetStartingItem0(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem1(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem2(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem3(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem4(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem5(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem6(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem7(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem8(const struct FBRInventoryEntryPlan& Item);
	void SetStartingItem9(const struct FBRInventoryEntryPlan& Item);
	void SetTeamCanStack(bool Stack);
	void SetTeamCollision(bool Collide);
	void SetTeamColor(const struct FColor& NewTeamColor);
	void SetTeamHealthMultiplier(float Health);
	void SetTeamHealthRegenPerSecond(float PerSecondRegen);
	void SetTeamHealthRegenStartTime(float StartTime);
	void SetTeamJumpHeightMultiplier(float Height);
	void SetTeamName(const class FString& NewTeamName);
	void SetTeamNameDistance(float Distance);
	void SetTeamSpawnMode(ETeamSpawnMode NewTeamSpawnMode);
	void SetTeamSpeedMultiplier(float Speed);
	void SetVisibility(ERulesetTeamVisibility Visibility_0);
	void SetWaterDamagePerSecond(float WaterDamagePerSecondIn);
	void SetWeaponDamageMode(bool bWeaponDamageModeIn);

	bool CanBeDamagedBy(class UBRRulesetTeam* TeamB) const;
	bool CanMemberBeDamagedBy(const TScriptInterface<class IBRRulesetMember>& Member, class AController* EventInstigator, class AActor* DamageCauser, TSubclassOf<class UDamageType> DamageTypeClass) const;
	bool CanRenameTeam() const;
	struct FColor GetActualTeamColor() const;
	int32 GetCombinedLeaderboardValue(class FName ValueName) const;
	int32 GetCombinedLeaderboardValueByIndex(int32 Index_0) const;
	bool GetLimitChatRange() const;
	class ABRPlayerState* GetMember(int32 Index_0) const;
	class ABRPlayerController* GetMemberController(int32 Index_0) const;
	void GetMembers(TArray<class ABRPlayerState*>* MembersOut) const;
	void GetMembersFor(const class ABRPlayerState* Viewer, TArray<class ABRPlayerState*>* MembersOut) const;
	TArray<class ABRPlayerState*> GetMembersOrderedByLeaderboardValue(class FName ValueName) const;
	int32 GetNumMembers() const;
	bool GetPlayerCanJoin(class ABRPlayerState* State) const;
	bool GetPlayerCanLeave(class ABRPlayerState* State) const;
	bool GetPlayerCanRestart(class ABRPlayerState* State) const;
	bool GetPlayerHasGameplayPermission(class ABRPlayerState* State, class FName Permission) const;
	struct FLinearColor GetPlayerNameColor(class ABRPlayerState* Member) const;
	struct FTransform GetPlayerStartTransform(class ABRPlayerState* State) const;
	class ABRPlayerState* GetRandomMember() const;
	bool GetTeamAllowedToUseSpecialBrick(const struct FBrickHandle& BrickHandle) const;
	struct FColor GetTeamDisplayColor() const;
	int32 GetTeamId() const;
	bool HasGameplayPermission(const class UObject* WorldContext, class FName Permission) const;
	bool Inspector_CanEditPermission(class FName Permission, class UObject* WorldContext) const;
	bool Inspector_GetPermissionState(class UObject* WorldContext, class FName Permission) const;
	bool IsHostileTo(class UBRRulesetTeam* TeamB) const;
	bool ShouldAllowFriendlyDamage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRulesetTeam">();
	}
	static class UBRRulesetTeam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRRulesetTeam>();
	}
};
static_assert(alignof(UBRRulesetTeam) == 0x000008, "Wrong alignment on UBRRulesetTeam");
static_assert(sizeof(UBRRulesetTeam) == 0x000328, "Wrong size on UBRRulesetTeam");
static_assert(offsetof(UBRRulesetTeam, OnGameplayPermissionUpdated) == 0x000038, "Member 'UBRRulesetTeam::OnGameplayPermissionUpdated' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, GameplayPermissionsLookup) == 0x000048, "Member 'UBRRulesetTeam::GameplayPermissionsLookup' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, GameplayPermissions) == 0x000098, "Member 'UBRRulesetTeam::GameplayPermissions' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, MemberStates) == 0x0000A8, "Member 'UBRRulesetTeam::MemberStates' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bIsUnaffiliatedTeam) == 0x0000B8, "Member 'UBRRulesetTeam::bIsUnaffiliatedTeam' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bIsUndeletable) == 0x0000B9, "Member 'UBRRulesetTeam::bIsUndeletable' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bGameTypeTeam) == 0x0000BA, "Member 'UBRRulesetTeam::bGameTypeTeam' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamName) == 0x0000C0, "Member 'UBRRulesetTeam::TeamName' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamColor) == 0x0000D0, "Member 'UBRRulesetTeam::TeamColor' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bFriendlyDamage) == 0x0000D4, "Member 'UBRRulesetTeam::bFriendlyDamage' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bSelfDamageMode) == 0x0000D5, "Member 'UBRRulesetTeam::bSelfDamageMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bPhysicsDamageMode) == 0x0000D6, "Member 'UBRRulesetTeam::bPhysicsDamageMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bWeaponDamageMode) == 0x0000D7, "Member 'UBRRulesetTeam::bWeaponDamageMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bEnvironmentDamageMode) == 0x0000D8, "Member 'UBRRulesetTeam::bEnvironmentDamageMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bBrickDamageMode) == 0x0000D9, "Member 'UBRRulesetTeam::bBrickDamageMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, WaterDamagePerSecond) == 0x0000DC, "Member 'UBRRulesetTeam::WaterDamagePerSecond' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, PlayerRespawnTime) == 0x0000E0, "Member 'UBRRulesetTeam::PlayerRespawnTime' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamSpawnMode) == 0x0000E4, "Member 'UBRRulesetTeam::TeamSpawnMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamHealthMultiplier) == 0x0000E8, "Member 'UBRRulesetTeam::TeamHealthMultiplier' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamSpeedMultiplier) == 0x0000EC, "Member 'UBRRulesetTeam::TeamSpeedMultiplier' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamJumpHeightMultiplier) == 0x0000F0, "Member 'UBRRulesetTeam::TeamJumpHeightMultiplier' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bTeamCollision) == 0x0000F4, "Member 'UBRRulesetTeam::bTeamCollision' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bTeamCanStack) == 0x0000F5, "Member 'UBRRulesetTeam::bTeamCanStack' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamNameDistance) == 0x0000F8, "Member 'UBRRulesetTeam::TeamNameDistance' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, EnemyNameDistanceMultiplier) == 0x0000FC, "Member 'UBRRulesetTeam::EnemyNameDistanceMultiplier' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, RespawnInvincibilityTime) == 0x000100, "Member 'UBRRulesetTeam::RespawnInvincibilityTime' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, RespawnSelfDestructPreventionTime) == 0x000104, "Member 'UBRRulesetTeam::RespawnSelfDestructPreventionTime' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bEnableTeamHealthRegeneration) == 0x000108, "Member 'UBRRulesetTeam::bEnableTeamHealthRegeneration' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamHealthRegenStartTime) == 0x00010C, "Member 'UBRRulesetTeam::TeamHealthRegenStartTime' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, TeamHealthRegenPerSecond) == 0x000110, "Member 'UBRRulesetTeam::TeamHealthRegenPerSecond' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, SpecialBrickUsePolicy) == 0x000114, "Member 'UBRRulesetTeam::SpecialBrickUsePolicy' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bCanUseCheckPoints) == 0x000115, "Member 'UBRRulesetTeam::bCanUseCheckPoints' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bCanReachGoalPoints) == 0x000116, "Member 'UBRRulesetTeam::bCanReachGoalPoints' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bRememberCheckPointBetweenJoins) == 0x000117, "Member 'UBRRulesetTeam::bRememberCheckPointBetweenJoins' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, ControlModeOverride) == 0x000118, "Member 'UBRRulesetTeam::ControlModeOverride' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bEnableCameraBlockedEffects) == 0x000119, "Member 'UBRRulesetTeam::bEnableCameraBlockedEffects' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bForceSpectatorMode) == 0x00011A, "Member 'UBRRulesetTeam::bForceSpectatorMode' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, PlayersSpectatorsCanView) == 0x00011B, "Member 'UBRRulesetTeam::PlayersSpectatorsCanView' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bAllowSpectatorFreeCamera) == 0x00011C, "Member 'UBRRulesetTeam::bAllowSpectatorFreeCamera' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bDeathNotifications) == 0x00011D, "Member 'UBRRulesetTeam::bDeathNotifications' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, SpectatorChat) == 0x00011E, "Member 'UBRRulesetTeam::SpectatorChat' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bLimitChatRange) == 0x00011F, "Member 'UBRRulesetTeam::bLimitChatRange' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, ChatRange) == 0x000120, "Member 'UBRRulesetTeam::ChatRange' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, Visibility) == 0x000124, "Member 'UBRRulesetTeam::Visibility' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, FakeTeamWhenHidden) == 0x000128, "Member 'UBRRulesetTeam::FakeTeamWhenHidden' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, CharacterBaseRotationOverride) == 0x000130, "Member 'UBRRulesetTeam::CharacterBaseRotationOverride' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, bKeepInventoryOnRespawn) == 0x000131, "Member 'UBRRulesetTeam::bKeepInventoryOnRespawn' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, MaxItemSlots) == 0x000134, "Member 'UBRRulesetTeam::MaxItemSlots' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem0) == 0x000138, "Member 'UBRRulesetTeam::StartingItem0' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem1) == 0x000168, "Member 'UBRRulesetTeam::StartingItem1' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem2) == 0x000198, "Member 'UBRRulesetTeam::StartingItem2' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem3) == 0x0001C8, "Member 'UBRRulesetTeam::StartingItem3' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem4) == 0x0001F8, "Member 'UBRRulesetTeam::StartingItem4' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem5) == 0x000228, "Member 'UBRRulesetTeam::StartingItem5' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem6) == 0x000258, "Member 'UBRRulesetTeam::StartingItem6' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem7) == 0x000288, "Member 'UBRRulesetTeam::StartingItem7' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem8) == 0x0002B8, "Member 'UBRRulesetTeam::StartingItem8' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, StartingItem9) == 0x0002E8, "Member 'UBRRulesetTeam::StartingItem9' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, PropertyDescriptorList) == 0x000318, "Member 'UBRRulesetTeam::PropertyDescriptorList' has a wrong offset!");
static_assert(offsetof(UBRRulesetTeam, CachedDescriptorList) == 0x000320, "Member 'UBRRulesetTeam::CachedDescriptorList' has a wrong offset!");

// Class Brickadia.BRServerSettingsBase_General
// 0x0080 (0x00C8 - 0x0048)
class UBRServerSettingsBase_General : public UBRServerSettingsBase
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ServerName;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerDescription;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerPassword;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlayers;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPubliclyListed;                                   // 0x0084(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WelcomeMessage;                                    // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobalRulesetSelfDamage;                          // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobalRulesetPhysicsDamage;                       // 0x0099(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGlobalRulesetEnableCameraBlockedEffects;          // 0x009A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9B[0x1];                                       // 0x009B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UploadTimeout;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPrefabBricks;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPrefabComponents;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             MaxPrefabSize;                                     // 0x00A8(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlacementBricks;                                // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPlacementEntities;                              // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        TemplatePlacementTimeout;                          // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetGlobalRulesetEnableCameraBlockedEffects(bool bBlockedEffects);
	void SetGlobalRulesetPhysicsDamage(bool bPhysicsDamage);
	void SetGlobalRulesetSelfDamage(bool bSelfDamage);
	void SetIsPubliclyListed(bool bInPubliclyListed);
	void SetMaxPlayers(int32 InMaxPlayers);
	void SetMaxPrefabBricks(int32 Value);
	void SetMaxPrefabComponents(int32 Value);
	void SetMaxPrefabSize(const struct FIntVector& Value);
	void SetServerDescription(const class FString& InServerDescription);
	void SetServerName(const class FString& InServerName);
	void SetServerPassword(const class FString& InServerPassword);
	void SetUploadTimeout(float Value);
	void SetWelcomeMessage(const class FString& InWelcomeMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRServerSettingsBase_General">();
	}
	static class UBRServerSettingsBase_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRServerSettingsBase_General>();
	}
};
static_assert(alignof(UBRServerSettingsBase_General) == 0x000008, "Wrong alignment on UBRServerSettingsBase_General");
static_assert(sizeof(UBRServerSettingsBase_General) == 0x0000C8, "Wrong size on UBRServerSettingsBase_General");
static_assert(offsetof(UBRServerSettingsBase_General, ServerName) == 0x000050, "Member 'UBRServerSettingsBase_General::ServerName' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, ServerDescription) == 0x000060, "Member 'UBRServerSettingsBase_General::ServerDescription' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, ServerPassword) == 0x000070, "Member 'UBRServerSettingsBase_General::ServerPassword' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, MaxPlayers) == 0x000080, "Member 'UBRServerSettingsBase_General::MaxPlayers' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, bPubliclyListed) == 0x000084, "Member 'UBRServerSettingsBase_General::bPubliclyListed' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, WelcomeMessage) == 0x000088, "Member 'UBRServerSettingsBase_General::WelcomeMessage' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, bGlobalRulesetSelfDamage) == 0x000098, "Member 'UBRServerSettingsBase_General::bGlobalRulesetSelfDamage' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, bGlobalRulesetPhysicsDamage) == 0x000099, "Member 'UBRServerSettingsBase_General::bGlobalRulesetPhysicsDamage' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, bGlobalRulesetEnableCameraBlockedEffects) == 0x00009A, "Member 'UBRServerSettingsBase_General::bGlobalRulesetEnableCameraBlockedEffects' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, UploadTimeout) == 0x00009C, "Member 'UBRServerSettingsBase_General::UploadTimeout' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, MaxPrefabBricks) == 0x0000A0, "Member 'UBRServerSettingsBase_General::MaxPrefabBricks' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, MaxPrefabComponents) == 0x0000A4, "Member 'UBRServerSettingsBase_General::MaxPrefabComponents' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, MaxPrefabSize) == 0x0000A8, "Member 'UBRServerSettingsBase_General::MaxPrefabSize' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, MaxPlacementBricks) == 0x0000B4, "Member 'UBRServerSettingsBase_General::MaxPlacementBricks' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, MaxPlacementEntities) == 0x0000B8, "Member 'UBRServerSettingsBase_General::MaxPlacementEntities' has a wrong offset!");
static_assert(offsetof(UBRServerSettingsBase_General, TemplatePlacementTimeout) == 0x0000C0, "Member 'UBRServerSettingsBase_General::TemplatePlacementTimeout' has a wrong offset!");

// Class Brickadia.BRSpherePhysicsStaticMeshComponent
// 0x0010 (0x05B0 - 0x05A0)
class UBRSpherePhysicsStaticMeshComponent final : public UStaticMeshComponent
{
public:
	bool                                          bUseSphere;                                        // 0x0598(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_599[0x3];                                      // 0x0599(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SphereBodge;                                       // 0x059C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseBodgeAsRadius;                                 // 0x05A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A1[0x7];                                      // 0x05A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBodySetup*                             CachedSphereBodySetup;                             // 0x05A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRSpherePhysicsStaticMeshComponent">();
	}
	static class UBRSpherePhysicsStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRSpherePhysicsStaticMeshComponent>();
	}
};
static_assert(alignof(UBRSpherePhysicsStaticMeshComponent) == 0x000010, "Wrong alignment on UBRSpherePhysicsStaticMeshComponent");
static_assert(sizeof(UBRSpherePhysicsStaticMeshComponent) == 0x0005B0, "Wrong size on UBRSpherePhysicsStaticMeshComponent");
static_assert(offsetof(UBRSpherePhysicsStaticMeshComponent, bUseSphere) == 0x000598, "Member 'UBRSpherePhysicsStaticMeshComponent::bUseSphere' has a wrong offset!");
static_assert(offsetof(UBRSpherePhysicsStaticMeshComponent, SphereBodge) == 0x00059C, "Member 'UBRSpherePhysicsStaticMeshComponent::SphereBodge' has a wrong offset!");
static_assert(offsetof(UBRSpherePhysicsStaticMeshComponent, bUseBodgeAsRadius) == 0x0005A0, "Member 'UBRSpherePhysicsStaticMeshComponent::bUseBodgeAsRadius' has a wrong offset!");
static_assert(offsetof(UBRSpherePhysicsStaticMeshComponent, CachedSphereBodySetup) == 0x0005A8, "Member 'UBRSpherePhysicsStaticMeshComponent::CachedSphereBodySetup' has a wrong offset!");

// Class Brickadia.BRTabSetWidget
// 0x0050 (0x0320 - 0x02D0)
class UBRTabSetWidget : public UUserWidget
{
public:
	class UHorizontalBox*                         TabBox;                                            // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBRTabSetEntry>                 TabButtonData;                                     // 0x02D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRTabWidget>               TabWidgetClass;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(int32 Index)>   OnTabSelected;                                     // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_300[0x18];                                     // 0x0300(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectedTab;                                       // 0x0318(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoSelectFirstEnabledTab();
	void AutoSelectFirstEnabledTabIfCurrentIsDisabled();
	void ClearSelectedTab();
	void SetSelectedTab(int32 Index_0);
	void SetTabEnabled(int32 Index_0, bool bEnabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTabSetWidget">();
	}
	static class UBRTabSetWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRTabSetWidget>();
	}
};
static_assert(alignof(UBRTabSetWidget) == 0x000008, "Wrong alignment on UBRTabSetWidget");
static_assert(sizeof(UBRTabSetWidget) == 0x000320, "Wrong size on UBRTabSetWidget");
static_assert(offsetof(UBRTabSetWidget, TabBox) == 0x0002D0, "Member 'UBRTabSetWidget::TabBox' has a wrong offset!");
static_assert(offsetof(UBRTabSetWidget, TabButtonData) == 0x0002D8, "Member 'UBRTabSetWidget::TabButtonData' has a wrong offset!");
static_assert(offsetof(UBRTabSetWidget, TabWidgetClass) == 0x0002E8, "Member 'UBRTabSetWidget::TabWidgetClass' has a wrong offset!");
static_assert(offsetof(UBRTabSetWidget, OnTabSelected) == 0x0002F0, "Member 'UBRTabSetWidget::OnTabSelected' has a wrong offset!");
static_assert(offsetof(UBRTabSetWidget, SelectedTab) == 0x000318, "Member 'UBRTabSetWidget::SelectedTab' has a wrong offset!");

// Class Brickadia.BRToolBindHintWidget
// 0x0000 (0x02D0 - 0x02D0)
class UBRToolBindHintWidget final : public UUserWidget
{
public:
	void Setup(const struct FBRToolBindHint& BindInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolBindHintWidget">();
	}
	static class UBRToolBindHintWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolBindHintWidget>();
	}
};
static_assert(alignof(UBRToolBindHintWidget) == 0x000008, "Wrong alignment on UBRToolBindHintWidget");
static_assert(sizeof(UBRToolBindHintWidget) == 0x0002D0, "Wrong size on UBRToolBindHintWidget");

// Class Brickadia.BrickGridHypotheticalActor
// 0x0000 (0x02C0 - 0x02C0)
class ABrickGridHypotheticalActor final : public ABrickGridActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BrickGridHypotheticalActor">();
	}
	static class ABrickGridHypotheticalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABrickGridHypotheticalActor>();
	}
};
static_assert(alignof(ABrickGridHypotheticalActor) == 0x000008, "Wrong alignment on ABrickGridHypotheticalActor");
static_assert(sizeof(ABrickGridHypotheticalActor) == 0x0002C0, "Wrong size on ABrickGridHypotheticalActor");

// Class Brickadia.BRToolPreviewPart_SimpleBrick
// 0x0020 (0x0110 - 0x00F0)
class UBRToolPreviewPart_SimpleBrick final : public UBRToolPreviewPartBase
{
public:
	class UBrickGridComponent*                    PreviewGrid;                                       // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x20];                                      // 0x00F0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolPreviewPart_SimpleBrick">();
	}
	static class UBRToolPreviewPart_SimpleBrick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolPreviewPart_SimpleBrick>();
	}
};
static_assert(alignof(UBRToolPreviewPart_SimpleBrick) == 0x000010, "Wrong alignment on UBRToolPreviewPart_SimpleBrick");
static_assert(sizeof(UBRToolPreviewPart_SimpleBrick) == 0x000110, "Wrong size on UBRToolPreviewPart_SimpleBrick");
static_assert(offsetof(UBRToolPreviewPart_SimpleBrick, PreviewGrid) == 0x0000E8, "Member 'UBRToolPreviewPart_SimpleBrick::PreviewGrid' has a wrong offset!");

// Class Brickadia.BRToolPreviewPart_ReplicatedBrickGrid
// 0x0010 (0x0100 - 0x00F0)
class UBRToolPreviewPart_ReplicatedBrickGrid final : public UBRToolPreviewPartBase
{
public:
	class UBrickGridComponent*                    PreviewGrid;                                       // 0x00E8(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBrickBuildingTemplate*                 Template_ServerOnly;                               // 0x00F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PreviewGrid();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolPreviewPart_ReplicatedBrickGrid">();
	}
	static class UBRToolPreviewPart_ReplicatedBrickGrid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolPreviewPart_ReplicatedBrickGrid>();
	}
};
static_assert(alignof(UBRToolPreviewPart_ReplicatedBrickGrid) == 0x000010, "Wrong alignment on UBRToolPreviewPart_ReplicatedBrickGrid");
static_assert(sizeof(UBRToolPreviewPart_ReplicatedBrickGrid) == 0x000100, "Wrong size on UBRToolPreviewPart_ReplicatedBrickGrid");
static_assert(offsetof(UBRToolPreviewPart_ReplicatedBrickGrid, PreviewGrid) == 0x0000E8, "Member 'UBRToolPreviewPart_ReplicatedBrickGrid::PreviewGrid' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewPart_ReplicatedBrickGrid, Template_ServerOnly) == 0x0000F0, "Member 'UBRToolPreviewPart_ReplicatedBrickGrid::Template_ServerOnly' has a wrong offset!");

// Class Brickadia.BRToolPreviewManagerComponent
// 0x0118 (0x01C0 - 0x00A8)
class UBRToolPreviewManagerComponent final : public UActorComponent
{
public:
	TSubclassOf<class ABRToolPreviewActor>        PreviewActorClass;                                 // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABrickGridHypotheticalActor*            HypotheticalGrid;                                  // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABRToolPreviewActor*                    PreviewActor;                                      // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C0[0x100];                                     // 0x00C0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroyPreview_ServerOnly();
	void InitializePreview_ServerOnly(const TArray<TSubclassOf<class UBRToolPreviewPartBase>>& Parts);
	void OnRep_PreviewActor();
	void ServerSetHypotheticalGridTransform(class USceneComponent* RelativeTo, const struct FTransform& NewTransform);
	void ServerSetPreviewInstancingParameters(const struct FBRToolPreviewInstancingParameters& NewInstancingParameters);
	void ServerSetPreviewPartDisplayParameters(int32 PartIndex, const struct FBRToolPreviewPartDisplayParameters& NewDisplayParameters);
	void ServerSetPreviewPartTransformParameters(int32 PartIndex, const struct FBRToolPreviewPartTransformParameters& NewTransformParameters);
	void ServerSetPreviewTransformParameters(const struct FBRToolPreviewTransformParameters& NewTransformParameters, bool bSnapTransform);
	void ServerSetPreviewVisibility(bool bNewVisibility);
	void SetHypotheticalGridTransform(class USceneComponent* RelativeTo, const struct FTransform& NewRelativeTransform);
	void SetPreviewInstancingParameters(const struct FBRToolPreviewInstancingParameters& NewInstancingParameters);
	void SetPreviewPartDisplayParameters(int32 PartIndex, const struct FBRToolPreviewPartDisplayParameters& NewDisplayParameters);
	void SetPreviewPartTransformParameters(int32 PartIndex, const struct FBRToolPreviewPartTransformParameters& NewTransformParameters);
	void SetPreviewTransformParameters(const struct FBRToolPreviewTransformParameters& NewTransformParameters, bool bSnapTransform);
	void SetPreviewVisibility(bool bNewVisibility);

	class UBRToolPreviewPartBase* GetPreviewPart(int32 PartIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRToolPreviewManagerComponent">();
	}
	static class UBRToolPreviewManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRToolPreviewManagerComponent>();
	}
};
static_assert(alignof(UBRToolPreviewManagerComponent) == 0x000008, "Wrong alignment on UBRToolPreviewManagerComponent");
static_assert(sizeof(UBRToolPreviewManagerComponent) == 0x0001C0, "Wrong size on UBRToolPreviewManagerComponent");
static_assert(offsetof(UBRToolPreviewManagerComponent, PreviewActorClass) == 0x0000A8, "Member 'UBRToolPreviewManagerComponent::PreviewActorClass' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewManagerComponent, HypotheticalGrid) == 0x0000B0, "Member 'UBRToolPreviewManagerComponent::HypotheticalGrid' has a wrong offset!");
static_assert(offsetof(UBRToolPreviewManagerComponent, PreviewActor) == 0x0000B8, "Member 'UBRToolPreviewManagerComponent::PreviewActor' has a wrong offset!");

// Class Brickadia.BRTool_Applicator
// 0x00D0 (0x06C0 - 0x05F0)
class ABRTool_Applicator final : public ABRToolBase
{
public:
	TSubclassOf<class UBRApplicatorHoverWidget>   PreviewWidgetClass;                                // 0x05F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRApplicatorBrickDialog>   BrickEditDialogClass;                              // 0x05F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRApplicatorEntityDialog>  EntityEditDialogClass;                             // 0x0600(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_608[0x10];                                     // 0x0608(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 HilightedActor;                                    // 0x0618(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 SelectedActor;                                     // 0x0620(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_628[0x8];                                      // 0x0628(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetComponent*                       PreviewWidgetComponent;                            // 0x0630(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRApplicatorBrickDialog*               LastBrickDialog;                                   // 0x0638(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRApplicatorEntityDialog*              LastEntityDialog;                                  // 0x0640(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EBRApplicatorClipboardState                   Clipboard_State;                                   // 0x0648(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_649[0x7];                                      // 0x0649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRApplicatorBrickClipboard            Clipboard_Brick;                                   // 0x0650(0x0058)(NativeAccessSpecifierPrivate)
	struct FBRApplicatorEntityClipboard           Clipboard_Entity;                                  // 0x06A8(0x0018)(NativeAccessSpecifierPrivate)

public:
	void Audio_OnAddBrickComponent(const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* Component);
	void Audio_OnCopyBrick(const struct FBrickHandle& BrickHandle);
	void Audio_OnCopyEntity(class AActor* ENTITY);
	void Audio_OnCopyOrPasteMissed();
	void Audio_OnPasteBrick(const struct FBrickHandle& BrickHandle);
	void Audio_OnPasteEntity(class AActor* ENTITY);
	void Audio_OnRemoveBrickComponent(const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* Component);
	void Audio_OnSelectBrick(const struct FBrickHandle& BrickHandle);
	void Audio_OnSelectEntity(class AActor* ENTITY);
	void Audio_OnSelectMissed();
	void ManualFire(class UBRApplicatorDialogBase* OpenApplicatorDialog);
	void ServerAddComponent(const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* Component);
	void ServerApplyBrickState(const struct FBrickHandle& BrickHandle, bool bVisible, EBrickCollisionChannels CollisionChannels, const TArray<class UBrickComponentTypeBase*>& ComponentTypes, const TArray<struct FInspectorPropertyChangelist>& ComponentDatas);
	void ServerCommitModifications();
	void ServerCopyBrick(const struct FBrickHandle& BrickHandle);
	void ServerCopyEntity(class AActor* ENTITY);
	void ServerModifyComponent(const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* Component, const struct FInspectorPropertyChangelist& Changelist);
	void ServerModifyEntity(class AActor* ENTITY, const struct FInspectorPropertyChangelist& Changelist);
	void ServerPasteBrick(const struct FBrickHandle& BrickHandle);
	void ServerPasteEntity(class AActor* ENTITY);
	void ServerRemoveComponent(const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* Component);
	void ServerResetBrickState(const struct FBrickHandle& BrickHandle);
	void ServerSetCollisionChannels(const struct FBrickHandle& BrickHandle, EBrickCollisionChannels CollisionChannels);
	void ServerSetComponentEnabledProp(const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* Component, bool bEnabled);
	void ServerSetVisible(const struct FBrickHandle& BrickHandle, bool bVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Applicator">();
	}
	static class ABRTool_Applicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Applicator>();
	}
};
static_assert(alignof(ABRTool_Applicator) == 0x000008, "Wrong alignment on ABRTool_Applicator");
static_assert(sizeof(ABRTool_Applicator) == 0x0006C0, "Wrong size on ABRTool_Applicator");
static_assert(offsetof(ABRTool_Applicator, PreviewWidgetClass) == 0x0005F0, "Member 'ABRTool_Applicator::PreviewWidgetClass' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, BrickEditDialogClass) == 0x0005F8, "Member 'ABRTool_Applicator::BrickEditDialogClass' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, EntityEditDialogClass) == 0x000600, "Member 'ABRTool_Applicator::EntityEditDialogClass' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, HilightedActor) == 0x000618, "Member 'ABRTool_Applicator::HilightedActor' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, SelectedActor) == 0x000620, "Member 'ABRTool_Applicator::SelectedActor' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, PreviewWidgetComponent) == 0x000630, "Member 'ABRTool_Applicator::PreviewWidgetComponent' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, LastBrickDialog) == 0x000638, "Member 'ABRTool_Applicator::LastBrickDialog' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, LastEntityDialog) == 0x000640, "Member 'ABRTool_Applicator::LastEntityDialog' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, Clipboard_State) == 0x000648, "Member 'ABRTool_Applicator::Clipboard_State' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, Clipboard_Brick) == 0x000650, "Member 'ABRTool_Applicator::Clipboard_Brick' has a wrong offset!");
static_assert(offsetof(ABRTool_Applicator, Clipboard_Entity) == 0x0006A8, "Member 'ABRTool_Applicator::Clipboard_Entity' has a wrong offset!");

// Class Brickadia.BRTool_Hammer
// 0x0028 (0x0618 - 0x05F0)
class ABRTool_Hammer final : public ABRToolBase
{
public:
	float                                         Range;                                             // 0x05F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RefireTime;                                        // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AntiSpamTime;                                      // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x1C];                                     // 0x05FC(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HammerBrick(const struct FVector& Location);
	void HammerEntity(const struct FVector& Location);
	void HammerHit(bool bHit, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void MulticastHammerBrick(const struct FVector& Location);
	void MulticastHammerEntity(const struct FVector& Location);
	void MulticastHammerHit(bool bHit, const struct FVector& HitLocation, const struct FVector& HitNormal);
	void ServerHammerBrick(const struct FBrickHandle& BrickHandle);
	void ServerHammerEntity(class AActor* ENTITY);
	void ServerHammerHit(bool bHit, const struct FVector& HitLocation, const struct FVector& HitNormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Hammer">();
	}
	static class ABRTool_Hammer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Hammer>();
	}
};
static_assert(alignof(ABRTool_Hammer) == 0x000008, "Wrong alignment on ABRTool_Hammer");
static_assert(sizeof(ABRTool_Hammer) == 0x000618, "Wrong size on ABRTool_Hammer");
static_assert(offsetof(ABRTool_Hammer, Range) == 0x0005F0, "Member 'ABRTool_Hammer::Range' has a wrong offset!");
static_assert(offsetof(ABRTool_Hammer, RefireTime) == 0x0005F4, "Member 'ABRTool_Hammer::RefireTime' has a wrong offset!");
static_assert(offsetof(ABRTool_Hammer, AntiSpamTime) == 0x0005F8, "Member 'ABRTool_Hammer::AntiSpamTime' has a wrong offset!");

// Class Brickadia.BRTool_Manipulator
// 0x0120 (0x0710 - 0x05F0)
class ABRTool_Manipulator final : public ABRToolBase
{
public:
	struct FRotator                               GrabRotation;                                      // 0x05F0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         GrabDistance;                                      // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRotation;                                     // 0x060C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60D[0x3];                                      // 0x060D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ClientGrabbedOffset;                               // 0x0610(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClientGrabbedState;                               // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBasicBrick*                            SocketBrickType;                                   // 0x0630(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBasicBrick*                            MicroSocketBrickType;                              // 0x0638(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_640[0x8];                                      // 0x0640(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRGizmo_PlacerLockOrigin*              AttachPointDisplayGizmo;                           // 0x0648(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDynamicTransformProxy*               GizmoTransformProxy;                               // 0x0650(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_658[0x8];                                      // 0x0658(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRManipulatorAttachJointData          AttachJointData;                                   // 0x0660(0x0090)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    ClientGrabbedComponent;                            // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F8[0x8];                                      // 0x06F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ABRManipulatorInputCapturer*            InputCapturer;                                     // 0x0700(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPhysicsHandleComponent*                PhysicsHandleNative;                               // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ClientPlayReleaseOff();
	void ClientPlaySound(class USoundBase* Sound);
	void CreateInputCapturer();
	void DestroyInputCapturer();
	bool HasPhysicsGrabbedObject();
	void LaunchGrabbedComponent();
	class UPrimitiveComponent* LineTraceForComponent(bool* bValidHit, struct FHitResult* HitResult);
	void MulticastInspect();
	void MulticastSetGrabObject(class UPrimitiveComponent* Grabbed, const struct FVector& Offset, bool bDisableGravity);
	void OnLaunch();
	void OnObjectGrabbed();
	void OnObjectReleased();
	void OnReleaseOff();
	void OnTogglePin(bool newPin);
	void OnUpdateGrabbedComponent();
	void PlayInspectAnimation();
	void ReleaseObject();
	void ServerAttachGrabbedObject(const struct FBRManipulatorAttachJointData& AttachData);
	void ServerDetachGrabbedObjectJoints();
	void ServerFreezeObject(class UPrimitiveComponent* TARGET);
	void ServerGrabObject(bool bRequestLockRot, class UPrimitiveComponent* RayObjct, const struct FVector& HitLocation, float HitDistance);
	void ServerInspect();
	void ServerProcessMousePitch(float Pitch);
	void ServerProcessMouseScroll(float Scroll);
	void ServerProcessMouseYaw(float Yaw);
	void ServerRelease(bool bLaunch, const struct FBRManipulatorAttachJointData& ClientAttachJointData);
	void UpdatePhysicsHandleTargetLocation();
	void UpdateSpring(class USceneComponent* Component);
	bool UseToggleMode();
	bool UseToggleModeBridge();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Manipulator">();
	}
	static class ABRTool_Manipulator* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Manipulator>();
	}
};
static_assert(alignof(ABRTool_Manipulator) == 0x000010, "Wrong alignment on ABRTool_Manipulator");
static_assert(sizeof(ABRTool_Manipulator) == 0x000710, "Wrong size on ABRTool_Manipulator");
static_assert(offsetof(ABRTool_Manipulator, GrabRotation) == 0x0005F0, "Member 'ABRTool_Manipulator::GrabRotation' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, GrabDistance) == 0x000608, "Member 'ABRTool_Manipulator::GrabDistance' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, bLockRotation) == 0x00060C, "Member 'ABRTool_Manipulator::bLockRotation' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, ClientGrabbedOffset) == 0x000610, "Member 'ABRTool_Manipulator::ClientGrabbedOffset' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, bClientGrabbedState) == 0x000628, "Member 'ABRTool_Manipulator::bClientGrabbedState' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, SocketBrickType) == 0x000630, "Member 'ABRTool_Manipulator::SocketBrickType' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, MicroSocketBrickType) == 0x000638, "Member 'ABRTool_Manipulator::MicroSocketBrickType' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, AttachPointDisplayGizmo) == 0x000648, "Member 'ABRTool_Manipulator::AttachPointDisplayGizmo' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, GizmoTransformProxy) == 0x000650, "Member 'ABRTool_Manipulator::GizmoTransformProxy' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, AttachJointData) == 0x000660, "Member 'ABRTool_Manipulator::AttachJointData' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, ClientGrabbedComponent) == 0x0006F0, "Member 'ABRTool_Manipulator::ClientGrabbedComponent' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, InputCapturer) == 0x000700, "Member 'ABRTool_Manipulator::InputCapturer' has a wrong offset!");
static_assert(offsetof(ABRTool_Manipulator, PhysicsHandleNative) == 0x000708, "Member 'ABRTool_Manipulator::PhysicsHandleNative' has a wrong offset!");

// Class Brickadia.BRTool_Selector
// 0x0008 (0x05F8 - 0x05F0)
class ABRTool_Selector final : public ABRToolBase
{
public:
	class UBrickBuildingTemplate*                 CurrentTemplate;                                   // 0x05F0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ServerCaptureTemplate(class UBrickGridComponent* TargetGrid, const struct FIntVector& SelectionCenter, const struct FIntVector& SelectionSize, bool bCut);
	void ServerDeleteSelection(class UBrickGridComponent* TargetGrid, const struct FIntVector& SelectionCenter, const struct FIntVector& SelectionSize);
	void ServerPasteTemplate(bool bIntoInventory);
	void ServerSplitSelection(class UBrickGridComponent* TargetGrid, const struct FIntVector& SelectionCenter, const struct FIntVector& SelectionSize);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRTool_Selector">();
	}
	static class ABRTool_Selector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRTool_Selector>();
	}
};
static_assert(alignof(ABRTool_Selector) == 0x000008, "Wrong alignment on ABRTool_Selector");
static_assert(sizeof(ABRTool_Selector) == 0x0005F8, "Wrong size on ABRTool_Selector");
static_assert(offsetof(ABRTool_Selector, CurrentTemplate) == 0x0005F0, "Member 'ABRTool_Selector::CurrentTemplate' has a wrong offset!");

// Class Brickadia.BRWeaponAmmoCollectionWidget
// 0x0010 (0x02E0 - 0x02D0)
class UBRWeaponAmmoCollectionWidget final : public UUserWidget
{
public:
	class UDynamicEntryBox*                       AmmosContainer;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWeaponAmmoWidget>        DefaultAmmoWidget;                                 // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponAmmoCollectionWidget">();
	}
	static class UBRWeaponAmmoCollectionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponAmmoCollectionWidget>();
	}
};
static_assert(alignof(UBRWeaponAmmoCollectionWidget) == 0x000008, "Wrong alignment on UBRWeaponAmmoCollectionWidget");
static_assert(sizeof(UBRWeaponAmmoCollectionWidget) == 0x0002E0, "Wrong size on UBRWeaponAmmoCollectionWidget");
static_assert(offsetof(UBRWeaponAmmoCollectionWidget, AmmosContainer) == 0x0002D0, "Member 'UBRWeaponAmmoCollectionWidget::AmmosContainer' has a wrong offset!");
static_assert(offsetof(UBRWeaponAmmoCollectionWidget, DefaultAmmoWidget) == 0x0002D8, "Member 'UBRWeaponAmmoCollectionWidget::DefaultAmmoWidget' has a wrong offset!");

// Class Brickadia.BRWeaponBase
// 0x01F0 (0x0570 - 0x0380)
class ABRWeaponBase final : public ABRItemBase
{
public:
	struct FBRWeaponHomingTarget                  PendingHomingTarget;                               // 0x0380(0x0020)(Transient, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A0[0x8];                                      // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UBRWeaponStateMachine>      StateMachineDescription;                           // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LegacyMagazineSize;                                // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBRWeaponAmmoUsageOverride                    LegacyAmmoUsageOverride;                           // 0x03B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B5[0x3];                                      // 0x03B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FBRWeaponAmmoCounter>           AmmoCounters;                                      // 0x03B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<float>                                 FixedZoomFactors;                                  // 0x03C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCheckForMuzzleBlock;                              // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               KillIconRotation;                                  // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             HudIcon;                                           // 0x03F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWeaponStateMachine*                  StateMachine;                                      // 0x0400(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_408[0x10];                                     // 0x0408(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EBRWeaponInputKeys                            PendingFrameInputs;                                // 0x0418(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBRWeaponSimulationState               SimState;                                          // 0x0420(0x0068)(BlueprintVisible, BlueprintReadOnly, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBRWeaponSimulationState               ReplicatedSimState_Owner;                          // 0x0488(0x0068)(BlueprintVisible, BlueprintReadOnly, Net, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FBRWeaponSimulationPosition            ReplicatedSimPosition_Remote;                      // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bFreezeFrameLocallyApplied;                        // 0x0500(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_501[0x7];                                      // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<uint16, struct FBRWeaponProjectileInfo>  LiveReplicatedProjectiles;                         // 0x0508(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<struct FBRWeaponProjectilePredictionInfo> LivePredictedProjectiles;                          // 0x0558(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_568[0x8];                                      // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearFreezeFrame();
	void ClearPredictedWeaponInput();
	void ClientDebugFiringVector(const struct FVector& position, const struct FVector& Direction);
	struct FBRWeaponHomingTarget GetHomingTarget();
	void MulticastReplicateAcceleratedExplosion(const struct FBRWeaponProjectileExplosionRep& Info);
	void MulticastReplicateAcceleratedExplosionWithSeed(const struct FBRWeaponProjectileExplosionRepWithSeed& Info);
	void MulticastReplicateAcceleratedMeleeExplosion(const struct FBRWeaponMeleeExplosionRep& Info);
	void MulticastReplicateAcceleratedProjectiles(const struct FBRWeaponProjectileSpawnRep& Info);
	void MulticastReplicateAcceleratedProjectilesWithSeed(const struct FBRWeaponProjectileSpawnRepWithSeed& Info);
	void OnRep_ReplicatedSimPosition();
	void ServerSetPendingHomingTarget(const struct FBRWeaponHomingTarget& HomingTarget);
	void SetFreezeFrame(float Duration);
	void SetPendingHomingTarget(const struct FBRWeaponHomingTarget& HomingTarget);
	void SetPredictedWeaponInput(EBRWeaponInputKeys Input, bool bPressed);

	bool CheckForFiringBlock(struct FVector* OutErrorLocation) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponBase">();
	}
	static class ABRWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABRWeaponBase>();
	}
};
static_assert(alignof(ABRWeaponBase) == 0x000008, "Wrong alignment on ABRWeaponBase");
static_assert(sizeof(ABRWeaponBase) == 0x000570, "Wrong size on ABRWeaponBase");
static_assert(offsetof(ABRWeaponBase, PendingHomingTarget) == 0x000380, "Member 'ABRWeaponBase::PendingHomingTarget' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, StateMachineDescription) == 0x0003A8, "Member 'ABRWeaponBase::StateMachineDescription' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, LegacyMagazineSize) == 0x0003B0, "Member 'ABRWeaponBase::LegacyMagazineSize' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, LegacyAmmoUsageOverride) == 0x0003B4, "Member 'ABRWeaponBase::LegacyAmmoUsageOverride' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, AmmoCounters) == 0x0003B8, "Member 'ABRWeaponBase::AmmoCounters' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, FixedZoomFactors) == 0x0003C8, "Member 'ABRWeaponBase::FixedZoomFactors' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, bCheckForMuzzleBlock) == 0x0003D8, "Member 'ABRWeaponBase::bCheckForMuzzleBlock' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, KillIconRotation) == 0x0003E0, "Member 'ABRWeaponBase::KillIconRotation' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, HudIcon) == 0x0003F8, "Member 'ABRWeaponBase::HudIcon' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, StateMachine) == 0x000400, "Member 'ABRWeaponBase::StateMachine' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, PendingFrameInputs) == 0x000418, "Member 'ABRWeaponBase::PendingFrameInputs' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, SimState) == 0x000420, "Member 'ABRWeaponBase::SimState' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, ReplicatedSimState_Owner) == 0x000488, "Member 'ABRWeaponBase::ReplicatedSimState_Owner' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, ReplicatedSimPosition_Remote) == 0x0004F0, "Member 'ABRWeaponBase::ReplicatedSimPosition_Remote' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, bFreezeFrameLocallyApplied) == 0x000500, "Member 'ABRWeaponBase::bFreezeFrameLocallyApplied' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, LiveReplicatedProjectiles) == 0x000508, "Member 'ABRWeaponBase::LiveReplicatedProjectiles' has a wrong offset!");
static_assert(offsetof(ABRWeaponBase, LivePredictedProjectiles) == 0x000558, "Member 'ABRWeaponBase::LivePredictedProjectiles' has a wrong offset!");

// Class Brickadia.BRWeaponProjectileMovementComponent
// 0x0060 (0x02C0 - 0x0260)
class UBRWeaponProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	struct FRotator                               SpinSpeed;                                         // 0x0258(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         SpinSpeedBounceMultiplier;                         // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReplicatedHomingTargetComponent;                   // 0x0278(0x0008)(ExportObject, Net, ZeroConstructor, InstancedReference, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Homing_Offset;                                     // 0x0280(0x0018)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Homing_ProportionalNavigationGain;                 // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29C[0x24];                                     // 0x029C(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ReplicatedHomingTargetComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponProjectileMovementComponent">();
	}
	static class UBRWeaponProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponProjectileMovementComponent>();
	}
};
static_assert(alignof(UBRWeaponProjectileMovementComponent) == 0x000010, "Wrong alignment on UBRWeaponProjectileMovementComponent");
static_assert(sizeof(UBRWeaponProjectileMovementComponent) == 0x0002C0, "Wrong size on UBRWeaponProjectileMovementComponent");
static_assert(offsetof(UBRWeaponProjectileMovementComponent, SpinSpeed) == 0x000258, "Member 'UBRWeaponProjectileMovementComponent::SpinSpeed' has a wrong offset!");
static_assert(offsetof(UBRWeaponProjectileMovementComponent, SpinSpeedBounceMultiplier) == 0x000270, "Member 'UBRWeaponProjectileMovementComponent::SpinSpeedBounceMultiplier' has a wrong offset!");
static_assert(offsetof(UBRWeaponProjectileMovementComponent, ReplicatedHomingTargetComponent) == 0x000278, "Member 'UBRWeaponProjectileMovementComponent::ReplicatedHomingTargetComponent' has a wrong offset!");
static_assert(offsetof(UBRWeaponProjectileMovementComponent, Homing_Offset) == 0x000280, "Member 'UBRWeaponProjectileMovementComponent::Homing_Offset' has a wrong offset!");
static_assert(offsetof(UBRWeaponProjectileMovementComponent, Homing_ProportionalNavigationGain) == 0x000298, "Member 'UBRWeaponProjectileMovementComponent::Homing_ProportionalNavigationGain' has a wrong offset!");

// Class Brickadia.BRWeaponResourceSubsystem
// 0x0060 (0x0090 - 0x0030)
class UBRWeaponResourceSubsystem final : public UGameInstanceSubsystem
{
public:
	TArray<class UBRWeaponResource*>              PlayerResources;                                   // 0x0030(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<class UBRWeaponResource*, int32>         PlayerResourceToSlot;                              // 0x0040(0x0050)(NativeAccessSpecifierPrivate)

public:
	int32 GetPlayerSlotFor(class UBRWeaponResource* Resource) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponResourceSubsystem">();
	}
	static class UBRWeaponResourceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponResourceSubsystem>();
	}
};
static_assert(alignof(UBRWeaponResourceSubsystem) == 0x000008, "Wrong alignment on UBRWeaponResourceSubsystem");
static_assert(sizeof(UBRWeaponResourceSubsystem) == 0x000090, "Wrong size on UBRWeaponResourceSubsystem");
static_assert(offsetof(UBRWeaponResourceSubsystem, PlayerResources) == 0x000030, "Member 'UBRWeaponResourceSubsystem::PlayerResources' has a wrong offset!");
static_assert(offsetof(UBRWeaponResourceSubsystem, PlayerResourceToSlot) == 0x000040, "Member 'UBRWeaponResourceSubsystem::PlayerResourceToSlot' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_MeleeAttack
// 0x0020 (0x00A8 - 0x0088)
class UBRWeaponStateBehavior_MeleeAttack final : public UBRWeaponStateBehavior_MeleeBase
{
public:
	TSubclassOf<class UBRDamageType>              DamageType;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateTransitionOnMiss;                             // 0x0094(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StateTransitionOnHitUndamageable;                  // 0x009C(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreezeFrameDurationOnDamage;                       // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_MeleeAttack">();
	}
	static class UBRWeaponStateBehavior_MeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_MeleeAttack>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_MeleeAttack) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_MeleeAttack");
static_assert(sizeof(UBRWeaponStateBehavior_MeleeAttack) == 0x0000A8, "Wrong size on UBRWeaponStateBehavior_MeleeAttack");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeAttack, DamageType) == 0x000088, "Member 'UBRWeaponStateBehavior_MeleeAttack::DamageType' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeAttack, Damage) == 0x000090, "Member 'UBRWeaponStateBehavior_MeleeAttack::Damage' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeAttack, StateTransitionOnMiss) == 0x000094, "Member 'UBRWeaponStateBehavior_MeleeAttack::StateTransitionOnMiss' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeAttack, StateTransitionOnHitUndamageable) == 0x00009C, "Member 'UBRWeaponStateBehavior_MeleeAttack::StateTransitionOnHitUndamageable' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateBehavior_MeleeAttack, FreezeFrameDurationOnDamage) == 0x0000A4, "Member 'UBRWeaponStateBehavior_MeleeAttack::FreezeFrameDurationOnDamage' has a wrong offset!");

// Class Brickadia.BRWeaponStateBehavior_RemoveFromInventory
// 0x0000 (0x0028 - 0x0028)
class UBRWeaponStateBehavior_RemoveFromInventory final : public UBRWeaponStateBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateBehavior_RemoveFromInventory">();
	}
	static class UBRWeaponStateBehavior_RemoveFromInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateBehavior_RemoveFromInventory>();
	}
};
static_assert(alignof(UBRWeaponStateBehavior_RemoveFromInventory) == 0x000008, "Wrong alignment on UBRWeaponStateBehavior_RemoveFromInventory");
static_assert(sizeof(UBRWeaponStateBehavior_RemoveFromInventory) == 0x000028, "Wrong size on UBRWeaponStateBehavior_RemoveFromInventory");

// Class Brickadia.BRWeaponStateMachine
// 0x0128 (0x0150 - 0x0028)
class UBRWeaponStateMachine final : public UObject
{
public:
	float                                         EquipDuration;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnequipDuration;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             EquipSound;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             EquippedFootstepLayer;                             // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponEquipAnimation;                              // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PlayerEquipAnimation;                              // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             UnequipSound;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WeaponUnequipAnimation;                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PlayerUnequipAnimation;                            // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBRWeaponResourceSlot                  Resources[0x8];                                    // 0x0068(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FBRWeaponState>                 States;                                            // 0x0128(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0x18];                                     // 0x0138(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWeaponStateMachine">();
	}
	static class UBRWeaponStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWeaponStateMachine>();
	}
};
static_assert(alignof(UBRWeaponStateMachine) == 0x000008, "Wrong alignment on UBRWeaponStateMachine");
static_assert(sizeof(UBRWeaponStateMachine) == 0x000150, "Wrong size on UBRWeaponStateMachine");
static_assert(offsetof(UBRWeaponStateMachine, EquipDuration) == 0x000028, "Member 'UBRWeaponStateMachine::EquipDuration' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, UnequipDuration) == 0x00002C, "Member 'UBRWeaponStateMachine::UnequipDuration' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, EquipSound) == 0x000030, "Member 'UBRWeaponStateMachine::EquipSound' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, EquippedFootstepLayer) == 0x000038, "Member 'UBRWeaponStateMachine::EquippedFootstepLayer' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, WeaponEquipAnimation) == 0x000040, "Member 'UBRWeaponStateMachine::WeaponEquipAnimation' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, PlayerEquipAnimation) == 0x000048, "Member 'UBRWeaponStateMachine::PlayerEquipAnimation' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, UnequipSound) == 0x000050, "Member 'UBRWeaponStateMachine::UnequipSound' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, WeaponUnequipAnimation) == 0x000058, "Member 'UBRWeaponStateMachine::WeaponUnequipAnimation' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, PlayerUnequipAnimation) == 0x000060, "Member 'UBRWeaponStateMachine::PlayerUnequipAnimation' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, Resources) == 0x000068, "Member 'UBRWeaponStateMachine::Resources' has a wrong offset!");
static_assert(offsetof(UBRWeaponStateMachine, States) == 0x000128, "Member 'UBRWeaponStateMachine::States' has a wrong offset!");

// Class Brickadia.BRWorldDetailsPanel
// 0x0080 (0x0350 - 0x02D0)
class UBRWorldDetailsPanel : public UUserWidget
{
public:
	uint8                                         Pad_2D0[0x20];                                     // 0x02D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UBRDialogFrameBase*                     DialogFrame;                                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             DescriptionText;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         MetadataText;                                      // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDynamicImage*                        Screenshot;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 NoImageOverlay;                                    // 0x0310(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    LoadButton;                                        // 0x0318(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    DeleteButton;                                      // 0x0320(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    ExplorerButton;                                    // 0x0328(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    ViewButton;                                        // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    StatsButton;                                       // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBRBundleDataProvider> BundleProvider;                                    // 0x0340(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleDeleteWorldClicked();
	void HandleLoadWorldClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldDetailsPanel">();
	}
	static class UBRWorldDetailsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldDetailsPanel>();
	}
};
static_assert(alignof(UBRWorldDetailsPanel) == 0x000008, "Wrong alignment on UBRWorldDetailsPanel");
static_assert(sizeof(UBRWorldDetailsPanel) == 0x000350, "Wrong size on UBRWorldDetailsPanel");
static_assert(offsetof(UBRWorldDetailsPanel, DialogFrame) == 0x0002F0, "Member 'UBRWorldDetailsPanel::DialogFrame' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, DescriptionText) == 0x0002F8, "Member 'UBRWorldDetailsPanel::DescriptionText' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, MetadataText) == 0x000300, "Member 'UBRWorldDetailsPanel::MetadataText' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, Screenshot) == 0x000308, "Member 'UBRWorldDetailsPanel::Screenshot' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, NoImageOverlay) == 0x000310, "Member 'UBRWorldDetailsPanel::NoImageOverlay' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, LoadButton) == 0x000318, "Member 'UBRWorldDetailsPanel::LoadButton' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, DeleteButton) == 0x000320, "Member 'UBRWorldDetailsPanel::DeleteButton' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, ExplorerButton) == 0x000328, "Member 'UBRWorldDetailsPanel::ExplorerButton' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, ViewButton) == 0x000330, "Member 'UBRWorldDetailsPanel::ViewButton' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, StatsButton) == 0x000338, "Member 'UBRWorldDetailsPanel::StatsButton' has a wrong offset!");
static_assert(offsetof(UBRWorldDetailsPanel, BundleProvider) == 0x000340, "Member 'UBRWorldDetailsPanel::BundleProvider' has a wrong offset!");

// Class Brickadia.BRWorldMultiDetailsPanel
// 0x0018 (0x02E8 - 0x02D0)
class UBRWorldMultiDetailsPanel : public UUserWidget
{
public:
	class UBRDialogFrameBase*                     DialogFrame;                                       // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         MetadataText;                                      // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    DeleteButton;                                      // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldMultiDetailsPanel">();
	}
	static class UBRWorldMultiDetailsPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldMultiDetailsPanel>();
	}
};
static_assert(alignof(UBRWorldMultiDetailsPanel) == 0x000008, "Wrong alignment on UBRWorldMultiDetailsPanel");
static_assert(sizeof(UBRWorldMultiDetailsPanel) == 0x0002E8, "Wrong size on UBRWorldMultiDetailsPanel");
static_assert(offsetof(UBRWorldMultiDetailsPanel, DialogFrame) == 0x0002D0, "Member 'UBRWorldMultiDetailsPanel::DialogFrame' has a wrong offset!");
static_assert(offsetof(UBRWorldMultiDetailsPanel, MetadataText) == 0x0002D8, "Member 'UBRWorldMultiDetailsPanel::MetadataText' has a wrong offset!");
static_assert(offsetof(UBRWorldMultiDetailsPanel, DeleteButton) == 0x0002E0, "Member 'UBRWorldMultiDetailsPanel::DeleteButton' has a wrong offset!");

// Class Brickadia.BRWorldBrowserDialog
// 0x0058 (0x0338 - 0x02E0)
class UBRWorldBrowserDialog : public UBRDialogBase
{
public:
	class UBRTabSetWidget*                        TabSet;                                            // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWorldBrowserContent*                 GalleryContent;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRWorldBrowserContent*                 LocalContent;                                      // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidgetSwitcher*                        ContentSwitcher;                                   // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    NewButton;                                         // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    SearchButton;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UBRWorldCreationDialog>     WorldCreationDialogClass;                          // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IBRBundleListingProvider> GalleryListingProvider;                            // 0x0318(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TScriptInterface<class IBRBundleListingProvider> LocalListingProvider;                              // 0x0328(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleNewWorldClicked();
	void HandleSearchClicked();
	void OnEnvironmentLoadRequested(const class FString& Environment);
	void OnWorldLoadRequested(const class FString& FilePath, bool bWriteable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldBrowserDialog">();
	}
	static class UBRWorldBrowserDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldBrowserDialog>();
	}
};
static_assert(alignof(UBRWorldBrowserDialog) == 0x000008, "Wrong alignment on UBRWorldBrowserDialog");
static_assert(sizeof(UBRWorldBrowserDialog) == 0x000338, "Wrong size on UBRWorldBrowserDialog");
static_assert(offsetof(UBRWorldBrowserDialog, TabSet) == 0x0002E0, "Member 'UBRWorldBrowserDialog::TabSet' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, GalleryContent) == 0x0002E8, "Member 'UBRWorldBrowserDialog::GalleryContent' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, LocalContent) == 0x0002F0, "Member 'UBRWorldBrowserDialog::LocalContent' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, ContentSwitcher) == 0x0002F8, "Member 'UBRWorldBrowserDialog::ContentSwitcher' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, NewButton) == 0x000300, "Member 'UBRWorldBrowserDialog::NewButton' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, SearchButton) == 0x000308, "Member 'UBRWorldBrowserDialog::SearchButton' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, WorldCreationDialogClass) == 0x000310, "Member 'UBRWorldBrowserDialog::WorldCreationDialogClass' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, GalleryListingProvider) == 0x000318, "Member 'UBRWorldBrowserDialog::GalleryListingProvider' has a wrong offset!");
static_assert(offsetof(UBRWorldBrowserDialog, LocalListingProvider) == 0x000328, "Member 'UBRWorldBrowserDialog::LocalListingProvider' has a wrong offset!");

// Class Brickadia.BRWorldCreationDialog
// 0x0038 (0x0318 - 0x02E0)
class UBRWorldCreationDialog : public UBRDialogBase
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UListView*                              MapList;                                           // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRDialogButtonBase*                    CreateButton;                                      // 0x02F8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SelectionSound;                                    // 0x0300(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBRMapInfo*                             SelectedMap;                                       // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCreateButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldCreationDialog">();
	}
	static class UBRWorldCreationDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldCreationDialog>();
	}
};
static_assert(alignof(UBRWorldCreationDialog) == 0x000008, "Wrong alignment on UBRWorldCreationDialog");
static_assert(sizeof(UBRWorldCreationDialog) == 0x000318, "Wrong size on UBRWorldCreationDialog");
static_assert(offsetof(UBRWorldCreationDialog, MapList) == 0x0002F0, "Member 'UBRWorldCreationDialog::MapList' has a wrong offset!");
static_assert(offsetof(UBRWorldCreationDialog, CreateButton) == 0x0002F8, "Member 'UBRWorldCreationDialog::CreateButton' has a wrong offset!");
static_assert(offsetof(UBRWorldCreationDialog, SelectionSound) == 0x000300, "Member 'UBRWorldCreationDialog::SelectionSound' has a wrong offset!");
static_assert(offsetof(UBRWorldCreationDialog, SelectedMap) == 0x000308, "Member 'UBRWorldCreationDialog::SelectedMap' has a wrong offset!");

// Class Brickadia.ColorWheel
// 0x0060 (0x01C8 - 0x0168)
class UColorWheel final : public UWidget
{
public:
	struct FLinearColor                           ValueHSV;                                          // 0x0168(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             ValueHSVDelegate;                                  // 0x0178(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(const struct FLinearColor& Value)> OnValueChanged;                                    // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMouseCaptureBegin;                               // 0x0198(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnMouseCaptureEnd;                                 // 0x01A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetValue(const struct FLinearColor& InValue);

	struct FLinearColor GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ColorWheel">();
	}
	static class UColorWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UColorWheel>();
	}
};
static_assert(alignof(UColorWheel) == 0x000008, "Wrong alignment on UColorWheel");
static_assert(sizeof(UColorWheel) == 0x0001C8, "Wrong size on UColorWheel");
static_assert(offsetof(UColorWheel, ValueHSV) == 0x000168, "Member 'UColorWheel::ValueHSV' has a wrong offset!");
static_assert(offsetof(UColorWheel, ValueHSVDelegate) == 0x000178, "Member 'UColorWheel::ValueHSVDelegate' has a wrong offset!");
static_assert(offsetof(UColorWheel, OnValueChanged) == 0x000188, "Member 'UColorWheel::OnValueChanged' has a wrong offset!");
static_assert(offsetof(UColorWheel, OnMouseCaptureBegin) == 0x000198, "Member 'UColorWheel::OnMouseCaptureBegin' has a wrong offset!");
static_assert(offsetof(UColorWheel, OnMouseCaptureEnd) == 0x0001A8, "Member 'UColorWheel::OnMouseCaptureEnd' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptorList_Vector
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_Vector final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_Vector">();
	}
	static class UInspectorPropertyDescriptorList_Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_Vector>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_Vector) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_Vector");
static_assert(sizeof(UInspectorPropertyDescriptorList_Vector) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_Vector");

// Class Brickadia.InspectorPropertyDescriptorList_Vector3f
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_Vector3f final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_Vector3f">();
	}
	static class UInspectorPropertyDescriptorList_Vector3f* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_Vector3f>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_Vector3f) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_Vector3f");
static_assert(sizeof(UInspectorPropertyDescriptorList_Vector3f) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_Vector3f");

// Class Brickadia.InspectorPropertyDescriptorList_Rotator
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_Rotator final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_Rotator">();
	}
	static class UInspectorPropertyDescriptorList_Rotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_Rotator>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_Rotator) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_Rotator");
static_assert(sizeof(UInspectorPropertyDescriptorList_Rotator) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_Rotator");

// Class Brickadia.InspectorPropertyDescriptorList_LinearColor
// 0x0000 (0x00E0 - 0x00E0)
class UInspectorPropertyDescriptorList_LinearColor final : public UInspectorPropertyDescriptorList
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptorList_LinearColor">();
	}
	static class UInspectorPropertyDescriptorList_LinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptorList_LinearColor>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptorList_LinearColor) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptorList_LinearColor");
static_assert(sizeof(UInspectorPropertyDescriptorList_LinearColor) == 0x0000E0, "Wrong size on UInspectorPropertyDescriptorList_LinearColor");

// Class Brickadia.AsyncActionTwoButtonsDialog
// 0x0098 (0x00C8 - 0x0030)
class UAsyncActionTwoButtonsDialog final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnButton1Clicked;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnButton2Clicked;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABRHUD*                                 HUD;                                               // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRTwoButtonsDialogBase*                Dialog;                                            // 0x0058(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x50];                                      // 0x0060(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ButtonIcon1;                                       // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             ButtonIcon2;                                       // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBRTwoButtonsDialogBase>    DialogClass;                                       // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncActionTwoButtonsDialog* CreateTwoButtonsDialog(class UObject* WorldContextObject, const class FText& Title, const class FText& Message, const class FText& ButtonMessage1, const class FText& ButtonMessage2, EBRDialogButtonStyle ButtonStyle1, EBRDialogButtonStyle ButtonStyle2, class UTexture2D* ButtonIcon1_0, class UTexture2D* ButtonIcon2_0, TSubclassOf<class UBRTwoButtonsDialogBase> DialogClass_0, bool bAllowEscapeDialog);
	static class UAsyncActionTwoButtonsDialog* QuickCreateTwoButtonsDialog(class UObject* WorldContextObject, const class FText& Title, const class FText& Message, const class FText& ButtonMessage1, const class FText& ButtonMessage2, EBRDialogButtonStyle ButtonStyle1, EBRDialogButtonStyle ButtonStyle2, class UTexture2D* ButtonIcon1_0, class UTexture2D* ButtonIcon2_0, bool bAllowEscapeDialog);

	void HandleClickedButton1();
	void HandleClickedButton2();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionTwoButtonsDialog">();
	}
	static class UAsyncActionTwoButtonsDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionTwoButtonsDialog>();
	}
};
static_assert(alignof(UAsyncActionTwoButtonsDialog) == 0x000008, "Wrong alignment on UAsyncActionTwoButtonsDialog");
static_assert(sizeof(UAsyncActionTwoButtonsDialog) == 0x0000C8, "Wrong size on UAsyncActionTwoButtonsDialog");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, OnButton1Clicked) == 0x000030, "Member 'UAsyncActionTwoButtonsDialog::OnButton1Clicked' has a wrong offset!");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, OnButton2Clicked) == 0x000040, "Member 'UAsyncActionTwoButtonsDialog::OnButton2Clicked' has a wrong offset!");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, HUD) == 0x000050, "Member 'UAsyncActionTwoButtonsDialog::HUD' has a wrong offset!");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, Dialog) == 0x000058, "Member 'UAsyncActionTwoButtonsDialog::Dialog' has a wrong offset!");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, ButtonIcon1) == 0x0000B0, "Member 'UAsyncActionTwoButtonsDialog::ButtonIcon1' has a wrong offset!");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, ButtonIcon2) == 0x0000B8, "Member 'UAsyncActionTwoButtonsDialog::ButtonIcon2' has a wrong offset!");
static_assert(offsetof(UAsyncActionTwoButtonsDialog, DialogClass) == 0x0000C0, "Member 'UAsyncActionTwoButtonsDialog::DialogClass' has a wrong offset!");

// Class Brickadia.AsyncActionThreeButtonsDialog
// 0x00C0 (0x00F0 - 0x0030)
class UAsyncActionThreeButtonsDialog final : public UBlueprintAsyncActionBase
{
public:
	TMulticastInlineDelegate<void()>              OnButton1Clicked;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnButton2Clicked;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnButton3Clicked;                                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ABRHUD*                                 HUD;                                               // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBRThreeButtonsDialogBase*              Dialog;                                            // 0x0068(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x60];                                      // 0x0070(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ButtonIcon1;                                       // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             ButtonIcon2;                                       // 0x00D8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTexture2D*                             ButtonIcon3;                                       // 0x00E0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UBRThreeButtonsDialogBase>  DialogClass;                                       // 0x00E8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncActionThreeButtonsDialog* CreateThreeButtonsDialog(class UObject* WorldContextObject, const class FText& Title, const class FText& Message, const class FText& ButtonMessage1, const class FText& ButtonMessage2, const class FText& ButtonMessage3, EBRDialogButtonStyle ButtonStyle1, EBRDialogButtonStyle ButtonStyle2, EBRDialogButtonStyle ButtonStyle3, class UTexture2D* ButtonIcon1_0, class UTexture2D* ButtonIcon2_0, class UTexture2D* ButtonIcon3_0, TSubclassOf<class UBRThreeButtonsDialogBase> DialogClass_0, bool bAllowEscapeDialog);
	static class UAsyncActionThreeButtonsDialog* QuickCreateThreeButtonsDialog(class UObject* WorldContextObject, const class FText& Title, const class FText& Message, const class FText& ButtonMessage1, const class FText& ButtonMessage2, const class FText& ButtonMessage3, EBRDialogButtonStyle ButtonStyle1, EBRDialogButtonStyle ButtonStyle2, EBRDialogButtonStyle ButtonStyle3, class UTexture2D* ButtonIcon1_0, class UTexture2D* ButtonIcon2_0, class UTexture2D* ButtonIcon3_0, bool bAllowEscapeDialog);

	void HandleClickedButton1();
	void HandleClickedButton2();
	void HandleClickedButton3();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncActionThreeButtonsDialog">();
	}
	static class UAsyncActionThreeButtonsDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncActionThreeButtonsDialog>();
	}
};
static_assert(alignof(UAsyncActionThreeButtonsDialog) == 0x000008, "Wrong alignment on UAsyncActionThreeButtonsDialog");
static_assert(sizeof(UAsyncActionThreeButtonsDialog) == 0x0000F0, "Wrong size on UAsyncActionThreeButtonsDialog");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, OnButton1Clicked) == 0x000030, "Member 'UAsyncActionThreeButtonsDialog::OnButton1Clicked' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, OnButton2Clicked) == 0x000040, "Member 'UAsyncActionThreeButtonsDialog::OnButton2Clicked' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, OnButton3Clicked) == 0x000050, "Member 'UAsyncActionThreeButtonsDialog::OnButton3Clicked' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, HUD) == 0x000060, "Member 'UAsyncActionThreeButtonsDialog::HUD' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, Dialog) == 0x000068, "Member 'UAsyncActionThreeButtonsDialog::Dialog' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, ButtonIcon1) == 0x0000D0, "Member 'UAsyncActionThreeButtonsDialog::ButtonIcon1' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, ButtonIcon2) == 0x0000D8, "Member 'UAsyncActionThreeButtonsDialog::ButtonIcon2' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, ButtonIcon3) == 0x0000E0, "Member 'UAsyncActionThreeButtonsDialog::ButtonIcon3' has a wrong offset!");
static_assert(offsetof(UAsyncActionThreeButtonsDialog, DialogClass) == 0x0000E8, "Member 'UAsyncActionThreeButtonsDialog::DialogClass' has a wrong offset!");

// Class Brickadia.DualTileView
// 0x0010 (0x0B90 - 0x0B80)
class UDualTileView final : public UTileView
{
public:
	float                                         SmallEntryHeight;                                  // 0x0B78(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SmallEntryWidth;                                   // 0x0B7C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumSmallItems;                                     // 0x0B80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B84[0xC];                                      // 0x0B84(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNumSmallItems(int32 NewNumSmallItems);
	void SetSmallEntryHeight(float NewHeight);
	void SetSmallEntryWidth(float NewWidth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DualTileView">();
	}
	static class UDualTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDualTileView>();
	}
};
static_assert(alignof(UDualTileView) == 0x000010, "Wrong alignment on UDualTileView");
static_assert(sizeof(UDualTileView) == 0x000B90, "Wrong size on UDualTileView");
static_assert(offsetof(UDualTileView, SmallEntryHeight) == 0x000B78, "Member 'UDualTileView::SmallEntryHeight' has a wrong offset!");
static_assert(offsetof(UDualTileView, SmallEntryWidth) == 0x000B7C, "Member 'UDualTileView::SmallEntryWidth' has a wrong offset!");
static_assert(offsetof(UDualTileView, NumSmallItems) == 0x000B80, "Member 'UDualTileView::NumSmallItems' has a wrong offset!");

// Class Brickadia.GenericThumbnailManager
// 0x00A0 (0x00E0 - 0x0040)
class UGenericThumbnailManager final : public UTickableWorldSubsystem
{
public:
	TMap<TSubclassOf<class UThumbnailProcessor>, class UThumbnailProcessor*> ActiveProcessors;                                  // 0x0040(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_90[0x30];                                      // 0x0090(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     AlphaInverterMaterial;                             // 0x00C0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     DownsampleMaterial;                                // 0x00C8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextureRenderTarget2D*                 ScratchRenderTarget;                               // 0x00D0(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D8[0x8];                                       // 0x00D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericThumbnailManager">();
	}
	static class UGenericThumbnailManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericThumbnailManager>();
	}
};
static_assert(alignof(UGenericThumbnailManager) == 0x000008, "Wrong alignment on UGenericThumbnailManager");
static_assert(sizeof(UGenericThumbnailManager) == 0x0000E0, "Wrong size on UGenericThumbnailManager");
static_assert(offsetof(UGenericThumbnailManager, ActiveProcessors) == 0x000040, "Member 'UGenericThumbnailManager::ActiveProcessors' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailManager, AlphaInverterMaterial) == 0x0000C0, "Member 'UGenericThumbnailManager::AlphaInverterMaterial' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailManager, DownsampleMaterial) == 0x0000C8, "Member 'UGenericThumbnailManager::DownsampleMaterial' has a wrong offset!");
static_assert(offsetof(UGenericThumbnailManager, ScratchRenderTarget) == 0x0000D0, "Member 'UGenericThumbnailManager::ScratchRenderTarget' has a wrong offset!");

// Class Brickadia.ActorBlueprintThumbnailProcessor
// 0x0050 (0x00A8 - 0x0058)
class UActorBlueprintThumbnailProcessor : public UThumbnailProcessor
{
public:
	uint8                                         Pad_58[0x50];                                      // 0x0058(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorBlueprintThumbnailProcessor">();
	}
	static class UActorBlueprintThumbnailProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorBlueprintThumbnailProcessor>();
	}
};
static_assert(alignof(UActorBlueprintThumbnailProcessor) == 0x000008, "Wrong alignment on UActorBlueprintThumbnailProcessor");
static_assert(sizeof(UActorBlueprintThumbnailProcessor) == 0x0000A8, "Wrong size on UActorBlueprintThumbnailProcessor");

// Class Brickadia.EntityTypeThumbnailProcessor
// 0x0050 (0x00F8 - 0x00A8)
class UEntityTypeThumbnailProcessor final : public UActorBlueprintThumbnailProcessor
{
public:
	uint8                                         Pad_A8[0x50];                                      // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityTypeThumbnailProcessor">();
	}
	static class UEntityTypeThumbnailProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityTypeThumbnailProcessor>();
	}
};
static_assert(alignof(UEntityTypeThumbnailProcessor) == 0x000008, "Wrong alignment on UEntityTypeThumbnailProcessor");
static_assert(sizeof(UEntityTypeThumbnailProcessor) == 0x0000F8, "Wrong size on UEntityTypeThumbnailProcessor");

// Class Brickadia.HatBase
// 0x0028 (0x02E8 - 0x02C0)
class AHatBase final : public AStaticMeshActor
{
public:
	class FText                                   DisplayName;                                       // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bCanRotate;                                        // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHatRotation                                  Rotation;                                          // 0x02D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NumColorableParts;                                 // 0x02D2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D3[0x5];                                      // 0x02D3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInstanceDynamic*>       MaterialInstances;                                 // 0x02D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetColor(int32 ElementIndex);
	TArray<struct FLinearColor> GetColors();
	void SetColor(const struct FLinearColor& Color, int32 ElementIndex);
	void SetColors(const TArray<struct FLinearColor>& Colors);
	void SetHatRotation(EHatRotation NewRotation);

	int32 GetNumColorableSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HatBase">();
	}
	static class AHatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHatBase>();
	}
};
static_assert(alignof(AHatBase) == 0x000008, "Wrong alignment on AHatBase");
static_assert(sizeof(AHatBase) == 0x0002E8, "Wrong size on AHatBase");
static_assert(offsetof(AHatBase, DisplayName) == 0x0002C0, "Member 'AHatBase::DisplayName' has a wrong offset!");
static_assert(offsetof(AHatBase, bCanRotate) == 0x0002D0, "Member 'AHatBase::bCanRotate' has a wrong offset!");
static_assert(offsetof(AHatBase, Rotation) == 0x0002D1, "Member 'AHatBase::Rotation' has a wrong offset!");
static_assert(offsetof(AHatBase, NumColorableParts) == 0x0002D2, "Member 'AHatBase::NumColorableParts' has a wrong offset!");
static_assert(offsetof(AHatBase, MaterialInstances) == 0x0002D8, "Member 'AHatBase::MaterialInstances' has a wrong offset!");

// Class Brickadia.HierarchicalRichTextBlockDecorator
// 0x0000 (0x0028 - 0x0028)
class UHierarchicalRichTextBlockDecorator : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HierarchicalRichTextBlockDecorator">();
	}
	static class UHierarchicalRichTextBlockDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHierarchicalRichTextBlockDecorator>();
	}
};
static_assert(alignof(UHierarchicalRichTextBlockDecorator) == 0x000008, "Wrong alignment on UHierarchicalRichTextBlockDecorator");
static_assert(sizeof(UHierarchicalRichTextBlockDecorator) == 0x000028, "Wrong size on UHierarchicalRichTextBlockDecorator");

// Class Brickadia.HierarchicalRichTextBlockEmojiDecorator
// 0x0000 (0x0028 - 0x0028)
class UHierarchicalRichTextBlockEmojiDecorator : public UHierarchicalRichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HierarchicalRichTextBlockEmojiDecorator">();
	}
	static class UHierarchicalRichTextBlockEmojiDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHierarchicalRichTextBlockEmojiDecorator>();
	}
};
static_assert(alignof(UHierarchicalRichTextBlockEmojiDecorator) == 0x000008, "Wrong alignment on UHierarchicalRichTextBlockEmojiDecorator");
static_assert(sizeof(UHierarchicalRichTextBlockEmojiDecorator) == 0x000028, "Wrong size on UHierarchicalRichTextBlockEmojiDecorator");

// Class Brickadia.HierarchicalRichTextBlockHyperlinkDecorator
// 0x0010 (0x0038 - 0x0028)
class UHierarchicalRichTextBlockHyperlinkDecorator final : public UHierarchicalRichTextBlockDecorator
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HierarchicalRichTextBlockHyperlinkDecorator">();
	}
	static class UHierarchicalRichTextBlockHyperlinkDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHierarchicalRichTextBlockHyperlinkDecorator>();
	}
};
static_assert(alignof(UHierarchicalRichTextBlockHyperlinkDecorator) == 0x000008, "Wrong alignment on UHierarchicalRichTextBlockHyperlinkDecorator");
static_assert(sizeof(UHierarchicalRichTextBlockHyperlinkDecorator) == 0x000038, "Wrong size on UHierarchicalRichTextBlockHyperlinkDecorator");

// Class Brickadia.BRRulesetMemberDestructable
// 0x0000 (0x0028 - 0x0028)
class IBRRulesetMemberDestructable final : public IBRRulesetMember
{
public:
	void Die(float FinalDamage, const class UDamageType* DeathType, class AController* InstigatedBy, class AActor* DeathCauser);
	void DieInternal(float FinalDamage, const class UDamageType* DeathType, class AController* InstigatedBy, class AActor* DeathCauser);
	float TakeDamageInternal(float DamageIn, const struct FDamageEvent& DamageEvent, class AController* EventInstigator, class AActor* DamageCauser);

	bool IsDead() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRulesetMemberDestructable">();
	}
	static class IBRRulesetMemberDestructable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBRRulesetMemberDestructable>();
	}
};
static_assert(alignof(IBRRulesetMemberDestructable) == 0x000008, "Wrong alignment on IBRRulesetMemberDestructable");
static_assert(sizeof(IBRRulesetMemberDestructable) == 0x000028, "Wrong size on IBRRulesetMemberDestructable");

// Class Brickadia.InspectorCategoryRowBase
// 0x0028 (0x02F8 - 0x02D0)
class UInspectorCategoryRowBase : public UUserWidget
{
public:
	class UTextBlock*                             CategoryNameText;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNamedSlot*                             ValueWidgetSlot;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                ResetButton;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              CollapseButton;                                    // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVerticalBox*                           CategoryPropertiesBoxToCollapse;                   // 0x02F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddValueWidget(class UInspectorPropertyWidgetBase* NewWidget);
	void OnCollapseButtonStateChanged(bool bIsOpen);
	void SetCategoryRowNameText(const class FText& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorCategoryRowBase">();
	}
	static class UInspectorCategoryRowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorCategoryRowBase>();
	}
};
static_assert(alignof(UInspectorCategoryRowBase) == 0x000008, "Wrong alignment on UInspectorCategoryRowBase");
static_assert(sizeof(UInspectorCategoryRowBase) == 0x0002F8, "Wrong size on UInspectorCategoryRowBase");
static_assert(offsetof(UInspectorCategoryRowBase, CategoryNameText) == 0x0002D0, "Member 'UInspectorCategoryRowBase::CategoryNameText' has a wrong offset!");
static_assert(offsetof(UInspectorCategoryRowBase, ValueWidgetSlot) == 0x0002D8, "Member 'UInspectorCategoryRowBase::ValueWidgetSlot' has a wrong offset!");
static_assert(offsetof(UInspectorCategoryRowBase, ResetButton) == 0x0002E0, "Member 'UInspectorCategoryRowBase::ResetButton' has a wrong offset!");
static_assert(offsetof(UInspectorCategoryRowBase, CollapseButton) == 0x0002E8, "Member 'UInspectorCategoryRowBase::CollapseButton' has a wrong offset!");
static_assert(offsetof(UInspectorCategoryRowBase, CategoryPropertiesBoxToCollapse) == 0x0002F0, "Member 'UInspectorCategoryRowBase::CategoryPropertiesBoxToCollapse' has a wrong offset!");

// Class Brickadia.InspectorPanelBase
// 0x0258 (0x0528 - 0x02D0)
class UInspectorPanelBase : public UUserWidget
{
public:
	TMulticastInlineDelegate<void()>              OnDirtied;                                         // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnEdited;                                          // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void()>              OnCommitted;                                       // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UVerticalBox*                           RowsBox;                                           // 0x0300(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorCategoryRowBase>  CategoryRowWidget;                                 // 0x0308(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyRowBase>  PropertyRowWidget;                                 // 0x0310(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UInspectorPropertyRowBase>  PropertyRowAlternateWidget;                        // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UInspectorPropertyDescriptor>, TSubclassOf<class UInspectorPropertyWidgetBase>> PropertyTypeWidgets;                               // 0x0320(0x0050)(Edit, BlueprintVisible, UObjectWrapper, NativeAccessSpecifierPublic)
	EInspectorCategoryCollapseMode                DefaultCollapseMode;                               // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_371[0x7];                                      // 0x0371(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInspectorPropertyWidgetBase*>   PropertyWidgets;                                   // 0x0378(0x0010)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UVerticalBox*>        CategoryBoxWidgets;                                // 0x0388(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UInspectorPropertyDescriptor*> PropertyDescriptors;                               // 0x03D8(0x0050)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UInspectorPropertyWidgetBase*> PropertyWidgetLookup;                              // 0x0428(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UInspectorPropertyRowBase*> PropertyRowWidgetLookup;                           // 0x0478(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FName, class UInspectorCategoryRowBase*> CategoryWidgetLookup;                              // 0x04C8(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	class UInspectorPropertyWidgetBase*           LastEditedProperty;                                // 0x0518(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLiveUpdates;                                      // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_521[0x7];                                      // 0x0521(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCategory(class FName CategoryFName, const struct FInspectorPropertyDescriptorListCategory& Category, const struct FInspectorViewTarget& ViewTargetForAll);
	void AddDescriptorList(TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass, const struct FInspectorViewTarget& ViewTargetForAll, bool bClearFirst);
	void AddDescriptorList2(class UInspectorPropertyDescriptorList* View, const struct FInspectorViewTarget& ViewTargetForAll, bool bClearFirst);
	void AddEmptyCategory(class FName CategoryFName, const class FText& CategoryDisplayName, TSubclassOf<class UInspectorCategoryRowBase> WidgetClassOverride, EInspectorCategoryCollapseMode CollapseMode);
	void AddInlineProperty(class FName CategoryFName, class UInspectorPropertyDescriptor* PropertyDescriptor, const struct FInspectorViewTarget& ViewTarget);
	void AddProperty(class FName CategoryFName, class UInspectorPropertyDescriptor* PropertyDescriptor, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyRowBase> WidgetClassOverride);
	void ClearChangelist();
	void ClearProperties();
	void DoLiveUpdate(bool bForce);
	void HandlePropertyCommit(class UInspectorPropertyWidgetBase* DirtyWidget);
	void HandlePropertyEdit(class UInspectorPropertyWidgetBase* DirtyWidget);
	void ResetChangelist();
	void SetValue(class FName ValueName, const struct FInspectorPropertyValue& Value);
	void SetValuesFromChangelist(const struct FInspectorPropertyChangelist& Changelist);

	struct FInspectorPropertyChangelist GetChangelist() const;
	struct FInspectorPropertyChangelist GetChangelistForLastEditedProperty() const;
	struct FInspectorPropertyChangelist GetReverseChangelist() const;
	void GetValue(class FName ValueName, struct FInspectorPropertyValue* ValueOut) const;
	struct FInspectorPropertyChangelist GetVerboseChangelist() const;
	struct FInspectorPropertyChangelist GetVerboseModifiedChangelist() const;
	bool HasChanges() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPanelBase">();
	}
	static class UInspectorPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPanelBase>();
	}
};
static_assert(alignof(UInspectorPanelBase) == 0x000008, "Wrong alignment on UInspectorPanelBase");
static_assert(sizeof(UInspectorPanelBase) == 0x000528, "Wrong size on UInspectorPanelBase");
static_assert(offsetof(UInspectorPanelBase, OnDirtied) == 0x0002D0, "Member 'UInspectorPanelBase::OnDirtied' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, OnEdited) == 0x0002E0, "Member 'UInspectorPanelBase::OnEdited' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, OnCommitted) == 0x0002F0, "Member 'UInspectorPanelBase::OnCommitted' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, RowsBox) == 0x000300, "Member 'UInspectorPanelBase::RowsBox' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, CategoryRowWidget) == 0x000308, "Member 'UInspectorPanelBase::CategoryRowWidget' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyRowWidget) == 0x000310, "Member 'UInspectorPanelBase::PropertyRowWidget' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyRowAlternateWidget) == 0x000318, "Member 'UInspectorPanelBase::PropertyRowAlternateWidget' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyTypeWidgets) == 0x000320, "Member 'UInspectorPanelBase::PropertyTypeWidgets' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, DefaultCollapseMode) == 0x000370, "Member 'UInspectorPanelBase::DefaultCollapseMode' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyWidgets) == 0x000378, "Member 'UInspectorPanelBase::PropertyWidgets' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, CategoryBoxWidgets) == 0x000388, "Member 'UInspectorPanelBase::CategoryBoxWidgets' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyDescriptors) == 0x0003D8, "Member 'UInspectorPanelBase::PropertyDescriptors' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyWidgetLookup) == 0x000428, "Member 'UInspectorPanelBase::PropertyWidgetLookup' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, PropertyRowWidgetLookup) == 0x000478, "Member 'UInspectorPanelBase::PropertyRowWidgetLookup' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, CategoryWidgetLookup) == 0x0004C8, "Member 'UInspectorPanelBase::CategoryWidgetLookup' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, LastEditedProperty) == 0x000518, "Member 'UInspectorPanelBase::LastEditedProperty' has a wrong offset!");
static_assert(offsetof(UInspectorPanelBase, bLiveUpdates) == 0x000520, "Member 'UInspectorPanelBase::bLiveUpdates' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Byte
// 0x0000 (0x0088 - 0x0088)
class UInspectorPropertyDescriptor_Byte final : public UInspectorPropertyDescriptor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Byte">();
	}
	static class UInspectorPropertyDescriptor_Byte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Byte>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Byte) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Byte");
static_assert(sizeof(UInspectorPropertyDescriptor_Byte) == 0x000088, "Wrong size on UInspectorPropertyDescriptor_Byte");

// Class Brickadia.InspectorPropertyDescriptor_Enum
// 0x0018 (0x00A0 - 0x0088)
class UInspectorPropertyDescriptor_Enum final : public UInspectorPropertyDescriptor
{
public:
	class UEnum*                                  EnumType;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NativeEnum;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShouldShowOptionFunction;                          // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TMap<class FString, uint8> GetEnumOptionList(const struct FInspectorViewTarget& ViewTarget, class UObject* WorldContext) const;
	bool GetShouldShowEnumOption(const struct FInspectorViewTarget& ViewTarget, class UObject* WorldContext, uint8 Option) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Enum">();
	}
	static class UInspectorPropertyDescriptor_Enum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Enum>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Enum) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Enum");
static_assert(sizeof(UInspectorPropertyDescriptor_Enum) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_Enum");
static_assert(offsetof(UInspectorPropertyDescriptor_Enum, EnumType) == 0x000088, "Member 'UInspectorPropertyDescriptor_Enum::EnumType' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Enum, NativeEnum) == 0x000090, "Member 'UInspectorPropertyDescriptor_Enum::NativeEnum' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Enum, ShouldShowOptionFunction) == 0x000098, "Member 'UInspectorPropertyDescriptor_Enum::ShouldShowOptionFunction' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Int
// 0x0018 (0x00A0 - 0x0088)
class UInspectorPropertyDescriptor_Int final : public UInspectorPropertyDescriptor
{
public:
	int32                                         UIStep;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIMin;                                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIMax;                                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampMin;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampMax;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         UnderlyingUnit;                                    // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         DisplayUnit;                                       // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseUIStep : 1;                                    // 0x009E(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMin : 1;                                     // 0x009E(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMax : 1;                                     // 0x009E(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMin : 1;                                  // 0x009E(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMax : 1;                                  // 0x009E(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDisplayUnit : 1;                               // 0x009E(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLiveSlider : 1;                                   // 0x009E(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_9F[0x1];                                       // 0x009F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Int">();
	}
	static class UInspectorPropertyDescriptor_Int* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Int>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Int) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Int");
static_assert(sizeof(UInspectorPropertyDescriptor_Int) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_Int");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, UIStep) == 0x000088, "Member 'UInspectorPropertyDescriptor_Int::UIStep' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, UIMin) == 0x00008C, "Member 'UInspectorPropertyDescriptor_Int::UIMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, UIMax) == 0x000090, "Member 'UInspectorPropertyDescriptor_Int::UIMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, ClampMin) == 0x000094, "Member 'UInspectorPropertyDescriptor_Int::ClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, ClampMax) == 0x000098, "Member 'UInspectorPropertyDescriptor_Int::ClampMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, UnderlyingUnit) == 0x00009C, "Member 'UInspectorPropertyDescriptor_Int::UnderlyingUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Int, DisplayUnit) == 0x00009D, "Member 'UInspectorPropertyDescriptor_Int::DisplayUnit' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Float
// 0x0028 (0x00B0 - 0x0088)
class UInspectorPropertyDescriptor_Float final : public UInspectorPropertyDescriptor
{
public:
	float                                         UIStep;                                            // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIMin;                                             // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIMax;                                             // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMin;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         UnderlyingUnit;                                    // 0x009C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         DisplayUnit;                                       // 0x009D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinFractionalDigits;                               // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFractionalDigits;                               // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseUIStep : 1;                                    // 0x00A8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMin : 1;                                     // 0x00A8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMax : 1;                                     // 0x00A8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMin : 1;                                  // 0x00A8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMax : 1;                                  // 0x00A8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDisplayUnit : 1;                               // 0x00A8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLiveSlider : 1;                                   // 0x00A8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Float">();
	}
	static class UInspectorPropertyDescriptor_Float* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Float>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Float) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Float");
static_assert(sizeof(UInspectorPropertyDescriptor_Float) == 0x0000B0, "Wrong size on UInspectorPropertyDescriptor_Float");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, UIStep) == 0x000088, "Member 'UInspectorPropertyDescriptor_Float::UIStep' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, UIMin) == 0x00008C, "Member 'UInspectorPropertyDescriptor_Float::UIMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, UIMax) == 0x000090, "Member 'UInspectorPropertyDescriptor_Float::UIMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, ClampMin) == 0x000094, "Member 'UInspectorPropertyDescriptor_Float::ClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, ClampMax) == 0x000098, "Member 'UInspectorPropertyDescriptor_Float::ClampMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, UnderlyingUnit) == 0x00009C, "Member 'UInspectorPropertyDescriptor_Float::UnderlyingUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, DisplayUnit) == 0x00009D, "Member 'UInspectorPropertyDescriptor_Float::DisplayUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, MinFractionalDigits) == 0x0000A0, "Member 'UInspectorPropertyDescriptor_Float::MinFractionalDigits' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Float, MaxFractionalDigits) == 0x0000A4, "Member 'UInspectorPropertyDescriptor_Float::MaxFractionalDigits' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_String
// 0x0008 (0x0090 - 0x0088)
class UInspectorPropertyDescriptor_String final : public UInspectorPropertyDescriptor
{
public:
	EStringDescriptorType                         Type;                                              // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LengthLimit;                                       // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_String">();
	}
	static class UInspectorPropertyDescriptor_String* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_String>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_String) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_String");
static_assert(sizeof(UInspectorPropertyDescriptor_String) == 0x000090, "Wrong size on UInspectorPropertyDescriptor_String");
static_assert(offsetof(UInspectorPropertyDescriptor_String, Type) == 0x000088, "Member 'UInspectorPropertyDescriptor_String::Type' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_String, LengthLimit) == 0x00008C, "Member 'UInspectorPropertyDescriptor_String::LengthLimit' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Name
// 0x0000 (0x0088 - 0x0088)
class UInspectorPropertyDescriptor_Name final : public UInspectorPropertyDescriptor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Name">();
	}
	static class UInspectorPropertyDescriptor_Name* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Name>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Name) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Name");
static_assert(sizeof(UInspectorPropertyDescriptor_Name) == 0x000088, "Wrong size on UInspectorPropertyDescriptor_Name");

// Class Brickadia.InspectorPropertyDescriptor_MonolithicStruct
// 0x0008 (0x0090 - 0x0088)
class UInspectorPropertyDescriptor_MonolithicStruct final : public UInspectorPropertyDescriptor_Struct
{
public:
	class UScriptStruct*                          ApplicableStruct;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_MonolithicStruct">();
	}
	static class UInspectorPropertyDescriptor_MonolithicStruct* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_MonolithicStruct>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_MonolithicStruct) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_MonolithicStruct");
static_assert(sizeof(UInspectorPropertyDescriptor_MonolithicStruct) == 0x000090, "Wrong size on UInspectorPropertyDescriptor_MonolithicStruct");
static_assert(offsetof(UInspectorPropertyDescriptor_MonolithicStruct, ApplicableStruct) == 0x000088, "Member 'UInspectorPropertyDescriptor_MonolithicStruct::ApplicableStruct' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Vector
// 0x0028 (0x00C0 - 0x0098)
class UInspectorPropertyDescriptor_Vector final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	float                                         UIStep;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIMin;                                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UIMax;                                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMin;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ClampMax;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         UnderlyingUnit;                                    // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         DisplayUnit;                                       // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinFractionalDigits;                               // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxFractionalDigits;                               // 0x00B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseUIStep : 1;                                    // 0x00B8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMin : 1;                                     // 0x00B8(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMax : 1;                                     // 0x00B8(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMin : 1;                                  // 0x00B8(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMax : 1;                                  // 0x00B8(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDisplayUnit : 1;                               // 0x00B8(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLiveSlider : 1;                                   // 0x00B8(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Vector">();
	}
	static class UInspectorPropertyDescriptor_Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Vector>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Vector) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Vector");
static_assert(sizeof(UInspectorPropertyDescriptor_Vector) == 0x0000C0, "Wrong size on UInspectorPropertyDescriptor_Vector");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, UIStep) == 0x000098, "Member 'UInspectorPropertyDescriptor_Vector::UIStep' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, UIMin) == 0x00009C, "Member 'UInspectorPropertyDescriptor_Vector::UIMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, UIMax) == 0x0000A0, "Member 'UInspectorPropertyDescriptor_Vector::UIMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, ClampMin) == 0x0000A4, "Member 'UInspectorPropertyDescriptor_Vector::ClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, ClampMax) == 0x0000A8, "Member 'UInspectorPropertyDescriptor_Vector::ClampMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, UnderlyingUnit) == 0x0000AC, "Member 'UInspectorPropertyDescriptor_Vector::UnderlyingUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, DisplayUnit) == 0x0000AD, "Member 'UInspectorPropertyDescriptor_Vector::DisplayUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, MinFractionalDigits) == 0x0000B0, "Member 'UInspectorPropertyDescriptor_Vector::MinFractionalDigits' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_Vector, MaxFractionalDigits) == 0x0000B4, "Member 'UInspectorPropertyDescriptor_Vector::MaxFractionalDigits' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_IntVector
// 0x0018 (0x00B0 - 0x0098)
class UInspectorPropertyDescriptor_IntVector final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	int32                                         UIStep;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIMin;                                             // 0x009C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UIMax;                                             // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampMin;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClampMax;                                          // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         UnderlyingUnit;                                    // 0x00AC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUnit                                         DisplayUnit;                                       // 0x00AD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bUseUIStep : 1;                                    // 0x00AE(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMin : 1;                                     // 0x00AE(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseUIMax : 1;                                     // 0x00AE(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMin : 1;                                  // 0x00AE(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseClampMax : 1;                                  // 0x00AE(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bUseDisplayUnit : 1;                               // 0x00AE(0x0001)(BitIndex: 0x05, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bLiveSlider : 1;                                   // 0x00AE(0x0001)(BitIndex: 0x06, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_AF[0x1];                                       // 0x00AF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_IntVector">();
	}
	static class UInspectorPropertyDescriptor_IntVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_IntVector>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_IntVector) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_IntVector");
static_assert(sizeof(UInspectorPropertyDescriptor_IntVector) == 0x0000B0, "Wrong size on UInspectorPropertyDescriptor_IntVector");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, UIStep) == 0x000098, "Member 'UInspectorPropertyDescriptor_IntVector::UIStep' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, UIMin) == 0x00009C, "Member 'UInspectorPropertyDescriptor_IntVector::UIMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, UIMax) == 0x0000A0, "Member 'UInspectorPropertyDescriptor_IntVector::UIMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, ClampMin) == 0x0000A4, "Member 'UInspectorPropertyDescriptor_IntVector::ClampMin' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, ClampMax) == 0x0000A8, "Member 'UInspectorPropertyDescriptor_IntVector::ClampMax' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, UnderlyingUnit) == 0x0000AC, "Member 'UInspectorPropertyDescriptor_IntVector::UnderlyingUnit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_IntVector, DisplayUnit) == 0x0000AD, "Member 'UInspectorPropertyDescriptor_IntVector::DisplayUnit' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Rotator
// 0x0008 (0x00A0 - 0x0098)
class UInspectorPropertyDescriptor_Rotator final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	uint8                                         bLiveSlider : 1;                                   // 0x0098(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Rotator">();
	}
	static class UInspectorPropertyDescriptor_Rotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Rotator>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Rotator) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Rotator");
static_assert(sizeof(UInspectorPropertyDescriptor_Rotator) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_Rotator");

// Class Brickadia.InspectorPropertyDescriptor_Color
// 0x0008 (0x00A0 - 0x0098)
class UInspectorPropertyDescriptor_Color final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	bool                                          bAllowOpacity;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Color">();
	}
	static class UInspectorPropertyDescriptor_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Color>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Color) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Color");
static_assert(sizeof(UInspectorPropertyDescriptor_Color) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_Color");
static_assert(offsetof(UInspectorPropertyDescriptor_Color, bAllowOpacity) == 0x000098, "Member 'UInspectorPropertyDescriptor_Color::bAllowOpacity' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_LinearColor
// 0x0008 (0x00A0 - 0x0098)
class UInspectorPropertyDescriptor_LinearColor final : public UInspectorPropertyDescriptor_DescriptorStruct
{
public:
	bool                                          bAllowOpacity;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_LinearColor">();
	}
	static class UInspectorPropertyDescriptor_LinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_LinearColor>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_LinearColor) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_LinearColor");
static_assert(sizeof(UInspectorPropertyDescriptor_LinearColor) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_LinearColor");
static_assert(offsetof(UInspectorPropertyDescriptor_LinearColor, bAllowOpacity) == 0x000098, "Member 'UInspectorPropertyDescriptor_LinearColor::bAllowOpacity' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_StringListToInt
// 0x0018 (0x00A0 - 0x0088)
class UInspectorPropertyDescriptor_StringListToInt final : public UInspectorPropertyDescriptor
{
public:
	class FName                                   StringListGetFunction;                             // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         StringList;                                        // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	TArray<class FString> GetStringList(const struct FInspectorViewTarget& ViewTarget, class UObject* WorldContext) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_StringListToInt">();
	}
	static class UInspectorPropertyDescriptor_StringListToInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_StringListToInt>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_StringListToInt) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_StringListToInt");
static_assert(sizeof(UInspectorPropertyDescriptor_StringListToInt) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_StringListToInt");
static_assert(offsetof(UInspectorPropertyDescriptor_StringListToInt, StringListGetFunction) == 0x000088, "Member 'UInspectorPropertyDescriptor_StringListToInt::StringListGetFunction' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_StringListToInt, StringList) == 0x000090, "Member 'UInspectorPropertyDescriptor_StringListToInt::StringList' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_PrimaryAssetList
// 0x0018 (0x00A0 - 0x0088)
class UInspectorPropertyDescriptor_PrimaryAssetList final : public UInspectorPropertyDescriptor
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    Filter;                                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBeNull;                                        // 0x0098(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_PrimaryAssetList">();
	}
	static class UInspectorPropertyDescriptor_PrimaryAssetList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_PrimaryAssetList>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_PrimaryAssetList) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_PrimaryAssetList");
static_assert(sizeof(UInspectorPropertyDescriptor_PrimaryAssetList) == 0x0000A0, "Wrong size on UInspectorPropertyDescriptor_PrimaryAssetList");
static_assert(offsetof(UInspectorPropertyDescriptor_PrimaryAssetList, PrimaryAssetType) == 0x000088, "Member 'UInspectorPropertyDescriptor_PrimaryAssetList::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_PrimaryAssetList, Filter) == 0x000090, "Member 'UInspectorPropertyDescriptor_PrimaryAssetList::Filter' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyDescriptor_PrimaryAssetList, bCanBeNull) == 0x000098, "Member 'UInspectorPropertyDescriptor_PrimaryAssetList::bCanBeNull' has a wrong offset!");

// Class Brickadia.InspectorPropertyDescriptor_Unknown
// 0x0000 (0x0088 - 0x0088)
class UInspectorPropertyDescriptor_Unknown final : public UInspectorPropertyDescriptor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyDescriptor_Unknown">();
	}
	static class UInspectorPropertyDescriptor_Unknown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyDescriptor_Unknown>();
	}
};
static_assert(alignof(UInspectorPropertyDescriptor_Unknown) == 0x000008, "Wrong alignment on UInspectorPropertyDescriptor_Unknown");
static_assert(sizeof(UInspectorPropertyDescriptor_Unknown) == 0x000088, "Wrong size on UInspectorPropertyDescriptor_Unknown");

// Class Brickadia.InspectorPropertyRowBase
// 0x0020 (0x02F0 - 0x02D0)
class UInspectorPropertyRowBase : public UUserWidget
{
public:
	class UTextBlock*                             PropertyNameText;                                  // 0x02D0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNamedSlot*                             ValueWidgetSlot;                                   // 0x02D8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                ResetButton;                                       // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 DisabledOverlay;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddValueWidget(class UInspectorPropertyWidgetBase* NewWidget);
	void OnAvailabilityChange(bool bEnabled);
	void SetPropertyRowNameText(const class FText& Name_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyRowBase">();
	}
	static class UInspectorPropertyRowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyRowBase>();
	}
};
static_assert(alignof(UInspectorPropertyRowBase) == 0x000008, "Wrong alignment on UInspectorPropertyRowBase");
static_assert(sizeof(UInspectorPropertyRowBase) == 0x0002F0, "Wrong size on UInspectorPropertyRowBase");
static_assert(offsetof(UInspectorPropertyRowBase, PropertyNameText) == 0x0002D0, "Member 'UInspectorPropertyRowBase::PropertyNameText' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyRowBase, ValueWidgetSlot) == 0x0002D8, "Member 'UInspectorPropertyRowBase::ValueWidgetSlot' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyRowBase, ResetButton) == 0x0002E0, "Member 'UInspectorPropertyRowBase::ResetButton' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyRowBase, DisabledOverlay) == 0x0002E8, "Member 'UInspectorPropertyRowBase::DisabledOverlay' has a wrong offset!");

// Class Brickadia.InspectorPropertyWidgetBase
// 0x00B0 (0x0380 - 0x02D0)
class UInspectorPropertyWidgetBase : public UUserWidget
{
public:
	TMulticastInlineDelegate<void(class UInspectorPropertyWidgetBase* Widget)> OnDirtied;                                         // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UInspectorPropertyWidgetBase* Widget)> OnEdited;                                          // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UInspectorPropertyWidgetBase* Widget)> OnCommitted;                                       // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FInspectorViewTarget                   ViewTarget;                                        // 0x0300(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FInspectorPropertyValue                ValueToCommit;                                     // 0x0330(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FInspectorPropertyValue                CachedUnchangedValue;                              // 0x0348(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UInspectorPropertyDescriptor*           PropertyDescriptor;                                // 0x0360(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInspectorPropertyRowBase*              ContainingRowWidget;                               // 0x0368(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bWasDirty;                                         // 0x0370(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsAvailable;                                      // 0x0371(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UButton*                                SetToDefaultButton;                                // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BindSetToDefaultButton(class UButton* ResetButtonIn);
	void Init(class UInspectorPropertyDescriptor* NewDescriptor, const struct FInspectorViewTarget& NewViewTarget, class UInspectorPropertyRowBase* NewContainingRow);
	bool LiveUpdate(bool bForce);
	void OnAvailabilityChange(bool Enabled);
	void OnInit(class UInspectorPropertyDescriptor* NewDescriptor, const struct FInspectorViewTarget& NewViewTarget);
	void OnValueChangedExternally(const struct FInspectorPropertyValue& ValueIn);
	void ReplaceCachedValue();
	void Reset();
	void SetDefaultValue();
	void SetValue(const struct FInspectorPropertyValue& ValueIn, bool bUpdatedExternally, bool bCommitValue);

	class UInspectorPropertyDescriptor* GetDescriptor() const;
	bool GetIsDirty() const;
	void GetValue(struct FInspectorPropertyValue* ValueOut) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorPropertyWidgetBase">();
	}
	static class UInspectorPropertyWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorPropertyWidgetBase>();
	}
};
static_assert(alignof(UInspectorPropertyWidgetBase) == 0x000008, "Wrong alignment on UInspectorPropertyWidgetBase");
static_assert(sizeof(UInspectorPropertyWidgetBase) == 0x000380, "Wrong size on UInspectorPropertyWidgetBase");
static_assert(offsetof(UInspectorPropertyWidgetBase, OnDirtied) == 0x0002D0, "Member 'UInspectorPropertyWidgetBase::OnDirtied' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, OnEdited) == 0x0002E0, "Member 'UInspectorPropertyWidgetBase::OnEdited' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, OnCommitted) == 0x0002F0, "Member 'UInspectorPropertyWidgetBase::OnCommitted' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, ViewTarget) == 0x000300, "Member 'UInspectorPropertyWidgetBase::ViewTarget' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, ValueToCommit) == 0x000330, "Member 'UInspectorPropertyWidgetBase::ValueToCommit' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, CachedUnchangedValue) == 0x000348, "Member 'UInspectorPropertyWidgetBase::CachedUnchangedValue' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, PropertyDescriptor) == 0x000360, "Member 'UInspectorPropertyWidgetBase::PropertyDescriptor' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, ContainingRowWidget) == 0x000368, "Member 'UInspectorPropertyWidgetBase::ContainingRowWidget' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, bWasDirty) == 0x000370, "Member 'UInspectorPropertyWidgetBase::bWasDirty' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, bIsAvailable) == 0x000371, "Member 'UInspectorPropertyWidgetBase::bIsAvailable' has a wrong offset!");
static_assert(offsetof(UInspectorPropertyWidgetBase, SetToDefaultButton) == 0x000378, "Member 'UInspectorPropertyWidgetBase::SetToDefaultButton' has a wrong offset!");

// Class Brickadia.InspectorStatics
// 0x0000 (0x0028 - 0x0028)
class UInspectorStatics final : public UBlueprintFunctionLibrary
{
public:
	static void ApplyPropertyChangelistEntryToObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass, const struct FInspectorPropertyChangelistEntry& Entry, bool bRunNotify);
	static void ApplyPropertyChangelistEntryToObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View, const struct FInspectorPropertyChangelistEntry& Entry, bool bRunNotify);
	static void ApplyPropertyChangelistToObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass, const struct FInspectorPropertyChangelist& Changelist, bool bRunNotify);
	static void ApplyPropertyChangelistToObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View, const struct FInspectorPropertyChangelist& Changelist, bool bRunNotify);
	static class FString ExportPropertyChangelistToDebugString(const struct FInspectorPropertyChangelist& InChangelist);
	static struct FJsonObjectWrapper ExportPropertyChangelistToJson(class UObject* WorldContext, const struct FInspectorPropertyChangelist& InChangelist, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static struct FJsonObjectWrapper ExportPropertyChangelistToJson2(class UObject* WorldContext, const struct FInspectorPropertyChangelist& InChangelist, class UInspectorPropertyDescriptorList* View);
	static bool GetChangelistValue(const struct FInspectorPropertyChangelist& Changelist, class FName ValueName, struct FInspectorPropertyValue* OutValue);
	static struct FInspectorPropertyChangelist GetDefaultPropertyChangelistFromObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static struct FInspectorPropertyChangelist GetDefaultPropertyChangelistFromObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View);
	static struct FInspectorPropertyChangelistEntry GetPropertyChangelistEntryFromObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass, const class FName& InProperty);
	static struct FInspectorPropertyChangelistEntry GetPropertyChangelistEntryFromObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View, const class FName& InProperty);
	static struct FInspectorPropertyChangelist GetPropertyChangelistFromObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static struct FInspectorPropertyChangelist GetPropertyChangelistFromObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View);
	static struct FInspectorPropertyChangelistEntry GetReversePropertyChangelistEntryFromObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass, const struct FInspectorPropertyChangelistEntry& InChangelistEntry);
	static struct FInspectorPropertyChangelistEntry GetReversePropertyChangelistEntryFromObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View, const struct FInspectorPropertyChangelistEntry& InChangelistEntry);
	static struct FInspectorPropertyChangelist GetReversePropertyChangelistFromObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass, const struct FInspectorPropertyChangelist& InChangelist);
	static struct FInspectorPropertyChangelist GetReversePropertyChangelistFromObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View, const struct FInspectorPropertyChangelist& InChangelist);
	static struct FInspectorPropertyChangelist GetVerbosePropertyChangelistFromObject(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static struct FInspectorPropertyChangelist GetVerbosePropertyChangelistFromObject2(class UObject* WorldContext, const struct FInspectorViewTarget& ViewTarget, class UInspectorPropertyDescriptorList* View);
	static struct FInspectorPropertyChangelist ImportPropertyChangelistFromJson(class UObject* WorldContext, const struct FJsonObjectWrapper& InJson, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static struct FInspectorPropertyChangelist ImportPropertyChangelistFromJson2(class UObject* WorldContext, const struct FJsonObjectWrapper& InJson, class UInspectorPropertyDescriptorList* View);
	static bool IsViewTargetValid(const struct FInspectorViewTarget& ViewTarget);
	static struct FInspectorViewTarget MakeViewTargetFromBrickComponent(const class UObject* WorldContext, const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* ComponentType);
	static struct FInspectorViewTarget MakeViewTargetFromBrickComponentProperty(const class UObject* WorldContext, const struct FBrickHandle& BrickHandle, class UBrickComponentTypeBase* ComponentType, const class FString& PropertyPath);
	static struct FInspectorViewTarget MakeViewTargetFromObject(class UObject* Instance);
	static struct FInspectorViewTarget MakeViewTargetFromObjectProperty(class UObject* Instance, const class FString& PropertyPath);
	static bool MergePropertyChangelists(const struct FInspectorPropertyChangelist& ChangelistA, const struct FInspectorPropertyChangelist& ChangelistB, struct FInspectorPropertyChangelist* Merged);
	static void MergePropertyDescriptorList(class UInspectorPropertyDescriptorList* DescriptorList, class UInspectorPropertyDescriptorList* Other);
	static void OverridePropertyChangelist(const struct FInspectorPropertyChangelist& ChangelistA, const struct FInspectorPropertyChangelist& ChangelistB, struct FInspectorPropertyChangelist* Overidden);
	static void PreProcessChangelist(const struct FInspectorPropertyChangelist& InChangelist, struct FInspectorPropertyChangelist* OutChangelist, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static void PreProcessChangelist2(const struct FInspectorPropertyChangelist& InChangelist, struct FInspectorPropertyChangelist* OutChangelist, class UInspectorPropertyDescriptorList* View);
	static void PreProcessChangelistEntryInline(struct FInspectorPropertyChangelistEntry* InOutEntry, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static void PreProcessChangelistEntryInline2(struct FInspectorPropertyChangelistEntry* InOutEntry, class UInspectorPropertyDescriptorList* View);
	static void PreProcessChangelistInline(struct FInspectorPropertyChangelist* InOutChangelist, TSubclassOf<class UInspectorPropertyDescriptorList> ViewClass);
	static void PreProcessChangelistInline2(struct FInspectorPropertyChangelist* InOutChangelist, class UInspectorPropertyDescriptorList* View);
	static struct FInspectorPropertyChangelist SetChangelistValue(const struct FInspectorPropertyChangelist& ChangelistIn, class FName ValueName, const struct FInspectorPropertyValue& NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InspectorStatics">();
	}
	static class UInspectorStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInspectorStatics>();
	}
};
static_assert(alignof(UInspectorStatics) == 0x000008, "Wrong alignment on UInspectorStatics");
static_assert(sizeof(UInspectorStatics) == 0x000028, "Wrong size on UInspectorStatics");

// Class Brickadia.IntVectorExtras
// 0x0000 (0x0028 - 0x0028)
class UIntVectorExtras final : public UBlueprintFunctionLibrary
{
public:
	static struct FIntVector Add_IntVectorInt(const struct FIntVector& A, int32 B);
	static struct FIntVector Add_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);
	static struct FIntVector Divide_IntVectorInt(const struct FIntVector& A, int32 B);
	static struct FIntVector Divide_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);
	static struct FIntVector IntVector_GetAbs(const struct FIntVector& A);
	static struct FIntVector Multiply_IntVectorInt(const struct FIntVector& A, int32 B);
	static struct FIntVector Multiply_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);
	static struct FIntVector Percent_IntVectorInt(const struct FIntVector& A, int32 B);
	static struct FIntVector Percent_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);
	static struct FIntVector Subtract_IntVectorInt(const struct FIntVector& A, int32 B);
	static struct FIntVector Subtract_IntVectorIntVector(const struct FIntVector& A, const struct FIntVector& B);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntVectorExtras">();
	}
	static class UIntVectorExtras* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntVectorExtras>();
	}
};
static_assert(alignof(UIntVectorExtras) == 0x000008, "Wrong alignment on UIntVectorExtras");
static_assert(sizeof(UIntVectorExtras) == 0x000028, "Wrong size on UIntVectorExtras");

// Class Brickadia.BRRichTextUtils
// 0x0000 (0x0028 - 0x0028)
class UBRRichTextUtils final : public UBlueprintFunctionLibrary
{
public:
	static class FString AddMarkup(const class FString& InText, const struct FColor& Color, const class FString& Style, const class FString& Font, int32 Size);
	static class FString EscapeDecorators(const class FString& Input);
	static class FString EscapeMarkdown(const class FString& Input);
	static class FString EscapeMarkup(const class FString& Input);
	static class FString ExpandMarkdown(class UObject* WorldContextObject, const class FString& Input, bool* bDidMarkdownChanges);
	static class FString ExpandURLs(const class FString& Input);
	static class FString FormatPlayerName(const class ABRPlayerController* Player);
	static class FString FormatPlayerNameFor(const class ABRPlayerState* Player, class ABRPlayerState* OtherPlayer);
	static int32 GetEffectiveLength(const class FString& Input);
	static class FString ProcessChatMessage(class UObject* WorldContextObject, const class FString& ChatMessage, bool* bDidMarkdownChanges);
	static class FString RemoveMarkup(const class FString& Input);
	static class FString RemoveNewLines(const class FString& Input);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRRichTextUtils">();
	}
	static class UBRRichTextUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRRichTextUtils>();
	}
};
static_assert(alignof(UBRRichTextUtils) == 0x000008, "Wrong alignment on UBRRichTextUtils");
static_assert(sizeof(UBRRichTextUtils) == 0x000028, "Wrong size on UBRRichTextUtils");

// Class Brickadia.BRBundleDatabase
// 0x0040 (0x0068 - 0x0028)
class UBRBundleDatabase final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRBundleDatabase">();
	}
	static class UBRBundleDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRBundleDatabase>();
	}
};
static_assert(alignof(UBRBundleDatabase) == 0x000008, "Wrong alignment on UBRBundleDatabase");
static_assert(sizeof(UBRBundleDatabase) == 0x000068, "Wrong size on UBRBundleDatabase");

// Class Brickadia.BRWorldManager
// 0x0090 (0x00C8 - 0x0038)
class UBRWorldManager final : public UBRWorldSubsystem
{
public:
	class UBRBundleDatabase*                      CachedWorldBundle;                                 // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x88];                                      // 0x0040(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestSaveWorldBP(const struct FBRWorldSaveParams& Params_0, const TDelegate<void(bool bSuccess, const struct FBRWorldSaveResult& Result, const class FText& Error)>& Callback);

	bool CanSaveWorldBP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BRWorldManager">();
	}
	static class UBRWorldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBRWorldManager>();
	}
};
static_assert(alignof(UBRWorldManager) == 0x000008, "Wrong alignment on UBRWorldManager");
static_assert(sizeof(UBRWorldManager) == 0x0000C8, "Wrong size on UBRWorldManager");
static_assert(offsetof(UBRWorldManager, CachedWorldBundle) == 0x000038, "Member 'UBRWorldManager::CachedWorldBundle' has a wrong offset!");

}

