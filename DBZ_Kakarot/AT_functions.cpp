#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AT

#include "Basic.hpp"

#include "AT_classes.hpp"
#include "AT_parameters.hpp"


namespace SDK
{

// Function AT.FishPawnCPP.GetEscapeLoopFlg
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AFishPawnCPP::GetEscapeLoopFlg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishPawnCPP", "GetEscapeLoopFlg");

	Params::FishPawnCPP_GetEscapeLoopFlg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.FishPawnCPP.GetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFishState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFishState AFishPawnCPP::GetState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishPawnCPP", "GetState");

	Params::FishPawnCPP_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.FishPawnCPP.SetEscapeLoopFlg
// (Final, Native, Public, BlueprintCallable)

void AFishPawnCPP::SetEscapeLoopFlg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishPawnCPP", "SetEscapeLoopFlg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActBase.OnFireProjectile
// (Final, Native, Protected)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActBase::OnFireProjectile(class AProjectile* InProjectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActBase", "OnFireProjectile");

	Params::ATActBase_OnFireProjectile Parms{};

	Parms.InProjectile = InProjectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccessPointBase.FinishedEffect
// (Native, Protected)
// Parameters:
// class UParticleSystemComponent*         PSysComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAccessPointBase::FinishedEffect(class UParticleSystemComponent* PSysComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessPointBase", "FinishedEffect");

	Params::AccessPointBase_FinishedEffect Parms{};

	Parms.PSysComp = PSysComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccessPointBase.OpenPoint
// (Native, Public)

void AAccessPointBase::OpenPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessPointBase", "OpenPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUIUserWidget.SetForceTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATUIUserWidget::SetForceTick(bool IsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUIUserWidget", "SetForceTick");

	Params::ATUIUserWidget_SetForceTick Parms{};

	Parms.IsOn = IsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICutinLevelUp_Lang.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UICutinLevelUp_Lang::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICutinLevelUp_Lang", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UICutinLevelUp_Lang.Ev_In_Xef_Shine
// (Final, Native, Protected)

void UAT_UICutinLevelUp_Lang::Ev_In_Xef_Shine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICutinLevelUp_Lang", "Ev_In_Xef_Shine");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccessPointBaseComponent.NotifyStateChangeRequest
// (Native, Public)

void UAccessPointBaseComponent::NotifyStateChangeRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessPointBaseComponent", "NotifyStateChangeRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccessPointBaseComponent.OpenPoint
// (Native, Public)

void UAccessPointBaseComponent::OpenPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccessPointBaseComponent", "OpenPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_LightTowerEffectComponent.OnQuestTiming
// (Final, Native, Public)
// Parameters:
// EQUEST_ACTOR_TIMING_TYPE                Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_LightTowerEffectComponent::OnQuestTiming(EQUEST_ACTOR_TIMING_TYPE Timing, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_LightTowerEffectComponent", "OnQuestTiming");

	Params::AT_LightTowerEffectComponent_OnQuestTiming Parms{};

	Parms.Timing = Timing;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIDemoSkipDialog.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIDemoSkipDialog::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIDemoSkipDialog", "OnDemoTiming");

	Params::AT_UIDemoSkipDialog_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATBattleAIBehaviorGroundMoveStep.OnChangeAction
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATBattleAIBehaviorGroundMoveStep::OnChangeAction(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleAIBehaviorGroundMoveStep", "OnChangeAction");

	Params::ATBattleAIBehaviorGroundMoveStep_OnChangeAction Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_VillainGroupEncounterHudComponent.OnEventBattleEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_VillainGroupEncounterHudComponent::OnEventBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_VillainGroupEncounterHudComponent", "OnEventBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccompanyAI.OnEncountBattleEnd
// (Final, Native, Public)

void UAccompanyAI::OnEncountBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccompanyAI", "OnEncountBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccompanyAI.OnUpdateAnimation
// (Final, Native, Public)
// Parameters:
// EATCharacterMoveState                   InMoveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccompanyAI::OnUpdateAnimation(EATCharacterMoveState InMoveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccompanyAI", "OnUpdateAnimation");

	Params::AccompanyAI_OnUpdateAnimation Parms{};

	Parms.InMoveType = InMoveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AccompanyAI.StopEvent
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    Chara                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccompanyAI::StopEvent(class AAT_Character* Chara)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccompanyAI", "StopEvent");

	Params::AccompanyAI_StopEvent Parms{};

	Parms.Chara = Chara;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCookResourceLoader.CompleteClear
// (Final, Native, Public)
// Parameters:
// class UATDataAssetCookingDemoCharacterResourceAsyncLoad*ResourceLoad                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCookResourceLoader::CompleteClear(class UATDataAssetCookingDemoCharacterResourceAsyncLoad* ResourceLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCookResourceLoader", "CompleteClear");

	Params::ATCookResourceLoader_CompleteClear Parms{};

	Parms.ResourceLoad = ResourceLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCookResourceLoader.CompleteLoad
// (Final, Native, Public)
// Parameters:
// class UATDataAssetCookingDemoCharacterResourceAsyncLoad*ResourceLoad                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCookResourceLoader::CompleteLoad(class UATDataAssetCookingDemoCharacterResourceAsyncLoad* ResourceLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCookResourceLoader", "CompleteLoad");

	Params::ATCookResourceLoader_CompleteLoad Parms{};

	Parms.ResourceLoad = ResourceLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsList.SetOffSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleTipsList::SetOffSet(float Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsList", "SetOffSet");

	Params::AT_UIBattleTipsList_SetOffSet Parms{};

	Parms.Offset = Offset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsList.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InBtnMsgId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InOpeMsgId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleTipsList::SetText(class FName InBtnMsgId, class FName InOpeMsgId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsList", "SetText");

	Params::AT_UIBattleTipsList_SetText Parms{};

	Parms.InBtnMsgId = InBtnMsgId;
	Parms.InOpeMsgId = InOpeMsgId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ActorTrackingEffectComponent.DeleteTrackingEffect
// (Final, Native, Public)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UActorTrackingEffectComponent::DeleteTrackingEffect(class AActor* Owner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ActorTrackingEffectComponent", "DeleteTrackingEffect");

	Params::ActorTrackingEffectComponent_DeleteTrackingEffect Parms{};

	Parms.Owner = Owner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcPawn.GetNpcMovementComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNpcMovementComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNpcMovementComponent* ANpcPawn::GetNpcMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcPawn", "GetNpcMovementComponent");

	Params::NpcPawn_GetNpcMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_MobBase.OnCollisionHit
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAT_MobBase::OnCollisionHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobBase", "OnCollisionHit");

	Params::AT_MobBase_OnCollisionHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_MobBase.SpawnFallEnd_CallBack
// (Final, Native, Public)

void AAT_MobBase::SpawnFallEnd_CallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobBase", "SpawnFallEnd_CallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_MobBase.SpawnFallStart_CallBack
// (Final, Native, Public)

void AAT_MobBase::SpawnFallStart_CallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobBase", "SpawnFallStart_CallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_MobBase.WalkingMoveDelegate_CallBack
// (Final, Native, Public)

void AAT_MobBase::WalkingMoveDelegate_CallBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobBase", "WalkingMoveDelegate_CallBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_MobBase_Static.OnVisibleChanged
// (Final, Native, Private)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_MobBase_Static::OnVisibleChanged(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobBase_Static", "OnVisibleChanged");

	Params::AT_MobBase_Static_OnVisibleChanged Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgBound.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActGroundBattleDmgBound::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgBound", "OnHitPhoton");

	Params::ATActGroundBattleDmgBound_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgBound.OnReachedJumpApex
// (Final, Native, Protected)

void UATActGroundBattleDmgBound::OnReachedJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgBound", "OnReachedJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEncounterHudCore.InitSetting
// (Event, Protected, BlueprintEvent)

void UAT_UIEncounterHudCore::InitSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEncounterHudCore", "InitSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIEncounterHudCore.RemoveParentWidget
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIEncounterHudCore::RemoveParentWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEncounterHudCore", "RemoveParentWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimNotifyState_AG_Trail.OverridePSTemplate
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* UAnimNotifyState_AG_Trail::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_AG_Trail", "OverridePSTemplate");

	Params::AnimNotifyState_AG_Trail_OverridePSTemplate Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AT.Projectile.DamageApplied
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "DamageApplied");

	Params::Projectile_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile.OffsetAbsorb
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::OffsetAbsorb(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OffsetAbsorb");

	Params::Projectile_OffsetAbsorb Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile.OffsetDraw
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::OffsetDraw(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OffsetDraw");

	Params::Projectile_OffsetDraw Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile.OffsetLose
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::OffsetLose(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OffsetLose");

	Params::Projectile_OffsetLose Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile.OffsetReflect
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile::OffsetReflect(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile", "OffsetReflect");

	Params::Projectile_OffsetReflect Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATProjectileBullet.HitRootSphere
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATProjectileBullet::HitRootSphere(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATProjectileBullet", "HitRootSphere");

	Params::ATProjectileBullet_HitRootSphere Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.BehaviorCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::BehaviorCheck(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "BehaviorCheck");

	Params::AIBase_BehaviorCheck Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.BehaviorLot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FDlt                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::BehaviorLot(float FDlt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "BehaviorLot");

	Params::AIBase_BehaviorLot Parms{};

	Parms.FDlt = FDlt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.CheckSeq
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// E_SEQ_AI                                Seq                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::CheckSeq(E_SEQ_AI Seq)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "CheckSeq");

	Params::AIBase_CheckSeq Parms{};

	Parms.Seq = Seq;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.CheckState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// E_AI_STATE                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::CheckState(E_AI_STATE State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "CheckState");

	Params::AIBase_CheckState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.DoMiniGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::DoMiniGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "DoMiniGame");

	Params::AIBase_DoMiniGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.GetAIStopEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::GetAIStopEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetAIStopEvent");

	Params::AIBase_GetAIStopEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UAIBase::GetCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetCharacter");

	Params::AIBase_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.GetDebugAIStop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::GetDebugAIStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetDebugAIStop");

	Params::AIBase_GetDebugAIStop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.GetDebugFlg
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBase::GetDebugFlg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetDebugFlg");

	Params::AIBase_GetDebugFlg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.GetSlopeX
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBase::GetSlopeX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetSlopeX");

	Params::AIBase_GetSlopeX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.GetSlopeY
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAIBase::GetSlopeY()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetSlopeY");

	Params::AIBase_GetSlopeY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.OnCookingTiming
// (Final, Native, Public)
// Parameters:
// EEventTimingType                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnCookingTiming(EEventTimingType Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnCookingTiming");

	Params::AIBase_OnCookingTiming Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "OnDemoTiming");

	Params::AIBase_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.RequestBehaviorCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::RequestBehaviorCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "RequestBehaviorCheck");

	Params::AIBase_RequestBehaviorCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.RequestCheck
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAIBase::RequestCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "RequestCheck");

	Params::AIBase_RequestCheck Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIBase.SetBehavior
// (Final, Native, Public, BlueprintCallable)

void UAIBase::SetBehavior()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "SetBehavior");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.SetMiniGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// E_AI_MINIGAME                           Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::SetMiniGame(E_AI_MINIGAME Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "SetMiniGame");

	Params::AIBase_SetMiniGame Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.SetSpecialBehavior
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// E_AI_SPECIAL                            Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::SetSpecialBehavior(E_AI_SPECIAL Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "SetSpecialBehavior");

	Params::AIBase_SetSpecialBehavior Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.UpdataStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIBase::UpdataStatus(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "UpdataStatus");

	Params::AIBase_UpdataStatus Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIBase.GetMiniGame
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// E_AI_MINIGAME                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

E_AI_MINIGAME UAIBase::GetMiniGame() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIBase", "GetMiniGame");

	Params::AIBase_GetMiniGame Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATActDmgBlowoffRoll.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActDmgBlowoffRoll::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgBlowoffRoll", "OnHitPhoton");

	Params::ATActDmgBlowoffRoll_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AIManager.CreateFriendDetails
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CHARACTER_TYPE                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFalling                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIndependent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UAIManager::CreateFriendDetails(ECHARACTER_TYPE CHARACTER_TYPE, const struct FVector& Pos, const struct FRotator& Rot, bool bFalling, bool bIndependent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIManager", "CreateFriendDetails");

	Params::AIManager_CreateFriendDetails Parms{};

	Parms.CHARACTER_TYPE = CHARACTER_TYPE;
	Parms.Pos = std::move(Pos);
	Parms.Rot = std::move(Rot);
	Parms.bFalling = bFalling;
	Parms.bIndependent = bIndependent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AIManager.DeleteFriend
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Chara                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAIManager::DeleteFriend(class AAT_Character* Chara)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AIManager", "DeleteFriend");

	Params::AIManager_DeleteFriend Parms{};

	Parms.Chara = Chara;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RideCharacterBase.OnCollisionOverlapBegin
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ARideCharacterBase::OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideCharacterBase", "OnCollisionOverlapBegin");

	Params::RideCharacterBase_OnCollisionOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RideCharacterBase.OnCollisionOverlapEnd
// (Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARideCharacterBase::OnCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideCharacterBase", "OnCollisionOverlapEnd");

	Params::RideCharacterBase_OnCollisionOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgBlowoff.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActDmgBlowoff::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgBlowoff", "OnHitPhoton");

	Params::ATActDmgBlowoff_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart_EmbList.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UICommunityStart_EmbList::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart_EmbList", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UICommunityStart_EmbList.OnInEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityStart_EmbList::OnInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart_EmbList", "OnInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart_EmbList.OnOutEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityStart_EmbList::OnOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart_EmbList", "OnOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.RidePlayerControllerBase.GetAxisValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_AXIS                  AxisType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PastTickNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ARidePlayerControllerBase::GetAxisValue(EAT_CONTROL_INPUT_AXIS AxisType, uint8 PastTickNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "GetAxisValue");

	Params::RidePlayerControllerBase_GetAxisValue Parms{};

	Parms.AxisType = AxisType;
	Parms.PastTickNum = PastTickNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RidePlayerControllerBase.IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARidePlayerControllerBase::IsPressed(EAT_CONTROL_INPUT_ACTION ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "IsPressed");

	Params::RidePlayerControllerBase_IsPressed Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RidePlayerControllerBase.PressedSimultaneous
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType1                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAT_CONTROL_INPUT_ACTION                ActionType2                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PastTickNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPermitHoldDown                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARidePlayerControllerBase::PressedSimultaneous(EAT_CONTROL_INPUT_ACTION ActionType1, EAT_CONTROL_INPUT_ACTION ActionType2, uint8 PastTickNum, bool bPermitHoldDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "PressedSimultaneous");

	Params::RidePlayerControllerBase_PressedSimultaneous Parms{};

	Parms.ActionType1 = ActionType1;
	Parms.ActionType2 = ActionType2;
	Parms.PastTickNum = PastTickNum;
	Parms.bPermitHoldDown = bPermitHoldDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RidePlayerControllerBase.SetPauseMenu
// (Final, Native, Public)
// Parameters:
// bool                                    bMenuPauseOff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARidePlayerControllerBase::SetPauseMenu(bool bMenuPauseOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "SetPauseMenu");

	Params::RidePlayerControllerBase_SetPauseMenu Parms{};

	Parms.bMenuPauseOff = bMenuPauseOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RidePlayerControllerBase.WasJustPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARidePlayerControllerBase::WasJustPressed(EAT_CONTROL_INPUT_ACTION ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "WasJustPressed");

	Params::RidePlayerControllerBase_WasJustPressed Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RidePlayerControllerBase.WasJustReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARidePlayerControllerBase::WasJustReleased(EAT_CONTROL_INPUT_ACTION ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "WasJustReleased");

	Params::RidePlayerControllerBase_WasJustReleased Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RidePlayerControllerBase.WasPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PastTickNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPermitHoldDown                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARidePlayerControllerBase::WasPressed(EAT_CONTROL_INPUT_ACTION ActionType, uint8 PastTickNum, bool bPermitHoldDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RidePlayerControllerBase", "WasPressed");

	Params::RidePlayerControllerBase_WasPressed Parms{};

	Parms.ActionType = ActionType;
	Parms.PastTickNum = PastTickNum;
	Parms.bPermitHoldDown = bPermitHoldDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATBattleCheerConditionBase.ReceiveEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATBattleCheerConditionBase::ReceiveEvent(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleCheerConditionBase", "ReceiveEvent");

	Params::ATBattleCheerConditionBase_ReceiveEvent Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActSpecialMoveZigzag.DamageApplied
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActSpecialMoveZigzag::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActSpecialMoveZigzag", "DamageApplied");

	Params::ATActSpecialMoveZigzag_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultDroneBase.OnHitDamageComponent
// (Final, Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAndroidAssaultDroneBase::OnHitDamageComponent(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneBase", "OnHitDamageComponent");

	Params::AndroidAssaultDroneBase_OnHitDamageComponent Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRidePillar.RequestPlayAnimGreat
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldRidePillar::RequestPlayAnimGreat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRidePillar", "RequestPlayAnimGreat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultDroneController.OnDamage
// (Event, Public, BlueprintEvent)

void AAndroidAssaultDroneController::OnDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneController", "OnDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AndroidAssaultDroneControllerInterface.BeginAlert
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAndroidAssaultDroneControllerInterface::BeginAlert()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneControllerInterface", "BeginAlert");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultDroneControllerInterface.BeginSearch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAndroidAssaultDroneControllerInterface::BeginSearch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneControllerInterface", "BeginSearch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultDroneControllerInterface.GetMoveLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IAndroidAssaultDroneControllerInterface::GetMoveLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneControllerInterface", "GetMoveLocation");

	Params::AndroidAssaultDroneControllerInterface_GetMoveLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AndroidAssaultDroneControllerInterface.IncrementMoveLocation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IAndroidAssaultDroneControllerInterface::IncrementMoveLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneControllerInterface", "IncrementMoveLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultDroneControllerInterface.IsInChasePlayer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InLength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAndroidAssaultDroneControllerInterface::IsInChasePlayer(float InLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneControllerInterface", "IsInChasePlayer");

	Params::AndroidAssaultDroneControllerInterface_IsInChasePlayer Parms{};

	Parms.InLength = InLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AndroidAssaultDroneControllerInterface.MoveToLocationKeepDistance
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          InTargetLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAcceptanceRadius                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InKeepDistance                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSensingDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAndroidAssaultDroneControllerInterface::MoveToLocationKeepDistance(const struct FVector& InTargetLocation, float InAcceptanceRadius, float InKeepDistance, float InSensingDistance, float InDTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDroneControllerInterface", "MoveToLocationKeepDistance");

	Params::AndroidAssaultDroneControllerInterface_MoveToLocationKeepDistance Parms{};

	Parms.InTargetLocation = std::move(InTargetLocation);
	Parms.InAcceptanceRadius = InAcceptanceRadius;
	Parms.InKeepDistance = InKeepDistance;
	Parms.InSensingDistance = InSensingDistance;
	Parms.InDTime = InDTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AndroidAssaultDCI_ChaseSupporter.ChaseSupporter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InDTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRotInterp                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAndroidAssaultDCI_ChaseSupporter::ChaseSupporter(float InDTime, float InRotInterp, float InDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultDCI_ChaseSupporter", "ChaseSupporter");

	Params::AndroidAssaultDCI_ChaseSupporter_ChaseSupporter Parms{};

	Parms.InDTime = InDTime;
	Parms.InRotInterp = InRotInterp;
	Parms.InDistance = InDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldTalkWin.OnMobMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Speaker                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bButtonVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldTalkWin::OnMobMessage(const class FString& Speaker, const class FString& Message, bool bButtonVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkWin", "OnMobMessage");

	Params::AT_UIFieldTalkWin_OnMobMessage Parms{};

	Parms.Speaker = std::move(Speaker);
	Parms.Message = std::move(Message);
	Parms.bButtonVisible = bButtonVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldTalkWin.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldTalkWin::SetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkWin", "SetVisible");

	Params::AT_UIFieldTalkWin_SetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultManager.OnAuraSearchEnd
// (Final, Native, Protected)

void UAndroidAssaultManager::OnAuraSearchEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultManager", "OnAuraSearchEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultManager.OnRideEnd
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAndroidAssaultManager::OnRideEnd(class AAT_Character* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultManager", "OnRideEnd");

	Params::AndroidAssaultManager_OnRideEnd Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultSearchComponent.IsInAlertArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAndroidAssaultSearchComponent::IsInAlertArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultSearchComponent", "IsInAlertArea");

	Params::AndroidAssaultSearchComponent_IsInAlertArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AndroidAssaultSearchComponent.IsInSearchArea
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAndroidAssaultSearchComponent::IsInSearchArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultSearchComponent", "IsInSearchArea");

	Params::AndroidAssaultSearchComponent_IsInSearchArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIIconLoad.DebugRequestAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIIconLoad::DebugRequestAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIIconLoad", "DebugRequestAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl003ESkill007.OnEndOfEndCutIn
// (Final, Native, Protected)

void UATActCpl003ESkill007::OnEndOfEndCutIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl003ESkill007", "OnEndOfEndCutIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActHugeSkillBeam.OnProjectileHitWall
// (Final, Native, Public)

void UATActHugeSkillBeam::OnProjectileHitWall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActHugeSkillBeam", "OnProjectileHitWall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimalAccessPoint.FinishedEffect
// (Final, Native, Protected)
// Parameters:
// class UParticleSystemComponent*         PSysComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimalAccessPoint::FinishedEffect(class UParticleSystemComponent* PSysComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalAccessPoint", "FinishedEffect");

	Params::AnimalAccessPoint_FinishedEffect Parms{};

	Parms.PSysComp = PSysComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcComponentBase.OnMontageBlendingOut_Call
// (Native, Public)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcComponentBase::OnMontageBlendingOut_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcComponentBase", "OnMontageBlendingOut_Call");

	Params::NpcComponentBase_OnMontageBlendingOut_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcComponentBase.OnMontageEnded_Call
// (Native, Public)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcComponentBase::OnMontageEnded_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcComponentBase", "OnMontageEnded_Call");

	Params::NpcComponentBase_OnMontageEnded_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcComponentBase.SplineMoveProc
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcComponentBase::SplineMoveProc(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcComponentBase", "SplineMoveProc");

	Params::NpcComponentBase_SplineMoveProc Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDamageCollisionBase.BeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATDamageCollisionBase::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDamageCollisionBase", "BeginOverlap");

	Params::ATDamageCollisionBase_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDamageCollisionBase.EndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDamageCollisionBase::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDamageCollisionBase", "EndOverlap");

	Params::ATDamageCollisionBase_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActSkillBeam.OnProjectileHitWall
// (Final, Native, Public)

void UATActSkillBeam::OnProjectileHitWall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActSkillBeam", "OnProjectileHitWall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimalComponentBase.UpdateAnimalParameter
// (Native, Public, BlueprintCallable)

void UAnimalComponentBase::UpdateAnimalParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalComponentBase", "UpdateAnimalParameter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.GetAnimInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimInstance* AAT_CharacterBase::GetAnimInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "GetAnimInstance");

	Params::AT_CharacterBase_GetAnimInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CharacterBase.OnActorBeginOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnActorBeginOverlap");

	Params::AT_CharacterBase_OnActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnActorEndOverlap
// (Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnActorEndOverlap");

	Params::AT_CharacterBase_OnActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnActorHit
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnActorHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnActorHit");

	Params::AT_CharacterBase_OnActorHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnFallLoop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnFallLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnFallLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnJumpCancelWait
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnJumpCancelWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnJumpCancelWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnLand2FlyNut
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnLand2FlyNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnLand2FlyNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnLandNut
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnLandNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnLandNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnNormalFlyDown
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnNormalFlyDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnNormalFlyDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnNormalFlyLoop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnNormalFlyLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnNormalFlyLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmBgnNormalFlyUp
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmBgnNormalFlyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmBgnNormalFlyUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndAirTrickEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndAirTrickEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndAirTrickEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndAirTrickStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndAirTrickStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndAirTrickStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndBattleStepEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndBattleStepEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndBattleStepEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndBattleStepStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndBattleStepStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndBattleStepStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndFallLoop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndFallLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndFallLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndJumpCancelWait
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndJumpCancelWait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndJumpCancelWait");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLand2FlyEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLand2FlyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLand2FlyEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLand2FlyNut
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLand2FlyNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLand2FlyNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLandJumpEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLandJumpEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLandJumpEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLandJumpStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLandJumpStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLandJumpStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLandNut
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLandNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLandNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLandTargetEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLandTargetEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLandTargetEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndLandTargetStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndLandTargetStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndLandTargetStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalBoostLanding
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalBoostLanding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalBoostLanding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyBoostEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyBoostEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyBoostEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyBoostPreLoop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyBoostPreLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyBoostPreLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyBoostRestart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyBoostRestart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyBoostRestart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyBoostStop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyBoostStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyBoostStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyDown
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyLoop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyStop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyTurn
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyTurn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyTurn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalFlyUp
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalFlyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalFlyUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalLandBoostEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalLandBoostEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalLandBoostEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalLandBoostPreLoop
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalLandBoostPreLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalLandBoostPreLoop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalRunEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalRunEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalRunEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalRunStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalRunStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalRunStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalWalkEnd
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalWalkEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalWalkEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndNormalWalkStart
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndNormalWalkStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndNormalWalkStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnAnmEndPreLand2Fly
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnAnmEndPreLand2Fly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnAnmEndPreLand2Fly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnBluePrintUpdateAnimation
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::OnBluePrintUpdateAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnBluePrintUpdateAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnMontageBlendingOut
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnMontageBlendingOut(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnMontageBlendingOut");

	Params::AT_CharacterBase_OnMontageBlendingOut Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnMontageEnded
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnMontageEnded(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnMontageEnded");

	Params::AT_CharacterBase_OnMontageEnded Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnMontageStarted
// (Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnMontageStarted(class UAnimMontage* PMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnMontageStarted");

	Params::AT_CharacterBase_OnMontageStarted Parms{};

	Parms.PMontage = PMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnPostChangeAnimationBlueprint
// (Final, Native, Public)
// Parameters:
// class UClass*                           InClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMesh                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnPostChangeAnimationBlueprint(const class UClass* InClass, const class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnPostChangeAnimationBlueprint");

	Params::AT_CharacterBase_OnPostChangeAnimationBlueprint Parms{};

	Parms.InClass = InClass;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.OnPreChangeAnimationBlueprint
// (Final, Native, Public)
// Parameters:
// class UClass*                           InClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMesh                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::OnPreChangeAnimationBlueprint(const class UClass* InClass, const class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "OnPreChangeAnimationBlueprint");

	Params::AT_CharacterBase_OnPreChangeAnimationBlueprint Parms{};

	Parms.InClass = InClass;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.ResetLookAtTargetLocation
// (Final, Native, Public, BlueprintCallable)

void AAT_CharacterBase::ResetLookAtTargetLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "ResetLookAtTargetLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.SetEnableLookAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::SetEnableLookAt(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "SetEnableLookAt");

	Params::AT_CharacterBase_SetEnableLookAt Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.SetLookAtTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::SetLookAtTarget(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "SetLookAtTarget");

	Params::AT_CharacterBase_SetLookAtTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.SetLookAtTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_CharacterBase::SetLookAtTargetLocation(const struct FVector& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "SetLookAtTargetLocation");

	Params::AT_CharacterBase_SetLookAtTargetLocation Parms{};

	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CharacterBase.GetLookAtLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AAT_CharacterBase::GetLookAtLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "GetLookAtLocation");

	Params::AT_CharacterBase_GetLookAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CharacterBase.HasFacial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CharacterBase::HasFacial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "HasFacial");

	Params::AT_CharacterBase_HasFacial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CharacterBase.IsBattleStepLoopAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CharacterBase::IsBattleStepLoopAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "IsBattleStepLoopAction");

	Params::AT_CharacterBase_IsBattleStepLoopAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CharacterBase.IsBattleStepStartAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CharacterBase::IsBattleStepStartAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "IsBattleStepStartAction");

	Params::AT_CharacterBase_IsBattleStepStartAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CharacterBase.IsFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CharacterBase::IsFall() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "IsFall");

	Params::AT_CharacterBase_IsFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CharacterBase.IsGetItemAutoPilotLoopAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CharacterBase::IsGetItemAutoPilotLoopAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CharacterBase", "IsGetItemAutoPilotLoopAction");

	Params::AT_CharacterBase_IsGetItemAutoPilotLoopAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.ActiveLeafEffect
// (Final, Native, Public)
// Parameters:
// class UParticleSystem*                  LeafEffect                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::ActiveLeafEffect(class UParticleSystem* LeafEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "ActiveLeafEffect");

	Params::AT_Character_ActiveLeafEffect Parms{};

	Parms.LeafEffect = LeafEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.DeActiveLeafEffect
// (Final, Native, Public)

void AAT_Character::DeActiveLeafEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "DeActiveLeafEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.IsWalkAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_Character::IsWalkAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "IsWalkAction");

	Params::AT_Character_IsWalkAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.OnAbsorbApplied
// (Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAT_Character::OnAbsorbApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnAbsorbApplied");

	Params::AT_Character_OnAbsorbApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnActorRide
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAT_Character::OnActorRide(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnActorRide");

	Params::AT_Character_OnActorRide Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnCookingTiming
// (Final, Native, Private)
// Parameters:
// EEventTimingType                        TimingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::OnCookingTiming(EEventTimingType TimingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnCookingTiming");

	Params::AT_Character_OnCookingTiming Parms{};

	Parms.TimingType = TimingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnDemoTiming");

	Params::AT_Character_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnLevelUp
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::OnLevelUp(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnLevelUp");

	Params::AT_Character_OnLevelUp Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnRent
// (Native, Event, Public, BlueprintEvent)

void AAT_Character::OnRent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnRent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnReturn
// (Native, Event, Public, BlueprintEvent)

void AAT_Character::OnReturn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnReturn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.OnStartBattleRideEnd
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::OnStartBattleRideEnd(class AAT_Character* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "OnStartBattleRideEnd");

	Params::AT_Character_OnStartBattleRideEnd Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.ResetCharacter
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EATCharacterReset                       InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InDir                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::ResetCharacter(EATCharacterReset InState, const struct FVector& InPos, const struct FVector& InDir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "ResetCharacter");

	Params::AT_Character_ResetCharacter Parms{};

	Parms.InState = InState;
	Parms.InPos = std::move(InPos);
	Parms.InDir = std::move(InDir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.SetActorLocationAndRotationDelayProc
// (Final, Native, Private)

void AAT_Character::SetActorLocationAndRotationDelayProc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "SetActorLocationAndRotationDelayProc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.SetHairMorphingValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     STargetNames                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    bIsMove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRepeat                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Fvalue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FMin                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FMax                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FRate                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_Character::SetHairMorphingValue(const TArray<class FName>& STargetNames, bool bIsMove, bool bRepeat, float Fvalue, float FMin, float FMax, float FRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "SetHairMorphingValue");

	Params::AT_Character_SetHairMorphingValue Parms{};

	Parms.STargetNames = std::move(STargetNames);
	Parms.bIsMove = bIsMove;
	Parms.bRepeat = bRepeat;
	Parms.Fvalue = Fvalue;
	Parms.FMin = FMin;
	Parms.FMax = FMax;
	Parms.FRate = FRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_Character.CheckIsApplyBoostCameraShake
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_Character::CheckIsApplyBoostCameraShake() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "CheckIsApplyBoostCameraShake");

	Params::AT_Character_CheckIsApplyBoostCameraShake Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.GetRestrictMoveControl
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UATRestrictMoveControl*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATRestrictMoveControl* AAT_Character::GetRestrictMoveControl() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "GetRestrictMoveControl");

	Params::AT_Character_GetRestrictMoveControl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.GetTargetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AAT_Character::GetTargetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "GetTargetCharacter");

	Params::AT_Character_GetTargetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.GetTargetVector
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AAT_Character::GetTargetVector() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "GetTargetVector");

	Params::AT_Character_GetTargetVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.GetVirtualController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UATVirtualController*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATVirtualController* AAT_Character::GetVirtualController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "GetVirtualController");

	Params::AT_Character_GetVirtualController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_Character.IsTargetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_Character::IsTargetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_Character", "IsTargetCharacter");

	Params::AT_Character_IsTargetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AnimalSpawnerVolumeGround.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimalSpawnerVolumeGround::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalSpawnerVolumeGround", "OnOverlapBegin");

	Params::AnimalSpawnerVolumeGround_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimalSpawnerVolumeGround.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimalSpawnerVolumeGround::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalSpawnerVolumeGround", "OnOverlapEnd");

	Params::AnimalSpawnerVolumeGround_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl001E_S_SKL002.TargetResetting
// (Final, Native, Private)

void UATActCpl001E_S_SKL002::TargetResetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl001E_S_SKL002", "TargetResetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimalSpawnerVolumeSky.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimalSpawnerVolumeSky::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalSpawnerVolumeSky", "OnOverlapBegin");

	Params::AnimalSpawnerVolumeSky_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimalSpawnerVolumeSky.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAnimalSpawnerVolumeSky::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimalSpawnerVolumeSky", "OnOverlapEnd");

	Params::AnimalSpawnerVolumeSky_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayerSpo.OnChangeCostume
// (Final, Native, Public)
// Parameters:
// uint8                                   InVariationID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InFormID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayerSpo::OnChangeCostume(uint8 InVariationID, uint8 InFormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayerSpo", "OnChangeCostume");

	Params::AT_UIBattleHudPlayerSpo_OnChangeCostume Parms{};

	Parms.InVariationID = InVariationID;
	Parms.InFormID = InFormID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayerSpo.OnChangePlayerBegin
// (Final, Native, Public)

void UAT_UIBattleHudPlayerSpo::OnChangePlayerBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayerSpo", "OnChangePlayerBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayerSpo.OnFormChange
// (Final, Native, Public)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InVariationID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InFormID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayerSpo::OnFormChange(bool IsOn, uint8 InVariationID, uint8 InFormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayerSpo", "OnFormChange");

	Params::AT_UIBattleHudPlayerSpo_OnFormChange Parms{};

	Parms.IsOn = IsOn;
	Parms.InVariationID = InVariationID;
	Parms.InFormID = InFormID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayerSpo.OnSkillBegin
// (Final, Native, Public)
// Parameters:
// class USkill*                           Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayerSpo::OnSkillBegin(class USkill* Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayerSpo", "OnSkillBegin");

	Params::AT_UIBattleHudPlayerSpo_OnSkillBegin Parms{};

	Parms.Skill = Skill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayerSpo.OnUpdateSkill
// (Final, Native, Public)

void UAT_UIBattleHudPlayerSpo::OnUpdateSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayerSpo", "OnUpdateSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl034SkillPunishmentStorm.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActCpl034SkillPunishmentStorm::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl034SkillPunishmentStorm", "OnSpawnProjectile");

	Params::ATActCpl034SkillPunishmentStorm_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleMsgBreak_Lang.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIBattleMsgBreak_Lang::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleMsgBreak_Lang", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_BlueprintFunctionLibrary.AddSparkingSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         InCharacterType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSkillID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::AddSparkingSkill(ECHARACTER_TYPE InCharacterType, class FName InSkillID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "AddSparkingSkill");

	Params::AT_BlueprintFunctionLibrary_AddSparkingSkill Parms{};

	Parms.InCharacterType = InCharacterType;
	Parms.InSkillID = InSkillID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.BannedAndRipoffSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::BannedAndRipoffSkill(ECHARACTER_TYPE CharacterType, class FName SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "BannedAndRipoffSkill");

	Params::AT_BlueprintFunctionLibrary_BannedAndRipoffSkill Parms{};

	Parms.CharacterType = CharacterType;
	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Call_BattleHud_HideSpValueAppearance
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Call_BattleHud_HideSpValueAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Call_BattleHud_HideSpValueAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Call_BattleHud_HudBreakAppearance
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Call_BattleHud_HudBreakAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Call_BattleHud_HudBreakAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Call_BattleHud_ResetHudAppearance
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Call_BattleHud_ResetHudAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Call_BattleHud_ResetHudAppearance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Call_BattleHUD_SpGaugeBreakAnimation
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Call_BattleHUD_SpGaugeBreakAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Call_BattleHUD_SpGaugeBreakAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Call_BattleHUD_SpGaugeSuperchargeAnimation
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Call_BattleHUD_SpGaugeSuperchargeAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Call_BattleHUD_SpGaugeSuperchargeAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Call_BattleHUD_SpGaugeSuperchargeAttackAnimation
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Call_BattleHUD_SpGaugeSuperchargeAttackAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Call_BattleHUD_SpGaugeSuperchargeAttackAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallBossBattleResult
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::CallBossBattleResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallBossBattleResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallFavorRateUp_CONTROL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_BlueprintFunctionLibrary::CallFavorRateUp_CONTROL(int32 Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallFavorRateUp_CONTROL");

	Params::AT_BlueprintFunctionLibrary_CallFavorRateUp_CONTROL Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.CallFavorRateUp_IN
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::CallFavorRateUp_IN(int32 Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallFavorRateUp_IN");

	Params::AT_BlueprintFunctionLibrary_CallFavorRateUp_IN Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallMainQuestBegin_IN
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::CallMainQuestBegin_IN()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallMainQuestBegin_IN");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallMainQuestBegin_OUT
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::CallMainQuestBegin_OUT()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallMainQuestBegin_OUT");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallMainQuestEnd_CONTROL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::CallMainQuestEnd_CONTROL(int32 Input, float Delta)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallMainQuestEnd_CONTROL");

	Params::AT_BlueprintFunctionLibrary_CallMainQuestEnd_CONTROL Parms{};

	Parms.Input = Input;
	Parms.Delta = Delta;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallMainQuestEnd_IN
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ChapterNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EpisodeNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::CallMainQuestEnd_IN(int32 ChapterNum, int32 EpisodeNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallMainQuestEnd_IN");

	Params::AT_BlueprintFunctionLibrary_CallMainQuestEnd_IN Parms{};

	Parms.ChapterNum = ChapterNum;
	Parms.EpisodeNum = EpisodeNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallTutorialTips_CONTROL
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::CallTutorialTips_CONTROL(int32 Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallTutorialTips_CONTROL");

	Params::AT_BlueprintFunctionLibrary_CallTutorialTips_CONTROL Parms{};

	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.CallTutorialTips_IN
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TipsId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnforce                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::CallTutorialTips_IN(class FName TipsId, bool bEnforce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "CallTutorialTips_IN");

	Params::AT_BlueprintFunctionLibrary_CallTutorialTips_IN Parms{};

	Parms.TipsId = TipsId;
	Parms.bEnforce = bEnforce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ClearBannedSkillSetting
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::ClearBannedSkillSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ClearBannedSkillSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.DebugUnlockAllArea
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::DebugUnlockAllArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "DebugUnlockAllArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.EnableDepthOfField
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::EnableDepthOfField(class UObject* WorldContextObject, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "EnableDepthOfField");

	Params::AT_BlueprintFunctionLibrary_EnableDepthOfField Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.EnumToBitFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Enum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_BlueprintFunctionLibrary::EnumToBitFlag(int32 Enum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "EnumToBitFlag");

	Params::AT_BlueprintFunctionLibrary_EnumToBitFlag Parms{};

	Parms.Enum = Enum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.ForceRequestOutDisplayNameUI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::ForceRequestOutDisplayNameUI(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ForceRequestOutDisplayNameUI");

	Params::AT_BlueprintFunctionLibrary_ForceRequestOutDisplayNameUI Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.GetActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAT_BlueprintFunctionLibrary::GetActor(int32 UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetActor");

	Params::AT_BlueprintFunctionLibrary_GetActor Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetActorByClassTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UAT_BlueprintFunctionLibrary::GetActorByClassTag(class UClass* Class_0, class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetActorByClassTag");

	Params::AT_BlueprintFunctionLibrary_GetActorByClassTag Parms{};

	Parms.Class_0 = Class_0;
	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetActorByTag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UAT_BlueprintFunctionLibrary::GetActorByTag(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetActorByTag");

	Params::AT_BlueprintFunctionLibrary_GetActorByTag Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetAIBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAIBase*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAIBase* UAT_BlueprintFunctionLibrary::GetAIBase(class APawn* InPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetAIBase");

	Params::AT_BlueprintFunctionLibrary_GetAIBase Parms{};

	Parms.InPawn = InPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetAIManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAIManager*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAIManager* UAT_BlueprintFunctionLibrary::GetAIManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetAIManager");

	Params::AT_BlueprintFunctionLibrary_GetAIManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetATCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UAT_BlueprintFunctionLibrary::GetATCharacter(int32 UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetATCharacter");

	Params::AT_BlueprintFunctionLibrary_GetATCharacter Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetATCharacterByType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UAT_BlueprintFunctionLibrary::GetATCharacterByType(ECHARACTER_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetATCharacterByType");

	Params::AT_BlueprintFunctionLibrary_GetATCharacterByType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetAtmosphericFogs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AAtmosphericFog*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AAtmosphericFog*> UAT_BlueprintFunctionLibrary::GetAtmosphericFogs(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetAtmosphericFogs");

	Params::AT_BlueprintFunctionLibrary_GetAtmosphericFogs Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetATVersion
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAT_BlueprintFunctionLibrary::GetATVersion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetATVersion");

	Params::AT_BlueprintFunctionLibrary_GetATVersion Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetBaseballGameManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UBaseballGameManager*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseballGameManager* UAT_BlueprintFunctionLibrary::GetBaseballGameManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetBaseballGameManager");

	Params::AT_BlueprintFunctionLibrary_GetBaseballGameManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetBuildConfiguration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAT_BlueprintFunctionLibrary::GetBuildConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetBuildConfiguration");

	Params::AT_BlueprintFunctionLibrary_GetBuildConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetCaptureManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UATUiCaptureManager*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATUiCaptureManager* UAT_BlueprintFunctionLibrary::GetCaptureManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetCaptureManager");

	Params::AT_BlueprintFunctionLibrary_GetCaptureManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetCharacterName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAT_BlueprintFunctionLibrary::GetCharacterName(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetCharacterName");

	Params::AT_BlueprintFunctionLibrary_GetCharacterName Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetDebugMenu
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDebugMenu*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDebugMenu* UAT_BlueprintFunctionLibrary::GetDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetDebugMenu");

	Params::AT_BlueprintFunctionLibrary_GetDebugMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetDefaultGameHud
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAT_GameHUD*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_GameHUD* UAT_BlueprintFunctionLibrary::GetDefaultGameHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetDefaultGameHud");

	Params::AT_BlueprintFunctionLibrary_GetDefaultGameHud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetDemoManageComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UATDemoManageComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATDemoManageComponent* UAT_BlueprintFunctionLibrary::GetDemoManageComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetDemoManageComponent");

	Params::AT_BlueprintFunctionLibrary_GetDemoManageComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetDragonBallManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UDragonBallManager*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDragonBallManager* UAT_BlueprintFunctionLibrary::GetDragonBallManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetDragonBallManager");

	Params::AT_BlueprintFunctionLibrary_GetDragonBallManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetHeightFogs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AExponentialHeightFog*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AExponentialHeightFog*> UAT_BlueprintFunctionLibrary::GetHeightFogs(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetHeightFogs");

	Params::AT_BlueprintFunctionLibrary_GetHeightFogs Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetQuestManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UQuestManager*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UQuestManager* UAT_BlueprintFunctionLibrary::GetQuestManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetQuestManager");

	Params::AT_BlueprintFunctionLibrary_GetQuestManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetRaceGameManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URaceGameManager*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URaceGameManager* UAT_BlueprintFunctionLibrary::GetRaceGameManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetRaceGameManager");

	Params::AT_BlueprintFunctionLibrary_GetRaceGameManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetRideManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class URideManager*                     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class URideManager* UAT_BlueprintFunctionLibrary::GetRideManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetRideManager");

	Params::AT_BlueprintFunctionLibrary_GetRideManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetSkyConditionManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class USkyConditionManager*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkyConditionManager* UAT_BlueprintFunctionLibrary::GetSkyConditionManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetSkyConditionManager");

	Params::AT_BlueprintFunctionLibrary_GetSkyConditionManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetSkyLights
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TagName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ASkyLight*>                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASkyLight*> UAT_BlueprintFunctionLibrary::GetSkyLights(class FName TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetSkyLights");

	Params::AT_BlueprintFunctionLibrary_GetSkyLights Parms{};

	Parms.TagName = TagName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.GetToClearFlagSuperTraining
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESuperTrainingType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrainingID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_BlueprintFunctionLibrary::GetToClearFlagSuperTraining(ESuperTrainingType Type, int32 TrainingID, ECHARACTER_TYPE Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "GetToClearFlagSuperTraining");

	Params::AT_BlueprintFunctionLibrary_GetToClearFlagSuperTraining Parms{};

	Parms.Type = Type;
	Parms.TrainingID = TrainingID;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.HasSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_BlueprintFunctionLibrary::HasSkill(ECHARACTER_TYPE CharacterType, class FName SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "HasSkill");

	Params::AT_BlueprintFunctionLibrary_HasSkill Parms{};

	Parms.CharacterType = CharacterType;
	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.HideAllChangesToSpGauge
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::HideAllChangesToSpGauge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "HideAllChangesToSpGauge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.HideKeyGuideUntilQuestCaption
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::HideKeyGuideUntilQuestCaption()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "HideKeyGuideUntilQuestCaption");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.isFlagOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Source                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Enum                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_BlueprintFunctionLibrary::IsFlagOn(const int32 Source, int32 Enum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "isFlagOn");

	Params::AT_BlueprintFunctionLibrary_IsFlagOn Parms{};

	Parms.Source = Source;
	Parms.Enum = Enum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.IsGameModeStateField
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_BlueprintFunctionLibrary::IsGameModeStateField()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "IsGameModeStateField");

	Params::AT_BlueprintFunctionLibrary_IsGameModeStateField Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.LaunchSuperTrainingMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  OwnerComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::LaunchSuperTrainingMenu(class UActorComponent* OwnerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "LaunchSuperTrainingMenu");

	Params::AT_BlueprintFunctionLibrary_LaunchSuperTrainingMenu Parms{};

	Parms.OwnerComponent = OwnerComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.LaunchSuperTrainingMenuFindlistID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FindlistID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::LaunchSuperTrainingMenuFindlistID(const class FString& FindlistID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "LaunchSuperTrainingMenuFindlistID");

	Params::AT_BlueprintFunctionLibrary_LaunchSuperTrainingMenuFindlistID Parms{};

	Parms.FindlistID = std::move(FindlistID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.LockCooking
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::LockCooking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "LockCooking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.MiniMapRadarDeleteUIAnimmation
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::MiniMapRadarDeleteUIAnimmation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "MiniMapRadarDeleteUIAnimmation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ModifyBattleHudAppearance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPlayerBattleHUDAppearance              InApperance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::ModifyBattleHudAppearance(EPlayerBattleHUDAppearance InApperance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ModifyBattleHudAppearance");

	Params::AT_BlueprintFunctionLibrary_ModifyBattleHudAppearance Parms{};

	Parms.InApperance = InApperance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ModifySpGaugeAppearance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESpGaugeOverlayAppearance               InApperance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::ModifySpGaugeAppearance(ESpGaugeOverlayAppearance InApperance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ModifySpGaugeAppearance");

	Params::AT_BlueprintFunctionLibrary_ModifySpGaugeAppearance Parms{};

	Parms.InApperance = InApperance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OpenCommunityMenuByTutorialMode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             UniqueId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OpenCommunityMenuByTutorialMode(const class FName& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OpenCommunityMenuByTutorialMode");

	Params::AT_BlueprintFunctionLibrary_OpenCommunityMenuByTutorialMode Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OpenCookingMenuChichi
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  OwnerComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OpenCookingMenuChichi(class UActorComponent* OwnerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OpenCookingMenuChichi");

	Params::AT_BlueprintFunctionLibrary_OpenCookingMenuChichi Parms{};

	Parms.OwnerComponent = OwnerComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OpenCookingMenuChichiActorName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OpenCookingMenuChichiActorName(const class FString& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OpenCookingMenuChichiActorName");

	Params::AT_BlueprintFunctionLibrary_OpenCookingMenuChichiActorName Parms{};

	Parms.ActorName = std::move(ActorName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OpenItemMenuByTutorialMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQuestTutorialType                      TutorialType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OpenItemMenuByTutorialMode(EQuestTutorialType TutorialType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OpenItemMenuByTutorialMode");

	Params::AT_BlueprintFunctionLibrary_OpenItemMenuByTutorialMode Parms{};

	Parms.TutorialType = TutorialType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OpenZCollectionBreakthroughTraining
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             EventBattleID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OpenZCollectionBreakthroughTraining(class FName EventBattleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OpenZCollectionBreakthroughTraining");

	Params::AT_BlueprintFunctionLibrary_OpenZCollectionBreakthroughTraining Parms{};

	Parms.EventBattleID = EventBattleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OpenZCollectionChallengeToGodOfDestruction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             EventBattleID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OpenZCollectionChallengeToGodOfDestruction(class FName EventBattleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OpenZCollectionChallengeToGodOfDestruction");

	Params::AT_BlueprintFunctionLibrary_OpenZCollectionChallengeToGodOfDestruction Parms{};

	Parms.EventBattleID = EventBattleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.OverrideSpGaugeValueDisplay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInMakeVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::OverrideSpGaugeValueDisplay(int32 InValue, bool bInMakeVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "OverrideSpGaugeValueDisplay");

	Params::AT_BlueprintFunctionLibrary_OverrideSpGaugeValueDisplay Parms{};

	Parms.InValue = InValue;
	Parms.bInMakeVisible = bInMakeVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.PauseAllParticle
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::PauseAllParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "PauseAllParticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.PauseMainQuestTitleAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLatentActionInfo                LatentInfo                                             (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::PauseMainQuestTitleAnim(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "PauseMainQuestTitleAnim");

	Params::AT_BlueprintFunctionLibrary_PauseMainQuestTitleAnim Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LatentInfo = std::move(LatentInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.PauseMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::PauseMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "PauseMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.PermissionSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             SkillId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::PermissionSkill(class FName SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "PermissionSkill");

	Params::AT_BlueprintFunctionLibrary_PermissionSkill Parms{};

	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.PhaseID2QuestID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InPhaseID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAT_BlueprintFunctionLibrary::PhaseID2QuestID(class FName InPhaseID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "PhaseID2QuestID");

	Params::AT_BlueprintFunctionLibrary_PhaseID2QuestID Parms{};

	Parms.InPhaseID = InPhaseID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.PlayBgm
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::PlayBgm(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "PlayBgm");

	Params::AT_BlueprintFunctionLibrary_PlayBgm Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Progress_DebugSet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Phase_no                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::Progress_DebugSet(class FName Name_0, int32 Phase_no)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Progress_DebugSet");

	Params::AT_BlueprintFunctionLibrary_Progress_DebugSet Parms{};

	Parms.Name_0 = Name_0;
	Parms.Phase_no = Phase_no;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Progress_GetName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAT_BlueprintFunctionLibrary::Progress_GetName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Progress_GetName");

	Params::AT_BlueprintFunctionLibrary_Progress_GetName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.Progress_Next
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::Progress_Next()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Progress_Next");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.Progress_Set
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Phase_no                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::Progress_Set(class FName Name_0, int32 Phase_no)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "Progress_Set");

	Params::AT_BlueprintFunctionLibrary_Progress_Set Parms{};

	Parms.Name_0 = Name_0;
	Parms.Phase_no = Phase_no;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ReleaseCooking
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::ReleaseCooking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ReleaseCooking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ReleasedCpl071
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_BlueprintFunctionLibrary::ReleasedCpl071()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ReleasedCpl071");

	Params::AT_BlueprintFunctionLibrary_ReleasedCpl071 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.ReplaceFloatMacro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TxtId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           RepplaceFloatCtn                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAT_BlueprintFunctionLibrary::ReplaceFloatMacro(const class FString& TxtId, const TArray<float>& RepplaceFloatCtn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ReplaceFloatMacro");

	Params::AT_BlueprintFunctionLibrary_ReplaceFloatMacro Parms{};

	Parms.TxtId = std::move(TxtId);
	Parms.RepplaceFloatCtn = std::move(RepplaceFloatCtn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.ReplaceIntegerMacro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TxtId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReplaceIntCtn                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAT_BlueprintFunctionLibrary::ReplaceIntegerMacro(const class FString& TxtId, const TArray<int32>& ReplaceIntCtn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ReplaceIntegerMacro");

	Params::AT_BlueprintFunctionLibrary_ReplaceIntegerMacro Parms{};

	Parms.TxtId = std::move(TxtId);
	Parms.ReplaceIntCtn = std::move(ReplaceIntCtn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.ReplaceTxtMacro
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TxtId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReplaceTxtIdCtn                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAT_BlueprintFunctionLibrary::ReplaceTxtMacro(const class FString& TxtId, const TArray<class FString>& ReplaceTxtIdCtn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ReplaceTxtMacro");

	Params::AT_BlueprintFunctionLibrary_ReplaceTxtMacro Parms{};

	Parms.TxtId = std::move(TxtId);
	Parms.ReplaceTxtIdCtn = std::move(ReplaceTxtIdCtn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestBattleDemoDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::RequestBattleDemoDamage(float InRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestBattleDemoDamage");

	Params::AT_BlueprintFunctionLibrary_RequestBattleDemoDamage Parms{};

	Parms.InRate = InRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestBattleDemoResult
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::RequestBattleDemoResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestBattleDemoResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestCtrlWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InbCtrlWindow                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::RequestCtrlWindow(bool InbCtrlWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestCtrlWindow");

	Params::AT_BlueprintFunctionLibrary_RequestCtrlWindow Parms{};

	Parms.InbCtrlWindow = InbCtrlWindow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestImportantLogSkillUnlockCheck
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::RequestImportantLogSkillUnlockCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestImportantLogSkillUnlockCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestInDisplayNameUI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             NameMsg                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        DispPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_BlueprintFunctionLibrary::RequestInDisplayNameUI(const class FName& NameMsg, const struct FVector2D& DispPos, float DisplayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestInDisplayNameUI");

	Params::AT_BlueprintFunctionLibrary_RequestInDisplayNameUI Parms{};

	Parms.NameMsg = NameMsg;
	Parms.DispPos = std::move(DispPos);
	Parms.DisplayTime = DisplayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestInDisplayPopularNameUI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             NameMsg                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PopularNameMsg                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        DispPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DisplayTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsLargeSize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_BlueprintFunctionLibrary::RequestInDisplayPopularNameUI(const class FName& NameMsg, const class FName& PopularNameMsg, const struct FVector2D& DispPos, float DisplayTime, bool IsLargeSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestInDisplayPopularNameUI");

	Params::AT_BlueprintFunctionLibrary_RequestInDisplayPopularNameUI Parms{};

	Parms.NameMsg = NameMsg;
	Parms.PopularNameMsg = PopularNameMsg;
	Parms.DispPos = std::move(DispPos);
	Parms.DisplayTime = DisplayTime;
	Parms.IsLargeSize = IsLargeSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestLoadUiCaptureByCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   VariationId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   FormID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::RequestLoadUiCaptureByCharacter(ECHARACTER_TYPE CharacterType, uint8 VariationId, uint8 FormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestLoadUiCaptureByCharacter");

	Params::AT_BlueprintFunctionLibrary_RequestLoadUiCaptureByCharacter Parms{};

	Parms.CharacterType = CharacterType;
	Parms.VariationId = VariationId;
	Parms.FormID = FormID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestLoadUiCaptureById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MasterId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::RequestLoadUiCaptureById(class FName MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestLoadUiCaptureById");

	Params::AT_BlueprintFunctionLibrary_RequestLoadUiCaptureById Parms{};

	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestRushInputQte
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::RequestRushInputQte()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestRushInputQte");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.RequestRushInputQteDemoDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::RequestRushInputQteDemoDamage(float InRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "RequestRushInputQteDemoDamage");

	Params::AT_BlueprintFunctionLibrary_RequestRushInputQteDemoDamage Parms{};

	Parms.InRate = InRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ResumeAllParticle
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::ResumeAllParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ResumeAllParticle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.SetFieldRideSelectBlock
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bBlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::SetFieldRideSelectBlock(bool bBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "SetFieldRideSelectBlock");

	Params::AT_BlueprintFunctionLibrary_SetFieldRideSelectBlock Parms{};

	Parms.bBlock = bBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.SetKeyGuideCtrlMode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EKeyGuideCtrlMode                       InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::SetKeyGuideCtrlMode(EKeyGuideCtrlMode InMode, bool bAutoIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "SetKeyGuideCtrlMode");

	Params::AT_BlueprintFunctionLibrary_SetKeyGuideCtrlMode Parms{};

	Parms.InMode = InMode;
	Parms.bAutoIn = bAutoIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.SetKeyGuideTutorialSetting
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::SetKeyGuideTutorialSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "SetKeyGuideTutorialSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.SetKeyGuideType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EKeyGuideType                           InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::SetKeyGuideType(EKeyGuideType InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "SetKeyGuideType");

	Params::AT_BlueprintFunctionLibrary_SetKeyGuideType Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.SetScreenResolution
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWindowMode                             WindowMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::SetScreenResolution(int32 Width, int32 Height, EWindowMode WindowMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "SetScreenResolution");

	Params::AT_BlueprintFunctionLibrary_SetScreenResolution Parms{};

	Parms.Width = Width;
	Parms.Height = Height;
	Parms.WindowMode = WindowMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.SetToClearFlagSuperTraining
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ESuperTrainingType                      Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrainingID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::SetToClearFlagSuperTraining(ESuperTrainingType Type, int32 TrainingID, ECHARACTER_TYPE Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "SetToClearFlagSuperTraining");

	Params::AT_BlueprintFunctionLibrary_SetToClearFlagSuperTraining Parms{};

	Parms.Type = Type;
	Parms.TrainingID = TrainingID;
	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ShutDownSuperTrainingMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UActorComponent*                  OwnerComponent                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::ShutDownSuperTrainingMenu(class UActorComponent* OwnerComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ShutDownSuperTrainingMenu");

	Params::AT_BlueprintFunctionLibrary_ShutDownSuperTrainingMenu Parms{};

	Parms.OwnerComponent = OwnerComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.ShutDownSuperTrainingMenuFindlistID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FindlistID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::ShutDownSuperTrainingMenuFindlistID(const class FString& FindlistID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "ShutDownSuperTrainingMenuFindlistID");

	Params::AT_BlueprintFunctionLibrary_ShutDownSuperTrainingMenuFindlistID Parms{};

	Parms.FindlistID = std::move(FindlistID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.StartQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FUIQuestInfo                     InQuestInfo                                            (Parm, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::StartQuest(const struct FUIQuestInfo& InQuestInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "StartQuest");

	Params::AT_BlueprintFunctionLibrary_StartQuest Parms{};

	Parms.InQuestInfo = std::move(InQuestInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.StartTickQuestNavigation
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::StartTickQuestNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "StartTickQuestNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.StartTrialClearMenu
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::StartTrialClearMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "StartTrialClearMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.StopBgm
// (Final, Native, Static, Public, BlueprintCallable)

void UAT_BlueprintFunctionLibrary::StopBgm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "StopBgm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.UnloadUiCaptureByCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   VariationId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   FormID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::UnloadUiCaptureByCharacter(ECHARACTER_TYPE CharacterType, uint8 VariationId, uint8 FormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "UnloadUiCaptureByCharacter");

	Params::AT_BlueprintFunctionLibrary_UnloadUiCaptureByCharacter Parms{};

	Parms.CharacterType = CharacterType;
	Parms.VariationId = VariationId;
	Parms.FormID = FormID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_BlueprintFunctionLibrary.UnloadUiCaptureById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MasterId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_BlueprintFunctionLibrary::UnloadUiCaptureById(class FName MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_BlueprintFunctionLibrary", "UnloadUiCaptureById");

	Params::AT_BlueprintFunctionLibrary_UnloadUiCaptureById Parms{};

	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureOptional.CompleteLoad
// (Final, Native, Public)
// Parameters:
// class UATDataAssetUiCaptureAsyncLoad*   Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureOptional::CompleteLoad(class UATDataAssetUiCaptureAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureOptional", "CompleteLoad");

	Params::AT_UI3DCaptureOptional_CompleteLoad Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UpperFacialAnimation.SetEnableUpperFaceAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IUpperFacialAnimation::SetEnableUpperFaceAnimation(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpperFacialAnimation", "SetEnableUpperFaceAnimation");

	Params::UpperFacialAnimation_SetEnableUpperFaceAnimation Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UpperFacialAnimation.IsEnableUpperFaceAnimation
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IUpperFacialAnimation::IsEnableUpperFaceAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UpperFacialAnimation", "IsEnableUpperFaceAnimation");

	Params::UpperFacialAnimation_IsEnableUpperFaceAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AreaBoundsVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAreaBoundsVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaBoundsVolume", "OnOverlapBegin");

	Params::AreaBoundsVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AreaBoundsVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAreaBoundsVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AreaBoundsVolume", "OnOverlapEnd");

	Params::AreaBoundsVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActor.OnBattleEnd
// (Final, Native, Public)

void ATriggerStaticActor::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActor", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActor.OnBattleStart
// (Final, Native, Public)

void ATriggerStaticActor::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActor", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActor.OnTouchSphereCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerStaticActor::OnTouchSphereCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActor", "OnTouchSphereCollision");

	Params::TriggerStaticActor_OnTouchSphereCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActor.OnUntouchSphereCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerStaticActor::OnUntouchSphereCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActor", "OnUntouchSphereCollision");

	Params::TriggerStaticActor_OnUntouchSphereCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActor.IsBattleEndCallable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATriggerStaticActor::IsBattleEndCallable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActor", "IsBattleEndCallable");

	Params::TriggerStaticActor_IsBattleEndCallable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_BaseHUD.CanvasSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D AAT_BaseHUD::CanvasSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_BaseHUD", "CanvasSize");

	Params::AT_BaseHUD_CanvasSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AnimNotify_SpawnEnemyAttackSign.OnFinishedSignEffectST
// (Final, Native, Private, Const)
// Parameters:
// class UParticleSystemComponent*         InParticle                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimNotify_SpawnEnemyAttackSign::OnFinishedSignEffectST(class UParticleSystemComponent* InParticle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotify_SpawnEnemyAttackSign", "OnFinishedSignEffectST");

	Params::AnimNotify_SpawnEnemyAttackSign_OnFinishedSignEffectST Parms{};

	Parms.InParticle = InParticle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDataAssetAsyncLoad.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATDataAssetAsyncLoad::IsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDataAssetAsyncLoad", "IsLoaded");

	Params::ATDataAssetAsyncLoad_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIBattle_Hud_ZOverthrow.StartZOverthrow
// (Final, Native, Public)

void UAT_UIBattle_Hud_ZOverthrow::StartZOverthrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattle_Hud_ZOverthrow", "StartZOverthrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl036BSkill004.Cpl036BSkill004ResetCamera
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActCpl036BSkill004::Cpl036BSkill004ResetCamera(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl036BSkill004", "Cpl036BSkill004ResetCamera");

	Params::ATActCpl036BSkill004_Cpl036BSkill004ResetCamera Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddDeactivateCharacterInEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CharacterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddDeactivateCharacterInEvent(class FName CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddDeactivateCharacterInEvent");

	Params::EventBlueprintFunctionLibrary_AddDeactivateCharacterInEvent Parms{};

	Parms.CharacterName = CharacterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddDestination
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDESTINATION_TYPE                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddDestination(class AActor* Actor, EDESTINATION_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddDestination");

	Params::EventBlueprintFunctionLibrary_AddDestination Parms{};

	Parms.Actor = Actor;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddItem
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddItem(class FName ItemId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddItem");

	Params::EventBlueprintFunctionLibrary_AddItem Parms{};

	Parms.ItemId = ItemId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddItemsToInventory
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddItemsToInventory(const class FName& ItemId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddItemsToInventory");

	Params::EventBlueprintFunctionLibrary_AddItemsToInventory Parms{};

	Parms.ItemId = ItemId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddQuestCompletedCount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddQuestCompletedCount(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddQuestCompletedCount");

	Params::EventBlueprintFunctionLibrary_AddQuestCompletedCount Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddSpeakerMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SpeakerID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddSpeakerMap(const class FString& SpeakerID, const class FString& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddSpeakerMap");

	Params::EventBlueprintFunctionLibrary_AddSpeakerMap Parms{};

	Parms.SpeakerID = std::move(SpeakerID);
	Parms.ActorName = std::move(ActorName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddSpeakerMapActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SpeakerID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddSpeakerMapActor(const class FString& SpeakerID, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddSpeakerMapActor");

	Params::EventBlueprintFunctionLibrary_AddSpeakerMapActor Parms{};

	Parms.SpeakerID = std::move(SpeakerID);
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AddSpeakerMapPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SpeakerID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AddSpeakerMapPlayer(const class FString& SpeakerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AddSpeakerMapPlayer");

	Params::EventBlueprintFunctionLibrary_AddSpeakerMapPlayer Parms{};

	Parms.SpeakerID = std::move(SpeakerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AndroidAssaultAreaActivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TakeOver                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AndroidAssaultAreaActivate(class FName AreaName, bool TakeOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AndroidAssaultAreaActivate");

	Params::EventBlueprintFunctionLibrary_AndroidAssaultAreaActivate Parms{};

	Parms.AreaName = AreaName;
	Parms.TakeOver = TakeOver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AndroidAssaultAreaActivateGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AreaGroup                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TakeOver                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AndroidAssaultAreaActivateGroup(class FName AreaGroup, bool TakeOver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AndroidAssaultAreaActivateGroup");

	Params::EventBlueprintFunctionLibrary_AndroidAssaultAreaActivateGroup Parms{};

	Parms.AreaGroup = AreaGroup;
	Parms.TakeOver = TakeOver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AndroidAssaultAreaDeactivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AndroidAssaultAreaDeactivate(class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AndroidAssaultAreaDeactivate");

	Params::EventBlueprintFunctionLibrary_AndroidAssaultAreaDeactivate Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AndroidAssaultAreaDeactivateAll
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::AndroidAssaultAreaDeactivateAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AndroidAssaultAreaDeactivateAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AndroidAssaultAreaDeactivateGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AreaGroup                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AndroidAssaultAreaDeactivateGroup(class FName AreaGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AndroidAssaultAreaDeactivateGroup");

	Params::EventBlueprintFunctionLibrary_AndroidAssaultAreaDeactivateGroup Parms{};

	Parms.AreaGroup = AreaGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AreaChangeTrainingEnd
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::AreaChangeTrainingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AreaChangeTrainingEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AreaChangeTrainingRetire
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bFadeOut                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AreaChangeTrainingRetire(bool bFadeOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AreaChangeTrainingRetire");

	Params::EventBlueprintFunctionLibrary_AreaChangeTrainingRetire Parms{};

	Parms.bFadeOut = bFadeOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.AutoMoveToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           AutoMoveCamera                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InGoalRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCharStateChange                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATCharacterAutoMoveBP                  CharChangeState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bGetOffVehicle                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::AutoMoveToActor(class AActor* Target, class AActor* AutoMoveCamera, float InGoalRadius, bool bCharStateChange, EATCharacterAutoMoveBP CharChangeState, bool bGetOffVehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "AutoMoveToActor");

	Params::EventBlueprintFunctionLibrary_AutoMoveToActor Parms{};

	Parms.Target = Target;
	Parms.AutoMoveCamera = AutoMoveCamera;
	Parms.InGoalRadius = InGoalRadius;
	Parms.bCharStateChange = bCharStateChange;
	Parms.CharChangeState = CharChangeState;
	Parms.bGetOffVehicle = bGetOffVehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.BackTalkTimes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::BackTalkTimes(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "BackTalkTimes");

	Params::EventBlueprintFunctionLibrary_BackTalkTimes Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.BreakQuest
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::BreakQuest(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "BreakQuest");

	Params::EventBlueprintFunctionLibrary_BreakQuest Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.CanAndroidAssaultAreaReactivate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CountName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::CanAndroidAssaultAreaReactivate(class FName CountName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CanAndroidAssaultAreaReactivate");

	Params::EventBlueprintFunctionLibrary_CanAndroidAssaultAreaReactivate Parms{};

	Parms.CountName = CountName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CancelCrossTalk
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     CrossTalkIds                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::CancelCrossTalk(const TArray<class FName>& CrossTalkIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CancelCrossTalk");

	Params::EventBlueprintFunctionLibrary_CancelCrossTalk Parms{};

	Parms.CrossTalkIds = std::move(CrossTalkIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeActorEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeActorEnable(class AActor* TargetActor, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeActorEnable");

	Params::EventBlueprintFunctionLibrary_ChangeActorEnable Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeCharacterParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeCharacterParts(class AAT_Character* Character, uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeCharacterParts");

	Params::EventBlueprintFunctionLibrary_ChangeCharacterParts Parms{};

	Parms.Character = Character;
	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeDragonBallState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bUsedState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeDragonBallState(bool bUsedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeDragonBallState");

	Params::EventBlueprintFunctionLibrary_ChangeDragonBallState Parms{};

	Parms.bUsedState = bUsedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeFieldCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EQuestFieldConditionType                Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeFieldCondition(EQuestFieldConditionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeFieldCondition");

	Params::EventBlueprintFunctionLibrary_ChangeFieldCondition Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeFriendAIStop
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    WaitActionFlg                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeFriendAIStop(bool Flg, bool WaitActionFlg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeFriendAIStop");

	Params::EventBlueprintFunctionLibrary_ChangeFriendAIStop Parms{};

	Parms.Flg = Flg;
	Parms.WaitActionFlg = WaitActionFlg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeMobCharacterEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_MobBase*                      TargetMob                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeMobCharacterEnable(class AAT_MobBase* TargetMob, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeMobCharacterEnable");

	Params::EventBlueprintFunctionLibrary_ChangeMobCharacterEnable Parms{};

	Parms.TargetMob = TargetMob;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeMobTalkID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Talk_id                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeMobTalkID(class FName Actor_name, const class FString& Talk_id, bool bForceReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeMobTalkID");

	Params::EventBlueprintFunctionLibrary_ChangeMobTalkID Parms{};

	Parms.Actor_name = Actor_name;
	Parms.Talk_id = std::move(Talk_id);
	Parms.bForceReset = bForceReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeNpcTalkIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeNpcTalkIcon(const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeNpcTalkIcon");

	Params::EventBlueprintFunctionLibrary_ChangeNpcTalkIcon Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeNpcTalkID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TalkID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeNpcTalkID(class AActor* TargetActor, const class FName& TalkID, bool bForceReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeNpcTalkID");

	Params::EventBlueprintFunctionLibrary_ChangeNpcTalkID Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TalkID = TalkID;
	Parms.bForceReset = bForceReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangePlayerParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangePlayerParts(uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangePlayerParts");

	Params::EventBlueprintFunctionLibrary_ChangePlayerParts Parms{};

	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeQuestActorEnable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeQuestActorEnable(class AActor* TargetActor, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeQuestActorEnable");

	Params::EventBlueprintFunctionLibrary_ChangeQuestActorEnable Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeQuestCharacterParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             FindName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeQuestCharacterParts(const class FName& FindName, uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeQuestCharacterParts");

	Params::EventBlueprintFunctionLibrary_ChangeQuestCharacterParts Parms{};

	Parms.FindName = FindName;
	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeSubtitle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InMessageId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeSubtitle(bool bEnable, const class FName& InMessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeSubtitle");

	Params::EventBlueprintFunctionLibrary_ChangeSubtitle Parms{};

	Parms.bEnable = bEnable;
	Parms.InMessageId = InMessageId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ChangeTeamMember
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   TeamNo                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ChangeTeamMember(int32 TeamNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ChangeTeamMember");

	Params::EventBlueprintFunctionLibrary_ChangeTeamMember Parms{};

	Parms.TeamNo = TeamNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.CharacterAddExp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Charatype                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddExp                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::CharacterAddExp(ECHARACTER_TYPE Charatype, int32 AddExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CharacterAddExp");

	Params::EventBlueprintFunctionLibrary_CharacterAddExp Parms{};

	Parms.Charatype = Charatype;
	Parms.AddExp = AddExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.CheckBreakingTrigger
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     InOnTriggerIdList                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                     InOffTriggerIdList                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::CheckBreakingTrigger(const TArray<class FName>& InOnTriggerIdList, const TArray<class FName>& InOffTriggerIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CheckBreakingTrigger");

	Params::EventBlueprintFunctionLibrary_CheckBreakingTrigger Parms{};

	Parms.InOnTriggerIdList = std::move(InOnTriggerIdList);
	Parms.InOffTriggerIdList = std::move(InOffTriggerIdList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CheckBreakingTriggerFromBreakableObj
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AWideUseBreakablePoint*>   InOnBreakableObjects                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AWideUseBreakablePoint*>   InOffBreakableObjects                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::CheckBreakingTriggerFromBreakableObj(const TArray<class AWideUseBreakablePoint*>& InOnBreakableObjects, const TArray<class AWideUseBreakablePoint*>& InOffBreakableObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CheckBreakingTriggerFromBreakableObj");

	Params::EventBlueprintFunctionLibrary_CheckBreakingTriggerFromBreakableObj Parms{};

	Parms.InOnBreakableObjects = std::move(InOnBreakableObjects);
	Parms.InOffBreakableObjects = std::move(InOffBreakableObjects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CheckBreakingTriggerWithReason
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     InOnTriggerIdList                                      (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class FName>                     InOffTriggerIdList                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EBrokenReason                           InBrokenReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::CheckBreakingTriggerWithReason(const TArray<class FName>& InOnTriggerIdList, const TArray<class FName>& InOffTriggerIdList, EBrokenReason InBrokenReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CheckBreakingTriggerWithReason");

	Params::EventBlueprintFunctionLibrary_CheckBreakingTriggerWithReason Parms{};

	Parms.InOnTriggerIdList = std::move(InOnTriggerIdList);
	Parms.InOffTriggerIdList = std::move(InOffTriggerIdList);
	Parms.InBrokenReason = InBrokenReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CheckBreakingTriggerWithReasonFromBreakableObj
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AWideUseBreakablePoint*>   InOnBreakableObjects                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AWideUseBreakablePoint*>   InOffBreakableObjects                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EBrokenReason                           InBrokenReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::CheckBreakingTriggerWithReasonFromBreakableObj(const TArray<class AWideUseBreakablePoint*>& InOnBreakableObjects, const TArray<class AWideUseBreakablePoint*>& InOffBreakableObjects, EBrokenReason InBrokenReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CheckBreakingTriggerWithReasonFromBreakableObj");

	Params::EventBlueprintFunctionLibrary_CheckBreakingTriggerWithReasonFromBreakableObj Parms{};

	Parms.InOnBreakableObjects = std::move(InOnBreakableObjects);
	Parms.InOffBreakableObjects = std::move(InOffBreakableObjects);
	Parms.InBrokenReason = InBrokenReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.ClearHaveDBCharacter
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ClearHaveDBCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ClearHaveDBCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ClearSpeakerActor
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ClearSpeakerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ClearSpeakerActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.CountBreakingTriggerOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     InTriggerIdList                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::CountBreakingTriggerOn(const TArray<class FName>& InTriggerIdList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CountBreakingTriggerOn");

	Params::EventBlueprintFunctionLibrary_CountBreakingTriggerOn Parms{};

	Parms.InTriggerIdList = std::move(InTriggerIdList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CountBreakingTriggerOnFromBreakableObj
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AWideUseBreakablePoint*>   InBreakableObjects                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::CountBreakingTriggerOnFromBreakableObj(const TArray<class AWideUseBreakablePoint*>& InBreakableObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CountBreakingTriggerOnFromBreakableObj");

	Params::EventBlueprintFunctionLibrary_CountBreakingTriggerOnFromBreakableObj Parms{};

	Parms.InBreakableObjects = std::move(InBreakableObjects);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CountBreakingTriggerOnWithReason
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     InTriggerIdList                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EBrokenReason                           InBrokenReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::CountBreakingTriggerOnWithReason(const TArray<class FName>& InTriggerIdList, EBrokenReason InBrokenReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CountBreakingTriggerOnWithReason");

	Params::EventBlueprintFunctionLibrary_CountBreakingTriggerOnWithReason Parms{};

	Parms.InTriggerIdList = std::move(InTriggerIdList);
	Parms.InBrokenReason = InBrokenReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CountBreakingTriggerOnWithReasonFromBreakableObj
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class AWideUseBreakablePoint*>   InBreakableObjects                                     (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EBrokenReason                           InBrokenReason                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::CountBreakingTriggerOnWithReasonFromBreakableObj(const TArray<class AWideUseBreakablePoint*>& InBreakableObjects, EBrokenReason InBrokenReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CountBreakingTriggerOnWithReasonFromBreakableObj");

	Params::EventBlueprintFunctionLibrary_CountBreakingTriggerOnWithReasonFromBreakableObj Parms{};

	Parms.InBreakableObjects = std::move(InBreakableObjects);
	Parms.InBrokenReason = InBrokenReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CreateEncountActors
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::CreateEncountActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CreateEncountActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.CreateEncountEnemyPool
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::CreateEncountEnemyPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CreateEncountEnemyPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.CreateFriendDetails
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CHARACTER_TYPE                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Pos                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rot                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bFalling                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UEventBlueprintFunctionLibrary::CreateFriendDetails(ECHARACTER_TYPE CHARACTER_TYPE, const struct FVector& Pos, const struct FRotator& Rot, bool bFalling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CreateFriendDetails");

	Params::EventBlueprintFunctionLibrary_CreateFriendDetails Parms{};

	Parms.CHARACTER_TYPE = CHARACTER_TYPE;
	Parms.Pos = std::move(Pos);
	Parms.Rot = std::move(Rot);
	Parms.bFalling = bFalling;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.CreateFusionCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Support_left_type                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         Support_right_type                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::CreateFusionCharacter(ECHARACTER_TYPE Support_left_type, ECHARACTER_TYPE Support_right_type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "CreateFusionCharacter");

	Params::EventBlueprintFunctionLibrary_CreateFusionCharacter Parms{};

	Parms.Support_left_type = Support_left_type;
	Parms.Support_right_type = Support_right_type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DebugAddMoney
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   MoneyNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::DebugAddMoney(int32 MoneyNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DebugAddMoney");

	Params::EventBlueprintFunctionLibrary_DebugAddMoney Parms{};

	Parms.MoneyNum = MoneyNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DebugChangeBalloonTalkId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TalkID                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::DebugChangeBalloonTalkId(class AActor* TargetActor, const class FName& TalkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DebugChangeBalloonTalkId");

	Params::EventBlueprintFunctionLibrary_DebugChangeBalloonTalkId Parms{};

	Parms.TargetActor = TargetActor;
	Parms.TalkID = TalkID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DebugLoadQuest
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::DebugLoadQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DebugLoadQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DebugSaveQuest
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::DebugSaveQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DebugSaveQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DebugStartGame
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::DebugStartGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DebugStartGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DeleteAllFriend
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::DeleteAllFriend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DeleteAllFriend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DeleteFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Chara                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::DeleteFriend(class AAT_Character* Chara)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DeleteFriend");

	Params::EventBlueprintFunctionLibrary_DeleteFriend Parms{};

	Parms.Chara = Chara;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DestroyEncountEnemyPool
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::DestroyEncountEnemyPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DestroyEncountEnemyPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DestructionFutureVisionSaveData
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::DestructionFutureVisionSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DestructionFutureVisionSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DisableFieldAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisalbe                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::DisableFieldAction(class AActor* Owner, bool bDisalbe)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DisableFieldAction");

	Params::EventBlueprintFunctionLibrary_DisableFieldAction Parms{};

	Parms.Owner = Owner;
	Parms.bDisalbe = bDisalbe;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.DisableNpcHeadIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::DisableNpcHeadIcon(const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "DisableNpcHeadIcon");

	Params::EventBlueprintFunctionLibrary_DisableNpcHeadIcon Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EnableTakeOverControlModeChangePlayerChara
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::EnableTakeOverControlModeChangePlayerChara()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EnableTakeOverControlModeChangePlayerChara");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EndQuestDirection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DirectionId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::EndQuestDirection(class FName DirectionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EndQuestDirection");

	Params::EventBlueprintFunctionLibrary_EndQuestDirection Parms{};

	Parms.DirectionId = DirectionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EndQuestGeneralTalkEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DirectionId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnbindingControl                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSwitchGeneraTalkLookAt                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NotTakeOverBGM                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisibleLeader                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisibleSupporters                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisibleCloud                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bVisibleLandmark                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::EndQuestGeneralTalkEvent(class FName DirectionId, bool bUnbindingControl, bool bSwitchGeneraTalkLookAt, bool NotTakeOverBGM, bool bVisibleLeader, bool bVisibleSupporters, bool bVisibleCloud, bool bVisibleLandmark)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EndQuestGeneralTalkEvent");

	Params::EventBlueprintFunctionLibrary_EndQuestGeneralTalkEvent Parms{};

	Parms.DirectionId = DirectionId;
	Parms.bUnbindingControl = bUnbindingControl;
	Parms.bSwitchGeneraTalkLookAt = bSwitchGeneraTalkLookAt;
	Parms.NotTakeOverBGM = NotTakeOverBGM;
	Parms.bVisibleLeader = bVisibleLeader;
	Parms.bVisibleSupporters = bVisibleSupporters;
	Parms.bVisibleCloud = bVisibleCloud;
	Parms.bVisibleLandmark = bVisibleLandmark;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EndQuestMainLogo
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::EndQuestMainLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EndQuestMainLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EndThankYou
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::EndThankYou()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EndThankYou");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EventBattleEnd
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::EventBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EventBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EventBattleLoad
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             BattleName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::EventBattleLoad(const class FName& BattleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EventBattleLoad");

	Params::EventBlueprintFunctionLibrary_EventBattleLoad Parms{};

	Parms.BattleName = BattleName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EventBattleRetire
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::EventBattleRetire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EventBattleRetire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EventBattleRetry
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::EventBattleRetry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EventBattleRetry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.EventBattleStart
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::EventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "EventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ExterminationEventEnd
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ExterminationEventEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ExterminationEventEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ExterminationEventStart
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ExterminationEventStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ExterminationEventStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.FetchSequentialEventBattleId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::FetchSequentialEventBattleId(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "FetchSequentialEventBattleId");

	Params::EventBlueprintFunctionLibrary_FetchSequentialEventBattleId Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.FlashBackFade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   FadeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   T_fade                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::FlashBackFade(int32 FadeType, float T_fade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "FlashBackFade");

	Params::EventBlueprintFunctionLibrary_FlashBackFade Parms{};

	Parms.FadeType = FadeType;
	Parms.T_fade = T_fade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ForceFetchUniqueId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AQuestCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::ForceFetchUniqueId(class AQuestCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ForceFetchUniqueId");

	Params::EventBlueprintFunctionLibrary_ForceFetchUniqueId Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.ForceLoadAssetMobHuman
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             PresetID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ForceLoadAssetMobHuman(const class FName& PresetID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ForceLoadAssetMobHuman");

	Params::EventBlueprintFunctionLibrary_ForceLoadAssetMobHuman Parms{};

	Parms.PresetID = PresetID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.GetAndroidAssaultBattleStartAreaGroup
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::GetAndroidAssaultBattleStartAreaGroup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetAndroidAssaultBattleStartAreaGroup");

	Params::EventBlueprintFunctionLibrary_GetAndroidAssaultBattleStartAreaGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetAndroidAssaultBattleStartAreaId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::GetAndroidAssaultBattleStartAreaId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetAndroidAssaultBattleStartAreaId");

	Params::EventBlueprintFunctionLibrary_GetAndroidAssaultBattleStartAreaId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetAndroidAssaultBattleStartAreaName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::GetAndroidAssaultBattleStartAreaName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetAndroidAssaultBattleStartAreaName");

	Params::EventBlueprintFunctionLibrary_GetAndroidAssaultBattleStartAreaName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetAtrociousLaps
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::GetAtrociousLaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetAtrociousLaps");

	Params::EventBlueprintFunctionLibrary_GetAtrociousLaps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetBrokenReason
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InTriggerId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBrokenReason                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBrokenReason UEventBlueprintFunctionLibrary::GetBrokenReason(class FName InTriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetBrokenReason");

	Params::EventBlueprintFunctionLibrary_GetBrokenReason Parms{};

	Parms.InTriggerId = InTriggerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetBrokenReasonFromBreakableObj
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWideUseBreakablePoint*           InBreakableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBrokenReason                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBrokenReason UEventBlueprintFunctionLibrary::GetBrokenReasonFromBreakableObj(class AWideUseBreakablePoint* InBreakableObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetBrokenReasonFromBreakableObj");

	Params::EventBlueprintFunctionLibrary_GetBrokenReasonFromBreakableObj Parms{};

	Parms.InBreakableObject = InBreakableObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetCharacterMoveState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EATCharacterMoveState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterMoveState UEventBlueprintFunctionLibrary::GetCharacterMoveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetCharacterMoveState");

	Params::EventBlueprintFunctionLibrary_GetCharacterMoveState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetCurrentDLCId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::GetCurrentDLCId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetCurrentDLCId");

	Params::EventBlueprintFunctionLibrary_GetCurrentDLCId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetEventBattleId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::GetEventBattleId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetEventBattleId");

	Params::EventBlueprintFunctionLibrary_GetEventBattleId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetExterminationStrengthLevel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::GetExterminationStrengthLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetExterminationStrengthLevel");

	Params::EventBlueprintFunctionLibrary_GetExterminationStrengthLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetItemNum
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             MasterId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::GetItemNum(class FName MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetItemNum");

	Params::EventBlueprintFunctionLibrary_GetItemNum Parms{};

	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetMessageFromID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringID                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEventBlueprintFunctionLibrary::GetMessageFromID(const class FString& StringID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetMessageFromID");

	Params::EventBlueprintFunctionLibrary_GetMessageFromID Parms{};

	Parms.StringID = std::move(StringID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetPartyLeader
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UEventBlueprintFunctionLibrary::GetPartyLeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetPartyLeader");

	Params::EventBlueprintFunctionLibrary_GetPartyLeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetPartySupportLeft
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UEventBlueprintFunctionLibrary::GetPartySupportLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetPartySupportLeft");

	Params::EventBlueprintFunctionLibrary_GetPartySupportLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetPartySupportRight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UEventBlueprintFunctionLibrary::GetPartySupportRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetPartySupportRight");

	Params::EventBlueprintFunctionLibrary_GetPartySupportRight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_Character* UEventBlueprintFunctionLibrary::GetPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetPlayer");

	Params::EventBlueprintFunctionLibrary_GetPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetQuestCompletedCount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UEventBlueprintFunctionLibrary::GetQuestCompletedCount(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetQuestCompletedCount");

	Params::EventBlueprintFunctionLibrary_GetQuestCompletedCount Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetQuestMainLogoHideTotalFrames
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FFrameNumber                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFrameNumber UEventBlueprintFunctionLibrary::GetQuestMainLogoHideTotalFrames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetQuestMainLogoHideTotalFrames");

	Params::EventBlueprintFunctionLibrary_GetQuestMainLogoHideTotalFrames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetSelectedRetryProgress
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UEventBlueprintFunctionLibrary::GetSelectedRetryProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetSelectedRetryProgress");

	Params::EventBlueprintFunctionLibrary_GetSelectedRetryProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetSpeakerFromID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringID                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UEventBlueprintFunctionLibrary::GetSpeakerFromID(const class FString& StringID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetSpeakerFromID");

	Params::EventBlueprintFunctionLibrary_GetSpeakerFromID Parms{};

	Parms.StringID = std::move(StringID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetStarFinishOffPostProcess_DLC6
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class APostProcessVolume*>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APostProcessVolume*> UEventBlueprintFunctionLibrary::GetStarFinishOffPostProcess_DLC6()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetStarFinishOffPostProcess_DLC6");

	Params::EventBlueprintFunctionLibrary_GetStarFinishOffPostProcess_DLC6 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GetThankYouHideTotalFrames
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// struct FFrameNumber                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FFrameNumber UEventBlueprintFunctionLibrary::GetThankYouHideTotalFrames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GetThankYouHideTotalFrames");

	Params::EventBlueprintFunctionLibrary_GetThankYouHideTotalFrames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GettingDownVehiclePlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::GettingDownVehiclePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GettingDownVehiclePlayer");

	Params::EventBlueprintFunctionLibrary_GettingDownVehiclePlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.GrantWish
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::GrantWish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "GrantWish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.HideAndroidAssaultBattleCondition
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::HideAndroidAssaultBattleCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "HideAndroidAssaultBattleCondition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.HideNextPreviewDetail
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::HideNextPreviewDetail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "HideNextPreviewDetail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.HideNextPreviewTitle
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::HideNextPreviewTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "HideNextPreviewTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.HideQuestMainLogo
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::HideQuestMainLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "HideQuestMainLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.HideTelop
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::HideTelop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "HideTelop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.HideThankYou
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::HideThankYou()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "HideThankYou");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.Is_DLC_06_03002_B_Flg
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::Is_DLC_06_03002_B_Flg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "Is_DLC_06_03002_B_Flg");

	Params::EventBlueprintFunctionLibrary_Is_DLC_06_03002_B_Flg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsActivatedWindow
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsActivatedWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsActivatedWindow");

	Params::EventBlueprintFunctionLibrary_IsActivatedWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsActivePlayerCharaType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsActivePlayerCharaType(ECHARACTER_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsActivePlayerCharaType");

	Params::EventBlueprintFunctionLibrary_IsActivePlayerCharaType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsAndroidAssaultActiveAreaGroupId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AreaGroup                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsAndroidAssaultActiveAreaGroupId(class FName AreaGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsAndroidAssaultActiveAreaGroupId");

	Params::EventBlueprintFunctionLibrary_IsAndroidAssaultActiveAreaGroupId Parms{};

	Parms.AreaGroup = AreaGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsAndroidAssaultActiveAreaId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsAndroidAssaultActiveAreaId(class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsAndroidAssaultActiveAreaId");

	Params::EventBlueprintFunctionLibrary_IsAndroidAssaultActiveAreaId Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsAvailableTrunks
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsAvailableTrunks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsAvailableTrunks");

	Params::EventBlueprintFunctionLibrary_IsAvailableTrunks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsBreakingTriggerOn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InTriggerId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsBreakingTriggerOn(class FName InTriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsBreakingTriggerOn");

	Params::EventBlueprintFunctionLibrary_IsBreakingTriggerOn Parms{};

	Parms.InTriggerId = InTriggerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsBreakingTriggerOnFromBreakableObj
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AWideUseBreakablePoint*           InBreakableObject                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsBreakingTriggerOnFromBreakableObj(class AWideUseBreakablePoint* InBreakableObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsBreakingTriggerOnFromBreakableObj");

	Params::EventBlueprintFunctionLibrary_IsBreakingTriggerOnFromBreakableObj Parms{};

	Parms.InBreakableObject = InBreakableObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsCompletedAtrociousPhase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsCompletedAtrociousPhase(class FName LevelName, uint8 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsCompletedAtrociousPhase");

	Params::EventBlueprintFunctionLibrary_IsCompletedAtrociousPhase Parms{};

	Parms.LevelName = LevelName;
	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsCurrentExterminationEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsCurrentExterminationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsCurrentExterminationEvent");

	Params::EventBlueprintFunctionLibrary_IsCurrentExterminationEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsEnableQuestTalkEventHUDType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsEnableQuestTalkEventHUDType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsEnableQuestTalkEventHUDType");

	Params::EventBlueprintFunctionLibrary_IsEnableQuestTalkEventHUDType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsEqualTalkingCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsEqualTalkingCondition(const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsEqualTalkingCondition");

	Params::EventBlueprintFunctionLibrary_IsEqualTalkingCondition Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsEventBattleLoaded
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsEventBattleLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsEventBattleLoaded");

	Params::EventBlueprintFunctionLibrary_IsEventBattleLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsExterminationBattleEnd
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             BastionId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsExterminationBattleEnd(class FName BastionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsExterminationBattleEnd");

	Params::EventBlueprintFunctionLibrary_IsExterminationBattleEnd Parms{};

	Parms.BastionId = BastionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsGeneralTalkingEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsGeneralTalkingEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsGeneralTalkingEvent");

	Params::EventBlueprintFunctionLibrary_IsGeneralTalkingEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsLoadedParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsLoadedParts(ECHARACTER_TYPE CharacterType, uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsLoadedParts");

	Params::EventBlueprintFunctionLibrary_IsLoadedParts Parms{};

	Parms.CharacterType = CharacterType;
	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsLoadedPartsWithFacial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsLoadedPartsWithFacial(ECHARACTER_TYPE CharacterType, uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsLoadedPartsWithFacial");

	Params::EventBlueprintFunctionLibrary_IsLoadedPartsWithFacial Parms{};

	Parms.CharacterType = CharacterType;
	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsNormalBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsNormalBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsNormalBattle");

	Params::EventBlueprintFunctionLibrary_IsNormalBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsPlayerPartyIgnoreSE
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsPlayerPartyIgnoreSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsPlayerPartyIgnoreSE");

	Params::EventBlueprintFunctionLibrary_IsPlayerPartyIgnoreSE Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsRetryEventBattle
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsRetryEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsRetryEventBattle");

	Params::EventBlueprintFunctionLibrary_IsRetryEventBattle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsRetryingQuest
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsRetryingQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsRetryingQuest");

	Params::EventBlueprintFunctionLibrary_IsRetryingQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsReturnedFromDLC3
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsReturnedFromDLC3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsReturnedFromDLC3");

	Params::EventBlueprintFunctionLibrary_IsReturnedFromDLC3 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsRiding
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableNimbus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsRiding(bool bEnableNimbus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsRiding");

	Params::EventBlueprintFunctionLibrary_IsRiding Parms{};

	Parms.bEnableNimbus = bEnableNimbus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsSceneFreeLoading
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsSceneFreeLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsSceneFreeLoading");

	Params::EventBlueprintFunctionLibrary_IsSceneFreeLoading Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.IsStarFinishDirection
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventBlueprintFunctionLibrary::IsStarFinishDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "IsStarFinishDirection");

	Params::EventBlueprintFunctionLibrary_IsStarFinishDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.LearnCharacterSkill
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Target                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetPalette                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::LearnCharacterSkill(const ECHARACTER_TYPE Target, const class FName SkillId, bool bSetPalette)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "LearnCharacterSkill");

	Params::EventBlueprintFunctionLibrary_LearnCharacterSkill Parms{};

	Parms.Target = Target;
	Parms.SkillId = SkillId;
	Parms.bSetPalette = bSetPalette;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.LoadQuestImage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReferenceId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::LoadQuestImage(class FName ReferenceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "LoadQuestImage");

	Params::EventBlueprintFunctionLibrary_LoadQuestImage Parms{};

	Parms.ReferenceId = ReferenceId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.NotifyAndroidAssaultFoundSceneTiming
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::NotifyAndroidAssaultFoundSceneTiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "NotifyAndroidAssaultFoundSceneTiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.NotPlayNextFadeOut
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::NotPlayNextFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "NotPlayNextFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OnCryingAnimationFinished
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::OnCryingAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OnCryingAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenChangePlayerAnim2D
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MesId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::OpenChangePlayerAnim2D(const class FString& MesId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenChangePlayerAnim2D");

	Params::EventBlueprintFunctionLibrary_OpenChangePlayerAnim2D Parms{};

	Parms.MesId = std::move(MesId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenChangePlayerWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MesId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::OpenChangePlayerWindow(const class FString& MesId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenChangePlayerWindow");

	Params::EventBlueprintFunctionLibrary_OpenChangePlayerWindow Parms{};

	Parms.MesId = std::move(MesId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenCommunityFavorRateUpMenu
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             UniqueId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::OpenCommunityFavorRateUpMenu(const class FName& UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenCommunityFavorRateUpMenu");

	Params::EventBlueprintFunctionLibrary_OpenCommunityFavorRateUpMenu Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenSystemWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MesId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::OpenSystemWindow(const class FString& MesId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenSystemWindow");

	Params::EventBlueprintFunctionLibrary_OpenSystemWindow Parms{};

	Parms.MesId = std::move(MesId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenSystemWindowAppendMessage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           MesId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MesId2                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::OpenSystemWindowAppendMessage(const class FString& MesId, const class FString& MesId2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenSystemWindowAppendMessage");

	Params::EventBlueprintFunctionLibrary_OpenSystemWindowAppendMessage Parms{};

	Parms.MesId = std::move(MesId);
	Parms.MesId2 = std::move(MesId2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenSystemWindowReplacedStrings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           MessageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReplacedStrings                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::OpenSystemWindowReplacedStrings(const class FString& MessageId, const TArray<class FString>& ReplacedStrings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenSystemWindowReplacedStrings");

	Params::EventBlueprintFunctionLibrary_OpenSystemWindowReplacedStrings Parms{};

	Parms.MessageId = std::move(MessageId);
	Parms.ReplacedStrings = std::move(ReplacedStrings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenTipsDLC6ExtraModeWindow
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::OpenTipsDLC6ExtraModeWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenTipsDLC6ExtraModeWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.OpenTipsNewWindow
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::OpenTipsNewWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "OpenTipsNewWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.PlayTalkEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             TalkEventID                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::PlayTalkEvent(class FName TalkEventID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "PlayTalkEvent");

	Params::EventBlueprintFunctionLibrary_PlayTalkEvent Parms{};

	Parms.TalkEventID = TalkEventID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.PlayTownBGM
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             bgmID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::PlayTownBGM(class FName bgmID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "PlayTownBGM");

	Params::EventBlueprintFunctionLibrary_PlayTownBGM Parms{};

	Parms.bgmID = bgmID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.Recovery
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bHealth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   HealthRatio                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMagicPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MagicPointRatio                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::Recovery(bool bHealth, float HealthRatio, bool bMagicPoint, float MagicPointRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "Recovery");

	Params::EventBlueprintFunctionLibrary_Recovery Parms{};

	Parms.bHealth = bHealth;
	Parms.HealthRatio = HealthRatio;
	Parms.bMagicPoint = bMagicPoint;
	Parms.MagicPointRatio = MagicPointRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ReleaseQuestTalkEventHUDType
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ReleaseQuestTalkEventHUDType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ReleaseQuestTalkEventHUDType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ReleaseZCollection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bRelease                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ReleaseZCollection(bool bRelease)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ReleaseZCollection");

	Params::EventBlueprintFunctionLibrary_ReleaseZCollection Parms{};

	Parms.bRelease = bRelease;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RemoveDeactivateCharacterInEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CharacterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RemoveDeactivateCharacterInEvent(class FName CharacterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RemoveDeactivateCharacterInEvent");

	Params::EventBlueprintFunctionLibrary_RemoveDeactivateCharacterInEvent Parms{};

	Parms.CharacterName = CharacterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RemoveDestination
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RemoveDestination(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RemoveDestination");

	Params::EventBlueprintFunctionLibrary_RemoveDestination Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RemoveHaveDBCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RemoveHaveDBCharacter(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RemoveHaveDBCharacter");

	Params::EventBlueprintFunctionLibrary_RemoveHaveDBCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RemoveMainQuestIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RemoveMainQuestIcon(const class FName& QuestId, const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RemoveMainQuestIcon");

	Params::EventBlueprintFunctionLibrary_RemoveMainQuestIcon Parms{};

	Parms.QuestId = QuestId;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RemoveMobEnemy
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RemoveMobEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RemoveMobEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RemoveSubQuestIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RemoveSubQuestIcon(const class FName& QuestId, const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RemoveSubQuestIcon");

	Params::EventBlueprintFunctionLibrary_RemoveSubQuestIcon Parms{};

	Parms.QuestId = QuestId;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestAddQuestActorName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FindlistID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestAddQuestActorName(class FName QuestId, class FName FindlistID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestAddQuestActorName");

	Params::EventBlueprintFunctionLibrary_RequestAddQuestActorName Parms{};

	Parms.QuestId = QuestId;
	Parms.FindlistID = FindlistID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestAndroidAssaultBattleResult
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestAndroidAssaultBattleResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestAndroidAssaultBattleResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestChangePlayerCharaFromCType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CHARACTER_TYPE                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestChangePlayerCharaFromCType(ECHARACTER_TYPE CHARACTER_TYPE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestChangePlayerCharaFromCType");

	Params::EventBlueprintFunctionLibrary_RequestChangePlayerCharaFromCType Parms{};

	Parms.CHARACTER_TYPE = CHARACTER_TYPE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestChangeTalkId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TalkID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FindlistID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestChangeTalkId(const class FString& TalkID, class FName FindlistID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestChangeTalkId");

	Params::EventBlueprintFunctionLibrary_RequestChangeTalkId Parms{};

	Parms.TalkID = std::move(TalkID);
	Parms.FindlistID = FindlistID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestCheckCameraEffect
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestCheckCameraEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestCheckCameraEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestClearQuestProgressInformation
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestClearQuestProgressInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestClearQuestProgressInformation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestCrossTalk
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             CrossTalkId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestCrossTalk(const class FName& CrossTalkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestCrossTalk");

	Params::EventBlueprintFunctionLibrary_RequestCrossTalk Parms{};

	Parms.CrossTalkId = CrossTalkId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestFadeAfterDemo
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestFadeAfterDemo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestFadeAfterDemo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestFadeBeforeDemo
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestFadeBeforeDemo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestFadeBeforeDemo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestForceCloseGameWindow
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestForceCloseGameWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestForceCloseGameWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestFormChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestFormChange(class AAT_Character* TargetCharacter, const class FName SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestFormChange");

	Params::EventBlueprintFunctionLibrary_RequestFormChange Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestLoadCharacterCostume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AQuestCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestLoadCharacterCostume(class AQuestCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestLoadCharacterCostume");

	Params::EventBlueprintFunctionLibrary_RequestLoadCharacterCostume Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestLoadEncountAssets
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestLoadEncountAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestLoadEncountAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestLoadNpcAssets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CallbackQuestId                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestLoadNpcAssets(class FName CallbackQuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestLoadNpcAssets");

	Params::EventBlueprintFunctionLibrary_RequestLoadNpcAssets Parms{};

	Parms.CallbackQuestId = CallbackQuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestLoadParts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestLoadParts(ECHARACTER_TYPE CharacterType, uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestLoadParts");

	Params::EventBlueprintFunctionLibrary_RequestLoadParts Parms{};

	Parms.CharacterType = CharacterType;
	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestLoadPartsWithFacial
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestLoadPartsWithFacial(ECHARACTER_TYPE CharacterType, uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestLoadPartsWithFacial");

	Params::EventBlueprintFunctionLibrary_RequestLoadPartsWithFacial Parms{};

	Parms.CharacterType = CharacterType;
	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestOpenLevelWhenResultClosed
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           AreaName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestOpenLevelWhenResultClosed(const class FString& AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestOpenLevelWhenResultClosed");

	Params::EventBlueprintFunctionLibrary_RequestOpenLevelWhenResultClosed Parms{};

	Parms.AreaName = std::move(AreaName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestQuestAutoSave
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::RequestQuestAutoSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestQuestAutoSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestQuestCommand
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CommandId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestQuestCommand(const class FString& CommandId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestQuestCommand");

	Params::EventBlueprintFunctionLibrary_RequestQuestCommand Parms{};

	Parms.CommandId = std::move(CommandId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestQuestNotification
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             NotifiId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestQuestNotification(const class FName& NotifiId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestQuestNotification");

	Params::EventBlueprintFunctionLibrary_RequestQuestNotification Parms{};

	Parms.NotifiId = NotifiId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestResumeQuest
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::RequestResumeQuest(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestResumeQuest");

	Params::EventBlueprintFunctionLibrary_RequestResumeQuest Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.RequestSimpleWindow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           SimpleWindowId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USimpleTalkWindow*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USimpleTalkWindow* UEventBlueprintFunctionLibrary::RequestSimpleWindow(const class FString& SimpleWindowId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "RequestSimpleWindow");

	Params::EventBlueprintFunctionLibrary_RequestSimpleWindow Parms{};

	Parms.SimpleWindowId = std::move(SimpleWindowId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.ResetDefaultQuestBGM
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ResetDefaultQuestBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ResetDefaultQuestBGM");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ResetHaveDBCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Db_id                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ResetHaveDBCharacter(class AAT_Character* Character, int32 Db_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ResetHaveDBCharacter");

	Params::EventBlueprintFunctionLibrary_ResetHaveDBCharacter Parms{};

	Parms.Character = Character;
	Parms.Db_id = Db_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ResetMobTalkID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ResetMobTalkID(class FName Actor_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ResetMobTalkID");

	Params::EventBlueprintFunctionLibrary_ResetMobTalkID Parms{};

	Parms.Actor_name = Actor_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ResetSubtitle
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::ResetSubtitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ResetSubtitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ResetTriggerQuestStart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ResetTriggerQuestStart(class FName Actor_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ResetTriggerQuestStart");

	Params::EventBlueprintFunctionLibrary_ResetTriggerQuestStart Parms{};

	Parms.Actor_name = Actor_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.Set_DLC_06_03002_B_Flg
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::Set_DLC_06_03002_B_Flg(bool Flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "Set_DLC_06_03002_B_Flg");

	Params::EventBlueprintFunctionLibrary_Set_DLC_06_03002_B_Flg Parms{};

	Parms.Flg = Flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetAvailableTrunks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    FlagAvailable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetAvailableTrunks(bool FlagAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetAvailableTrunks");

	Params::EventBlueprintFunctionLibrary_SetAvailableTrunks Parms{};

	Parms.FlagAvailable = FlagAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetCameraAngle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   InYaw                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPitch                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetCameraAngle(float InYaw, float InPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetCameraAngle");

	Params::EventBlueprintFunctionLibrary_SetCameraAngle Parms{};

	Parms.InYaw = InYaw;
	Parms.InPitch = InPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetCharacterSpeakerId
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SpeakerID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetCharacterSpeakerId(const class FName& ActorName, const class FString& SpeakerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetCharacterSpeakerId");

	Params::EventBlueprintFunctionLibrary_SetCharacterSpeakerId Parms{};

	Parms.ActorName = ActorName;
	Parms.SpeakerID = std::move(SpeakerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDefaultPlatformFeatures
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::SetDefaultPlatformFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDefaultPlatformFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDisableChangeBgmForAssaultBattle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetDisableChangeBgmForAssaultBattle(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDisableChangeBgmForAssaultBattle");

	Params::EventBlueprintFunctionLibrary_SetDisableChangeBgmForAssaultBattle Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDisableChangeBgmForNextEventBattle
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::SetDisableChangeBgmForNextEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDisableChangeBgmForNextEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDisableCompletedSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetDisableCompletedSave(class FName QuestId, bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDisableCompletedSave");

	Params::EventBlueprintFunctionLibrary_SetDisableCompletedSave Parms{};

	Parms.QuestId = QuestId;
	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDisabledAutoSave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetDisabledAutoSave(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDisabledAutoSave");

	Params::EventBlueprintFunctionLibrary_SetDisabledAutoSave Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDisabledAutoSaveUI
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetDisabledAutoSaveUI(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDisabledAutoSaveUI");

	Params::EventBlueprintFunctionLibrary_SetDisabledAutoSaveUI Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetDrawActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetDrawActor(class AActor* Actor, bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetDrawActor");

	Params::EventBlueprintFunctionLibrary_SetDrawActor Parms{};

	Parms.Actor = Actor;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnableCrossTalkLipSync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsEnable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnableCrossTalkLipSync(bool bIsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnableCrossTalkLipSync");

	Params::EventBlueprintFunctionLibrary_SetEnableCrossTalkLipSync Parms{};

	Parms.bIsEnable = bIsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnableDinasaurs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnableDinasaurs(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnableDinasaurs");

	Params::EventBlueprintFunctionLibrary_SetEnableDinasaurs Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnableIdlingUntilDoorMoved
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PhaseID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnableIdlingUntilDoorMoved(class FName QuestId, class FName PhaseID, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnableIdlingUntilDoorMoved");

	Params::EventBlueprintFunctionLibrary_SetEnableIdlingUntilDoorMoved Parms{};

	Parms.QuestId = QuestId;
	Parms.PhaseID = PhaseID;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnablePlatformFeatures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableRecording                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableStreaming                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableScreenshots                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableSharing                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnablePlatformFeatures(bool bEnableRecording, bool bEnableStreaming, bool bEnableScreenshots, bool bEnableSharing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnablePlatformFeatures");

	Params::EventBlueprintFunctionLibrary_SetEnablePlatformFeatures Parms{};

	Parms.bEnableRecording = bEnableRecording;
	Parms.bEnableStreaming = bEnableStreaming;
	Parms.bEnableScreenshots = bEnableScreenshots;
	Parms.bEnableSharing = bEnableSharing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnablePlayerCameraUpdate
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnablePlayerCameraUpdate(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnablePlayerCameraUpdate");

	Params::EventBlueprintFunctionLibrary_SetEnablePlayerCameraUpdate Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnablePlayerCameraView
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnablePlayerCameraView(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnablePlayerCameraView");

	Params::EventBlueprintFunctionLibrary_SetEnablePlayerCameraView Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnableRidingOnQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnableRidingOnQuest(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnableRidingOnQuest");

	Params::EventBlueprintFunctionLibrary_SetEnableRidingOnQuest Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetEnableScreenFade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetEnableScreenFade(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetEnableScreenFade");

	Params::EventBlueprintFunctionLibrary_SetEnableScreenFade Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetExtendQuestProgress
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ProgressID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetExtendQuestProgress(class FName ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetExtendQuestProgress");

	Params::EventBlueprintFunctionLibrary_SetExtendQuestProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetHaveDBCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Db_id                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetHaveDBCharacter(class AAT_Character* Character, int32 Db_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetHaveDBCharacter");

	Params::EventBlueprintFunctionLibrary_SetHaveDBCharacter Parms{};

	Parms.Character = Character;
	Parms.Db_id = Db_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetMessageIDDelayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringID                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// E_MSG_FACE_ICON                         Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DispTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetMessageIDDelayTime(const class FString& StringID, E_MSG_FACE_ICON Icon, float DispTime, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetMessageIDDelayTime");

	Params::EventBlueprintFunctionLibrary_SetMessageIDDelayTime Parms{};

	Parms.StringID = std::move(StringID);
	Parms.Icon = Icon;
	Parms.DispTime = DispTime;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetNpcLightTower
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELightTowerKind                         LightTowerType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivate                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetNpcLightTower(const class FName& ActorName, ELightTowerKind LightTowerType, bool bActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetNpcLightTower");

	Params::EventBlueprintFunctionLibrary_SetNpcLightTower Parms{};

	Parms.ActorName = ActorName;
	Parms.LightTowerType = LightTowerType;
	Parms.bActivate = bActivate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetNpcTalkIcon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMOB_ICON_TYPE                          IconType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetNpcTalkIcon(const class FName& ActorName, EMOB_ICON_TYPE IconType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetNpcTalkIcon");

	Params::EventBlueprintFunctionLibrary_SetNpcTalkIcon Parms{};

	Parms.ActorName = ActorName;
	Parms.IconType = IconType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetPlayerLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Loc                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetPlayerLocation(const struct FVector& Loc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetPlayerLocation");

	Params::EventBlueprintFunctionLibrary_SetPlayerLocation Parms{};

	Parms.Loc = std::move(Loc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetPlayerPartyIgnoreSE
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetPlayerPartyIgnoreSE(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetPlayerPartyIgnoreSE");

	Params::EventBlueprintFunctionLibrary_SetPlayerPartyIgnoreSE Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetQuestTalkEventHUDType
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::SetQuestTalkEventHUDType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetQuestTalkEventHUDType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetReturnedFromDLC3
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::SetReturnedFromDLC3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetReturnedFromDLC3");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetSelectRideIcon
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ERIDE_ICON_TYPE                         InIcon                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetSelectRideIcon(ERIDE_ICON_TYPE InIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetSelectRideIcon");

	Params::EventBlueprintFunctionLibrary_SetSelectRideIcon Parms{};

	Parms.InIcon = InIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetSubtitles
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringID                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DispTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetSubtitles(const class FString& StringID, float DispTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetSubtitles");

	Params::EventBlueprintFunctionLibrary_SetSubtitles Parms{};

	Parms.StringID = std::move(StringID);
	Parms.DispTime = DispTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetSubtitlesQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringID                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DispTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetSubtitlesQuest(const class FString& StringID, float DispTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetSubtitlesQuest");

	Params::EventBlueprintFunctionLibrary_SetSubtitlesQuest Parms{};

	Parms.StringID = std::move(StringID);
	Parms.DispTime = DispTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetSubtitlesQuestDelayTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StringID                                               (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DispTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetSubtitlesQuestDelayTime(const class FString& StringID, float DispTime, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetSubtitlesQuestDelayTime");

	Params::EventBlueprintFunctionLibrary_SetSubtitlesQuestDelayTime Parms{};

	Parms.StringID = std::move(StringID);
	Parms.DispTime = DispTime;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetTargetAim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    Charctor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAT_Character*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetTargetAim(class AAT_Character* Charctor, class AAT_Character* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetTargetAim");

	Params::EventBlueprintFunctionLibrary_SetTargetAim Parms{};

	Parms.Charctor = Charctor;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetupAndroidAssaultBattleCondition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             BattleName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetupAndroidAssaultBattleCondition(class FName BattleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetupAndroidAssaultBattleCondition");

	Params::EventBlueprintFunctionLibrary_SetupAndroidAssaultBattleCondition Parms{};

	Parms.BattleName = BattleName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetupCharacterCostume
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AQuestCharacter*                  TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetupCharacterCostume(class AQuestCharacter* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetupCharacterCostume");

	Params::EventBlueprintFunctionLibrary_SetupCharacterCostume Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetUpdateAwakeAllQuest
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::SetUpdateAwakeAllQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetUpdateAwakeAllQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetUpdateSleepOtherQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetUpdateSleepOtherQuest(class FName QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetUpdateSleepOtherQuest");

	Params::EventBlueprintFunctionLibrary_SetUpdateSleepOtherQuest Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetUpdateSleepQuest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSleep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetUpdateSleepQuest(class FName QuestId, bool bSleep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetUpdateSleepQuest");

	Params::EventBlueprintFunctionLibrary_SetUpdateSleepQuest Parms{};

	Parms.QuestId = QuestId;
	Parms.bSleep = bSleep;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetViewByControlCharacter
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    InbImmediate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetViewByControlCharacter(bool InbImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetViewByControlCharacter");

	Params::EventBlueprintFunctionLibrary_SetViewByControlCharacter Parms{};

	Parms.InbImmediate = InbImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetViewByControlCharacterWithBlemdTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   FBlendTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetViewByControlCharacterWithBlemdTime(float FBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetViewByControlCharacterWithBlemdTime");

	Params::EventBlueprintFunctionLibrary_SetViewByControlCharacterWithBlemdTime Parms{};

	Parms.FBlendTime = FBlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SetViewTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EViewTargetBlendFunction                BlendFunc                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockOutgoing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::SetViewTarget(class AActor* NewViewTarget, float BlendTime, EViewTargetBlendFunction BlendFunc, float BlendExp, bool bLockOutgoing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SetViewTarget");

	Params::EventBlueprintFunctionLibrary_SetViewTarget Parms{};

	Parms.NewViewTarget = NewViewTarget;
	Parms.BlendTime = BlendTime;
	Parms.BlendFunc = BlendFunc;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowAndroidAssaultBattleCondition
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ShowAndroidAssaultBattleCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowAndroidAssaultBattleCondition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowNextPreviewDetail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           HeaderMessageId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SubjectMessageId                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ShowNextPreviewDetail(const class FString& HeaderMessageId, const class FString& SubjectMessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowNextPreviewDetail");

	Params::EventBlueprintFunctionLibrary_ShowNextPreviewDetail Parms{};

	Parms.HeaderMessageId = std::move(HeaderMessageId);
	Parms.SubjectMessageId = std::move(SubjectMessageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowNextPreviewTitle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TitleMessageId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ShowNextPreviewTitle(const class FString& TitleMessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowNextPreviewTitle");

	Params::EventBlueprintFunctionLibrary_ShowNextPreviewTitle Parms{};

	Parms.TitleMessageId = std::move(TitleMessageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowQuestImage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReferenceId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ShowQuestImage(class FName ReferenceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowQuestImage");

	Params::EventBlueprintFunctionLibrary_ShowQuestImage Parms{};

	Parms.ReferenceId = ReferenceId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowQuestMainLogo
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::ShowQuestMainLogo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowQuestMainLogo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowSubjugationMission
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ShowSubjugationMission()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowSubjugationMission");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowTelop
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// struct FTelopInfo                       TelopInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTelopInfo                       TelopInfo2                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ShowTelop(const struct FTelopInfo& TelopInfo, const struct FTelopInfo& TelopInfo2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowTelop");

	Params::EventBlueprintFunctionLibrary_ShowTelop Parms{};

	Parms.TelopInfo = std::move(TelopInfo);
	Parms.TelopInfo2 = std::move(TelopInfo2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowTelopWithScale
// (Final, Native, Static, Public, HasOutParams)
// Parameters:
// struct FTelopInfo                       TelopInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTelopInfo                       TelopInfo2                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   SizeRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::ShowTelopWithScale(const struct FTelopInfo& TelopInfo, const struct FTelopInfo& TelopInfo2, float SizeRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowTelopWithScale");

	Params::EventBlueprintFunctionLibrary_ShowTelopWithScale Parms{};

	Parms.TelopInfo = std::move(TelopInfo);
	Parms.TelopInfo2 = std::move(TelopInfo2);
	Parms.SizeRate = SizeRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowThankYou
// (Final, Native, Static, Public)

void UEventBlueprintFunctionLibrary::ShowThankYou()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowThankYou");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.ShowTurtleSchoolTutorial
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::ShowTurtleSchoolTutorial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "ShowTurtleSchoolTutorial");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.SpawnActorWithName
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UClass*                           ClassName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UEventBlueprintFunctionLibrary::SpawnActorWithName(class UClass* ClassName, const struct FTransform& Transform, class FName ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SpawnActorWithName");

	Params::EventBlueprintFunctionLibrary_SpawnActorWithName Parms{};

	Parms.ClassName = ClassName;
	Parms.Transform = std::move(Transform);
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventBlueprintFunctionLibrary.SpawnDragonball
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::SpawnDragonball()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "SpawnDragonball");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.StartAndroidAssaultReactiveCount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             CountName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::StartAndroidAssaultReactiveCount(class FName CountName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "StartAndroidAssaultReactiveCount");

	Params::EventBlueprintFunctionLibrary_StartAndroidAssaultReactiveCount Parms{};

	Parms.CountName = CountName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.StartQuestDirection
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DirectionId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenSuppoters                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::StartQuestDirection(class FName DirectionId, bool bHiddenSuppoters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "StartQuestDirection");

	Params::EventBlueprintFunctionLibrary_StartQuestDirection Parms{};

	Parms.DirectionId = DirectionId;
	Parms.bHiddenSuppoters = bHiddenSuppoters;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.StartQuestGeneralTalkEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             DirectionId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBindingControl                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableIK                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopAutoMove                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSwitchGeneraTalkLookAt                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenMobCharacters                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenLeader                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenSuppoters                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenClound                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenLandmark                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::StartQuestGeneralTalkEvent(class FName DirectionId, bool bBindingControl, bool bDisableIK, bool bStopAutoMove, bool bSwitchGeneraTalkLookAt, bool bHiddenMobCharacters, bool bHiddenLeader, bool bHiddenSuppoters, bool bHiddenClound, bool bHiddenLandmark)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "StartQuestGeneralTalkEvent");

	Params::EventBlueprintFunctionLibrary_StartQuestGeneralTalkEvent Parms{};

	Parms.DirectionId = DirectionId;
	Parms.bBindingControl = bBindingControl;
	Parms.bDisableIK = bDisableIK;
	Parms.bStopAutoMove = bStopAutoMove;
	Parms.bSwitchGeneraTalkLookAt = bSwitchGeneraTalkLookAt;
	Parms.bHiddenMobCharacters = bHiddenMobCharacters;
	Parms.bHiddenLeader = bHiddenLeader;
	Parms.bHiddenSuppoters = bHiddenSuppoters;
	Parms.bHiddenClound = bHiddenClound;
	Parms.bHiddenLandmark = bHiddenLandmark;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.StopDinosaurs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bStop                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventBlueprintFunctionLibrary::StopDinosaurs(bool bStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "StopDinosaurs");

	Params::EventBlueprintFunctionLibrary_StopDinosaurs Parms{};

	Parms.bStop = bStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.UnlockAtrociousBossTrophy
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::UnlockAtrociousBossTrophy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "UnlockAtrociousBossTrophy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.UnlockCellSagaTrophy
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::UnlockCellSagaTrophy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "UnlockCellSagaTrophy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.UnlockDefeatedPiccoloTrophy
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::UnlockDefeatedPiccoloTrophy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "UnlockDefeatedPiccoloTrophy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.UnlockFriezaSagaTrophy
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::UnlockFriezaSagaTrophy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "UnlockFriezaSagaTrophy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.UnlockSaiyanSagaTrophy
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::UnlockSaiyanSagaTrophy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "UnlockSaiyanSagaTrophy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventBlueprintFunctionLibrary.UpdateDragonBallUI
// (Final, Native, Static, Public, BlueprintCallable)

void UEventBlueprintFunctionLibrary::UpdateDragonBallUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("EventBlueprintFunctionLibrary", "UpdateDragonBallUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FieldActionBonfireActor.OnProgressChanged
// (Final, Native, Private)
// Parameters:
// int32                                   NextPhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFieldActionBonfireActor::OnProgressChanged(int32 NextPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionBonfireActor", "OnProgressChanged");

	Params::FieldActionBonfireActor_OnProgressChanged Parms{};

	Parms.NextPhase = NextPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FieldActionBonfireActor.OpenMenu
// (Native, Public)

void AFieldActionBonfireActor::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionBonfireActor", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl034SkillBarrier.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActCpl034SkillBarrier::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl034SkillBarrier", "OnSpawnProjectile");

	Params::ATActCpl034SkillBarrier_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.GetSelectValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIMenuBarBase03::GetSelectValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "GetSelectValue");

	Params::AT_UIMenuBarBase03_GetSelectValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuBarBase03.HideAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::HideAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "HideAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.InitListSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCmnMenuBar03Param>       MenuItemCtn                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SelectNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuBarBase03::InitListSetting(const TArray<struct FCmnMenuBar03Param>& MenuItemCtn, int32 SelectNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "InitListSetting");

	Params::AT_UIMenuBarBase03_InitListSetting Parms{};

	Parms.MenuItemCtn = std::move(MenuItemCtn);
	Parms.SelectNo = SelectNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuBarBase03::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "MouseWheel");

	Params::AT_UIMenuBarBase03_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.MouseWheelOuter
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuBarBase03::MouseWheelOuter(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "MouseWheelOuter");

	Params::AT_UIMenuBarBase03_MouseWheelOuter Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuBarBase03.PageDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuBarBase03::PageDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "PageDown");

	Params::AT_UIMenuBarBase03_PageDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuBarBase03.PageUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuBarBase03::PageUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "PageUp");

	Params::AT_UIMenuBarBase03_PageUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuBarBase03.PlayArrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLeft                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuBarBase03::PlayArrow(bool bLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "PlayArrow");

	Params::AT_UIMenuBarBase03_PlayArrow Parms{};

	Parms.bLeft = bLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.PlayCancel
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::PlayCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "PlayCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.PlayDecide
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::PlayDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "PlayDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.PlayEnter
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::PlayEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "PlayEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::RequestPlayInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "RequestPlayInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::RequestPlayOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "RequestPlayOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.SelectDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::SelectDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "SelectDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.SelectUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::SelectUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "SelectUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.SetEnableLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuBarBase03::SetEnableLoop(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "SetEnableLoop");

	Params::AT_UIMenuBarBase03_SetEnableLoop Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuBarBase03.ShowAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuBarBase03::ShowAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuBarBase03", "ShowAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.UnderWaterRestartVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnderWaterRestartVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnderWaterRestartVolume", "OnOverlapBegin");

	Params::UnderWaterRestartVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UnderWaterRestartVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AUnderWaterRestartVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UnderWaterRestartVolume", "OnOverlapEnd");

	Params::UnderWaterRestartVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FieldPointComponent.DebugUpdate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFieldPointComponent::DebugUpdate(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldPointComponent", "DebugUpdate");

	Params::FieldPointComponent_DebugUpdate Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UMGRenderingManager.EndPlay
// (Final, Native, Public)

void UUMGRenderingManager::EndPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UMGRenderingManager", "EndPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICompZListCds.Anim_In
// (Final, Native, Public, BlueprintCallable)

void UAT_UICompZListCds::Anim_In()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICompZListCds", "Anim_In");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.MineralMiningPointNormal.OnActionChange
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMineralMiningPointNormal::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MineralMiningPointNormal", "OnActionChange");

	Params::MineralMiningPointNormal_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.MineralMiningPointNormal.OnComponentHit
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AMineralMiningPointNormal::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MineralMiningPointNormal", "OnComponentHit");

	Params::MineralMiningPointNormal_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATAtrociousBattleBase.OnBeginPlayLevelTiming
// (Final, Native, Public)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATAtrociousBattleBase::OnBeginPlayLevelTiming(const class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATAtrociousBattleBase", "OnBeginPlayLevelTiming");

	Params::ATAtrociousBattleBase_OnBeginPlayLevelTiming Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldMapInfo.OnInGameBeginPlay
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATWorldMapInfo::OnInGameBeginPlay(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldMapInfo", "OnInGameBeginPlay");

	Params::ATWorldMapInfo_OnInGameBeginPlay Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.Change_Char
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleHudPlayer::Change_Char()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "Change_Char");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnBattleEnd
// (Final, Native, Public)

void UAT_UIBattleHudPlayer::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnBattleStart
// (Final, Native, Public)

void UAT_UIBattleHudPlayer::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnBeginCoopSkill
// (Final, Native, Public)

void UAT_UIBattleHudPlayer::OnBeginCoopSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnBeginCoopSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnBeginFormChange
// (Final, Native, Public)

void UAT_UIBattleHudPlayer::OnBeginFormChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnBeginFormChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnChangeCostume
// (Final, Native, Public)
// Parameters:
// uint8                                   InVatiationID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InFormID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayer::OnChangeCostume(uint8 InVatiationID, uint8 InFormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnChangeCostume");

	Params::AT_UIBattleHudPlayer_OnChangeCostume Parms{};

	Parms.InVatiationID = InVatiationID;
	Parms.InFormID = InFormID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnChangePlayer
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayer::OnChangePlayer(class AAT_Character* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnChangePlayer");

	Params::AT_UIBattleHudPlayer_OnChangePlayer Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnEntrySupport
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   InMemberType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayer::OnEntrySupport(const struct FPartyMember& InMember, uint8 InMemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnEntrySupport");

	Params::AT_UIBattleHudPlayer_OnEntrySupport Parms{};

	Parms.InMember = std::move(InMember);
	Parms.InMemberType = InMemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnExitSupport
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   InMemberType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayer::OnExitSupport(const struct FPartyMember& InMember, uint8 InMemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnExitSupport");

	Params::AT_UIBattleHudPlayer_OnExitSupport Parms{};

	Parms.InMember = std::move(InMember);
	Parms.InMemberType = InMemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnFormChange
// (Final, Native, Public)
// Parameters:
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   VariationId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   FormID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayer::OnFormChange(bool IsOn, uint8 VariationId, uint8 FormID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnFormChange");

	Params::AT_UIBattleHudPlayer_OnFormChange Parms{};

	Parms.IsOn = IsOn;
	Parms.VariationId = VariationId;
	Parms.FormID = FormID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OnFusionEnd
// (Final, Native, Public)
// Parameters:
// class UATParty*                         PlayerParty                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudPlayer::OnFusionEnd(class UATParty* PlayerParty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OnFusionEnd");

	Params::AT_UIBattleHudPlayer_OnFusionEnd Parms{};

	Parms.PlayerParty = PlayerParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudPlayer.OutEvent
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleHudPlayer::OutEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudPlayer", "OutEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorldCurs.RequestClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapWorldCurs::RequestClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorldCurs", "RequestClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorldCurs.RequestOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapWorldCurs::RequestOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorldCurs", "RequestOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimNotifyState_AG_CharacterTrail.OverridePSTemplate
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystem* UAnimNotifyState_AG_CharacterTrail::OverridePSTemplate(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_AG_CharacterTrail", "OverridePSTemplate");

	Params::AnimNotifyState_AG_CharacterTrail_OverridePSTemplate Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AT.AnimNotifyState_AttachObject.GetAttachedObject
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UAnimNotifyState_AttachObject::GetAttachedObject(class USkeletalMeshComponent* MeshComp) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_AttachObject", "GetAttachedObject");

	Params::AnimNotifyState_AttachObject_GetAttachedObject Parms{};

	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase00.ForceSetSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NO                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPlayInAnim                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::ForceSetSelect(int32 NO, bool IsPlayInAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "ForceSetSelect");

	Params::AT_UIMenuListBase00_ForceSetSelect Parms{};

	Parms.NO = NO;
	Parms.IsPlayInAnim = IsPlayInAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.HideAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::HideAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "HideAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.InitListSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NumTxt                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCmnMenuList00Param>      MenuItemCtn                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SelectNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsRankStar                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::InitListSetting(const class FString& TitleTxt, const class FString& NumTxt, const TArray<struct FCmnMenuList00Param>& MenuItemCtn, int32 SelectNo, bool IsRankStar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "InitListSetting");

	Params::AT_UIMenuListBase00_InitListSetting Parms{};

	Parms.TitleTxt = std::move(TitleTxt);
	Parms.NumTxt = std::move(NumTxt);
	Parms.MenuItemCtn = std::move(MenuItemCtn);
	Parms.SelectNo = SelectNo;
	Parms.IsRankStar = IsRankStar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.InitSkillListSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCmnSkillMenuList00Param> MenuItemCtn                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SelectNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::InitSkillListSetting(const class FString& TitleTxt, const TArray<struct FCmnSkillMenuList00Param>& MenuItemCtn, int32 SelectNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "InitSkillListSetting");

	Params::AT_UIMenuListBase00_InitSkillListSetting Parms{};

	Parms.TitleTxt = std::move(TitleTxt);
	Parms.MenuItemCtn = std::move(MenuItemCtn);
	Parms.SelectNo = SelectNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "MouseWheel");

	Params::AT_UIMenuListBase00_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.PageDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuListBase00::PageDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "PageDown");

	Params::AT_UIMenuListBase00_PageDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase00.PageUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuListBase00::PageUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "PageUp");

	Params::AT_UIMenuListBase00_PageUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase00.RequestEnterAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEndDeactive                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOut                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::RequestEnterAnim(bool IsEndDeactive, bool IsOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "RequestEnterAnim");

	Params::AT_UIMenuListBase00_RequestEnterAnim Parms{};

	Parms.IsEndDeactive = IsEndDeactive;
	Parms.IsOut = IsOut;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::RequestPlayInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "RequestPlayInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::RequestPlayOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "RequestPlayOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SelectDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::SelectDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SelectDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SelectUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::SelectUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SelectUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SetEnableLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::SetEnableLoop(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SetEnableLoop");

	Params::AT_UIMenuListBase00_SetEnableLoop Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SetListActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartIdx                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::SetListActive(bool bIsActive, int32 StartIdx, int32 EndIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SetListActive");

	Params::AT_UIMenuListBase00_SetListActive Parms{};

	Parms.bIsActive = bIsActive;
	Parms.StartIdx = StartIdx;
	Parms.EndIdx = EndIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SetListAllActive
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::SetListAllActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SetListAllActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SetThinMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsThin                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::SetThinMode(bool bIsThin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SetThinMode");

	Params::AT_UIMenuListBase00_SetThinMode Parms{};

	Parms.bIsThin = bIsThin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.SetWidth
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase00::SetWidth(float Width)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "SetWidth");

	Params::AT_UIMenuListBase00_SetWidth Parms{};

	Parms.Width = Width;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.ShowAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase00::ShowAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "ShowAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase00.GetListNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIMenuListBase00::GetListNum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "GetListNum");

	Params::AT_UIMenuListBase00_GetListNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase00.GetSelectValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIMenuListBase00::GetSelectValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase00", "GetSelectValue");

	Params::AT_UIMenuListBase00_GetSelectValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AnimNotifyState_AttackHitAttachPhoton.BeginOverlap
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAnimNotifyState_AttackHitAttachPhoton::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_AttackHitAttachPhoton", "BeginOverlap");

	Params::AnimNotifyState_AttackHitAttachPhoton_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.GetSelectValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIMenuListBase01::GetSelectValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "GetSelectValue");

	Params::AT_UIMenuListBase01_GetSelectValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase01.HideAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::HideAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "HideAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.InitListSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NumTxt                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCmnMenuListParam>        MenuItemCtn                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SelectNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllDisp                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase01::InitListSetting(const class FString& TitleTxt, const class FString& NumTxt, const TArray<struct FCmnMenuListParam>& MenuItemCtn, int32 SelectNo, bool AllDisp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "InitListSetting");

	Params::AT_UIMenuListBase01_InitListSetting Parms{};

	Parms.TitleTxt = std::move(TitleTxt);
	Parms.NumTxt = std::move(NumTxt);
	Parms.MenuItemCtn = std::move(MenuItemCtn);
	Parms.SelectNo = SelectNo;
	Parms.AllDisp = AllDisp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase01::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "MouseWheel");

	Params::AT_UIMenuListBase01_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.PageDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuListBase01::PageDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "PageDown");

	Params::AT_UIMenuListBase01_PageDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase01.PageUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuListBase01::PageUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "PageUp");

	Params::AT_UIMenuListBase01_PageUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase01.RequestPlayEnterAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::RequestPlayEnterAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "RequestPlayEnterAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsFade                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase01::RequestPlayInAnim(bool IsFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "RequestPlayInAnim");

	Params::AT_UIMenuListBase01_RequestPlayInAnim Parms{};

	Parms.IsFade = IsFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsFade                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase01::RequestPlayOutAnim(bool IsFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "RequestPlayOutAnim");

	Params::AT_UIMenuListBase01_RequestPlayOutAnim Parms{};

	Parms.IsFade = IsFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.ResetAllAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::ResetAllAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "ResetAllAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.SelectDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::SelectDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "SelectDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.SelectUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::SelectUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "SelectUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.SetEnableLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase01::SetEnableLoop(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "SetEnableLoop");

	Params::AT_UIMenuListBase01_SetEnableLoop Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.ShowAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::ShowAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "ShowAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.SubtractionMenuNum
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::SubtractionMenuNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "SubtractionMenuNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase01.UpdateList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase01::UpdateList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase01", "UpdateList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.GetSelectValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIMenuListBase03::GetSelectValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "GetSelectValue");

	Params::AT_UIMenuListBase03_GetSelectValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase03.HideAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::HideAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "HideAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.InitListSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FCmnMenuList03Param>      MenuItemCtn                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   SelectNo                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase03::InitListSetting(const class FString& TitleTxt, const TArray<struct FCmnMenuList03Param>& MenuItemCtn, int32 SelectNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "InitListSetting");

	Params::AT_UIMenuListBase03_InitListSetting Parms{};

	Parms.TitleTxt = std::move(TitleTxt);
	Parms.MenuItemCtn = std::move(MenuItemCtn);
	Parms.SelectNo = SelectNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.PageDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::PageDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "PageDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.PageUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::PageUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "PageUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.RequestPlayEnterAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::RequestPlayEnterAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "RequestPlayEnterAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::RequestPlayInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "RequestPlayInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::RequestPlayOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "RequestPlayOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.SelectDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::SelectDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "SelectDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.SelectUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::SelectUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "SelectUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.SetEnableLoop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase03::SetEnableLoop(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "SetEnableLoop");

	Params::AT_UIMenuListBase03_SetEnableLoop Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase03.ShowAllNut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase03::ShowAllNut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase03", "ShowAllNut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActAssaultAttack.OnSettleEvent
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATActAssaultAttack::OnSettleEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActAssaultAttack", "OnSettleEvent");

	Params::ATActAssaultAttack_OnSettleEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimNotifyState_DirectionCamera.OnNotifyBegin
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalDuration                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState_DirectionCamera::OnNotifyBegin(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation, float TotalDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_DirectionCamera", "OnNotifyBegin");

	Params::AnimNotifyState_DirectionCamera_OnNotifyBegin Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;
	Parms.TotalDuration = TotalDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AnimNotifyState_DirectionCamera.OnNotifyEnd
// (Native, Public, BlueprintCallable, Const)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimSequenceBase*                Animation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAnimNotifyState_DirectionCamera::OnNotifyEnd(class USkeletalMeshComponent* MeshComp, class UAnimSequenceBase* Animation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_DirectionCamera", "OnNotifyEnd");

	Params::AnimNotifyState_DirectionCamera_OnNotifyEnd Parms{};

	Parms.MeshComp = MeshComp;
	Parms.Animation = Animation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIBattleManager.OnBattleCutinAnimEnd
// (Final, Native, Public)
// Parameters:
// EBattleCutin_AnimType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleManager::OnBattleCutinAnimEnd(EBattleCutin_AnimType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleManager", "OnBattleCutinAnimEnd");

	Params::AT_UIBattleManager_OnBattleCutinAnimEnd Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleManager.OnPause
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIBattleManager::OnPause(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleManager", "OnPause");

	Params::AT_UIBattleManager_OnPause Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ItemStaticActor.OnHitOwn
// (Final, Native, Public, BlueprintCallable)

void AItemStaticActor::OnHitOwn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemStaticActor", "OnHitOwn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase06.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMenuListBase06::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase06", "MouseWheel");

	Params::AT_UIMenuListBase06_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase06.PageDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuListBase06::PageDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase06", "PageDown");

	Params::AT_UIMenuListBase06_PageDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase06.PageUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMenuListBase06::PageUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase06", "PageUp");

	Params::AT_UIMenuListBase06_PageUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuListBase06.SelectDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase06::SelectDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase06", "SelectDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMenuListBase06.SelectUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMenuListBase06::SelectUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuListBase06", "SelectUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_AnimInstance.ATStopSlotAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InBlendOutTime                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SlotNodeName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_AnimInstance::ATStopSlotAnimation(float InBlendOutTime, class FName SlotNodeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "ATStopSlotAnimation");

	Params::AT_AnimInstance_ATStopSlotAnimation Parms{};

	Parms.InBlendOutTime = InBlendOutTime;
	Parms.SlotNodeName = SlotNodeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_AnimInstance.GetIsJoinIngameDemo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_AnimInstance::GetIsJoinIngameDemo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "GetIsJoinIngameDemo");

	Params::AT_AnimInstance_GetIsJoinIngameDemo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.IsSlotAnimationExtend
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_AnimInstance::IsSlotAnimationExtend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "IsSlotAnimationExtend");

	Params::AT_AnimInstance_IsSlotAnimationExtend Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.GetCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AAT_CharacterBase*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_CharacterBase* UAT_AnimInstance::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "GetCharacter");

	Params::AT_AnimInstance_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.GetClothesAdditiveAlpha
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAT_AnimInstance::GetClothesAdditiveAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "GetClothesAdditiveAlpha");

	Params::AT_AnimInstance_GetClothesAdditiveAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.GetHairAdditiveAlpha
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAT_AnimInstance::GetHairAdditiveAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "GetHairAdditiveAlpha");

	Params::AT_AnimInstance_GetHairAdditiveAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.GetOptionsAdditiveAlpha
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAT_AnimInstance::GetOptionsAdditiveAlpha() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "GetOptionsAdditiveAlpha");

	Params::AT_AnimInstance_GetOptionsAdditiveAlpha Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.IsAdditiveClothes
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_AnimInstance::IsAdditiveClothes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "IsAdditiveClothes");

	Params::AT_AnimInstance_IsAdditiveClothes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.IsAdditiveHair
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_AnimInstance::IsAdditiveHair() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "IsAdditiveHair");

	Params::AT_AnimInstance_IsAdditiveHair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_AnimInstance.IsAdditiveOptions
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_AnimInstance::IsAdditiveOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_AnimInstance", "IsAdditiveOptions");

	Params::AT_AnimInstance_IsAdditiveOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDirectionBase.OnBeginDirection
// (Final, Native, Protected)
// Parameters:
// struct FDirectionParameter              InParameter                                            (Parm, NativeAccessSpecifierPublic)

void UATDirectionBase::OnBeginDirection(const struct FDirectionParameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionBase", "OnBeginDirection");

	Params::ATDirectionBase_OnBeginDirection Parms{};

	Parms.InParameter = std::move(InParameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDirectionBase.OnEndDirection
// (Final, Native, Protected)

void UATDirectionBase::OnEndDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionBase", "OnEndDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDirectionRingout.OnFinishedRingoutUI
// (Final, Native, Protected)

void UATDirectionRingout::OnFinishedRingoutUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionRingout", "OnFinishedRingoutUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DamageExpCharacter.ApplyAppearance
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_DamageExpCharacter::ApplyAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DamageExpCharacter", "ApplyAppearance");

	Params::AT_DamageExpCharacter_ApplyAppearance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDLC6FieldMemoriesActor.OnBattleEnd
// (Final, Native, Protected)

void AATDLC6FieldMemoriesActor::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDLC6FieldMemoriesActor", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDLC6FieldMemoriesActor.OnClosedConfirmWindow
// (Final, Native, Protected)
// Parameters:
// int32                                   SelectID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDLC6FieldMemoriesActor::OnClosedConfirmWindow(int32 SelectID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDLC6FieldMemoriesActor", "OnClosedConfirmWindow");

	Params::ATDLC6FieldMemoriesActor_OnClosedConfirmWindow Parms{};

	Parms.SelectID = SelectID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DepthOfFieldManager.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueFlag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_DepthOfFieldManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool bContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DepthOfFieldManager", "OnDemoTiming");

	Params::AT_DepthOfFieldManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.bContinueFlag = bContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_EffectStatics.BeginTrail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  PParticle                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FirstSocketName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SecondSocketName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         WidthMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DestroyOtherParticle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UAT_EffectStatics::BeginTrail(class USkeletalMeshComponent* MeshComp, class UParticleSystem* PParticle, class FName FirstSocketName, class FName SecondSocketName, ETrailWidthMode WidthMode, bool DestroyOtherParticle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "BeginTrail");

	Params::AT_EffectStatics_BeginTrail Parms{};

	Parms.MeshComp = MeshComp;
	Parms.PParticle = PParticle;
	Parms.FirstSocketName = FirstSocketName;
	Parms.SecondSocketName = SecondSocketName;
	Parms.WidthMode = WidthMode;
	Parms.DestroyOtherParticle = DestroyOtherParticle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_EffectStatics.CallGuardHitEffectCPP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageOwner                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  EffectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OffsetSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_EffectStatics::CallGuardHitEffectCPP(class AActor* HitActor, class AActor* DamageOwner, class UParticleSystem* EffectType, float OffsetSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "CallGuardHitEffectCPP");

	Params::AT_EffectStatics_CallGuardHitEffectCPP Parms{};

	Parms.HitActor = HitActor;
	Parms.DamageOwner = DamageOwner;
	Parms.EffectType = EffectType;
	Parms.OffsetSize = OffsetSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_EffectStatics.CallHitEffectCPP
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          HitPosition                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Origin                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           HitActor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystem*                  Effect                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           AttachToActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UAT_EffectStatics::CallHitEffectCPP(const struct FVector& HitPosition, const struct FVector& Origin, class AActor* HitActor, class UParticleSystem* Effect, const struct FRotator& Rotation, class AActor* AttachToActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "CallHitEffectCPP");

	Params::AT_EffectStatics_CallHitEffectCPP Parms{};

	Parms.HitPosition = std::move(HitPosition);
	Parms.Origin = std::move(Origin);
	Parms.HitActor = HitActor;
	Parms.Effect = Effect;
	Parms.Rotation = std::move(Rotation);
	Parms.AttachToActor = AttachToActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_EffectStatics.DrawPhysicalSurfaceDebug
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Res                                                    (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          VStart                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          VEnd                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_EffectStatics::DrawPhysicalSurfaceDebug(class AActor* Character, ETraceTypeQuery TraceType, const struct FHitResult& Res, const struct FVector& VStart, const struct FVector& VEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "DrawPhysicalSurfaceDebug");

	Params::AT_EffectStatics_DrawPhysicalSurfaceDebug Parms{};

	Parms.Character = Character;
	Parms.TraceType = TraceType;
	Parms.Res = std::move(Res);
	Parms.VStart = std::move(VStart);
	Parms.VEnd = std::move(VEnd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_EffectStatics.EndTrail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_EffectStatics::EndTrail(class USkeletalMeshComponent* MeshComp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "EndTrail");

	Params::AT_EffectStatics_EndTrail Parms{};

	Parms.MeshComp = MeshComp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_EffectStatics.EnlargeEffect
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UParticleSystemComponent*         Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   KamehaSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OtherSmokeSize                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_EffectStatics::EnlargeEffect(class UParticleSystemComponent* Component, float KamehaSize, const struct FVector& OtherSmokeSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "EnlargeEffect");

	Params::AT_EffectStatics_EnlargeEffect Parms{};

	Parms.Component = Component;
	Parms.KamehaSize = KamehaSize;
	Parms.OtherSmokeSize = std::move(OtherSmokeSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_EffectStatics.IsNearCamera
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ImpactPoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Thre                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_EffectStatics::IsNearCamera(const struct FVector& ImpactPoint, float Thre)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "IsNearCamera");

	Params::AT_EffectStatics_IsNearCamera Parms{};

	Parms.ImpactPoint = std::move(ImpactPoint);
	Parms.Thre = Thre;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_EffectStatics.IsNearly
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETraceTypeQuery                         TraceType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UAT_EffectStatics::IsNearly(class AActor* Character, ETraceTypeQuery TraceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "IsNearly");

	Params::AT_EffectStatics_IsNearly Parms{};

	Parms.Character = Character;
	Parms.TraceType = TraceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_EffectStatics.IsNearlyGround
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UAT_EffectStatics::IsNearlyGround(class AActor* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "IsNearlyGround");

	Params::AT_EffectStatics_IsNearlyGround Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_EffectStatics.TickTrail
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           MeshComp                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FirstSocketName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SecondSocketName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETrailWidthMode                         WidthMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_EffectStatics::TickTrail(class USkeletalMeshComponent* MeshComp, class FName FirstSocketName, class FName SecondSocketName, ETrailWidthMode WidthMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_EffectStatics", "TickTrail");

	Params::AT_EffectStatics_TickTrail Parms{};

	Parms.MeshComp = MeshComp;
	Parms.FirstSocketName = FirstSocketName;
	Parms.SecondSocketName = SecondSocketName;
	Parms.WidthMode = WidthMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_ExternalEncounterHudComponent.OnEventBattleEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_ExternalEncounterHudComponent::OnEventBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_ExternalEncounterHudComponent", "OnEventBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.UiCaptureSet.CreateSubCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCreateCaptureSetParameter       Parameter                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedSkelMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedLighting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUiCaptureSet::CreateSubCamera(const struct FCreateCaptureSetParameter& Parameter, class UTextureRenderTarget2D* Target, bool NeedSkelMesh, bool NeedLighting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "CreateSubCamera");

	Params::UiCaptureSet_CreateSubCamera Parms{};

	Parms.Parameter = std::move(Parameter);
	Parms.Target = Target;
	Parms.NeedSkelMesh = NeedSkelMesh;
	Parms.NeedLighting = NeedLighting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UiCaptureSet.DestroyActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ActorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUiCaptureSet::DestroyActor(int32 ActorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "DestroyActor");

	Params::UiCaptureSet_DestroyActor Parms{};

	Parms.ActorId = ActorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UiCaptureSet.DestroyAllActors
// (Final, Native, Public, BlueprintCallable)

void UUiCaptureSet::DestroyAllActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "DestroyAllActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.UiCaptureSet.GetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ActorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInUseCapturedCharacter                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UUiCaptureSet::GetActor(int32 ActorId, bool bInUseCapturedCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "GetActor");

	Params::UiCaptureSet_GetActor Parms{};

	Parms.ActorId = ActorId;
	Parms.bInUseCapturedCharacter = bInUseCapturedCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.UiCaptureSet.GetCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneCaptureComponent2D*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneCaptureComponent2D* UUiCaptureSet::GetCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "GetCamera");

	Params::UiCaptureSet_GetCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.UiCaptureSet.GetCameraActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASceneCapture2D*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASceneCapture2D* UUiCaptureSet::GetCameraActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "GetCameraActor");

	Params::UiCaptureSet_GetCameraActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.UiCaptureSet.MoveCaptureSet
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UUiCaptureSet::MoveCaptureSet(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "MoveCaptureSet");

	Params::UiCaptureSet_MoveCaptureSet Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UiCaptureSet.RequestSpawnByMasterId
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             MasterId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UUiCaptureSet::RequestSpawnByMasterId(const struct FTransform& Transform, class FName MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "RequestSpawnByMasterId");

	Params::UiCaptureSet_RequestSpawnByMasterId Parms{};

	Parms.Transform = std::move(Transform);
	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.UiCaptureSet.RequestSpawnCharacter
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   VariationId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   FormID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MasterId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAT_CapturedCharacter*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AAT_CapturedCharacter* UUiCaptureSet::RequestSpawnCharacter(const struct FTransform& Transform, ECHARACTER_TYPE CharacterType, class FName UniqueId, uint8 VariationId, uint8 FormID, class FName MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "RequestSpawnCharacter");

	Params::UiCaptureSet_RequestSpawnCharacter Parms{};

	Parms.Transform = std::move(Transform);
	Parms.CharacterType = CharacterType;
	Parms.UniqueId = UniqueId;
	Parms.VariationId = VariationId;
	Parms.FormID = FormID;
	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.UiCaptureSet.SetCameraShowFlags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NeedSkelMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedLighting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUiCaptureSet::SetCameraShowFlags(bool NeedSkelMesh, bool NeedLighting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "SetCameraShowFlags");

	Params::UiCaptureSet_SetCameraShowFlags Parms{};

	Parms.NeedSkelMesh = NeedSkelMesh;
	Parms.NeedLighting = NeedLighting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.UiCaptureSet.SetRenderTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUiCaptureSet::SetRenderTarget(class UTextureRenderTarget2D* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UiCaptureSet", "SetRenderTarget");

	Params::UiCaptureSet_SetRenderTarget Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.GetUIFieldManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIFieldManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIFieldManager* AAT_GameHUD::GetUIFieldManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "GetUIFieldManager");

	Params::AT_GameHUD_GetUIFieldManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameHUD.GetUIMiniGameManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIMiniGameManager*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIMiniGameManager* AAT_GameHUD::GetUIMiniGameManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "GetUIMiniGameManager");

	Params::AT_GameHUD_GetUIMiniGameManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameHUD.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnDemoTiming");

	Params::AT_GameHUD_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnDisableBalloonDragonball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NDbIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnDisableBalloonDragonball(class AActor* PActor, int32 NDbIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnDisableBalloonDragonball");

	Params::AT_GameHUD_OnDisableBalloonDragonball Parms{};

	Parms.PActor = PActor;
	Parms.NDbIdx = NDbIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnEnableBalloonDragonball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NDbIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnEnableBalloonDragonball(class AActor* PActor, int32 NDbIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnEnableBalloonDragonball");

	Params::AT_GameHUD_OnEnableBalloonDragonball Parms{};

	Parms.PActor = PActor;
	Parms.NDbIdx = NDbIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnGetDragonball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NDbIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnGetDragonball(class AActor* PActor, int32 NDbIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnGetDragonball");

	Params::AT_GameHUD_OnGetDragonball Parms{};

	Parms.PActor = PActor;
	Parms.NDbIdx = NDbIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnLoadCompleted
// (Final, Native, Protected)

void AAT_GameHUD::OnLoadCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnLoadCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnMobFrontMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Speaker                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    buttonVisible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnMobFrontMessage(const class FString& Speaker, const class FString& Message, bool buttonVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnMobFrontMessage");

	Params::AT_GameHUD_OnMobFrontMessage Parms{};

	Parms.Speaker = std::move(Speaker);
	Parms.Message = std::move(Message);
	Parms.buttonVisible = buttonVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnMobMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Speaker                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    buttonVisible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnMobMessage(const class FString& Speaker, const class FString& Message, bool buttonVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnMobMessage");

	Params::AT_GameHUD_OnMobMessage Parms{};

	Parms.Speaker = std::move(Speaker);
	Parms.Message = std::move(Message);
	Parms.buttonVisible = buttonVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnSpawnedDragonball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NDbIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnSpawnedDragonball(class AActor* PActor, int32 NDbIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnSpawnedDragonball");

	Params::AT_GameHUD_OnSpawnedDragonball Parms{};

	Parms.PActor = PActor;
	Parms.NDbIdx = NDbIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnVisibleDragonBallActIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnVisibleDragonBallActIcon(bool bVisible, class AActor* PActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnVisibleDragonBallActIcon");

	Params::AT_GameHUD_OnVisibleDragonBallActIcon Parms{};

	Parms.bVisible = bVisible;
	Parms.PActor = PActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.OnVisibleMobSerif
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::OnVisibleMobSerif(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "OnVisibleMobSerif");

	Params::AT_GameHUD_OnVisibleMobSerif Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.ResetDragonBallComp
// (Final, Native, Public, BlueprintCallable)

void AAT_GameHUD::ResetDragonBallComp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "ResetDragonBallComp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.SetHudVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::SetHudVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "SetHudVisible");

	Params::AT_GameHUD_SetHudVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameHUD.SetWidePosition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bWidePosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_GameHUD::SetWidePosition(bool bWidePosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameHUD", "SetWidePosition");

	Params::AT_GameHUD_SetWidePosition Parms{};

	Parms.bWidePosition = bWidePosition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameInstance.CompleteLoadTerrainDecorateResouces
// (Final, Native, Public)

void UAT_GameInstance::CompleteLoadTerrainDecorateResouces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "CompleteLoadTerrainDecorateResouces");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_GameInstance.GetCmnFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UICmnFade*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UICmnFade* UAT_GameInstance::GetCmnFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "GetCmnFade");

	Params::AT_GameInstance_GetCmnFade Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameInstance.GetCmnSystemDialog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIXcmnSystemDialog*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIXcmnSystemDialog* UAT_GameInstance::GetCmnSystemDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "GetCmnSystemDialog");

	Params::AT_GameInstance_GetCmnSystemDialog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameInstance.GetCmnSystemIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIXcmnSystemIcon*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIXcmnSystemIcon* UAT_GameInstance::GetCmnSystemIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "GetCmnSystemIcon");

	Params::AT_GameInstance_GetCmnSystemIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameInstance.GetInstallUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIXcmnInstall*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIXcmnInstall* UAT_GameInstance::GetInstallUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "GetInstallUI");

	Params::AT_GameInstance_GetInstallUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameInstance.GetLoadScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UILoadingScreen*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UILoadingScreen* UAT_GameInstance::GetLoadScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "GetLoadScreen");

	Params::AT_GameInstance_GetLoadScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_GameInstance.LLM_ManualOutput
// (Final, Native, Public)

void UAT_GameInstance::LLM_ManualOutput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_GameInstance", "LLM_ManualOutput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUIEmbeddedMovie.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UATUIEmbeddedMovie::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUIEmbeddedMovie", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_MobAnimalBase.Get_AnimalParameter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FAnimalParameterTable            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAnimalParameterTable AAT_MobAnimalBase::Get_AnimalParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobAnimalBase", "Get_AnimalParameter");

	Params::AT_MobAnimalBase_Get_AnimalParameter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_MobAnimalBase.OnActionChange
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAT_MobAnimalBase::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobAnimalBase", "OnActionChange");

	Params::AT_MobAnimalBase_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_MobCharacter.CreateMessageWindow
// (Event, Public, BlueprintEvent)

void AAT_MobCharacter::CreateMessageWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_MobCharacter", "CreateMessageWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_TriggerStaticActorInterface.IsTouch
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IAT_TriggerStaticActorInterface::IsTouch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_TriggerStaticActorInterface", "IsTouch");

	Params::AT_TriggerStaticActorInterface_IsTouch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UI3DCaptureWidget.AddRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   XAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::AddRotation(float XAngle, float YAngle, float ZAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "AddRotation");

	Params::AT_UI3DCaptureWidget_AddRotation Parms{};

	Parms.XAngle = XAngle;
	Parms.YAngle = YAngle;
	Parms.ZAngle = ZAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.AddRotationHorizontal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InPower                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::AddRotationHorizontal(float InPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "AddRotationHorizontal");

	Params::AT_UI3DCaptureWidget_AddRotationHorizontal Parms{};

	Parms.InPower = InPower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.AddTranslate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::AddTranslate(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "AddTranslate");

	Params::AT_UI3DCaptureWidget_AddTranslate Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.CompleteLoadFacialParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::CompleteLoadFacialParts(class UATDataAssetFacialAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "CompleteLoadFacialParts");

	Params::AT_UI3DCaptureWidget_CompleteLoadFacialParts Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.CompleteLoadForm
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::CompleteLoadForm(class UATDataAssetFormMeshAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "CompleteLoadForm");

	Params::AT_UI3DCaptureWidget_CompleteLoadForm Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.CompleteLoadFormId
// (Final, Native, Public)
// Parameters:
// class UATDataAssetUiCaptureAsyncLoad*   Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::CompleteLoadFormId(class UATDataAssetUiCaptureAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "CompleteLoadFormId");

	Params::AT_UI3DCaptureWidget_CompleteLoadFormId Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.CompleteLoadVariation
// (Final, Native, Public)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::CompleteLoadVariation(class UATDataAssetVariationMeshAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "CompleteLoadVariation");

	Params::AT_UI3DCaptureWidget_CompleteLoadVariation Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.CreatePostProcess
// (Event, Public, BlueprintEvent)

void UAT_UI3DCaptureWidget::CreatePostProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "CreatePostProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UI3DCaptureWidget.Destroy
// (Final, Native, Public, BlueprintCallable)

void UAT_UI3DCaptureWidget::Destroy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "Destroy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.DestroyPostProcess
// (Event, Public, BlueprintEvent)

void UAT_UI3DCaptureWidget::DestroyPostProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "DestroyPostProcess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UI3DCaptureWidget.LoadModel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           ModelPath                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AnimPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AnimBPPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MontagePath                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MasterId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::LoadModel(const class FString& ModelPath, const class FString& AnimPath, const class FString& AnimBPPath, const class FString& MontagePath, const class FName& MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "LoadModel");

	Params::AT_UI3DCaptureWidget_LoadModel Parms{};

	Parms.ModelPath = std::move(ModelPath);
	Parms.AnimPath = std::move(AnimPath);
	Parms.AnimBPPath = std::move(AnimBPPath);
	Parms.MontagePath = std::move(MontagePath);
	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.LoadModelByCharacterType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AnimId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FaceId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbAppendId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::LoadModelByCharacterType(ECHARACTER_TYPE Type, uint8 Variation, uint8 Form, const class FString& AnimId, const class FString& FaceId, bool InbAppendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "LoadModelByCharacterType");

	Params::AT_UI3DCaptureWidget_LoadModelByCharacterType Parms{};

	Parms.Type = Type;
	Parms.Variation = Variation;
	Parms.Form = Form;
	Parms.AnimId = std::move(AnimId);
	Parms.FaceId = std::move(FaceId);
	Parms.InbAppendId = InbAppendId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.LoadModelById
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             MasterId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::LoadModelById(class FName MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "LoadModelById");

	Params::AT_UI3DCaptureWidget_LoadModelById Parms{};

	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.LoadModelByUniqueId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             UniqueId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AnimId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FaceId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbAppendId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::LoadModelByUniqueId(ECHARACTER_TYPE Type, const class FName& UniqueId, uint8 Variation, uint8 Form, const class FString& AnimId, const class FString& FaceId, bool InbAppendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "LoadModelByUniqueId");

	Params::AT_UI3DCaptureWidget_LoadModelByUniqueId Parms{};

	Parms.Type = Type;
	Parms.UniqueId = UniqueId;
	Parms.Variation = Variation;
	Parms.Form = Form;
	Parms.AnimId = std::move(AnimId);
	Parms.FaceId = std::move(FaceId);
	Parms.InbAppendId = InbAppendId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.LoadParticle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           ParticlePath                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MasterId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::LoadParticle(const class FString& ParticlePath, const class FName& MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "LoadParticle");

	Params::AT_UI3DCaptureWidget_LoadParticle Parms{};

	Parms.ParticlePath = std::move(ParticlePath);
	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.SetCameraTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTransform                       Trans                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::SetCameraTransform(const struct FTransform& Trans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetCameraTransform");

	Params::AT_UI3DCaptureWidget_SetCameraTransform Parms{};

	Parms.Trans = std::move(Trans);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.SetFOV
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FOV                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::SetFOV(float FOV)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetFOV");

	Params::AT_UI3DCaptureWidget_SetFOV Parms{};

	Parms.FOV = FOV;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.SetLoadIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::SetLoadIcon(class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetLoadIcon");

	Params::AT_UI3DCaptureWidget_SetLoadIcon Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.SetModelColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::SetModelColor(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetModelColor");

	Params::AT_UI3DCaptureWidget_SetModelColor Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.SetModelInitRotation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   XAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   YAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ZAngle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::SetModelInitRotation(float XAngle, float YAngle, float ZAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetModelInitRotation");

	Params::AT_UI3DCaptureWidget_SetModelInitRotation Parms{};

	Parms.XAngle = XAngle;
	Parms.YAngle = YAngle;
	Parms.ZAngle = ZAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.SetRenderTargetEvent
// (Event, Public, BlueprintEvent)

void UAT_UI3DCaptureWidget::SetRenderTargetEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetRenderTargetEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UI3DCaptureWidget.SetRenderTargetFromIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::SetRenderTargetFromIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "SetRenderTargetFromIndex");

	Params::AT_UI3DCaptureWidget_SetRenderTargetFromIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.UnLoadModel
// (Final, Native, Public, BlueprintCallable)

void UAT_UI3DCaptureWidget::UnLoadModel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "UnLoadModel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.UpdateCameraTransform
// (Final, Native, Public, BlueprintCallable)

void UAT_UI3DCaptureWidget::UpdateCameraTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "UpdateCameraTransform");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.Zoom
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UI3DCaptureWidget::Zoom(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "Zoom");

	Params::AT_UI3DCaptureWidget_Zoom Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UI3DCaptureWidget.GetCameraLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAT_UI3DCaptureWidget::GetCameraLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "GetCameraLocation");

	Params::AT_UI3DCaptureWidget_GetCameraLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UI3DCaptureWidget.GetCameraTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FTransform UAT_UI3DCaptureWidget::GetCameraTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "GetCameraTransform");

	Params::AT_UI3DCaptureWidget_GetCameraTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UI3DCaptureWidget.GetCurrentModelColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UAT_UI3DCaptureWidget::GetCurrentModelColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "GetCurrentModelColor");

	Params::AT_UI3DCaptureWidget_GetCurrentModelColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UI3DCaptureWidget.GetZoomRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAT_UI3DCaptureWidget::GetZoomRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "GetZoomRate");

	Params::AT_UI3DCaptureWidget_GetZoomRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UI3DCaptureWidget.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UI3DCaptureWidget::IsLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UI3DCaptureWidget", "IsLoaded");

	Params::AT_UI3DCaptureWidget_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIAssaultEvent_Gauge.OnBattleStart
// (Final, Native, Public)

void UAT_UIAssaultEvent_Gauge::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIAssaultEvent_Gauge", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCond.ConstructFirstOnly
// (Event, Public, BlueprintEvent)

void UAT_UIBattleCond::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCond", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIBattleCond.OnBattleCutinEnd
// (Final, Native, Public)
// Parameters:
// EBattleCutin_AnimType                   InAnimType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCond::OnBattleCutinEnd(EBattleCutin_AnimType InAnimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCond", "OnBattleCutinEnd");

	Params::AT_UIBattleCond_OnBattleCutinEnd Parms{};

	Parms.InAnimType = InAnimType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCond.OnEndEventBattle
// (Final, Native, Public)

void UAT_UIBattleCond::OnEndEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCond", "OnEndEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCond.OnStartEventBattle
// (Final, Native, Public)

void UAT_UIBattleCond::OnStartEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCond", "OnStartEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.DebugDamageBoostCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCrowd::DebugDamageBoostCount(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "DebugDamageBoostCount");

	Params::AT_UIBattleCrowd_DebugDamageBoostCount Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.DebugPlayStart
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleCrowd::DebugPlayStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "DebugPlayStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.DebugRemainingEnemiesCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCrowd::DebugRemainingEnemiesCount(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "DebugRemainingEnemiesCount");

	Params::AT_UIBattleCrowd_DebugRemainingEnemiesCount Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.DebugSetOverKillNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCrowd::DebugSetOverKillNum(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "DebugSetOverKillNum");

	Params::AT_UIBattleCrowd_DebugSetOverKillNum Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.InitEnemiesCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCrowd::InitEnemiesCount(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "InitEnemiesCount");

	Params::AT_UIBattleCrowd_InitEnemiesCount Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.OnBattleEnd
// (Final, Native, Public)

void UAT_UIBattleCrowd::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.OnBattleStart
// (Final, Native, Public)

void UAT_UIBattleCrowd::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.OnCountupFinish
// (Final, Native, Public)
// Parameters:
// int32                                   FinishNum                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCrowd::OnCountupFinish(int32 FinishNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "OnCountupFinish");

	Params::AT_UIBattleCrowd_OnCountupFinish Parms{};

	Parms.FinishNum = FinishNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.OnRemaingAnimationEnd
// (Final, Native, Public)

void UAT_UIBattleCrowd::OnRemaingAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "OnRemaingAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowd.OnZcmbAnimationFinish
// (Final, Native, Public)

void UAT_UIBattleCrowd::OnZcmbAnimationFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowd", "OnZcmbAnimationFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBoostDamage.OnComboAddEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIBoostDamage::OnComboAddEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBoostDamage", "OnComboAddEvent");

	Params::AT_UIBoostDamage_OnComboAddEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBoostDamage.OnComboEndEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIBoostDamage::OnComboEndEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBoostDamage", "OnComboEndEvent");

	Params::AT_UIBoostDamage_OnComboEndEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowdResult.DebugRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrowdResultType                        ResultType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrowdResultRank                        Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleCrowdResult::DebugRequest(ECrowdResultType ResultType, ECrowdResultRank Rank, int32 Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowdResult", "DebugRequest");

	Params::AT_UIBattleCrowdResult_DebugRequest Parms{};

	Parms.ResultType = ResultType;
	Parms.Rank = Rank;
	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleCrowdResult.StartAnimRank
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleCrowdResult::StartAnimRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleCrowdResult", "StartAnimRank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleStraightBoost.DamageApplied
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActGroundBattleStraightBoost::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleStraightBoost", "DamageApplied");

	Params::ATActGroundBattleStraightBoost_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.OnBattleEnd
// (Final, Native, Public)

void UAT_UIBattleHudEnemy::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.OnBattleStart
// (Final, Native, Public)

void UAT_UIBattleHudEnemy::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.OnChangeTarget
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTargetEnemy                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::OnChangeTarget(class AAT_Character* InOwner, class AActor* InTargetEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "OnChangeTarget");

	Params::AT_UIBattleHudEnemy_OnChangeTarget Parms{};

	Parms.InOwner = InOwner;
	Parms.InTargetEnemy = InTargetEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.OnEvtBattleEnd
// (Final, Native, Public)

void UAT_UIBattleHudEnemy::OnEvtBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "OnEvtBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.OnEvtBattleStart
// (Final, Native, Public)

void UAT_UIBattleHudEnemy::OnEvtBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "OnEvtBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.OnExitMember
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   MemberType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::OnExitMember(const struct FPartyMember& InMember, uint8 MemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "OnExitMember");

	Params::AT_UIBattleHudEnemy_OnExitMember Parms{};

	Parms.InMember = std::move(InMember);
	Parms.MemberType = MemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.SetDebugBarMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InBar                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::SetDebugBarMax(int32 InBar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "SetDebugBarMax");

	Params::AT_UIBattleHudEnemy_SetDebugBarMax Parms{};

	Parms.InBar = InBar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.SetDebugBreak
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnim                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::SetDebugBreak(int32 InVal, bool bAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "SetDebugBreak");

	Params::AT_UIBattleHudEnemy_SetDebugBreak Parms{};

	Parms.InVal = InVal;
	Parms.bAnim = bAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.SetDebugBreakMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::SetDebugBreakMax(int32 InMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "SetDebugBreakMax");

	Params::AT_UIBattleHudEnemy_SetDebugBreakMax Parms{};

	Parms.InMax = InMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.SetDebugHp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InVal                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnim                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::SetDebugHp(int32 InVal, bool bAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "SetDebugHp");

	Params::AT_UIBattleHudEnemy_SetDebugHp Parms{};

	Parms.InVal = InVal;
	Parms.bAnim = bAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleHudEnemy.SetDebugHpMax
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InMax                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleHudEnemy::SetDebugHpMax(int32 InMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleHudEnemy", "SetDebugHpMax");

	Params::AT_UIBattleHudEnemy_SetDebugHpMax Parms{};

	Parms.InMax = InMax;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleInfoChallenge.OnBattleEnd
// (Final, Native, Public)

void UAT_UIBattleInfoChallenge::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleInfoChallenge", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleInfoChallenge.OnBattleStart
// (Final, Native, Public)

void UAT_UIBattleInfoChallenge::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleInfoChallenge", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEnemiesBaseBehaviour.OnCollisionOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATEnemiesBaseBehaviour::OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEnemiesBaseBehaviour", "OnCollisionOverlapBegin");

	Params::ATEnemiesBaseBehaviour_OnCollisionOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleRescueParts.OnBattleStart
// (Final, Native, Protected)

void UAT_UIBattleRescueParts::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleRescueParts", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleResult.InitSetting
// (Event, Protected, BlueprintEvent)

void UAT_UIBattleResult::InitSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleResult", "InitSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIBattleResult.OnEndBattleResultCount
// (Final, Native, Private)

void UAT_UIBattleResult::OnEndBattleResultCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleResult", "OnEndBattleResultCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleResult.RequestStartAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleResult::RequestStartAnim(int32 Rank, int32 TotalExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleResult", "RequestStartAnim");

	Params::AT_UIBattleResult_RequestStartAnim Parms{};

	Parms.Rank = Rank;
	Parms.TotalExp = TotalExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleResult.StartAnimCloudStart
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleResult::StartAnimCloudStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleResult", "StartAnimCloudStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleResult.StartAnimRank
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleResult::StartAnimRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleResult", "StartAnimRank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleResult.TestRequestAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   AnimType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleResult::TestRequestAnim(int32 AnimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleResult", "TestRequestAnim");

	Params::AT_UIBattleResult_TestRequestAnim Parms{};

	Parms.AnimType = AnimType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTime.OnBattleEnd
// (Final, Native, Public)

void UAT_UIBattleTime::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTime", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTime.OnBattleStart
// (Final, Native, Public)

void UAT_UIBattleTime::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTime", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTime.OnEventBattleStart
// (Final, Native, Public)

void UAT_UIBattleTime::OnEventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTime", "OnEventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleCounterZComboCount.OnActionChange
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEventBattleCounterZComboCount::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleCounterZComboCount", "OnActionChange");

	Params::ATEventBattleCounterZComboCount_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.OnBattleEnd
// (Final, Native, Public)

void UAT_UIBattleTipsTutorial::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.OnBattleStart
// (Final, Native, Public)

void UAT_UIBattleTipsTutorial::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.OnChangePlayer
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleTipsTutorial::OnChangePlayer(class AAT_Character* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "OnChangePlayer");

	Params::AT_UIBattleTipsTutorial_OnChangePlayer Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleTipsTutorial::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.SetCtrlMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyGuideCtrlMode                       InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleTipsTutorial::SetCtrlMode(EKeyGuideCtrlMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "SetCtrlMode");

	Params::AT_UIBattleTipsTutorial_SetCtrlMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.SetGuideType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyGuideType                           InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIBattleTipsTutorial::SetGuideType(EKeyGuideType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "SetGuideType");

	Params::AT_UIBattleTipsTutorial_SetGuideType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBattleTipsTutorial.SetTutorialQuestSetting
// (Final, Native, Public, BlueprintCallable)

void UAT_UIBattleTipsTutorial::SetTutorialQuestSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBattleTipsTutorial", "SetTutorialQuestSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEnvironmentEffectManager.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEnvironmentEffectManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEnvironmentEffectManager", "OnDemoTiming");

	Params::ATEnvironmentEffectManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBootLogo.IsComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIBootLogo::IsComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBootLogo", "IsComplete");

	Params::AT_UIBootLogo_IsComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIBootLogo.IsLoadComplete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIBootLogo::IsLoadComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBootLogo", "IsLoadComplete");

	Params::AT_UIBootLogo_IsLoadComplete Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIChoiceWin.Choice_Exit
// (Final, Native, Public, BlueprintCallable)

void UAT_UIChoiceWin::Choice_Exit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIChoiceWin", "Choice_Exit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmn00MenuList7.RequestPlayActiveAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UICmn00MenuList7::RequestPlayActiveAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmn00MenuList7", "RequestPlayActiveAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.ExitDoor
// (Final, Native, Static, Public, BlueprintCallable)

void UATLevelBlueprintFunctionLibrary::ExitDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "ExitDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.GetEventTriggerValue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UATLevelBlueprintFunctionLibrary::GetEventTriggerValue(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "GetEventTriggerValue");

	Params::ATLevelBlueprintFunctionLibrary_GetEventTriggerValue Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATLevelBlueprintFunctionLibrary.GetLevelManager
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AATLevelManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AATLevelManager* UATLevelBlueprintFunctionLibrary::GetLevelManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "GetLevelManager");

	Params::ATLevelBlueprintFunctionLibrary_GetLevelManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATLevelBlueprintFunctionLibrary.IsEventTriggerTrue
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATLevelBlueprintFunctionLibrary::IsEventTriggerTrue(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "IsEventTriggerTrue");

	Params::ATLevelBlueprintFunctionLibrary_IsEventTriggerTrue Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATLevelBlueprintFunctionLibrary.IsInDoor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATLevelBlueprintFunctionLibrary::IsInDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "IsInDoor");

	Params::ATLevelBlueprintFunctionLibrary_IsInDoor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATLevelBlueprintFunctionLibrary.Level_ActivateSubLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::Level_ActivateSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "Level_ActivateSubLevel");

	Params::ATLevelBlueprintFunctionLibrary_Level_ActivateSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.Level_DeactivateSubLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::Level_DeactivateSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "Level_DeactivateSubLevel");

	Params::ATLevelBlueprintFunctionLibrary_Level_DeactivateSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.Level_LoadSubLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::Level_LoadSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "Level_LoadSubLevel");

	Params::ATLevelBlueprintFunctionLibrary_Level_LoadSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.Level_UnloadSubLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::Level_UnloadSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "Level_UnloadSubLevel");

	Params::ATLevelBlueprintFunctionLibrary_Level_UnloadSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.RemoveLevelCondition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             LevelConditionId                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::RemoveLevelCondition(const class FName& LevelConditionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "RemoveLevelCondition");

	Params::ATLevelBlueprintFunctionLibrary_RemoveLevelCondition Parms{};

	Parms.LevelConditionId = LevelConditionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.RequestEvent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FATLevelEventParam               Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::RequestEvent(const struct FATLevelEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "RequestEvent");

	Params::ATLevelBlueprintFunctionLibrary_RequestEvent Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelBlueprintFunctionLibrary.RequestFlagInWorldMap
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           InFlagName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelBlueprintFunctionLibrary::RequestFlagInWorldMap(const class FString& InFlagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATLevelBlueprintFunctionLibrary", "RequestFlagInWorldMap");

	Params::ATLevelBlueprintFunctionLibrary_RequestFlagInWorldMap Parms{};

	Parms.InFlagName = std::move(InFlagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ItemTrader.OnFinishedTalking
// (Final, Native, Public)

void UItemTrader::OnFinishedTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemTrader", "OnFinishedTalking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnFade.StartFade
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUMG_FADE_TYPE                          FadeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMG_FADE_COLOR                         FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSecond                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETWEEN_TYPE                             TweenType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnFade::StartFade(EUMG_FADE_TYPE FadeType, EUMG_FADE_COLOR FadeColor, float FadeSecond, ETWEEN_TYPE TweenType, float StartDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnFade", "StartFade");

	Params::AT_UICmnFade_StartFade Parms{};

	Parms.FadeType = FadeType;
	Parms.FadeColor = FadeColor;
	Parms.FadeSecond = FadeSecond;
	Parms.TweenType = TweenType;
	Parms.StartDelay = StartDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnFade.StartFadeWihthParam
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EUMG_FADE_TYPE                          FadeType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FadeSecond                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETWEEN_TYPE                             TweenType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDelay                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnFade::StartFadeWihthParam(EUMG_FADE_TYPE FadeType, const struct FLinearColor& FadeColor, float FadeSecond, ETWEEN_TYPE TweenType, float StartDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnFade", "StartFadeWihthParam");

	Params::AT_UICmnFade_StartFadeWihthParam Parms{};

	Parms.FadeType = FadeType;
	Parms.FadeColor = std::move(FadeColor);
	Parms.FadeSecond = FadeSecond;
	Parms.TweenType = TweenType;
	Parms.StartDelay = StartDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UILoadingScreen.Ev_Anm_Change_Tips00
// (Final, Native, Protected, BlueprintCallable)

void UAT_UILoadingScreen::Ev_Anm_Change_Tips00()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "Ev_Anm_Change_Tips00");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UILoadingScreen.InitSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSimple                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UILoadingScreen::InitSetting(bool IsSimple)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "InitSetting");

	Params::AT_UILoadingScreen_InitSetting Parms{};

	Parms.IsSimple = IsSimple;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UILoadingScreen.IsEndAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UILoadingScreen::IsEndAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "IsEndAnim");

	Params::AT_UILoadingScreen_IsEndAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UILoadingScreen.IsInactive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UILoadingScreen::IsInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "IsInactive");

	Params::AT_UILoadingScreen_IsInactive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UILoadingScreen.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UILoadingScreen::RequestPlayInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "RequestPlayInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UILoadingScreen.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UILoadingScreen::RequestPlayOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "RequestPlayOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UILoadingScreen.SetVisibleProgressBar
// (Final, Native, Protected, BlueprintCallable)

void UAT_UILoadingScreen::SetVisibleProgressBar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "SetVisibleProgressBar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UILoadingScreen.UpdateProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UILoadingScreen::UpdateProgress(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UILoadingScreen", "UpdateProgress");

	Params::AT_UILoadingScreen_UpdateProgress Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LipSyncUtils.GetAreaRowByName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDataTable*                       DataTable                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PName                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLipSyncAreaData                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLipSyncAreaData ULipSyncUtils::GetAreaRowByName(class UDataTable* DataTable, class FName PName, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LipSyncUtils", "GetAreaRowByName");

	Params::LipSyncUtils_GetAreaRowByName Parms{};

	Parms.DataTable = DataTable;
	Parms.PName = PName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function AT.AT_UICmnLoadingBar.IsEndAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UICmnLoadingBar::IsEndAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnLoadingBar", "IsEndAnim");

	Params::AT_UICmnLoadingBar_IsEndAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UICmnLoadingBar.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UICmnLoadingBar::RequestPlayInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnLoadingBar", "RequestPlayInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnLoadingBar.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UICmnLoadingBar::RequestPlayOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnLoadingBar", "RequestPlayOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnLoadingBar.SetProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnLoadingBar::SetProgress(float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnLoadingBar", "SetProgress");

	Params::AT_UICmnLoadingBar_SetProgress Parms{};

	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTab.ChangeEnableSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLeft                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnTab::ChangeEnableSelect(bool IsLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTab", "ChangeEnableSelect");

	Params::AT_UICmnTab_ChangeEnableSelect Parms{};

	Parms.IsLeft = IsLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTab.InitCategoryIcon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCmnTabIconParam>         IconTypeCtn                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UICmnTab::InitCategoryIcon(const TArray<struct FCmnTabIconParam>& IconTypeCtn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTab", "InitCategoryIcon");

	Params::AT_UICmnTab_InitCategoryIcon Parms{};

	Parms.IconTypeCtn = std::move(IconTypeCtn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTab.RequestPlayEnterAnim
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLeftArraw                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnTab::RequestPlayEnterAnim(bool IsLeftArraw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTab", "RequestPlayEnterAnim");

	Params::AT_UICmnTab_RequestPlayEnterAnim Parms{};

	Parms.IsLeftArraw = IsLeftArraw;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTab.SetDisableSelectAll
// (Final, Native, Public, BlueprintCallable)

void UAT_UICmnTab::SetDisableSelectAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTab", "SetDisableSelectAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTab.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnTab::SetEnable(int32 Index_0, bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTab", "SetEnable");

	Params::AT_UICmnTab_SetEnable Parms{};

	Parms.Index_0 = Index_0;
	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTab.SetEnableSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICmnTab::SetEnableSelect(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTab", "SetEnableSelect");

	Params::AT_UICmnTab_SetEnableSelect Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICmnTabIcon.IconClickEvent
// (Final, Native, Public)

void UAT_UICmnTabIcon::IconClickEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICmnTabIcon", "IconClickEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleGuardAround.TargetResetting
// (Final, Native, Private)

void UATActGroundBattleGuardAround::TargetResetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleGuardAround", "TargetResetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnBattleEnd
// (Final, Native, Protected)

void UAT_UICommandPalette::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnBattleStart
// (Final, Native, Protected)

void UAT_UICommandPalette::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnBeginCoopSkill
// (Final, Native, Protected)

void UAT_UICommandPalette::OnBeginCoopSkill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnBeginCoopSkill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnEntrySupport
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   InMemberType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommandPalette::OnEntrySupport(const struct FPartyMember& InMember, uint8 InMemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnEntrySupport");

	Params::AT_UICommandPalette_OnEntrySupport Parms{};

	Parms.InMember = std::move(InMember);
	Parms.InMemberType = InMemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnEventBattleStart
// (Final, Native, Protected)

void UAT_UICommandPalette::OnEventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnEventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnExitSupport
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   InMemberType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommandPalette::OnExitSupport(const struct FPartyMember& InMember, uint8 InMemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnExitSupport");

	Params::AT_UICommandPalette_OnExitSupport Parms{};

	Parms.InMember = std::move(InMember);
	Parms.InMemberType = InMemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnLoadedSpecialNameForLongAttackParam
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          LoadOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommandPalette::OnLoadedSpecialNameForLongAttackParam(class UATDataAssetUiAsyncLoad* LoadOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnLoadedSpecialNameForLongAttackParam");

	Params::AT_UICommandPalette_OnLoadedSpecialNameForLongAttackParam Parms{};

	Parms.LoadOwner = LoadOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnPlayerChange
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommandPalette::OnPlayerChange(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnPlayerChange");

	Params::AT_UICommandPalette_OnPlayerChange Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommandPalette.OnSkillBegin
// (Final, Native, Protected)
// Parameters:
// class USkill*                           Skill                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommandPalette::OnSkillBegin(class USkill* Skill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommandPalette", "OnSkillBegin");

	Params::AT_UICommandPalette_OnSkillBegin Parms{};

	Parms.Skill = Skill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_CapturedCharacter.ApplyAppearance
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CapturedCharacter::ApplyAppearance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CapturedCharacter", "ApplyAppearance");

	Params::AT_CapturedCharacter_ApplyAppearance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_CapturedCharacter.PlayFacialMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAT_CapturedCharacter::PlayFacialMontage(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_CapturedCharacter", "PlayFacialMontage");

	Params::AT_CapturedCharacter_PlayFacialMontage Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIInfoLogBar.ConstructFirstOnly
// (Event, Public, BlueprintEvent)

void UAT_UIInfoLogBar::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIInfoLogBar", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UICommunityBoard.CheckHovered
// (Final, Native, Public)

void UAT_UICommunityBoard::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.EndHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoard::EndHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "EndHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.MouseClickDecide
// (Final, Native, Public)

void UAT_UICommunityBoard::MouseClickDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "MouseClickDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UICommunityBoard::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.MouseClickTabRight
// (Final, Native, Public)

void UAT_UICommunityBoard::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.PlayInCommRank
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoard::PlayInCommRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "PlayInCommRank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.PlayOutCommRank
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoard::PlayOutCommRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "PlayOutCommRank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.SetSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityBoard::SetSelectTab(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "SetSelectTab");

	Params::AT_UICommunityBoard_SetSelectTab Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard.StartHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoard::StartHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard", "StartHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard_PanelFrame.Evt_Anm_Change_Emb
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICommunityBoard_PanelFrame::Evt_Anm_Change_Emb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard_PanelFrame", "Evt_Anm_Change_Emb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard_PanelFrame.Evt_Anm_Get_Emb
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICommunityBoard_PanelFrame::Evt_Anm_Get_Emb()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard_PanelFrame", "Evt_Anm_Get_Emb");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard_PanelFrame.OnLinkBonusChange
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             LinkBonusID                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOccur                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityBoard_PanelFrame::OnLinkBonusChange(const class FName& LinkBonusID, bool bIsOccur)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard_PanelFrame", "OnLinkBonusChange");

	Params::AT_UICommunityBoard_PanelFrame_OnLinkBonusChange Parms{};

	Parms.LinkBonusID = LinkBonusID;
	Parms.bIsOccur = bIsOccur;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoard_PanelFrame.SetReleaseLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   RelLv                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityBoard_PanelFrame::SetReleaseLevel(int32 RelLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoard_PanelFrame", "SetReleaseLevel");

	Params::AT_UICommunityBoard_PanelFrame_SetReleaseLevel Parms{};

	Parms.RelLv = RelLv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoardDetail.CancelMove
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoardDetail::CancelMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoardDetail", "CancelMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoardDetail.CommitMove
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoardDetail::CommitMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoardDetail", "CommitMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoardDetail.Evt_Anim_Rank_Up
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityBoardDetail::Evt_Anim_Rank_Up()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoardDetail", "Evt_Anim_Rank_Up");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoardDetail.SetCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECOMMUNITY_CATEGORY                     InCate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityBoardDetail::SetCategory(ECOMMUNITY_CATEGORY InCate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoardDetail", "SetCategory");

	Params::AT_UICommunityBoardDetail_SetCategory Parms{};

	Parms.InCate = InCate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityBoardDetail.SetPreSubLv
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECOMMUNITY_CATEGORY                     InCate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLv                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityBoardDetail::SetPreSubLv(ECOMMUNITY_CATEGORY InCate, int32 InLv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityBoardDetail", "SetPreSubLv");

	Params::AT_UICommunityBoardDetail_SetPreSubLv Parms{};

	Parms.InCate = InCate;
	Parms.InLv = InLv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemPaletteCustomize.CheckHovered
// (Final, Native, Public)

void UAT_UIItemPaletteCustomize::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemPaletteCustomize", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATC_CharacterActionManager.OnMontageBlendingOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATC_CharacterActionManager::OnMontageBlendingOut(class UAnimMontage* InMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATC_CharacterActionManager", "OnMontageBlendingOut");

	Params::ATC_CharacterActionManager_OnMontageBlendingOut Parms{};

	Parms.InMontage = InMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATC_CharacterActionManager.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     InMontage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATC_CharacterActionManager::OnMontageEnded(class UAnimMontage* InMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATC_CharacterActionManager", "OnMontageEnded");

	Params::ATC_CharacterActionManager_OnMontageEnded Parms{};

	Parms.InMontage = InMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityManager.OnLoadTexture
// (Final, Native, Private)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       InTexture                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityManager::OnLoadTexture(const class FString& InPath, class UTexture2D* InTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityManager", "OnLoadTexture");

	Params::AT_UICommunityManager_OnLoadTexture Parms{};

	Parms.InPath = std::move(InPath);
	Parms.InTexture = InTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityManager.OnLoadWidget
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          InLoader                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICommunityManager::OnLoadWidget(class UATDataAssetUiAsyncLoad* InLoader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityManager", "OnLoadWidget");

	Params::AT_UICommunityManager_OnLoadWidget Parms{};

	Parms.InLoader = InLoader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.CheckHovered
// (Final, Native, Public)

void UAT_UICommunityStart::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UICommunityStart::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UICommunityStart.EndHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityStart::EndHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "EndHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UICommunityStart::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "MouseClickDecide");

	Params::AT_UICommunityStart_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UICommunityStart::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.MouseClickTabRight
// (Final, Native, Public)

void UAT_UICommunityStart::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.OnInEnd
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICommunityStart::OnInEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "OnInEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.OnOutEnd
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICommunityStart::OnOutEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "OnOutEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICommunityStart.StartHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UICommunityStart::StartHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICommunityStart", "StartHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSceneCapture2D.Activate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATSceneCapture2D::Activate(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSceneCapture2D", "Activate");

	Params::ATSceneCapture2D_Activate Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.ChangeArea
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMapM::ChangeArea(const class FName& AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "ChangeArea");

	Params::AT_UIMapM_ChangeArea Parms{};

	Parms.AreaName = AreaName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.ForceClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapM::ForceClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "ForceClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.IsMapTexLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMapM::IsMapTexLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "IsMapTexLoaded");

	Params::AT_UIMapM_IsMapTexLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMapM.IsMapTexValid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMapM::IsMapTexValid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "IsMapTexValid");

	Params::AT_UIMapM_IsMapTexValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMapM.LoadMapTexture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InLevelName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMapM::LoadMapTexture(const class FString& InLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "LoadMapTexture");

	Params::AT_UIMapM_LoadMapTexture Parms{};

	Parms.InLevelName = std::move(InLevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.OnInHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapM::OnInHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "OnInHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.OnOffMapS
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapM::OnOffMapS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "OnOffMapS");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.OnOutHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapM::OnOutHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "OnOutHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.RequestInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapM::RequestInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "RequestInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.RequestOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapM::RequestOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "RequestOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapM.TransitionToWorldMap
// (Final, Native, Protected)

void UAT_UIMapM::TransitionToWorldMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapM", "TransitionToWorldMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.ClearKeyHelp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyHelpGroup                           InUserGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIKeyHelp::ClearKeyHelp(EKeyHelpGroup InUserGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "ClearKeyHelp");

	Params::AT_UIKeyHelp_ClearKeyHelp Parms{};

	Parms.InUserGroup = InUserGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.IsKeyHelpAppeared
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIKeyHelp::IsKeyHelpAppeared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "IsKeyHelpAppeared");

	Params::AT_UIKeyHelp_IsKeyHelpAppeared Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIKeyHelp.IsKeyHelpExited
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIKeyHelp::IsKeyHelpExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "IsKeyHelpExited");

	Params::AT_UIKeyHelp_IsKeyHelpExited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIKeyHelp.LoadKeyHelpArrangement
// (Final, Native, Public, BlueprintCallable)

void UAT_UIKeyHelp::LoadKeyHelpArrangement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "LoadKeyHelpArrangement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.PushKeyHelp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyHelpId                              InKeyHelpId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MsgId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EKeyHelpGroup                           InUserGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIKeyHelp::PushKeyHelp(EKeyHelpId InKeyHelpId, const class FString& MsgId, EKeyHelpGroup InUserGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "PushKeyHelp");

	Params::AT_UIKeyHelp_PushKeyHelp Parms{};

	Parms.InKeyHelpId = InKeyHelpId;
	Parms.MsgId = std::move(MsgId);
	Parms.InUserGroup = InUserGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.RequestKeyHelpHide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyHelpGroup                           InUserGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIKeyHelp::RequestKeyHelpHide(EKeyHelpGroup InUserGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "RequestKeyHelpHide");

	Params::AT_UIKeyHelp_RequestKeyHelpHide Parms{};

	Parms.InUserGroup = InUserGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.RequestKeyHelpShow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EKeyHelpGroup                           InUserGroup                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIKeyHelp::RequestKeyHelpShow(EKeyHelpGroup InUserGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "RequestKeyHelpShow");

	Params::AT_UIKeyHelp_RequestKeyHelpShow Parms{};

	Parms.InUserGroup = InUserGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.SaveKeyHelpArrangement
// (Final, Native, Public, BlueprintCallable)

void UAT_UIKeyHelp::SaveKeyHelpArrangement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "SaveKeyHelpArrangement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.SetHelpMsgText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MsgId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIKeyHelp::SetHelpMsgText(const class FString& MsgId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "SetHelpMsgText");

	Params::AT_UIKeyHelp_SetHelpMsgText Parms{};

	Parms.MsgId = std::move(MsgId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIKeyHelp.SetHelpMsgTextTop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MsgId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIKeyHelp::SetHelpMsgTextTop(const class FString& MsgId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIKeyHelp", "SetHelpMsgTextTop");

	Params::AT_UIKeyHelp_SetHelpMsgTextTop Parms{};

	Parms.MsgId = std::move(MsgId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATIngameDemoCtrl.OnIngameDemoActionEnd
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATIngameDemoCtrl::OnIngameDemoActionEnd(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATIngameDemoCtrl", "OnIngameDemoActionEnd");

	Params::ATIngameDemoCtrl_OnIngameDemoActionEnd Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapTex.OnChangePhaseTiming
// (Final, Native, Private)
// Parameters:
// int32                                   Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMapTex::OnChangePhaseTiming(int32 Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapTex", "OnChangePhaseTiming");

	Params::AT_UIMapTex_OnChangePhaseTiming Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapTex.OnChangeQuestTiming
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             NewName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMapTex::OnChangeQuestTiming(const class FName& NewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapTex", "OnChangeQuestTiming");

	Params::AT_UIMapTex_OnChangeQuestTiming Parms{};

	Parms.NewName = NewName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorldWin.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMapWorldWin::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorldWin", "MouseWheel");

	Params::AT_UIMapWorldWin_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameBar01.PlayChangeAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartAtTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameBar01::PlayChangeAnimation(float StartAtTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameBar01", "PlayChangeAnimation");

	Params::AT_UIMiniGameBar01_PlayChangeAnimation Parms{};

	Parms.StartAtTime = StartAtTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameBar01.SetParamWithPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsPlayer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameBar01::SetParamWithPoints(int32 Rank, const class FString& Name_0, int32 Points, bool IsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameBar01", "SetParamWithPoints");

	Params::AT_UIMiniGameBar01_SetParamWithPoints Parms{};

	Parms.Rank = Rank;
	Parms.Name_0 = std::move(Name_0);
	Parms.Points = Points;
	Parms.IsPlayer = IsPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameBar01.SetParamWithTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        Record                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsShine                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameBar01::SetParamWithTime(int32 Rank, const class FString& Name_0, const struct FTimespan& Record, bool bIsShine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameBar01", "SetParamWithTime");

	Params::AT_UIMiniGameBar01_SetParamWithTime Parms{};

	Parms.Rank = Rank;
	Parms.Name_0 = std::move(Name_0);
	Parms.Record = std::move(Record);
	Parms.bIsShine = bIsShine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingComplete.Close
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingComplete::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingComplete", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingComplete.OnReceivedCreateEndEvent
// (Final, Native, Public)

void UAT_UICookingComplete::OnReceivedCreateEndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingComplete", "OnReceivedCreateEndEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingComplete.OnReceivedCreateStartEvent
// (Final, Native, Public)

void UAT_UICookingComplete::OnReceivedCreateStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingComplete", "OnReceivedCreateStartEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingComplete.Open
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingComplete::Open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingComplete", "Open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingComplete.OpenDevelop
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TargetMsgId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Grade                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLevelUp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingComplete::OpenDevelop(const class FString& TargetMsgId, int32 Grade, bool bLevelUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingComplete", "OpenDevelop");

	Params::AT_UICookingComplete_OpenDevelop Parms{};

	Parms.TargetMsgId = std::move(TargetMsgId);
	Parms.Grade = Grade;
	Parms.bLevelUp = bLevelUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingComplete.Start_Dev_Level
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingComplete::Start_Dev_Level()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingComplete", "Start_Dev_Level");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl003SkillMakoho.HitRootSphere
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile_Cpl003SkillMakoho::HitRootSphere(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl003SkillMakoho", "HitRootSphere");

	Params::Projectile_Cpl003SkillMakoho_HitRootSphere Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.ClearEffectType
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingEffect::ClearEffectType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "ClearEffectType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.Close
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingEffect::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.DebugOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingEffect::DebugOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "DebugOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.OnReceivedCookingTimingEndEvent
// (Final, Native, Public)

void UAT_UICookingEffect::OnReceivedCookingTimingEndEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "OnReceivedCookingTimingEndEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.OnReceivedCookingTimingStartEvent
// (Final, Native, Public)

void UAT_UICookingEffect::OnReceivedCookingTimingStartEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "OnReceivedCookingTimingStartEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.Open
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingEffect::Open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "Open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.SetCookRank
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingEffect::SetCookRank(int32 Rank)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "SetCookRank");

	Params::AT_UICookingEffect_SetCookRank Parms{};

	Parms.Rank = Rank;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingEffect.SetEffectType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SmlType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEFFECT_TYPE                            InEffType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingEffect::SetEffectType(int32 SmlType, EEFFECT_TYPE InEffType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingEffect", "SetEffectType");

	Params::AT_UICookingEffect_SetEffectType Parms{};

	Parms.SmlType = SmlType;
	Parms.InEffType = InEffType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.CheckHovered
// (Final, Native, Public)

void UAT_UICookingMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.Close
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsCourse                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenu::Close(bool bIsCourse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "Close");

	Params::AT_UICookingMenu_Close Parms{};

	Parms.bIsCourse = bIsCourse;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UICookingMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "MouseClickDecide");

	Params::AT_UICookingMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.MouseClickStateResult
// (Final, Native, Public)

void UAT_UICookingMenu::MouseClickStateResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "MouseClickStateResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UICookingMenu::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.MouseClickTabRight
// (Final, Native, Public)

void UAT_UICookingMenu::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnBentoCreateEnd
// (Final, Native, Protected)

void UAT_UICookingMenu::OnBentoCreateEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnBentoCreateEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnCancel
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnCookDemoEnd
// (Final, Native, Protected)
// Parameters:
// int8                                    CutNo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenu::OnCookDemoEnd(int8 CutNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnCookDemoEnd");

	Params::AT_UICookingMenu_OnCookDemoEnd Parms{};

	Parms.CutNo = CutNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnCookDemoStart
// (Final, Native, Protected)
// Parameters:
// int8                                    CutNo                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenu::OnCookDemoStart(int8 CutNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnCookDemoStart");

	Params::AT_UICookingMenu_OnCookDemoStart Parms{};

	Parms.CutNo = CutNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnDecide
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnDown
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnLB
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnLB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnLB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnRB
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnRB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnRB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnUp
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.OnX
// (Final, Native, Protected, BlueprintCallable)

void UAT_UICookingMenu::OnX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "OnX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.Open
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECOOKING_ACCESSER                       InAccesser                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenu::Open(ECOOKING_ACCESSER InAccesser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "Open");

	Params::AT_UICookingMenu_Open Parms{};

	Parms.InAccesser = InAccesser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.SelectCourceClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UICookingMenu::SelectCourceClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "SelectCourceClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenu.SetSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenu::SetSelectTab(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenu", "SetSelectTab");

	Params::AT_UICookingMenu_SetSelectTab Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenuShopList.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenuShopList::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenuShopList", "MouseWheel");

	Params::AT_UICookingMenuShopList_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICookingMenuShopList.OnLoadedOverWriteParam
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          LoadOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingMenuShopList::OnLoadedOverWriteParam(class UATDataAssetUiAsyncLoad* LoadOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingMenuShopList", "OnLoadedOverWriteParam");

	Params::AT_UICookingMenuShopList_OnLoadedOverWriteParam Parms{};

	Parms.LoadOwner = LoadOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlatformFeatures.EnableRecording
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableRecording                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlatformFeatures::EnableRecording(bool bEnableRecording)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "EnableRecording");

	Params::ATPlatformFeatures_EnableRecording Parms{};

	Parms.bEnableRecording = bEnableRecording;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlatformFeatures.EnableScreenshots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlatformFeatures::EnableScreenshots(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "EnableScreenshots");

	Params::ATPlatformFeatures_EnableScreenshots Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlatformFeatures.EnableSharing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlatformFeatures::EnableSharing(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "EnableSharing");

	Params::ATPlatformFeatures_EnableSharing Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlatformFeatures.EnableStreaming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnableStreaming                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlatformFeatures::EnableStreaming(bool bEnableStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "EnableStreaming");

	Params::ATPlatformFeatures_EnableStreaming Parms{};

	Parms.bEnableStreaming = bEnableStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlatformFeatures.IsEnabledRecording
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATPlatformFeatures::IsEnabledRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "IsEnabledRecording");

	Params::ATPlatformFeatures_IsEnabledRecording Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlatformFeatures.IsEnabledScreenshots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATPlatformFeatures::IsEnabledScreenshots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "IsEnabledScreenshots");

	Params::ATPlatformFeatures_IsEnabledScreenshots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlatformFeatures.IsEnabledSharing
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATPlatformFeatures::IsEnabledSharing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "IsEnabledSharing");

	Params::ATPlatformFeatures_IsEnabledSharing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlatformFeatures.IsEnabledStreaming
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATPlatformFeatures::IsEnabledStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlatformFeatures", "IsEnabledStreaming");

	Params::ATPlatformFeatures_IsEnabledStreaming Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UICookingResult.DebugRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UICookingResult::DebugRequest(int32 InNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICookingResult", "DebugRequest");

	Params::AT_UICookingResult_DebugRequest Parms{};

	Parms.InNo = InNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UICutinLevelUp.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UICutinLevelUp::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UICutinLevelUp", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIDamagePop.AnimTextSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InDamageValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                InNumMaterial                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIDamagePop::AnimTextSetting(int32 InDamageValue, class UMaterialInstance* InNumMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIDamagePop", "AnimTextSetting");

	Params::AT_UIDamagePop_AnimTextSetting Parms{};

	Parms.InDamageValue = InDamageValue;
	Parms.InNumMaterial = InNumMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIDamagePop.SetVisibleAndTickable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIDamagePop::SetVisibleAndTickable(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIDamagePop", "SetVisibleAndTickable");

	Params::AT_UIDamagePop_SetVisibleAndTickable Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDataAssetSupportCharacterTalkAsyncLoad.CompleteLoadAlways
// (Final, Native, Public)

void UATDataAssetSupportCharacterTalkAsyncLoad::CompleteLoadAlways()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDataAssetSupportCharacterTalkAsyncLoad", "CompleteLoadAlways");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlComponent.OnBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlayerAutoControlComponent::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlComponent", "OnBeginOverlap");

	Params::ATPlayerAutoControlComponent_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlComponent.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlayerAutoControlComponent::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlComponent", "OnEndOverlap");

	Params::ATPlayerAutoControlComponent_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlComponent.QuestChangePhaseTiming
// (Final, Native, Public)
// Parameters:
// int32                                   NextPhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPlayerAutoControlComponent::QuestChangePhaseTiming(int32 NextPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlComponent", "QuestChangePhaseTiming");

	Params::ATPlayerAutoControlComponent_QuestChangePhaseTiming Parms{};

	Parms.NextPhase = NextPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.Blink
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTime::Blink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "Blink");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.Close
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTime::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.Open
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTime::Open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "Open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.Recovery
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTime::Recovery()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "Recovery");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.SetEnoughTime
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTime::SetEnoughTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "SetEnoughTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.SetTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        TimeLimit                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameTime::SetTime(const struct FTimespan& TimeLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "SetTime");

	Params::AT_UIMiniGameTime_SetTime Parms{};

	Parms.TimeLimit = std::move(TimeLimit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTime.SetTooShortTime
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTime::SetTooShortTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTime", "SetTooShortTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEncounterDirection.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIEncounterDirection::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEncounterDirection", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.ATPillarObject.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATPillarObject::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarObject", "OnComponentHit");

	Params::ATPillarObject_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPillarObject.OnParticleSystemFinished
// (Final, Native, Public)
// Parameters:
// class UParticleSystemComponent*         FinishedComponent                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPillarObject::OnParticleSystemFinished(class UParticleSystemComponent* FinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarObject", "OnParticleSystemFinished");

	Params::ATPillarObject_OnParticleSystemFinished Parms{};

	Parms.FinishedComponent = FinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEncounterDirectionChild.SetEncounterDirectionType
// (Event, Public, BlueprintEvent)
// Parameters:
// EEncounterDirectionType                 Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIEncounterDirectionChild::SetEncounterDirectionType(EEncounterDirectionType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEncounterDirectionChild", "SetEncounterDirectionType");

	Params::AT_UIEncounterDirectionChild_SetEncounterDirectionType Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.ATActCpl005SkillDeathSlicer.OnEndCutin
// (Final, Native, Protected)

void UATActCpl005SkillDeathSlicer::OnEndCutin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl005SkillDeathSlicer", "OnEndCutin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEncounterHud.InitSetting
// (Event, Protected, BlueprintEvent)

void UAT_UIEncounterHud::InitSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEncounterHud", "InitSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.ATEventBattleCounterJustDodgeCount.OnActionChange
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEventBattleCounterJustDodgeCount::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleCounterJustDodgeCount", "OnActionChange");

	Params::ATEventBattleCounterJustDodgeCount_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIconCtnBase.DebugAddStateIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<E_STATE_ICON_TYPE>               InBuff                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIconCtnBase::DebugAddStateIcon(const TArray<E_STATE_ICON_TYPE>& InBuff, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIconCtnBase", "DebugAddStateIcon");

	Params::AT_UIStateIconCtnBase_DebugAddStateIcon Parms{};

	Parms.InBuff = std::move(InBuff);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIconCtnBase.DebugRemoveStateIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<E_STATE_ICON_TYPE>               InBuff                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIconCtnBase::DebugRemoveStateIcon(const TArray<E_STATE_ICON_TYPE>& InBuff, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIconCtnBase", "DebugRemoveStateIcon");

	Params::AT_UIStateIconCtnBase_DebugRemoveStateIcon Parms{};

	Parms.InBuff = std::move(InBuff);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIconCtnBase.DebugTargetChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<E_STATE_ICON_TYPE>               InBuffList                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAT_UIStateIconCtnBase::DebugTargetChange(const TArray<E_STATE_ICON_TYPE>& InBuffList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIconCtnBase", "DebugTargetChange");

	Params::AT_UIStateIconCtnBase_DebugTargetChange Parms{};

	Parms.InBuffList = std::move(InBuffList);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEnemyStateIcon.OnBattleEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_UIEnemyStateIcon::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEnemyStateIcon", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEnemyStateIcon.OnBattleStart
// (Final, Native, Public, BlueprintCallable)

void UAT_UIEnemyStateIcon::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEnemyStateIcon", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEnemyStateIcon.OnPlayerChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    InPlayerChar                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIEnemyStateIcon::OnPlayerChange(class AAT_Character* InPlayerChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEnemyStateIcon", "OnPlayerChange");

	Params::AT_UIEnemyStateIcon_OnPlayerChange Parms{};

	Parms.InPlayerChar = InPlayerChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIEnemyStateIcon.OnTargetChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InEnemy                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIEnemyStateIcon::OnTargetChange(class AActor* InEnemy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIEnemyStateIcon", "OnTargetChange");

	Params::AT_UIEnemyStateIcon_OnTargetChange Parms{};

	Parms.InEnemy = InEnemy;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UINotificationManager.OnBattleEscapeCutinEnd
// (Final, Native, Private)
// Parameters:
// EBattleCutin_AnimType                   InAnimType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UINotificationManager::OnBattleEscapeCutinEnd(EBattleCutin_AnimType InAnimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UINotificationManager", "OnBattleEscapeCutinEnd");

	Params::AT_UINotificationManager_OnBattleEscapeCutinEnd Parms{};

	Parms.InAnimType = InAnimType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UINotificationManager.OnBattleFinishCutinEnd
// (Final, Native, Private)
// Parameters:
// EBattleCutin_AnimType                   InAnimType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UINotificationManager::OnBattleFinishCutinEnd(EBattleCutin_AnimType InAnimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UINotificationManager", "OnBattleFinishCutinEnd");

	Params::AT_UINotificationManager_OnBattleFinishCutinEnd Parms{};

	Parms.InAnimType = InAnimType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UINotificationManager.OnBattleResultEndEvaluation
// (Final, Native, Private)

void UAT_UINotificationManager::OnBattleResultEndEvaluation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UINotificationManager", "OnBattleResultEndEvaluation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UINotificationManager.OnBattleResultStartRank
// (Final, Native, Private)

void UAT_UINotificationManager::OnBattleResultStartRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UINotificationManager", "OnBattleResultStartRank");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UINotificationManager.OnBattleRingOutCutinEnd
// (Final, Native, Private)

void UAT_UINotificationManager::OnBattleRingOutCutinEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UINotificationManager", "OnBattleRingOutCutinEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIExterminationForcesGauge.ExterminationEndFunc
// (Final, Native, Public)

void UAT_UIExterminationForcesGauge::ExterminationEndFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIExterminationForcesGauge", "ExterminationEndFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIExterminationForcesGauge.ExterminationStartFunc
// (Final, Native, Public)

void UAT_UIExterminationForcesGauge::ExterminationStartFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIExterminationForcesGauge", "ExterminationStartFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIExterminationForcesGauge.QuestEndFunc
// (Final, Native, Public)

void UAT_UIExterminationForcesGauge::QuestEndFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIExterminationForcesGauge", "QuestEndFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIExterminationForcesGauge.QuestStartFunc
// (Final, Native, Public)

void UAT_UIExterminationForcesGauge::QuestStartFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIExterminationForcesGauge", "QuestStartFunc");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIExterminationForcesGauge.ShowForcedChange
// (Final, Native, Public)

void UAT_UIExterminationForcesGauge::ShowForcedChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIExterminationForcesGauge", "ShowForcedChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameWin00.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UIMiniGameWin00::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameWin00", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameWin00.MouseClickTabRight
// (Final, Native, Public)

void UAT_UIMiniGameWin00::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameWin00", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATExterminationBastionBase.OnEventBattleEnd
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      InParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AATExterminationBastionBase::OnEventBattleEnd(const struct FEventParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATExterminationBastionBase", "OnEventBattleEnd");

	Params::ATExterminationBastionBase_OnEventBattleEnd Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATExterminationBastionBase.OnEventBattleStart
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      InParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AATExterminationBastionBase::OnEventBattleStart(const struct FEventParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATExterminationBastionBase", "OnEventBattleStart");

	Params::ATExterminationBastionBase_OnEventBattleStart Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATExterminationBastionBase.OnHitCollision
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATExterminationBastionBase::OnHitCollision(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATExterminationBastionBase", "OnHitCollision");

	Params::ATExterminationBastionBase_OnHitCollision Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.GetUIFieldManagerInstance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAT_UIFieldManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIFieldManager* UAT_UIFieldManager::GetUIFieldManagerInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_UIFieldManager", "GetUIFieldManagerInstance");

	Params::AT_UIFieldManager_GetUIFieldManagerInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.AddEventIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMapIcon                                InIconType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CircleRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::AddEventIcon(EMapIcon InIconType, class AActor* InOwner, float CircleRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "AddEventIcon");

	Params::AT_UIFieldManager_AddEventIcon Parms{};

	Parms.InIconType = InIconType;
	Parms.InOwner = InOwner;
	Parms.CircleRadius = CircleRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.BeginNextPreviewFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMG_FADE_COLOR                         FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::BeginNextPreviewFadeIn(float Duration, EUMG_FADE_COLOR FadeColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "BeginNextPreviewFadeIn");

	Params::AT_UIFieldManager_BeginNextPreviewFadeIn Parms{};

	Parms.Duration = Duration;
	Parms.FadeColor = FadeColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.BeginNextPreviewFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMG_FADE_COLOR                         FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::BeginNextPreviewFadeOut(float Duration, EUMG_FADE_COLOR FadeColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "BeginNextPreviewFadeOut");

	Params::AT_UIFieldManager_BeginNextPreviewFadeOut Parms{};

	Parms.Duration = Duration;
	Parms.FadeColor = FadeColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.BeginQuestImgFadeIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMG_FADE_COLOR                         FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::BeginQuestImgFadeIn(float Duration, EUMG_FADE_COLOR FadeColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "BeginQuestImgFadeIn");

	Params::AT_UIFieldManager_BeginQuestImgFadeIn Parms{};

	Parms.Duration = Duration;
	Parms.FadeColor = FadeColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.BeginQuestImgFadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUMG_FADE_COLOR                         FadeColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::BeginQuestImgFadeOut(float Duration, EUMG_FADE_COLOR FadeColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "BeginQuestImgFadeOut");

	Params::AT_UIFieldManager_BeginQuestImgFadeOut Parms{};

	Parms.Duration = Duration;
	Parms.FadeColor = FadeColor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.EndOfUseQuestImg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::EndOfUseQuestImg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "EndOfUseQuestImg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.GetDragonball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NDbIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::GetDragonball(class AActor* PActor, int32 NDbIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "GetDragonball");

	Params::AT_UIFieldManager_GetDragonball Parms{};

	Parms.PActor = PActor;
	Parms.NDbIdx = NDbIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.GetMapManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIMapManager*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIMapManager* UAT_UIFieldManager::GetMapManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "GetMapManager");

	Params::AT_UIFieldManager_GetMapManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.GetXCmnFadeBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIXcmnFadeBlur*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIXcmnFadeBlur* UAT_UIFieldManager::GetXCmnFadeBlur()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "GetXCmnFadeBlur");

	Params::AT_UIFieldManager_GetXCmnFadeBlur Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.GetXCmnHeader
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIXCmnHeader*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIXCmnHeader* UAT_UIFieldManager::GetXCmnHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "GetXCmnHeader");

	Params::AT_UIFieldManager_GetXCmnHeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.HideNextPreviewDetail
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::HideNextPreviewDetail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "HideNextPreviewDetail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.HideNextPreviewTitle
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::HideNextPreviewTitle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "HideNextPreviewTitle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.HideSceneCaptureLayer
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::HideSceneCaptureLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "HideSceneCaptureLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.IsEventIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMapIcon                                InIconType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::IsEventIcon(EMapIcon InIconType, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "IsEventIcon");

	Params::AT_UIFieldManager_IsEventIcon Parms{};

	Parms.InIconType = InIconType;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.IsNextPreviewFadeFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::IsNextPreviewFadeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "IsNextPreviewFadeFinished");

	Params::AT_UIFieldManager_IsNextPreviewFadeFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.IsQuestImgFadeFinished
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::IsQuestImgFadeFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "IsQuestImgFadeFinished");

	Params::AT_UIFieldManager_IsQuestImgFadeFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.IsQuestImgLoadedAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::IsQuestImgLoadedAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "IsQuestImgLoadedAsset");

	Params::AT_UIFieldManager_IsQuestImgLoadedAsset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.IsShowQuestImgPicture
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::IsShowQuestImgPicture()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "IsShowQuestImgPicture");

	Params::AT_UIFieldManager_IsShowQuestImgPicture Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.OnPause
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::OnPause(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "OnPause");

	Params::AT_UIFieldManager_OnPause Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.RemoveAllEventIcon
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::RemoveAllEventIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "RemoveAllEventIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.RemoveAtrociousIcon
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::RemoveAtrociousIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "RemoveAtrociousIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.RemoveEventIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMapIcon                                InIconType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::RemoveEventIcon(EMapIcon InIconType, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "RemoveEventIcon");

	Params::AT_UIFieldManager_RemoveEventIcon Parms{};

	Parms.InIconType = InIconType;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.ResetDragonBallComp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::ResetDragonBallComp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "ResetDragonBallComp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.SetQuestImgAnimationInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   OverridePanTime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveFloat*                      OverrideAnimEasingCurve                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::SetQuestImgAnimationInfo(float OverridePanTime, class UCurveFloat* OverrideAnimEasingCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "SetQuestImgAnimationInfo");

	Params::AT_UIFieldManager_SetQuestImgAnimationInfo Parms{};

	Parms.OverridePanTime = OverridePanTime;
	Parms.OverrideAnimEasingCurve = OverrideAnimEasingCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.SetQuestImgBaseColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     LinearColor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::SetQuestImgBaseColor(const struct FLinearColor& LinearColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "SetQuestImgBaseColor");

	Params::AT_UIFieldManager_SetQuestImgBaseColor Parms{};

	Parms.LinearColor = std::move(LinearColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.SetQuestImgLayerOrder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAddToViewportLayer                     LayerOrder                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::SetQuestImgLayerOrder(EAddToViewportLayer LayerOrder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "SetQuestImgLayerOrder");

	Params::AT_UIFieldManager_SetQuestImgLayerOrder Parms{};

	Parms.LayerOrder = LayerOrder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.SetQuestImgLoadAsset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PathToImageAsset                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::SetQuestImgLoadAsset(const class FString& PathToImageAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "SetQuestImgLoadAsset");

	Params::AT_UIFieldManager_SetQuestImgLoadAsset Parms{};

	Parms.PathToImageAsset = std::move(PathToImageAsset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.SetQuestImgVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestImageAnimationType                InQuestImageAnimationType                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCrossFade                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::SetQuestImgVisible(bool bVisible, EQuestImageAnimationType InQuestImageAnimationType, bool bInCrossFade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "SetQuestImgVisible");

	Params::AT_UIFieldManager_SetQuestImgVisible Parms{};

	Parms.bVisible = bVisible;
	Parms.InQuestImageAnimationType = InQuestImageAnimationType;
	Parms.bInCrossFade = bInCrossFade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.ShowNextPreviewDetail
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           HeaderMessageId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SubjectMessageId                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::ShowNextPreviewDetail(const class FString& HeaderMessageId, const class FString& SubjectMessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "ShowNextPreviewDetail");

	Params::AT_UIFieldManager_ShowNextPreviewDetail Parms{};

	Parms.HeaderMessageId = std::move(HeaderMessageId);
	Parms.SubjectMessageId = std::move(SubjectMessageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.ShowNextPreviewTitle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TitleMessageId                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::ShowNextPreviewTitle(const class FString& TitleMessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "ShowNextPreviewTitle");

	Params::AT_UIFieldManager_ShowNextPreviewTitle Parms{};

	Parms.TitleMessageId = std::move(TitleMessageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.ShowSceneCaptureLayer
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::ShowSceneCaptureLayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "ShowSceneCaptureLayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.SpawnDragonball
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           PActor                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NDbIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::SpawnDragonball(class AActor* PActor, int32 NDbIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "SpawnDragonball");

	Params::AT_UIFieldManager_SpawnDragonball Parms{};

	Parms.PActor = PActor;
	Parms.NDbIdx = NDbIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.StartDragonballAcquisition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InDragonballIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldManager::StartDragonballAcquisition(int32 InDragonballIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "StartDragonballAcquisition");

	Params::AT_UIFieldManager_StartDragonballAcquisition Parms{};

	Parms.InDragonballIndex = InDragonballIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.StartUsingQuestImg
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::StartUsingQuestImg(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "StartUsingQuestImg");

	Params::AT_UIFieldManager_StartUsingQuestImg Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldManager.StopQuestImgAnimation
// (Final, Native, Public, BlueprintCallable)

void UAT_UIFieldManager::StopQuestImgAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "StopQuestImgAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldManager.IsUpdateState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldManager::IsUpdateState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldManager", "IsUpdateState");

	Params::AT_UIFieldManager_IsUpdateState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsApplyFootIK
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsApplyFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsApplyFootIK");

	Params::ATCharacterAnimInstance_IsApplyFootIK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsThirdJumpRolling
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsThirdJumpRolling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsThirdJumpRolling");

	Params::ATCharacterAnimInstance_IsThirdJumpRolling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.OnMontageBlendingOutDelegate
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterAnimInstance::OnMontageBlendingOutDelegate(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "OnMontageBlendingOutDelegate");

	Params::ATCharacterAnimInstance_OnMontageBlendingOutDelegate Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.OnMontageStartedDelegate
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterAnimInstance::OnMontageStartedDelegate(class UAnimMontage* Montage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "OnMontageStartedDelegate");

	Params::ATCharacterAnimInstance_OnMontageStartedDelegate Parms{};

	Parms.Montage = Montage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.SetBlendTimeLookAtCancelDefault
// (Final, Native, Public, BlueprintCallable)

void UATCharacterAnimInstance::SetBlendTimeLookAtCancelDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "SetBlendTimeLookAtCancelDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.SetBlendTimeLookAtDefault
// (Final, Native, Public, BlueprintCallable)

void UATCharacterAnimInstance::SetBlendTimeLookAtDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "SetBlendTimeLookAtDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.SetDefaltProperty_Implementation
// (Final, Native, Public, BlueprintCallable)

void UATCharacterAnimInstance::SetDefaltProperty_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "SetDefaltProperty_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.SetFirstPersonView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InView                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterAnimInstance::SetFirstPersonView(bool InView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "SetFirstPersonView");

	Params::ATCharacterAnimInstance_SetFirstPersonView Parms{};

	Parms.InView = InView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.ToDefaultProperty_Implementation
// (Final, Native, Public, BlueprintCallable)

void UATCharacterAnimInstance::ToDefaultProperty_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "ToDefaultProperty_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtAngleHead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtAngleHead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtAngleHead");

	Params::ATCharacterAnimInstance_GetBattleLookAtAngleHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtAngleHeadUpDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtAngleHeadUpDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtAngleHeadUpDown");

	Params::ATCharacterAnimInstance_GetBattleLookAtAngleHeadUpDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtAngleSpine01
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtAngleSpine01() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtAngleSpine01");

	Params::ATCharacterAnimInstance_GetBattleLookAtAngleSpine01 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtAngleSpine02
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtAngleSpine02() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtAngleSpine02");

	Params::ATCharacterAnimInstance_GetBattleLookAtAngleSpine02 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtAngleSpine03
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtAngleSpine03() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtAngleSpine03");

	Params::ATCharacterAnimInstance_GetBattleLookAtAngleSpine03 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtBlendTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtBlendTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtBlendTime");

	Params::ATCharacterAnimInstance_GetBattleLookAtBlendTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtBlendTimeCancel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtBlendTimeCancel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtBlendTimeCancel");

	Params::ATCharacterAnimInstance_GetBattleLookAtBlendTimeCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtInitTargetLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetBattleLookAtInitTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtInitTargetLocation");

	Params::ATCharacterAnimInstance_GetBattleLookAtInitTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetBattleLookAtLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtLocation");

	Params::ATCharacterAnimInstance_GetBattleLookAtLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleLookAtTriggerThreashold
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBattleLookAtTriggerThreashold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleLookAtTriggerThreashold");

	Params::ATCharacterAnimInstance_GetBattleLookAtTriggerThreashold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBattleStandStepBack
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::GetBattleStandStepBack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBattleStandStepBack");

	Params::ATCharacterAnimInstance_GetBattleStandStepBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBlendSpaceTypeForLipSync
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UATCharacterAnimInstance::GetBlendSpaceTypeForLipSync() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBlendSpaceTypeForLipSync");

	Params::ATCharacterAnimInstance_GetBlendSpaceTypeForLipSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBlendTimeLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBlendTimeLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBlendTimeLookAt");

	Params::ATCharacterAnimInstance_GetBlendTimeLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBlendTimeLookAtCancel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBlendTimeLookAtCancel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBlendTimeLookAtCancel");

	Params::ATCharacterAnimInstance_GetBlendTimeLookAtCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamBattleMove
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetBsParamBattleMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamBattleMove");

	Params::ATCharacterAnimInstance_GetBsParamBattleMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamBattleStep
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetBsParamBattleStep() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamBattleStep");

	Params::ATCharacterAnimInstance_GetBsParamBattleStep Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamBattleTurn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBsParamBattleTurn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamBattleTurn");

	Params::ATCharacterAnimInstance_GetBsParamBattleTurn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamFloatMoveLP
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetBsParamFloatMoveLP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamFloatMoveLP");

	Params::ATCharacterAnimInstance_GetBsParamFloatMoveLP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamNimbusMoveLP
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetBsParamNimbusMoveLP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamNimbusMoveLP");

	Params::ATCharacterAnimInstance_GetBsParamNimbusMoveLP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamPillarMove
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetBsParamPillarMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamPillarMove");

	Params::ATCharacterAnimInstance_GetBsParamPillarMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamPillarReady
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetBsParamPillarReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamPillarReady");

	Params::ATCharacterAnimInstance_GetBsParamPillarReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetBsParamStandMoveLP
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetBsParamStandMoveLP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetBsParamStandMoveLP");

	Params::ATCharacterAnimInstance_GetBsParamStandMoveLP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetClampAngleHeadBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetClampAngleHeadBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetClampAngleHeadBone");

	Params::ATCharacterAnimInstance_GetClampAngleHeadBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetClampAngleHeadBoneUpDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetClampAngleHeadBoneUpDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetClampAngleHeadBoneUpDown");

	Params::ATCharacterAnimInstance_GetClampAngleHeadBoneUpDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetClampAnglePelvisBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetClampAnglePelvisBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetClampAnglePelvisBone");

	Params::ATCharacterAnimInstance_GetClampAnglePelvisBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetClampAngleSpineBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetClampAngleSpineBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetClampAngleSpineBone");

	Params::ATCharacterAnimInstance_GetClampAngleSpineBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetCurrentBattleFloatVariation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterBattleFloatVariation        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterBattleFloatVariation UATCharacterAnimInstance::GetCurrentBattleFloatVariation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetCurrentBattleFloatVariation");

	Params::ATCharacterAnimInstance_GetCurrentBattleFloatVariation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetCurrentFloatBoostMotionState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterFloatBoostMotionState       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterFloatBoostMotionState UATCharacterAnimInstance::GetCurrentFloatBoostMotionState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetCurrentFloatBoostMotionState");

	Params::ATCharacterAnimInstance_GetCurrentFloatBoostMotionState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetCurrentFloatRoll
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterFloatRoll                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterFloatRoll UATCharacterAnimInstance::GetCurrentFloatRoll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetCurrentFloatRoll");

	Params::ATCharacterAnimInstance_GetCurrentFloatRoll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetCurrentJump
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterJump                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterJump UATCharacterAnimInstance::GetCurrentJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetCurrentJump");

	Params::ATCharacterAnimInstance_GetCurrentJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetCurrentMoveGear
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterMoveGear                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterMoveGear UATCharacterAnimInstance::GetCurrentMoveGear() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetCurrentMoveGear");

	Params::ATCharacterAnimInstance_GetCurrentMoveGear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetEnableGazing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::GetEnableGazing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetEnableGazing");

	Params::ATCharacterAnimInstance_GetEnableGazing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetEnableLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::GetEnableLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetEnableLookAt");

	Params::ATCharacterAnimInstance_GetEnableLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetEyePupilScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetEyePupilScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetEyePupilScale");

	Params::ATCharacterAnimInstance_GetEyePupilScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetFloatSwitchGearMoveGear
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterMoveGear                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterMoveGear UATCharacterAnimInstance::GetFloatSwitchGearMoveGear() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetFloatSwitchGearMoveGear");

	Params::ATCharacterAnimInstance_GetFloatSwitchGearMoveGear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGazeOffsetLH
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetGazeOffsetLH() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGazeOffsetLH");

	Params::ATCharacterAnimInstance_GetGazeOffsetLH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGazeOffsetLV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetGazeOffsetLV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGazeOffsetLV");

	Params::ATCharacterAnimInstance_GetGazeOffsetLV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGazeOffsetRH
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetGazeOffsetRH() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGazeOffsetRH");

	Params::ATCharacterAnimInstance_GetGazeOffsetRH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGazeOffsetRV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetGazeOffsetRV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGazeOffsetRV");

	Params::ATCharacterAnimInstance_GetGazeOffsetRV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGeneralBlendSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UBlendSpaceBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlendSpaceBase* UATCharacterAnimInstance::GetGeneralBlendSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGeneralBlendSpace");

	Params::ATCharacterAnimInstance_GetGeneralBlendSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGeneralBlendSpaceAxisX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetGeneralBlendSpaceAxisX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGeneralBlendSpaceAxisX");

	Params::ATCharacterAnimInstance_GetGeneralBlendSpaceAxisX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetGeneralBlendSpaceAxisY
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetGeneralBlendSpaceAxisY() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetGeneralBlendSpaceAxisY");

	Params::ATCharacterAnimInstance_GetGeneralBlendSpaceAxisY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetHeadBoneScaleForFpView
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetHeadBoneScaleForFpView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetHeadBoneScaleForFpView");

	Params::ATCharacterAnimInstance_GetHeadBoneScaleForFpView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetInterpolationBlendTypeForLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInterpolationBlend                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInterpolationBlend UATCharacterAnimInstance::GetInterpolationBlendTypeForLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetInterpolationBlendTypeForLookAt");

	Params::ATCharacterAnimInstance_GetInterpolationBlendTypeForLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLastJump
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterJump                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterJump UATCharacterAnimInstance::GetLastJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLastJump");

	Params::ATCharacterAnimInstance_GetLastJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLeftFootEffectorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetLeftFootEffectorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLeftFootEffectorLocation");

	Params::ATCharacterAnimInstance_GetLeftFootEffectorLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLeftJointTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetLeftJointTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLeftJointTarget");

	Params::ATCharacterAnimInstance_GetLeftJointTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLipSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATCharacterAnimInstance::GetLipSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLipSize");

	Params::ATCharacterAnimInstance_GetLipSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLipWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetLipWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLipWeight");

	Params::ATCharacterAnimInstance_GetLipWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLookAtCalculator
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULookAtCalculator*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULookAtCalculator* UATCharacterAnimInstance::GetLookAtCalculator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLookAtCalculator");

	Params::ATCharacterAnimInstance_GetLookAtCalculator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLookAtLocationForward
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetLookAtLocationForward(float Length) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLookAtLocationForward");

	Params::ATCharacterAnimInstance_GetLookAtLocationForward Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLookAtTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UATCharacterAnimInstance::GetLookAtTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLookAtTarget");

	Params::ATCharacterAnimInstance_GetLookAtTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetLookAtTargetLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetLookAtTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetLookAtTargetLocation");

	Params::ATCharacterAnimInstance_GetLookAtTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetMontageBase
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterMontageBase                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterMontageBase UATCharacterAnimInstance::GetMontageBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetMontageBase");

	Params::ATCharacterAnimInstance_GetMontageBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetMoveEDMoveGear
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterMoveGear                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterMoveGear UATCharacterAnimInstance::GetMoveEDMoveGear() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetMoveEDMoveGear");

	Params::ATCharacterAnimInstance_GetMoveEDMoveGear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetMoveSTMoveGear
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterMoveGear                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterMoveGear UATCharacterAnimInstance::GetMoveSTMoveGear() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetMoveSTMoveGear");

	Params::ATCharacterAnimInstance_GetMoveSTMoveGear Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetNimbusRideType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterNimbusRide                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterNimbusRide UATCharacterAnimInstance::GetNimbusRideType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetNimbusRideType");

	Params::ATCharacterAnimInstance_GetNimbusRideType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetRightFootEffectorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetRightFootEffectorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetRightFootEffectorLocation");

	Params::ATCharacterAnimInstance_GetRightFootEffectorLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetRightJointTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UATCharacterAnimInstance::GetRightJointTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetRightJointTarget");

	Params::ATCharacterAnimInstance_GetRightJointTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetStandWaitVariation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EATCharacterStandWaitVariationState     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EATCharacterStandWaitVariationState UATCharacterAnimInstance::GetStandWaitVariation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetStandWaitVariation");

	Params::ATCharacterAnimInstance_GetStandWaitVariation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetStandWaitVariationBlendTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetStandWaitVariationBlendTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetStandWaitVariationBlendTime");

	Params::ATCharacterAnimInstance_GetStandWaitVariationBlendTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetStandWalkEDAnimPlayRate
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetStandWalkEDAnimPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetStandWalkEDAnimPlayRate");

	Params::ATCharacterAnimInstance_GetStandWalkEDAnimPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetStandWalkEDAnimStartPosition
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetStandWalkEDAnimStartPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetStandWalkEDAnimStartPosition");

	Params::ATCharacterAnimInstance_GetStandWalkEDAnimStartPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.GetTriggerThreasholdLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UATCharacterAnimInstance::GetTriggerThreasholdLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "GetTriggerThreasholdLookAt");

	Params::ATCharacterAnimInstance_GetTriggerThreasholdLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsChangeLookAtRootNo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsChangeLookAtRootNo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsChangeLookAtRootNo");

	Params::ATCharacterAnimInstance_IsChangeLookAtRootNo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableBattleLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableBattleLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableBattleLookAt");

	Params::ATCharacterAnimInstance_IsEnableBattleLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableBattleLookAtCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableBattleLookAtCondition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableBattleLookAtCondition");

	Params::ATCharacterAnimInstance_IsEnableBattleLookAtCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableBattleLookAtRotateHead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableBattleLookAtRotateHead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableBattleLookAtRotateHead");

	Params::ATCharacterAnimInstance_IsEnableBattleLookAtRotateHead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableBattleLookAtRotateSpine01
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableBattleLookAtRotateSpine01() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableBattleLookAtRotateSpine01");

	Params::ATCharacterAnimInstance_IsEnableBattleLookAtRotateSpine01 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableBattleLookAtRotateSpine02
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableBattleLookAtRotateSpine02() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableBattleLookAtRotateSpine02");

	Params::ATCharacterAnimInstance_IsEnableBattleLookAtRotateSpine02 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableBattleLookAtRotateSpine03
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableBattleLookAtRotateSpine03() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableBattleLookAtRotateSpine03");

	Params::ATCharacterAnimInstance_IsEnableBattleLookAtRotateSpine03 Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableGeneralBlendSpace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableGeneralBlendSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableGeneralBlendSpace");

	Params::ATCharacterAnimInstance_IsEnableGeneralBlendSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableLipSync
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableLipSync() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableLipSync");

	Params::ATCharacterAnimInstance_IsEnableLipSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableLookAt");

	Params::ATCharacterAnimInstance_IsEnableLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableRotateHeadBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableRotateHeadBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableRotateHeadBone");

	Params::ATCharacterAnimInstance_IsEnableRotateHeadBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableRotatePelvisBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableRotatePelvisBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableRotatePelvisBone");

	Params::ATCharacterAnimInstance_IsEnableRotatePelvisBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsEnableRotateSpineBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsEnableRotateSpineBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsEnableRotateSpineBone");

	Params::ATCharacterAnimInstance_IsEnableRotateSpineBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsFirstPersonView
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsFirstPersonView() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsFirstPersonView");

	Params::ATCharacterAnimInstance_IsFirstPersonView Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsHighJump
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsHighJump() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsHighJump");

	Params::ATCharacterAnimInstance_IsHighJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsLookForwardMoving
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsLookForwardMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsLookForwardMoving");

	Params::ATCharacterAnimInstance_IsLookForwardMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsShotBattleMove
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsShotBattleMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsShotBattleMove");

	Params::ATCharacterAnimInstance_IsShotBattleMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.IsThirdJumpLanding
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::IsThirdJumpLanding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "IsThirdJumpLanding");

	Params::ATCharacterAnimInstance_IsThirdJumpLanding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATCharacterAnimInstance.UseBattleLookAtInitLocation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATCharacterAnimInstance::UseBattleLookAtInitLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterAnimInstance", "UseBattleLookAtInitLocation");

	Params::ATCharacterAnimInstance_UseBattleLookAtInitLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldNaviWin.OnBeginBattle
// (Final, Native, Public)

void UAT_UIFieldNaviWin::OnBeginBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldNaviWin", "OnBeginBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldNaviWin.OnEndBattle
// (Final, Native, Public)

void UAT_UIFieldNaviWin::OnEndBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldNaviWin", "OnEndBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateResourcesReferenceCounter.DecrementReferenceCounter
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrainDecorateResourcesReferenceCounter::DecrementReferenceCounter(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateResourcesReferenceCounter", "DecrementReferenceCounter");

	Params::TerrainDecorateResourcesReferenceCounter_DecrementReferenceCounter Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRideIcon.GetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERIDE_ICON_TYPE                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERIDE_ICON_TYPE UAT_UIFieldRideIcon::GetType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRideIcon", "GetType");

	Params::AT_UIFieldRideIcon_GetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldRideIcon.SetBan
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsBan                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldRideIcon::SetBan(bool IsBan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRideIcon", "SetBan");

	Params::AT_UIFieldRideIcon_SetBan Parms{};

	Parms.IsBan = IsBan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRideIcon.SetGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldRideIcon::SetGauge(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRideIcon", "SetGauge");

	Params::AT_UIFieldRideIcon_SetGauge Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRideIcon.SetRootVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldRideIcon::SetRootVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRideIcon", "SetRootVisibility");

	Params::AT_UIFieldRideIcon_SetRootVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRideIcon.SetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERIDE_ICON_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Highlight                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsBan                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldRideIcon::SetType(ERIDE_ICON_TYPE Type, bool Highlight, bool IsBan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRideIcon", "SetType");

	Params::AT_UIFieldRideIcon_SetType Parms{};

	Parms.Type = Type;
	Parms.Highlight = Highlight;
	Parms.IsBan = IsBan;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRidePillarResult.RequestBestRecodeSe
// (Final, Native, Private, BlueprintCallable)

void UAT_UIFieldRidePillarResult::RequestBestRecodeSe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRidePillarResult", "RequestBestRecodeSe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldRidePillarResult.UpdateBestRecodeChangeTiming
// (Final, Native, Private, BlueprintCallable)

void UAT_UIFieldRidePillarResult::UpdateBestRecodeChangeTiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldRidePillarResult", "UpdateBestRecodeChangeTiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldSearch.DebugGetAT_UIFieldSearch_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAT_UIFieldSearch*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIFieldSearch* UAT_UIFieldSearch::DebugGetAT_UIFieldSearch_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_UIFieldSearch", "DebugGetAT_UIFieldSearch_BP");

	Params::AT_UIFieldSearch_DebugGetAT_UIFieldSearch_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldSearch.AddSearchIcon
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EITEM_ICON_TYPE                         Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIFieldSearch::AddSearchIcon(const struct FVector& Pos, EITEM_ICON_TYPE Icon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldSearch", "AddSearchIcon");

	Params::AT_UIFieldSearch_AddSearchIcon Parms{};

	Parms.Pos = std::move(Pos);
	Parms.Icon = Icon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldSearch.RemoveSearchIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldSearch::RemoveSearchIcon(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldSearch", "RemoveSearchIcon");

	Params::AT_UIFieldSearch_RemoveSearchIcon Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldSearch.SetCirclePosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldSearch::SetCirclePosition(const struct FVector& InPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldSearch", "SetCirclePosition");

	Params::AT_UIFieldSearch_SetCirclePosition Parms{};

	Parms.InPos = std::move(InPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldSearch.SetCircleRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldSearch::SetCircleRange(float InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldSearch", "SetCircleRange");

	Params::AT_UIFieldSearch_SetCircleRange Parms{};

	Parms.InRange = InRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldSearch.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InIsVisible                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldSearch::SetVisible(bool InIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldSearch", "SetVisible");

	Params::AT_UIFieldSearch_SetVisible Parms{};

	Parms.InIsVisible = InIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldTalkFree.DebugGetAT_UIFieldTalkFree_BP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAT_UIFieldTalkFree*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIFieldTalkFree* UAT_UIFieldTalkFree::DebugGetAT_UIFieldTalkFree_BP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_UIFieldTalkFree", "DebugGetAT_UIFieldTalkFree_BP");

	Params::AT_UIFieldTalkFree_DebugGetAT_UIFieldTalkFree_BP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldTalkFree.CheckEventSpeakOpened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldTalkFree::CheckEventSpeakOpened(const class AActor* ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkFree", "CheckEventSpeakOpened");

	Params::AT_UIFieldTalkFree_CheckEventSpeakOpened Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIFieldTalkFree.RequestCloseEventSpeak
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ID                                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsImmediateClose                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldTalkFree::RequestCloseEventSpeak(const class AActor* ID, bool IsImmediateClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkFree", "RequestCloseEventSpeak");

	Params::AT_UIFieldTalkFree_RequestCloseEventSpeak Parms{};

	Parms.ID = ID;
	Parms.IsImmediateClose = IsImmediateClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldTalkFree.RequestOpenEventSpeak
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InTarget                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInUseSpecialFrame                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSpeakerUniqueId                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AQuestCharacter*                  InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsStringId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLifeTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldTalkFree::RequestOpenEventSpeak(const struct FVector& InPos, const class AActor* InTarget, bool bInUseSpecialFrame, const class FName& InSpeakerUniqueId, class AQuestCharacter* InOwner, const class FString& InString, bool IsStringId, float InLifeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkFree", "RequestOpenEventSpeak");

	Params::AT_UIFieldTalkFree_RequestOpenEventSpeak Parms{};

	Parms.InPos = std::move(InPos);
	Parms.InTarget = InTarget;
	Parms.bInUseSpecialFrame = bInUseSpecialFrame;
	Parms.InSpeakerUniqueId = InSpeakerUniqueId;
	Parms.InOwner = InOwner;
	Parms.InString = std::move(InString);
	Parms.IsStringId = IsStringId;
	Parms.InLifeTime = InLifeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldTalkFreeCore.DebugRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Obj                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InStr                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIFieldTalkFreeCore::DebugRequest(const class AActor* Obj, const class FString& InStr)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkFreeCore", "DebugRequest");

	Params::AT_UIFieldTalkFreeCore_DebugRequest Parms{};

	Parms.Obj = Obj;
	Parms.InStr = std::move(InStr);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIFieldTalkFreeCore.IsEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIFieldTalkFreeCore::IsEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIFieldTalkFreeCore", "IsEnd");

	Params::AT_UIFieldTalkFreeCore_IsEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIQuestNavigation.ClearMainQuestList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::ClearMainQuestList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "ClearMainQuestList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.ClearQuestReplay
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::ClearQuestReplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "ClearQuestReplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.ClearSubQuestList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::ClearSubQuestList(class FName QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "ClearSubQuestList");

	Params::AT_UIQuestNavigation_ClearSubQuestList Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.HideQuestInfo
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::HideQuestInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "HideQuestInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.OnBattleEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.OnBattleStart
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.OnChangedExtendProgress
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::OnChangedExtendProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "OnChangedExtendProgress");

	Params::AT_UIQuestNavigation_OnChangedExtendProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.OnChangedProgress
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::OnChangedProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "OnChangedProgress");

	Params::AT_UIQuestNavigation_OnChangedProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.PlayInQuestList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::PlayInQuestList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "PlayInQuestList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.PlayInQuestListAndUpdateList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUIQuestInfo                     InQuestInfo                                            (Parm, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::PlayInQuestListAndUpdateList(const struct FUIQuestInfo& InQuestInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "PlayInQuestListAndUpdateList");

	Params::AT_UIQuestNavigation_PlayInQuestListAndUpdateList Parms{};

	Parms.InQuestInfo = std::move(InQuestInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.PlayOutQuestList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestNavigation::PlayOutQuestList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "PlayOutQuestList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.SetMainQuestCollectionNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InListIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InGetNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::SetMainQuestCollectionNum(int32 InListIndex, int32 InGetNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "SetMainQuestCollectionNum");

	Params::AT_UIQuestNavigation_SetMainQuestCollectionNum Parms{};

	Parms.InListIndex = InListIndex;
	Parms.InGetNum = InGetNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.SetSubQuestCollectionNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InListIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InGetNum                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::SetSubQuestCollectionNum(int32 InListIndex, int32 InGetNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "SetSubQuestCollectionNum");

	Params::AT_UIQuestNavigation_SetSubQuestCollectionNum Parms{};

	Parms.InListIndex = InListIndex;
	Parms.InGetNum = InGetNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.StartQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUIQuestInfo                     InQuestInfo                                            (Parm, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::StartQuest(const struct FUIQuestInfo& InQuestInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "StartQuest");

	Params::AT_UIQuestNavigation_StartQuest Parms{};

	Parms.InQuestInfo = std::move(InQuestInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestNavigation.UpdateQuestList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FUIQuestInfo                     InQuestInfo                                            (Parm, NativeAccessSpecifierPublic)

void UAT_UIQuestNavigation::UpdateQuestList(const struct FUIQuestInfo& InQuestInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestNavigation", "UpdateQuestList");

	Params::AT_UIQuestNavigation_UpdateQuestList Parms{};

	Parms.InQuestInfo = std::move(InQuestInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameover.CheckHovered
// (Final, Native, Private)

void UAT_UIGameover::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameover", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameover.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIGameover::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameover", "MouseClickDecide");

	Params::AT_UIGameover_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameover.OnEndBarAnim
// (Final, Native, Private)

void UAT_UIGameover::OnEndBarAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameover", "OnEndBarAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.BackAndClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::BackAndClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "BackAndClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.BackToPressButtonDisplay
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::BackToPressButtonDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "BackToPressButtonDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.CheckHovered
// (Final, Native, Private)

void UAT_UIGameTitle::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.GotoLoadGame
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::GotoLoadGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "GotoLoadGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.GotoMenuList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::GotoMenuList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "GotoMenuList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.GotoNextMenu
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::GotoNextMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "GotoNextMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.InPress
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::InPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "InPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.InStart
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::InStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "InStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.ListDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIGameTitle::ListDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "ListDown");

	Params::AT_UIGameTitle_ListDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIGameTitle.ListUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIGameTitle::ListUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "ListUp");

	Params::AT_UIGameTitle_ListUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIGameTitle.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIGameTitle::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "MouseClickDecide");

	Params::AT_UIGameTitle_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.OnChangeNextDLCInfoMessage
// (Final, Native, Private)

void UAT_UIGameTitle::OnChangeNextDLCInfoMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "OnChangeNextDLCInfoMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.SetAnimationWithToriggeredByFadein
// (Final, Native, Public, BlueprintCallable)

void UAT_UIGameTitle::SetAnimationWithToriggeredByFadein()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "SetAnimationWithToriggeredByFadein");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameTitle.SetWorldContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          A_WorldContextObject                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIGameTitle::SetWorldContext(class UObject* A_WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameTitle", "SetWorldContext");

	Params::AT_UIGameTitle_SetWorldContext Parms{};

	Parms.A_WorldContextObject = A_WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameWindow.CheckHovered
// (Final, Native, Public)

void UAT_UIGameWindow::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameWindow", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameWindow.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIGameWindow::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameWindow", "MouseClickDecide");

	Params::AT_UIGameWindow_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIGameWindow.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIGameWindow::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIGameWindow", "MouseWheel");

	Params::AT_UIGameWindow_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDirectionAssault.OnPressedButton
// (Final, Native, Public)

void UATDirectionAssault::OnPressedButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionAssault", "OnPressedButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSubReward.Deco_In
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestSubReward::Deco_In()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSubReward", "Deco_In");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSubReward.Win_In
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestSubReward::Win_In()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSubReward", "Win_In");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSubReward.Win_Out
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestSubReward::Win_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSubReward", "Win_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhaseBase.RequestDisplayPurpose
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestPhaseBase::RequestDisplayPurpose(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhaseBase", "RequestDisplayPurpose");

	Params::QuestPhaseBase_RequestDisplayPurpose Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhaseBase.RequestShowNavigation
// (Final, Native, Protected)

void UQuestPhaseBase::RequestShowNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhaseBase", "RequestShowNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollText.InitSetting
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollText::InitSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollText", "InitSetting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollText.PlayScroll
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollText::PlayScroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollText", "PlayScroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollText.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           StrTxt                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIScrollText::SetText(const class FString& StrTxt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollText", "SetText");

	Params::AT_UIScrollText_SetText Parms{};

	Parms.StrTxt = std::move(StrTxt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollText.StopScroll
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollText::StopScroll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollText", "StopScroll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction AT.AT_UIScrollText.UmgDelegate__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UAT_UIScrollText::UmgDelegate__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollText", "UmgDelegate__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIItemMenu.ChangeSelectMenuDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::ChangeSelectMenuDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ChangeSelectMenuDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.ChangeSelectMenuPageDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIItemMenu::ChangeSelectMenuPageDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ChangeSelectMenuPageDown");

	Params::AT_UIItemMenu_ChangeSelectMenuPageDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIItemMenu.ChangeSelectMenuPageUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIItemMenu::ChangeSelectMenuPageUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ChangeSelectMenuPageUp");

	Params::AT_UIItemMenu_ChangeSelectMenuPageUp Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIItemMenu.ChangeSelectMenuUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::ChangeSelectMenuUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ChangeSelectMenuUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.ChangeSelectTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsLeft                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIItemMenu::ChangeSelectTab(bool IsLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ChangeSelectTab");

	Params::AT_UIItemMenu_ChangeSelectTab Parms{};

	Parms.IsLeft = IsLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.CheckHovered
// (Final, Native, Public)

void UAT_UIItemMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.HeaderInCore
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIItemMenu::HeaderInCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "HeaderInCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.HeaderOutCore
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIItemMenu::HeaderOutCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "HeaderOutCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.ListInCore
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIItemMenu::ListInCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ListInCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.ListOutCore
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIItemMenu::ListOutCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "ListOutCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.MenuBgInCore
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIItemMenu::MenuBgInCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "MenuBgInCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.MenuBgOutCore
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIItemMenu::MenuBgOutCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "MenuBgOutCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIItemMenu::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "MouseWheel");

	Params::AT_UIItemMenu_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.RequestPlayInAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::RequestPlayInAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "RequestPlayInAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.RequestPlayInCharaSelectAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::RequestPlayInCharaSelectAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "RequestPlayInCharaSelectAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.RequestPlayOutAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::RequestPlayOutAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "RequestPlayOutAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.RequestPlayOutCharaSelectAnim
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::RequestPlayOutCharaSelectAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "RequestPlayOutCharaSelectAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.SetInitInventory
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::SetInitInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "SetInitInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.SetSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIItemMenu::SetSelectTab(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "SetSelectTab");

	Params::AT_UIItemMenu_SetSelectTab Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.UpdateInventory
// (Final, Native, Public, BlueprintCallable)

void UAT_UIItemMenu::UpdateInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "UpdateInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIItemMenu.IsAnimCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIItemMenu::IsAnimCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIItemMenu", "IsAnimCompleted");

	Params::AT_UIItemMenu_IsAnimCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMapManager.SwitchMap
// (Final, Native, Public)
// Parameters:
// uint8                                   MapState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   AnimState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMapManager::SwitchMap(uint8 MapState, uint8 AnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapManager", "SwitchMap");

	Params::AT_UIMapManager_SwitchMap Parms{};

	Parms.MapState = MapState;
	Parms.AnimState = AnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.CheckHovered
// (Final, Native, Private)

void UAT_UIMapWorld::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputCancel
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputConfirm
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputDown
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputLeft
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputRight
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputUp
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputX
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.InputY
// (Final, Native, Private, BlueprintCallable)

void UAT_UIMapWorld::InputY()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "InputY");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIMapWorld::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "MouseClickDecide");

	Params::AT_UIMapWorld_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.OnClosedInfoWindow
// (Final, Native, Private)

void UAT_UIMapWorld::OnClosedInfoWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "OnClosedInfoWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorld.OnCursorMove
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIMapWorld::OnCursorMove(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorld", "OnCursorMove");

	Params::AT_UIMapWorld_OnCursorMove Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorldCurs01.RequestClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapWorldCurs01::RequestClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorldCurs01", "RequestClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMapWorldCurs01.RequestOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMapWorldCurs01::RequestOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMapWorldCurs01", "RequestOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIBar03Choice.UpdateVolumeEvent
// (Event, Protected, BlueprintEvent)

void UAT_UIBar03Choice::UpdateVolumeEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIBar03Choice", "UpdateVolumeEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIList03Choice.RequestPlayEnter
// (Final, Native, Public, BlueprintCallable)

void UAT_UIList03Choice::RequestPlayEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIList03Choice", "RequestPlayEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIList03Choice.SetMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NameTxt                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNewIcon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsActive                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InIsCheck                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIList03Choice::SetMenu(const class FString& NameTxt, bool IsNewIcon, bool InIsActive, bool InIsCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIList03Choice", "SetMenu");

	Params::AT_UIList03Choice_SetMenu Parms{};

	Parms.NameTxt = std::move(NameTxt);
	Parms.IsNewIcon = IsNewIcon;
	Parms.InIsActive = InIsActive;
	Parms.InIsCheck = InIsCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIList03Choice.SetSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsSelect                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIList03Choice::SetSelect(bool IsSelect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIList03Choice", "SetSelect");

	Params::AT_UIList03Choice_SetSelect Parms{};

	Parms.IsSelect = IsSelect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIList03Choice.SetToFastTravel
// (Final, Native, Public, BlueprintCallable)

void UAT_UIList03Choice::SetToFastTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIList03Choice", "SetToFastTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIList03Choice.CanSelect
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIList03Choice::CanSelect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIList03Choice", "CanSelect");

	Params::AT_UIList03Choice_CanSelect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMenuWindow.SetupListConfirmWindow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FMenuWIndowSetupListNumMenuInfo>ListCtn                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FString>                   ChoiceCtn                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIMenuWindow::SetupListConfirmWindow(const class FString& TitleTxt, const TArray<struct FMenuWIndowSetupListNumMenuInfo>& ListCtn, const TArray<class FString>& ChoiceCtn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMenuWindow", "SetupListConfirmWindow");

	Params::AT_UIMenuWindow_SetupListConfirmWindow Parms{};

	Parms.TitleTxt = std::move(TitleTxt);
	Parms.ListCtn = std::move(ListCtn);
	Parms.ChoiceCtn = std::move(ChoiceCtn);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.CheckPointClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::CheckPointClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "CheckPointClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.CheckPointOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::CheckPointOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "CheckPointOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.CloseDirection
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::CloseDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "CloseDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.CloseTips
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::CloseTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "CloseTips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.GetCircleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAT_UIMiniGameRace::GetCircleRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "GetCircleRadius");

	Params::AT_UIMiniGameRace_GetCircleRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMiniGameRace.GetNextCheckPointLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAT_UIMiniGameRace::GetNextCheckPointLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "GetNextCheckPointLocation");

	Params::AT_UIMiniGameRace_GetNextCheckPointLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMiniGameRace.GetPlayerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAT_UIMiniGameRace::GetPlayerLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "GetPlayerLocation");

	Params::AT_UIMiniGameRace_GetPlayerLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMiniGameRace.LimitTimerClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::LimitTimerClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "LimitTimerClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.LimitTimerOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::LimitTimerOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "LimitTimerOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.OpenDirection
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::OpenDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "OpenDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.OpenTips
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::OpenTips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "OpenTips");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetCheckPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NowNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetCheckPoint(int32 NowNum, int32 MaxNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetCheckPoint");

	Params::AT_UIMiniGameRace_SetCheckPoint Parms{};

	Parms.NowNum = NowNum;
	Parms.MaxNum = MaxNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetCheckPointPassageText
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::SetCheckPointPassageText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetCheckPointPassageText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetCircleRadius
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetCircleRadius(float Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetCircleRadius");

	Params::AT_UIMiniGameRace_SetCircleRadius Parms{};

	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetEnableBlinkLimitTimeTextColor
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::SetEnableBlinkLimitTimeTextColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetEnableBlinkLimitTimeTextColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetEnableDefaultLimitTimeTextColor
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::SetEnableDefaultLimitTimeTextColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetEnableDefaultLimitTimeTextColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetLimitTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        TimeLimit                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetLimitTime(const struct FTimespan& TimeLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetLimitTime");

	Params::AT_UIMiniGameRace_SetLimitTime Parms{};

	Parms.TimeLimit = std::move(TimeLimit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetNextCheckPointLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetNextCheckPointLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetNextCheckPointLocation");

	Params::AT_UIMiniGameRace_SetNextCheckPointLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetPlayerLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetPlayerLocation(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetPlayerLocation");

	Params::AT_UIMiniGameRace_SetPlayerLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetSpped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetSpped(int32 Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetSpped");

	Params::AT_UIMiniGameRace_SetSpped Parms{};

	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SetTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FTimespan                        TimeLimit                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::SetTime(const struct FTimespan& TimeLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SetTime");

	Params::AT_UIMiniGameRace_SetTime Parms{};

	Parms.TimeLimit = std::move(TimeLimit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SppedClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::SppedClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SppedClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.SppedOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::SppedOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "SppedOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.StartBlinkLmitTimeTextAnimation
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::StartBlinkLmitTimeTextAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "StartBlinkLmitTimeTextAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.StopBlinkLmitTimeTextAnimation
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::StopBlinkLmitTimeTextAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "StopBlinkLmitTimeTextAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.TimerClose
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::TimerClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "TimerClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.TimerOpen
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameRace::TimerOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "TimerOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameRace.UpdateDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AHUD*                             HUD                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameRace::UpdateDirection(class AHUD* HUD)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameRace", "UpdateDirection");

	Params::AT_UIMiniGameRace_UpdateDirection Parms{};

	Parms.HUD = HUD;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameResult.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIMiniGameResult::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameResult", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIMiniGameResult.DebugOpenWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameResult::DebugOpenWindow(int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameResult", "DebugOpenWindow");

	Params::AT_UIMiniGameResult_DebugOpenWindow Parms{};

	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameResult.DebugRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMiniGameType                           MiniGameType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameResult::DebugRequest(EMiniGameType MiniGameType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameResult", "DebugRequest");

	Params::AT_UIMiniGameResult_DebugRequest Parms{};

	Parms.MiniGameType = MiniGameType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameResult.PlayAnimOut
// (Final, Native, Public)

void UAT_UIMiniGameResult::PlayAnimOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameResult", "PlayAnimOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.CheckHovered
// (Final, Native, Public)

void UAT_UIMiniGameTop::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.GetSelectItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUI_MINIGAME_TOP_ESELECT_ID             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUI_MINIGAME_TOP_ESELECT_ID UAT_UIMiniGameTop::GetSelectItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "GetSelectItem");

	Params::AT_UIMiniGameTop_GetSelectItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMiniGameTop.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIMiniGameTop::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "MouseClickDecide");

	Params::AT_UIMiniGameTop_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.PlayBack
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTop::PlayBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "PlayBack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIMiniGameTop::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.SetRecordWithPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Points                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameTop::SetRecordWithPoints(int32 Rank, int32 Points)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "SetRecordWithPoints");

	Params::AT_UIMiniGameTop_SetRecordWithPoints Parms{};

	Parms.Rank = Rank;
	Parms.Points = Points;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.SetRecordWithTime
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Rank                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTimespan                        BestTime                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameTop::SetRecordWithTime(int32 Rank, const struct FTimespan& BestTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "SetRecordWithTime");

	Params::AT_UIMiniGameTop_SetRecordWithTime Parms{};

	Parms.Rank = Rank;
	Parms.BestTime = std::move(BestTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.SetType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMINIGAMETOPTYPE_ID                     InType                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniGameTop::SetType(const EMINIGAMETOPTYPE_ID InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "SetType");

	Params::AT_UIMiniGameTop_SetType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniGameTop.GetType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EMINIGAMETOPTYPE_ID                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMINIGAMETOPTYPE_ID UAT_UIMiniGameTop::GetType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "GetType");

	Params::AT_UIMiniGameTop_GetType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMiniGameTop.IsEnd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIMiniGameTop::IsEnd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniGameTop", "IsEnd");

	Params::AT_UIMiniGameTop_IsEnd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIMiniMapRadar.MapTexAfterInit
// (Final, Native, Public)

void UAT_UIMiniMapRadar::MapTexAfterInit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniMapRadar", "MapTexAfterInit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniMapRadar.OnBattleEnd
// (Final, Native, Public)

void UAT_UIMiniMapRadar::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniMapRadar", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniMapRadar.OnBattleStart
// (Final, Native, Public)

void UAT_UIMiniMapRadar::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniMapRadar", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIMiniMapRadar.OnChangePlayer
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InPlayerIns                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIMiniMapRadar::OnChangePlayer(class AAT_Character* InPlayerIns)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIMiniMapRadar", "OnChangePlayer");

	Params::AT_UIMiniMapRadar_OnChangePlayer Parms{};

	Parms.InPlayerIns = InPlayerIns;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgBlowoff.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActGroundBattleDmgBlowoff::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgBlowoff", "OnHitPhoton");

	Params::ATActGroundBattleDmgBlowoff_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIPlayerStateIcon.OnBattleEnd
// (Final, Native, Public, BlueprintCallable)

void UAT_UIPlayerStateIcon::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIPlayerStateIcon", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIPlayerStateIcon.OnBattleStart
// (Final, Native, Public, BlueprintCallable)

void UAT_UIPlayerStateIcon::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIPlayerStateIcon", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIPlayerStateIcon.OnPlayerChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AAT_Character*                    InChar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIPlayerStateIcon::OnPlayerChange(class AAT_Character* InChar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIPlayerStateIcon", "OnPlayerChange");

	Params::AT_UIPlayerStateIcon_OnPlayerChange Parms{};

	Parms.InChar = InChar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgLock.OnEndLockAction
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActDmgLock::OnEndLockAction(class AAT_Character* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgLock", "OnEndLockAction");

	Params::ATActDmgLock_OnEndLockAction Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Header_Cloud_In
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Header_Cloud_In()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Header_Cloud_In");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Header_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Header_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Header_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Rank_In
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Rank_In()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Rank_In");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Rank_In_Se
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Rank_In_Se()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Rank_In_Se");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Rank_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Rank_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Rank_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Scroll_Cloud_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Scroll_Cloud_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Scroll_Cloud_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Start_Rank1
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Start_Rank1()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Start_Rank1");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Start_Rank2
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Start_Rank2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Start_Rank2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Start_Rank3
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Start_Rank3()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Start_Rank3");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Start_Rank4
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Start_Rank4()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Start_Rank4");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainClear.Start_Rank5
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestMainClear::Start_Rank5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainClear", "Start_Rank5");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestMainLogo.OnChangeProgress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             InProgressId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIQuestMainLogo::OnChangeProgress(const class FName& InProgressId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestMainLogo", "OnChangeProgress");

	Params::AT_UIQuestMainLogo_OnChangeProgress Parms{};

	Parms.InProgressId = InProgressId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestRetry.CheckHovered
// (Final, Native, Public)

void UAT_UIQuestRetry::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestRetry", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestRetry.On_Ev_Anm_In_List
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestRetry::On_Ev_Anm_In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestRetry", "On_Ev_Anm_In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestRetry.On_Ev_Anm_Out_List
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestRetry::On_Ev_Anm_Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestRetry", "On_Ev_Anm_Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestRetry.On_In_Header_Bg
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestRetry::On_In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestRetry", "On_In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestRetry.On_Out_Bg
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestRetry::On_Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestRetry", "On_Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestRetry.On_Out_Header
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIQuestRetry::On_Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestRetry", "On_Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.CheckHovered
// (Final, Native, Public)

void UAT_UIQuestSub::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Choice_In_Internal
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Choice_In_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Choice_In_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Header_Choice_Out_Internal
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Header_Choice_Out_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Header_Choice_Out_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Header_In_Internal
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Header_In_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Header_In_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Header_Out_Internal
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Header_Out_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Header_Out_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Icon_Clear_Se
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Icon_Clear_Se()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Icon_Clear_Se");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIQuestSub::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "MouseClickDecide");

	Params::AT_UIQuestSub_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Title_In
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Title_In()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Title_In");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIQuestSub.Title_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIQuestSub::Title_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIQuestSub", "Title_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgLongBlowoffVertical.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActDmgLongBlowoffVertical::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgLongBlowoffVertical", "OnHitPhoton");

	Params::ATActDmgLongBlowoffVertical_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollBar.InitScrollValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ScrollBarHeight                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   DisplayMenu                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ScrollMaxMenu                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MoveVolume                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIScrollBar::InitScrollValue(float ScrollBarHeight, int32 DisplayMenu, int32 ScrollMaxMenu, int32 MoveVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollBar", "InitScrollValue");

	Params::AT_UIScrollBar_InitScrollValue Parms{};

	Parms.ScrollBarHeight = ScrollBarHeight;
	Parms.DisplayMenu = DisplayMenu;
	Parms.ScrollMaxMenu = ScrollMaxMenu;
	Parms.MoveVolume = MoveVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollBar.ScrollDown
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollBar::ScrollDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollBar", "ScrollDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollBar.ScrollUp
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollBar::ScrollUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollBar", "ScrollUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollBar.SetBottom
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollBar::SetBottom()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollBar", "SetBottom");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollBar.SetTop
// (Final, Native, Public, BlueprintCallable)

void UAT_UIScrollBar::SetTop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollBar", "SetTop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIScrollBar.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   MenuValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIScrollBar::SetValue(int32 MenuValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIScrollBar", "SetValue");

	Params::AT_UIScrollBar_SetValue Parms{};

	Parms.MenuValue = MenuValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.CheckHovered
// (Final, Native, Private)

void UAT_UIShopCommon::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.GetShopItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FXlistBar04Info>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FXlistBar04Info> UAT_UIShopCommon::GetShopItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "GetShopItem");

	Params::AT_UIShopCommon_GetShopItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIShopCommon.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopCommon::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "MouseClickDecide");

	Params::AT_UIShopCommon_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.MouseClickTabLeft
// (Final, Native, Private)

void UAT_UIShopCommon::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.MouseClickTabRight
// (Final, Native, Private)

void UAT_UIShopCommon::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.MouseWheel
// (Final, Native, Private)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIShopCommon::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "MouseWheel");

	Params::AT_UIShopCommon_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.On_InHeaderBg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopCommon::On_InHeaderBg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "On_InHeaderBg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.On_OutBg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopCommon::On_OutBg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "On_OutBg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.On_OutHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopCommon::On_OutHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "On_OutHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopCommon::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopCommon::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopCommon.SetShopItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FXlistBar04Info>          A_ShopItemList                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAT_UIShopCommon::SetShopItem(TArray<struct FXlistBar04Info>* A_ShopItemList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopCommon", "SetShopItem");

	Params::AT_UIShopCommon_SetShopItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (A_ShopItemList != nullptr)
		*A_ShopItemList = std::move(Parms.A_ShopItemList);
}


// Function AT.ATFormPartsLoader.CompleteClear
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFormPartsLoader::CompleteClear(class UATDataAssetFormMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFormPartsLoader", "CompleteClear");

	Params::ATFormPartsLoader_CompleteClear Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFormPartsLoader.CompleteLoad
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFormPartsLoader::CompleteLoad(class UATDataAssetFormMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFormPartsLoader", "CompleteLoad");

	Params::ATFormPartsLoader_CompleteLoad Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.CheckHovered
// (Final, Native, Public)

void UAT_UIShopDevelop::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.In_Header_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelop::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.In_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelop::In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelop::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.Out_Header
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelop::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.Out_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelop::Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelop.SetSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIShopDevelop::SetSelectTab(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelop", "SetSelectTab");

	Params::AT_UIShopDevelop_SetSelectTab Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.CheckHovered
// (Final, Native, Public)

void UAT_UIShopDevelopCustom::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.In_Header_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.In_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.In_SubList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::In_SubList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "In_SubList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.Out_Header
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.Out_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.Out_SubList
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopDevelopCustom::Out_SubList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "Out_SubList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.PartsUpdateInMouseWheel
// (Final, Native, Public)

void UAT_UIShopDevelopCustom::PartsUpdateInMouseWheel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "PartsUpdateInMouseWheel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopDevelopCustom.SetSelectTab
// (Final, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIShopDevelopCustom::SetSelectTab(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopDevelopCustom", "SetSelectTab");

	Params::AT_UIShopDevelopCustom_SetSelectTab Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.DemoEnd
// (Final, Native, Public)

void UATCharacterMovementComponent::DemoEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "DemoEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.DemoStart
// (Final, Native, Public)

void UATCharacterMovementComponent::DemoStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "DemoStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.GeneralTalkEnd
// (Final, Native, Public)

void UATCharacterMovementComponent::GeneralTalkEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "GeneralTalkEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.GeneralTalkStart
// (Final, Native, Public)

void UATCharacterMovementComponent::GeneralTalkStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "GeneralTalkStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.OnBattleEnd
// (Final, Native, Public)

void UATCharacterMovementComponent::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.OnBattleStart
// (Final, Native, Public)

void UATCharacterMovementComponent::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterMovementComponent::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "OnDemoTiming");

	Params::ATCharacterMovementComponent_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMovementComponent.OnMoveSolveByHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InCauserActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InCauserComp                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InNormalImpulse                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATCharacterMovementComponent::OnMoveSolveByHit(class UPrimitiveComponent* OverlappedComp, class AActor* InCauserActor, class UPrimitiveComponent* InCauserComp, const struct FVector& InNormalImpulse, const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMovementComponent", "OnMoveSolveByHit");

	Params::ATCharacterMovementComponent_OnMoveSolveByHit Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.InCauserActor = InCauserActor;
	Parms.InCauserComp = InCauserComp;
	Parms.InNormalImpulse = std::move(InNormalImpulse);
	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopInfo.CheckHovered
// (Final, Native, Public)

void UAT_UIShopInfo::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopInfo", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopInfo.DebugRequest
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopInfo::DebugRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopInfo", "DebugRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopInfo.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopInfo::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopInfo", "MouseClickDecide");

	Params::AT_UIShopInfo_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTop.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTop::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTop", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTop.DebugRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESHOPTOP_DEBUG_ID                       InNo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIShopTop::DebugRequest(ESHOPTOP_DEBUG_ID InNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTop", "DebugRequest");

	Params::AT_UIShopTop_DebugRequest Parms{};

	Parms.InNo = InNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTop.In_List_Commu
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopTop::In_List_Commu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTop", "In_List_Commu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTop.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTop::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTop", "MouseClickDecide");

	Params::AT_UIShopTop_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTop.Out_List_Commu
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopTop::Out_List_Commu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTop", "Out_List_Commu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterSparkingComponent.DamageApplied
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATCharacterSparkingComponent::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterSparkingComponent", "DamageApplied");

	Params::ATCharacterSparkingComponent_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterSparkingComponent.HitOffsetDraw
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATCharacterSparkingComponent::HitOffsetDraw(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterSparkingComponent", "HitOffsetDraw");

	Params::ATCharacterSparkingComponent_HitOffsetDraw Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterSparkingComponent.HitOffsetLose
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATCharacterSparkingComponent::HitOffsetLose(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterSparkingComponent", "HitOffsetLose");

	Params::ATCharacterSparkingComponent_HitOffsetLose Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "MouseClickDecide");

	Params::AT_UIShopTraining_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UIShopTraining::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.MouseClickTabRight
// (Final, Native, Public)

void UAT_UIShopTraining::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnClearAnimation
// (Final, Native, Private)

void UAT_UIShopTraining::OnClearAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnClearAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnEventBattleEnd
// (Final, Native, Private)

void UAT_UIShopTraining::OnEventBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnEventBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnEventBattleNotify
// (Final, Native, Private)

void UAT_UIShopTraining::OnEventBattleNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnEventBattleNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnEventBattleStart
// (Final, Native, Private)

void UAT_UIShopTraining::OnEventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnEventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnFinishedSlide_L_OutAnimation
// (Final, Native, Private)

void UAT_UIShopTraining::OnFinishedSlide_L_OutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnFinishedSlide_L_OutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnFinishedSlide_R_OutAnimation
// (Final, Native, Private)

void UAT_UIShopTraining::OnFinishedSlide_R_OutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnFinishedSlide_R_OutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining.OnIconClearAnimation
// (Final, Native, Private)

void UAT_UIShopTraining::OnIconClearAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining", "OnIconClearAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterPartsManager.DestroyFacialParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterPartsManager::DestroyFacialParts(class UATDataAssetFacialAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterPartsManager", "DestroyFacialParts");

	Params::ATCharacterPartsManager_DestroyFacialParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterPartsManager.DestroyFormParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterPartsManager::DestroyFormParts(class UATDataAssetFormMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterPartsManager", "DestroyFormParts");

	Params::ATCharacterPartsManager_DestroyFormParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterPartsManager.DestroyVariationParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterPartsManager::DestroyVariationParts(class UATDataAssetVariationMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterPartsManager", "DestroyVariationParts");

	Params::ATCharacterPartsManager_DestroyVariationParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterPartsManager.SpawnFacialParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterPartsManager::SpawnFacialParts(class UATDataAssetFacialAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterPartsManager", "SpawnFacialParts");

	Params::ATCharacterPartsManager_SpawnFacialParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterPartsManager.SpawnFormParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterPartsManager::SpawnFormParts(class UATDataAssetFormMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterPartsManager", "SpawnFormParts");

	Params::ATCharacterPartsManager_SpawnFormParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterPartsManager.SpawnVariationParts
// (Final, Native, Public)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterPartsManager::SpawnVariationParts(class UATDataAssetVariationMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterPartsManager", "SpawnVariationParts");

	Params::ATCharacterPartsManager_SpawnVariationParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining00.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining00::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining00", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining00.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining00::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining00", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining00.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining00::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining00", "MouseClickDecide");

	Params::AT_UIShopTraining00_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining00.OnConfirmWindowSelectItem
// (Final, Native, Private)
// Parameters:
// int32                                   SELECT                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIShopTraining00::OnConfirmWindowSelectItem(int32 SELECT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining00", "OnConfirmWindowSelectItem");

	Params::AT_UIShopTraining00_OnConfirmWindowSelectItem Parms{};

	Parms.SELECT = SELECT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining00.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIShopTraining00::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining00", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining01::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining01::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining01::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "MouseClickDecide");

	Params::AT_UIShopTraining01_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UIShopTraining01::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.MouseClickTabRight
// (Final, Native, Public)

void UAT_UIShopTraining01::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.OnFinishedSlide_L_OutAnimation
// (Final, Native, Private)

void UAT_UIShopTraining01::OnFinishedSlide_L_OutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "OnFinishedSlide_L_OutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining01.OnFinishedSlide_R_OutAnimation
// (Final, Native, Private)

void UAT_UIShopTraining01::OnFinishedSlide_R_OutAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining01", "OnFinishedSlide_R_OutAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining02.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining02::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining02", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining02.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining02::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining02", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining02.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining02::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining02", "MouseClickDecide");

	Params::AT_UIShopTraining02_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining03.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining03::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining03", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining03.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining03::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining03", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining03.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining03::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining03", "MouseClickDecide");

	Params::AT_UIShopTraining03_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining04.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining04::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining04", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining04.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining04::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining04", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining04.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining04::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining04", "MouseClickDecide");

	Params::AT_UIShopTraining04_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining05.CheckHovered
// (Final, Native, Public)

void UAT_UIShopTraining05::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining05", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining05.DetailUpdate
// (Final, Native, Public)

void UAT_UIShopTraining05::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining05", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIShopTraining05.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIShopTraining05::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIShopTraining05", "MouseClickDecide");

	Params::AT_UIShopTraining05_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillChain.OnBattleEnd
// (Final, Native, Public)

void UAT_UISkillChain::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillChain", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillChain.OnBattleStart
// (Final, Native, Public)

void UAT_UISkillChain::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillChain", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillChain.OnComboAddEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UISkillChain::OnComboAddEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillChain", "OnComboAddEvent");

	Params::AT_UISkillChain_OnComboAddEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillChain.OnComboEndEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UISkillChain::OnComboEndEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillChain", "OnComboEndEvent");

	Params::AT_UISkillChain_OnComboEndEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillChain.OnTotalDamageEnd
// (Final, Native, Private)

void UAT_UISkillChain::OnTotalDamageEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillChain", "OnTotalDamageEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.CheckHovered
// (Final, Native, Public)

void UAT_UISkillCustomize::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.DetailUpdate
// (Final, Native, Public)

void UAT_UISkillCustomize::DetailUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "DetailUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.In_Header_Bg
// (Final, Native, Private, BlueprintCallable)

void UAT_UISkillCustomize::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.In_List
// (Final, Native, Private, BlueprintCallable)

void UAT_UISkillCustomize::In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UISkillCustomize::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "MouseClickDecide");

	Params::AT_UISkillCustomize_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UISkillCustomize::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.MouseClickTabRight
// (Final, Native, Public)

void UAT_UISkillCustomize::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.Out_Bg
// (Final, Native, Private, BlueprintCallable)

void UAT_UISkillCustomize::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.Out_Header
// (Final, Native, Private, BlueprintCallable)

void UAT_UISkillCustomize::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomize.Out_List
// (Final, Native, Private, BlueprintCallable)

void UAT_UISkillCustomize::Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomize", "Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillCustomizePlate.Change_Txt
// (Final, Native, Private, BlueprintCallable)

void UAT_UISkillCustomizePlate::Change_Txt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillCustomizePlate", "Change_Txt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillEnemyIcon.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UISkillEnemyIcon::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillEnemyIcon", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UISkillTree.OnInputCancel
// (Final, Native, Public)

void UAT_UISkillTree::OnInputCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputDecide
// (Final, Native, Public)

void UAT_UISkillTree::OnInputDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputDPadDown
// (Final, Native, Public)

void UAT_UISkillTree::OnInputDPadDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputDPadDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputDPadLeft
// (Final, Native, Public)

void UAT_UISkillTree::OnInputDPadLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputDPadLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputDPadRight
// (Final, Native, Public)

void UAT_UISkillTree::OnInputDPadRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputDPadRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputDPadUp
// (Final, Native, Public)

void UAT_UISkillTree::OnInputDPadUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputDPadUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputGotoSkillCustomize
// (Final, Native, Public)

void UAT_UISkillTree::OnInputGotoSkillCustomize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputGotoSkillCustomize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.OnInputZoomOut
// (Final, Native, Public)

void UAT_UISkillTree::OnInputZoomOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "OnInputZoomOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTree.Open
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UISkillTreeMenu*              OwnerMenu_0                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInStartWithTraining                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         InCharType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AwakePassiveMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SuperPassiveSkillID                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISkillTree::Open(class UAT_UISkillTreeMenu* OwnerMenu_0, bool bInStartWithTraining, ECHARACTER_TYPE InCharType, bool AwakePassiveMode, class FName SuperPassiveSkillID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTree", "Open");

	Params::AT_UISkillTree_Open Parms{};

	Parms.OwnerMenu_0 = OwnerMenu_0;
	Parms.bInStartWithTraining = bInStartWithTraining;
	Parms.InCharType = InCharType;
	Parms.AwakePassiveMode = AwakePassiveMode;
	Parms.SuperPassiveSkillID = SuperPassiveSkillID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.In_Header_Bg
// (Final, Native, Protected, BlueprintCallable)

void UAT_UISkillTreeMenu::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.OnMessegeWindowCancel
// (Final, Native, Protected)

void UAT_UISkillTreeMenu::OnMessegeWindowCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "OnMessegeWindowCancel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.OnMessegeWindowDecide
// (Final, Native, Protected)

void UAT_UISkillTreeMenu::OnMessegeWindowDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "OnMessegeWindowDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.OnMessegeWindowDown
// (Final, Native, Protected)

void UAT_UISkillTreeMenu::OnMessegeWindowDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "OnMessegeWindowDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.OnMessegeWindowUp
// (Final, Native, Protected)

void UAT_UISkillTreeMenu::OnMessegeWindowUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "OnMessegeWindowUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.OnSkillGetWindowClosed
// (Final, Native, Protected)
// Parameters:
// int32                                   SELECT                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISkillTreeMenu::OnSkillGetWindowClosed(int32 SELECT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "OnSkillGetWindowClosed");

	Params::AT_UISkillTreeMenu_OnSkillGetWindowClosed Parms{};

	Parms.SELECT = SELECT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.OnSkillGetWindowClosedInSuperPassiveOpend
// (Final, Native, Protected)
// Parameters:
// int32                                   SELECT                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISkillTreeMenu::OnSkillGetWindowClosedInSuperPassiveOpend(int32 SELECT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "OnSkillGetWindowClosedInSuperPassiveOpend");

	Params::AT_UISkillTreeMenu_OnSkillGetWindowClosedInSuperPassiveOpend Parms{};

	Parms.SELECT = SELECT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.Out_Bg
// (Final, Native, Protected, BlueprintCallable)

void UAT_UISkillTreeMenu::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreeMenu.Out_Header
// (Final, Native, Protected, BlueprintCallable)

void UAT_UISkillTreeMenu::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreeMenu", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISkillTreePanel.OnIn_Line
// (Final, Native, Protected, BlueprintCallable)

void UAT_UISkillTreePanel::OnIn_Line()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISkillTreePanel", "OnIn_Line");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.AddCaptureParam
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   VariationId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   FormID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AnimId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   FaceId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFacialType                             FacialType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       CameraTrans                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FString                           FacialPath                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartChar::AddCaptureParam(ECHARACTER_TYPE Icon, uint8 VariationId, uint8 FormID, const class FString& AnimId, uint8 FaceId, EFacialType FacialType, const struct FTransform& CameraTrans, const class FString& FacialPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "AddCaptureParam");

	Params::AT_UIStartChar_AddCaptureParam Parms{};

	Parms.Icon = Icon;
	Parms.VariationId = VariationId;
	Parms.FormID = FormID;
	Parms.AnimId = std::move(AnimId);
	Parms.FaceId = FaceId;
	Parms.FacialType = FacialType;
	Parms.CameraTrans = std::move(CameraTrans);
	Parms.FacialPath = std::move(FacialPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.CheckHovered
// (Final, Native, Public)

void UAT_UIStartChar::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.Close
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartChar::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.GetCursorIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIStartChar::GetCursorIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "GetCursorIndex");

	Params::AT_UIStartChar_GetCursorIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartChar.GetFocusNum
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIStartChar::GetFocusNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "GetFocusNum");

	Params::AT_UIStartChar_GetFocusNum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartChar.GetViewIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAT_UIStartChar::GetViewIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "GetViewIndex");

	Params::AT_UIStartChar_GetViewIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartChar.IsLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIStartChar::IsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "IsLoaded");

	Params::AT_UIStartChar_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartChar.LoadAsset
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartChar::LoadAsset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "LoadAsset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIStartChar::MouseClickDecide(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "MouseClickDecide");

	Params::AT_UIStartChar_MouseClickDecide Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartChar::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "MouseWheel");

	Params::AT_UIStartChar_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.OnInBgHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartChar::OnInBgHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "OnInBgHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.OnOutBg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartChar::OnOutBg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "OnOutBg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.OnOutHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartChar::OnOutHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "OnOutHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.Open
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartChar::Open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "Open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartChar.SetViewIndexAndCursorIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   A_view                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   A_cursor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartChar::SetViewIndexAndCursorIndex(int32 A_view, int32 A_cursor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartChar", "SetViewIndexAndCursorIndex");

	Params::AT_UIStartChar_SetViewIndexAndCursorIndex Parms{};

	Parms.A_view = A_view;
	Parms.A_cursor = A_cursor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCharBar.Focus
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCharBar::Focus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCharBar", "Focus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCharBar.InputDecide
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCharBar::InputDecide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCharBar", "InputDecide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCharBar.LoseFocus
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCharBar::LoseFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCharBar", "LoseFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCharBar.SetParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EUnselectableFilterText                 Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartCharBar::SetParam(ECHARACTER_TYPE Type, class UTexture2D* Icon, EUnselectableFilterText Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCharBar", "SetParam");

	Params::AT_UIStartCharBar_SetParam Parms{};

	Parms.Type = Type;
	Parms.Icon = Icon;
	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCharBar.SetToRemoveView
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCharBar::SetToRemoveView()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCharBar", "SetToRemoveView");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCommuDetail.Bg_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCommuDetail::Bg_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCommuDetail", "Bg_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCommuDetail.CheckHovered
// (Final, Native, Public)

void UAT_UIStartCommuDetail::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCommuDetail", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCommuDetail.Header_Bg_In_Internal
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCommuDetail::Header_Bg_In_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCommuDetail", "Header_Bg_In_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCommuDetail.Header_Out_Internal
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartCommuDetail::Header_Out_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCommuDetail", "Header_Out_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartCommuDetail.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIStartCommuDetail::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartCommuDetail", "MouseClickDecide");

	Params::AT_UIStartCommuDetail_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDlc.CheckHovered
// (Final, Native, Public)

void UAT_UIStartDlc::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDlc", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDlc.CheckHoveredArrow
// (Final, Native, Public)

void UAT_UIStartDlc::CheckHoveredArrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDlc", "CheckHoveredArrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDlc.ClickSelectDown
// (Final, Native, Public)

void UAT_UIStartDlc::ClickSelectDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDlc", "ClickSelectDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDlc.ClickSelectUp
// (Final, Native, Public)

void UAT_UIStartDlc::ClickSelectUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDlc", "ClickSelectUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenu.CheckHovered
// (Final, Native, Public)

void UAT_UIStartDragonBallMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIStartDragonBallMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenu", "MouseClickDecide");

	Params::AT_UIStartDragonBallMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenu.PlayInHeaderBg
// (Final, Native, Private, BlueprintCallable)

void UAT_UIStartDragonBallMenu::PlayInHeaderBg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenu", "PlayInHeaderBg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenu.PlayOutBg
// (Final, Native, Private, BlueprintCallable)

void UAT_UIStartDragonBallMenu::PlayOutBg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenu", "PlayOutBg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenu.PlayOutHeader
// (Final, Native, Private, BlueprintCallable)

void UAT_UIStartDragonBallMenu::PlayOutHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenu", "PlayOutHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenuBar.CancelText
// (Final, Native, Private, BlueprintCallable)

void UAT_UIStartDragonBallMenuBar::CancelText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenuBar", "CancelText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartDragonBallMenuBar.SetText
// (Final, Native, Private, BlueprintCallable)

void UAT_UIStartDragonBallMenuBar::SetText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartDragonBallMenuBar", "SetText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartOption.CheckHovered
// (Final, Native, Public)

void UAT_UIStartOption::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartOption", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartOption.In_Header_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartOption::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartOption", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartOption.In_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartOption::In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartOption", "In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartOption.Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartOption::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartOption", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartOption.Out_Header
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartOption::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartOption", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartOption.Out_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartOption::Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartOption", "Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartParty.CheckHovered
// (Final, Native, Public)

void UAT_UIStartParty::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartParty", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartParty.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIStartParty::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartParty", "MouseClickDecide");

	Params::AT_UIStartParty_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartParty.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartParty::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartParty", "MouseWheel");

	Params::AT_UIStartParty_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartParty.On_In_Down
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartParty::On_In_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartParty", "On_In_Down");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartParty.On_Out_Down
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartParty::On_Out_Down()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartParty", "On_Out_Down");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartPartyBar.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIStartPartyBar::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyBar", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIStartPartyBar.Ev_Change_Char
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartPartyBar::Ev_Change_Char()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyBar", "Ev_Change_Char");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartPartyBar.SetAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetAnimation*                 Enter                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 InCurs                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 InDown                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 OutDown                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartPartyBar::SetAnimation(class UWidgetAnimation* Enter, class UWidgetAnimation* InCurs, class UWidgetAnimation* InDown, class UWidgetAnimation* OutDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyBar", "SetAnimation");

	Params::AT_UIStartPartyBar_SetAnimation Parms{};

	Parms.Enter = Enter;
	Parms.InCurs = InCurs;
	Parms.InDown = InDown;
	Parms.OutDown = OutDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartPartyBar.GetCharaType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECHARACTER_TYPE                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECHARACTER_TYPE UAT_UIStartPartyBar::GetCharaType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyBar", "GetCharaType");

	Params::AT_UIStartPartyBar_GetCharaType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartPartyBar.GetEditMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EStartPartyBarEditMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStartPartyBarEditMode UAT_UIStartPartyBar::GetEditMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyBar", "GetEditMode");

	Params::AT_UIStartPartyBar_GetEditMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartPartyBar.GetIsPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIStartPartyBar::GetIsPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyBar", "GetIsPlayer");

	Params::AT_UIStartPartyBar_GetIsPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartPartyList.GetEditMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EStartPartyBarEditMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EStartPartyBarEditMode UAT_UIStartPartyList::GetEditMode(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyList", "GetEditMode");

	Params::AT_UIStartPartyList_GetEditMode Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartPartyList.GetIsPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIStartPartyList::GetIsPlayer(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyList", "GetIsPlayer");

	Params::AT_UIStartPartyList_GetIsPlayer Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartPartyList.SetParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       Tex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUnConfigurable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSwap                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartPartyList::SetParam(int32 Index_0, ECHARACTER_TYPE Type, class UTexture2D* Tex, bool bUnConfigurable, bool bChange, bool bSwap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyList", "SetParam");

	Params::AT_UIStartPartyList_SetParam Parms{};

	Parms.Index_0 = Index_0;
	Parms.Type = Type;
	Parms.Tex = Tex;
	Parms.bUnConfigurable = bUnConfigurable;
	Parms.bChange = bChange;
	Parms.bSwap = bSwap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartPartyList.GetCharaType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECHARACTER_TYPE UAT_UIStartPartyList::GetCharaType(int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyList", "GetCharaType");

	Params::AT_UIStartPartyList_GetCharaType Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStartPartyTeam.CheckHovered
// (Final, Native, Private)

void UAT_UIStartPartyTeam::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyTeam", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartPartyTeam.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIStartPartyTeam::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartPartyTeam", "MouseClickDecide");

	Params::AT_UIStartPartyTeam_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.CheckHovered
// (Final, Native, Public)

void UAT_UIStartQuest::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.On_In_Header_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartQuest::On_In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "On_In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.On_In_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartQuest::On_In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "On_In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.On_Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartQuest::On_Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "On_Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.On_Out_Header
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartQuest::On_Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "On_Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.On_Out_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartQuest::On_Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "On_Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.OnFinished_Anim_Chage_Story
// (Final, Native, Private)

void UAT_UIStartQuest::OnFinished_Anim_Chage_Story()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "OnFinished_Anim_Chage_Story");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.OnFinished_Anim_Chage_Task
// (Final, Native, Private)

void UAT_UIStartQuest::OnFinished_Anim_Chage_Task()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "OnFinished_Anim_Chage_Task");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartQuest.UpdateDetail
// (Final, Native, Private)

void UAT_UIStartQuest::UpdateDetail()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartQuest", "UpdateDetail");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartSaveLoad.In_Header_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartSaveLoad::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartSaveLoad", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartSaveLoad.Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartSaveLoad::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartSaveLoad", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartSaveLoad.Out_Header
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartSaveLoad::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartSaveLoad", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatus.Close
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartStatus::Close()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatus", "Close");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatus.OnInBgHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartStatus::OnInBgHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatus", "OnInBgHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatus.OnOutBg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartStatus::OnOutBg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatus", "OnOutBg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatus.OnOutHeader
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartStatus::OnOutHeader()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatus", "OnOutHeader");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatus.Open
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartStatus::Open()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatus", "Open");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatusHud.SetGauge
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   CurrentNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EGaugeColor                             Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsAnim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartStatusHud::SetGauge(float CurrentNum, float MaxNum, EGaugeColor Color, bool IsAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatusHud", "SetGauge");

	Params::AT_UIStartStatusHud_SetGauge Parms{};

	Parms.CurrentNum = CurrentNum;
	Parms.MaxNum = MaxNum;
	Parms.Color = Color;
	Parms.IsAnim = IsAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatusList00.Set
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESkillIcon                              Icon                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SkillName                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartStatusList00::Set(ESkillIcon Icon, const class FString& SkillName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatusList00", "Set");

	Params::AT_UIStartStatusList00_Set Parms{};

	Parms.Icon = Icon;
	Parms.SkillName = std::move(SkillName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatusList01.Set
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EViewStatusIconType                     StatusIconType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartStatusList01::Set(EViewStatusIconType StatusIconType, const class FString& ItemName, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatusList01", "Set");

	Params::AT_UIStartStatusList01_Set Parms{};

	Parms.StatusIconType = StatusIconType;
	Parms.ItemName = std::move(ItemName);
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartStatusList02.Set
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Title                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStartStatusList02::Set(const class FString& Title, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartStatusList02", "Set");

	Params::AT_UIStartStatusList02_Set Parms{};

	Parms.Title = std::move(Title);
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTips.CheckHovered
// (Final, Native, Public)

void UAT_UIStartTips::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTips", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTips.In_Header_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTips::In_Header_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTips", "In_Header_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTips.In_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTips::In_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTips", "In_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTips.Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTips::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTips", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTips.Out_Header
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTips::Out_Header()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTips", "Out_Header");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTips.Out_List
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTips::Out_List()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTips", "Out_List");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.CheckHovered
// (Final, Native, Public)

void UAT_UIStartTop::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Com_In_Curs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Com_In_Curs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Com_In_Curs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Com_In_SubCurs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Com_In_SubCurs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Com_In_SubCurs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Com_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Com_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Com_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Com_Out_Curs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Com_Out_Curs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Com_Out_Curs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Com_Out_SubCurs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Com_Out_SubCurs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Com_Out_SubCurs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.In_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::In_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "In_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.In_Curs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::In_Curs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "In_Curs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Loop_CompZ_Deco
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Loop_CompZ_Deco()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Loop_CompZ_Deco");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Out_Bg
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Out_Bg()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Out_Bg");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Out_Curs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Out_Curs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Out_Curs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Sys_In_Curs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Sys_In_Curs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Sys_In_Curs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Sys_In_SubCurs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Sys_In_SubCurs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Sys_In_SubCurs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Sys_Out
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Sys_Out()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Sys_Out");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Sys_Out_Curs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Sys_Out_Curs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Sys_Out_Curs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStartTop.Sys_Out_SubCurs
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStartTop::Sys_Out_SubCurs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStartTop", "Sys_Out_SubCurs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATBattleAI.OnChangeAction
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATBattleAI::OnChangeAction(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleAI", "OnChangeAction");

	Params::ATBattleAI_OnChangeAction Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.CheckEndSign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIStateIcon::CheckEndSign()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "CheckEndSign");

	Params::AT_UIStateIcon_CheckEndSign Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStateIcon.Clear
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStateIcon::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.IsVisibleEffectLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIStateIcon::IsVisibleEffectLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "IsVisibleEffectLight");

	Params::AT_UIStateIcon_IsVisibleEffectLight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStateIcon.Pause
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStateIcon::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.RequestPlayAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EAnimType                               AnimType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::RequestPlayAnimation(EAnimType AnimType, int32 PlayCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "RequestPlayAnimation");

	Params::AT_UIStateIcon_RequestPlayAnimation Parms{};

	Parms.AnimType = AnimType;
	Parms.PlayCount = PlayCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.Resume
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStateIcon::Resume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "Resume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetAnimReqThrough
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsThrough                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetAnimReqThrough(bool IsThrough)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetAnimReqThrough");

	Params::AT_UIStateIcon_SetAnimReqThrough Parms{};

	Parms.IsThrough = IsThrough;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetBattleMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInBatteleMode                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetBattleMode(bool bInBatteleMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetBattleMode");

	Params::AT_UIStateIcon_SetBattleMode Parms{};

	Parms.bInBatteleMode = bInBatteleMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetBuffTimeRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InRate                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetBuffTimeRate(float InRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetBuffTimeRate");

	Params::AT_UIStateIcon_SetBuffTimeRate Parms{};

	Parms.InRate = InRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetIconInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FStateIconInfo                   InIconInfo                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetIconInfo(const struct FStateIconInfo& InIconInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetIconInfo");

	Params::AT_UIStateIcon_SetIconInfo Parms{};

	Parms.InIconInfo = std::move(InIconInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        InPostion                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetPosition(const struct FVector2D& InPostion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetPosition");

	Params::AT_UIStateIcon_SetPosition Parms{};

	Parms.InPostion = std::move(InPostion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetSelfTimerMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOnTimer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetSelfTimerMode(bool bOnTimer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetSelfTimerMode");

	Params::AT_UIStateIcon_SetSelfTimerMode Parms{};

	Parms.bOnTimer = bOnTimer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetVisible(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetVisible");

	Params::AT_UIStateIcon_SetVisible Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.SetVisibleEffectLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIStateIcon::SetVisibleEffectLight(bool InEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "SetVisibleEffectLight");

	Params::AT_UIStateIcon_SetVisibleEffectLight Parms{};

	Parms.InEnable = InEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.StopPlayAnimation
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStateIcon::StopPlayAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "StopPlayAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.UndoAnimMovement
// (Final, Native, Public, BlueprintCallable)

void UAT_UIStateIcon::UndoAnimMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "UndoAnimMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIStateIcon.GetPlayingAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAnimType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAnimType UAT_UIStateIcon::GetPlayingAnim() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "GetPlayingAnim");

	Params::AT_UIStateIcon_GetPlayingAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIStateIcon.GetPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UAT_UIStateIcon::GetPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIStateIcon", "GetPosition");

	Params::AT_UIStateIcon_GetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UISystemWindow.CheckHovered
// (Final, Native, Protected)

void UAT_UISystemWindow::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.MouseClickDecide
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "MouseClickDecide");

	Params::AT_UISystemWindow_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetClosed
// (Final, Native, Protected, BlueprintCallable)

void UAT_UISystemWindow::SetClosed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetClosed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetUpMessageWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MainMsg                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFeedMarkVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::SetUpMessageWindow(const class FString& MainMsg, bool bFeedMarkVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetUpMessageWindow");

	Params::AT_UISystemWindow_SetUpMessageWindow Parms{};

	Parms.MainMsg = std::move(MainMsg);
	Parms.bFeedMarkVisible = bFeedMarkVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetupSelectItemMessageWindow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           MainTxt_0                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   SelectItemCtn                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DefaultSelectNo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::SetupSelectItemMessageWindow(const class FString& MainTxt_0, const TArray<class FString>& SelectItemCtn, int32 DefaultSelectNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetupSelectItemMessageWindow");

	Params::AT_UISystemWindow_SetupSelectItemMessageWindow Parms{};

	Parms.MainTxt_0 = std::move(MainTxt_0);
	Parms.SelectItemCtn = std::move(SelectItemCtn);
	Parms.DefaultSelectNo = DefaultSelectNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetupSelectItemTitleWindow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt_0                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   SelectItemCtn                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DefaultSelectNo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::SetupSelectItemTitleWindow(const class FString& TitleTxt_0, const TArray<class FString>& SelectItemCtn, int32 DefaultSelectNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetupSelectItemTitleWindow");

	Params::AT_UISystemWindow_SetupSelectItemTitleWindow Parms{};

	Parms.TitleTxt_0 = std::move(TitleTxt_0);
	Parms.SelectItemCtn = std::move(SelectItemCtn);
	Parms.DefaultSelectNo = DefaultSelectNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetupSelectOnlyWindow
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FString>                   SelectItemCtn                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DefaultSelectNo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::SetupSelectOnlyWindow(const TArray<class FString>& SelectItemCtn, int32 DefaultSelectNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetupSelectOnlyWindow");

	Params::AT_UISystemWindow_SetupSelectOnlyWindow Parms{};

	Parms.SelectItemCtn = std::move(SelectItemCtn);
	Parms.DefaultSelectNo = DefaultSelectNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetupTitleWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TitleTxt_0                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MainMsg                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFeedMarkVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::SetupTitleWindow(const class FString& TitleTxt_0, const class FString& MainMsg, bool bFeedMarkVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetupTitleWindow");

	Params::AT_UISystemWindow_SetupTitleWindow Parms{};

	Parms.TitleTxt_0 = std::move(TitleTxt_0);
	Parms.MainMsg = std::move(MainMsg);
	Parms.bFeedMarkVisible = bFeedMarkVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UISystemWindow.SetVisible
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UISystemWindow::SetVisible(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UISystemWindow", "SetVisible");

	Params::AT_UISystemWindow_SetVisible Parms{};

	Parms.Visible = Visible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AutoMoveTrigger.StartArrival
// (Event, Public, BlueprintEvent)

void AAutoMoveTrigger::StartArrival()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoMoveTrigger", "StartArrival");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AutoMoveTrigger.StartAutoMoveTrigger
// (Final, Native, Public, BlueprintCallable)

void AAutoMoveTrigger::StartAutoMoveTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoMoveTrigger", "StartAutoMoveTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AutoMoveTrigger.CheckTriggerId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAutoMoveTrigger::CheckTriggerId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoMoveTrigger", "CheckTriggerId");

	Params::AutoMoveTrigger_CheckTriggerId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AutoMoveTrigger.IsEnableTrigger
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAutoMoveTrigger::IsEnableTrigger() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AutoMoveTrigger", "IsEnableTrigger");

	Params::AutoMoveTrigger_IsEnableTrigger Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UITips.CheckHovered
// (Final, Native, Public)

void UAT_UITips::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.In_Headder
// (Final, Native, Public, BlueprintCallable)

void UAT_UITips::In_Headder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "In_Headder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.In_Win
// (Final, Native, Public, BlueprintCallable)

void UAT_UITips::In_Win()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "In_Win");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.Loop_Arrow
// (Final, Native, Public, BlueprintCallable)

void UAT_UITips::Loop_Arrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "Loop_Arrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UITips::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "MouseClickDecide");

	Params::AT_UITips_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.MouseClickTabLeft
// (Final, Native, Public)

void UAT_UITips::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.MouseClickTabRight
// (Final, Native, Public)

void UAT_UITips::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.Out_Headder
// (Final, Native, Public, BlueprintCallable)

void UAT_UITips::Out_Headder()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "Out_Headder");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITips.Out_Win
// (Final, Native, Public, BlueprintCallable)

void UAT_UITips::Out_Win()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITips", "Out_Win");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITipsDLC6ExtraMode.CheckHovered
// (Final, Native, Public)

void UAT_UITipsDLC6ExtraMode::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITipsDLC6ExtraMode", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITipsDLC6ExtraMode.In_Win
// (Final, Native, Public, BlueprintCallable)

void UAT_UITipsDLC6ExtraMode::In_Win()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITipsDLC6ExtraMode", "In_Win");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITipsDLC6ExtraMode.Loop_Arrow
// (Final, Native, Public, BlueprintCallable)

void UAT_UITipsDLC6ExtraMode::Loop_Arrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITipsDLC6ExtraMode", "Loop_Arrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITipsDLC6ExtraMode.Out_Win
// (Final, Native, Public, BlueprintCallable)

void UAT_UITipsDLC6ExtraMode::Out_Win()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITipsDLC6ExtraMode", "Out_Win");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITipsNew.StartInputAccepting
// (Final, Native, Public)

void UAT_UITipsNew::StartInputAccepting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITipsNew", "StartInputAccepting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITotalDamage.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UITotalDamage::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITotalDamage", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.ATActCpl021SkillShortRange.IsHitWall
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActCpl021SkillShortRange::IsHitWall(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl021SkillShortRange", "IsHitWall");

	Params::ATActCpl021SkillShortRange_IsHitWall Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Chicken_Component.OnVisibleChangedCallBack
// (Final, Native, Public)
// Parameters:
// bool                                    State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UChicken_Component::OnVisibleChangedCallBack(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Chicken_Component", "OnVisibleChangedCallBack");

	Params::Chicken_Component_OnVisibleChangedCallBack Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UITrialClear.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UITrialClear::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UITrialClear", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIUtil.DebugChangeLangage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// ERegionType                             InRegion                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ELanguageType                           InLanguage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIUtil::DebugChangeLangage(ERegionType InRegion, ELanguageType InLanguage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_UIUtil", "DebugChangeLangage");

	Params::AT_UIUtil_DebugChangeLangage Parms{};

	Parms.InRegion = InRegion;
	Parms.InLanguage = InLanguage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIUtil.SettoUICommonInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIUtil::SettoUICommonInput(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AT_UIUtil", "SettoUICommonInput");

	Params::AT_UIUtil_SettoUICommonInput Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIVillainGroupEncounterHud.InitSetting
// (Event, Protected, BlueprintEvent)

void UAT_UIVillainGroupEncounterHud::InitSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIVillainGroupEncounterHud", "InitSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIVillainGroupEncounterHudCore.InitSetting
// (Event, Protected, BlueprintEvent)

void UAT_UIVillainGroupEncounterHudCore::InitSetting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIVillainGroupEncounterHudCore", "InitSetting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIWindowManager.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIWindowManager::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIWindowManager", "MouseClickDecide");

	Params::AT_UIWindowManager_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActHighBoost.DamageApplied
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActHighBoost::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActHighBoost", "DamageApplied");

	Params::ATActHighBoost_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnAgreement.CheckHovered
// (Final, Native, Private)

void UAT_UIXcmnAgreement::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnAgreement", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnAgreement.Loop_Arrow
// (Final, Native, Private, BlueprintCallable)

void UAT_UIXcmnAgreement::Loop_Arrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnAgreement", "Loop_Arrow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnAgreement.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIXcmnAgreement::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnAgreement", "MouseClickDecide");

	Params::AT_UIXcmnAgreement_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnAgreement.MouseClickTabLeft
// (Final, Native, Private)

void UAT_UIXcmnAgreement::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnAgreement", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnAgreement.MouseClickTabRight
// (Final, Native, Private)

void UAT_UIXcmnAgreement::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnAgreement", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnBg.IsStopAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXcmnBg::IsStopAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnBg", "IsStopAnimation");

	Params::AT_UIXcmnBg_IsStopAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXcmnBg.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnBg::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnBg", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnBg.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnBg::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnBg", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnBg.SetRootVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXcmnBg::SetRootVisibility(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnBg", "SetRootVisibility");

	Params::AT_UIXcmnBg_SetRootVisibility Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnCredit.OnInAnimationFinished
// (Final, Native, Private)

void UAT_UIXcmnCredit::OnInAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnCredit", "OnInAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnCredit.OnOutAnimationFinished
// (Final, Native, Private)

void UAT_UIXcmnCredit::OnOutAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnCredit", "OnOutAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnCredit.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnCredit::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnCredit", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnCredit.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnCredit::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnCredit", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnCredit.RequestDataLoad
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnCredit::RequestDataLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnCredit", "RequestDataLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnCredit.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXcmnCredit::IsLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnCredit", "IsLoaded");

	Params::AT_UIXcmnCredit_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXCmnEmb.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIXCmnEmb::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnEmb", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIXCmnEmb_Cursor.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIXCmnEmb_Cursor::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnEmb_Cursor", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIXCmnEmb_Reality.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIXCmnEmb_Reality::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnEmb_Reality", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIXCmnEmb_Reality.Evt_Anim_Frame_In00
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIXCmnEmb_Reality::Evt_Anim_Frame_In00()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnEmb_Reality", "Evt_Anim_Frame_In00");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATBattleDemoPlayer.OnEndResult
// (Final, Native, Protected)

void UATBattleDemoPlayer::OnEndResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleDemoPlayer", "OnEndResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATBattleDemoPlayer.OnFinishedSequencer
// (Final, Native, Protected)

void UATBattleDemoPlayer::OnFinishedSequencer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleDemoPlayer", "OnFinishedSequencer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnFadeBlur.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnFadeBlur::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnFadeBlur", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnFadeBlur.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnFadeBlur::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnFadeBlur", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnHeader.IsFinishSetFontType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXCmnHeader::IsFinishSetFontType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnHeader", "IsFinishSetFontType");

	Params::AT_UIXCmnHeader_IsFinishSetFontType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXCmnHeader.IsHeaderStateIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXCmnHeader::IsHeaderStateIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnHeader", "IsHeaderStateIn");

	Params::AT_UIXCmnHeader_IsHeaderStateIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXCmnHeader.PlayIn
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXCmnHeader::PlayIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnHeader", "PlayIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnHeader.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXCmnHeader::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnHeader", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnHeader.SetFontType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EXCmnHeaderFontType                     FontType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXCmnHeaderIconType                     IconType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXCmnHeader::SetFontType(EXCmnHeaderFontType FontType, EXCmnHeaderIconType IconType, bool bAutoStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnHeader", "SetFontType");

	Params::AT_UIXCmnHeader_SetFontType Parms{};

	Parms.FontType = FontType;
	Parms.IconType = IconType;
	Parms.bAutoStart = bAutoStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnHeader.SetFontTypeWithCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EXCmnHeaderFontType                     FontType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECOMMUNITY_CATEGORY                     CmuType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAutoStart                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXCmnHeader::SetFontTypeWithCategory(EXCmnHeaderFontType FontType, ECOMMUNITY_CATEGORY CmuType, bool bAutoStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnHeader", "SetFontTypeWithCategory");

	Params::AT_UIXCmnHeader_SetFontTypeWithCategory Parms{};

	Parms.FontType = FontType;
	Parms.CmuType = CmuType;
	Parms.bAutoStart = bAutoStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnHeaderS.PlayIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMiniHeaderType                         HeaderType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXcmnHeaderS::PlayIn(EMiniHeaderType HeaderType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnHeaderS", "PlayIn");

	Params::AT_UIXcmnHeaderS_PlayIn Parms{};

	Parms.HeaderType = HeaderType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnHeaderS.PlayOut
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXcmnHeaderS::PlayOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnHeaderS", "PlayOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Credits.PlayCredits
// (Final, Native, Protected, BlueprintCallable)

void ACredits::PlayCredits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Credits", "PlayCredits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Credits.StopCredits
// (Final, Native, Protected, BlueprintCallable)

void ACredits::StopCredits()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Credits", "StopCredits");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnKeyHelpBNID.OnPressKey
// (Final, Native, Protected)

void UAT_UIXcmnKeyHelpBNID::OnPressKey()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnKeyHelpBNID", "OnPressKey");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnMultiLineTextFitBox.SetText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (Parm, NativeAccessSpecifierPublic)

void UAT_UIXcmnMultiLineTextFitBox::SetText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnMultiLineTextFitBox", "SetText");

	Params::AT_UIXcmnMultiLineTextFitBox_SetText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnMultiLineTextFitBox.GetText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UAT_UIXcmnMultiLineTextFitBox::GetText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnMultiLineTextFitBox", "GetText");

	Params::AT_UIXcmnMultiLineTextFitBox_GetText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXCmnPause.CheckHovered
// (Final, Native, Private)

void UAT_UIXCmnPause::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnPause", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnPause.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIXCmnPause::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnPause", "MouseClickDecide");

	Params::AT_UIXCmnPause_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnPause.MouseClickTabLeft
// (Final, Native, Private)

void UAT_UIXCmnPause::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnPause", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnPause.MouseClickTabRight
// (Final, Native, Private)

void UAT_UIXCmnPause::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnPause", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXCmnPause.OnEnterAnimEnd
// (Final, Native, Private)

void UAT_UIXCmnPause::OnEnterAnimEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXCmnPause", "OnEnterAnimEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnSystemIcon.DebugRequestLoad
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXcmnSystemIcon::DebugRequestLoad(int32 InNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnSystemIcon", "DebugRequestLoad");

	Params::AT_UIXcmnSystemIcon_DebugRequestLoad Parms{};

	Parms.InNo = InNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnSystemIcon.OnSaveBegin
// (Final, Native, Public)

void UAT_UIXcmnSystemIcon::OnSaveBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnSystemIcon", "OnSaveBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnSystemIcon.OnSaveEnd
// (Final, Native, Public)
// Parameters:
// bool                                    IsSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXcmnSystemIcon::OnSaveEnd(bool IsSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnSystemIcon", "OnSaveEnd");

	Params::AT_UIXcmnSystemIcon_OnSaveEnd Parms{};

	Parms.IsSuccess = IsSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnSystemIcon.OnSaveLoadBegin
// (Final, Native, Public)

void UAT_UIXcmnSystemIcon::OnSaveLoadBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnSystemIcon", "OnSaveLoadBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnSystemIcon.OnSystemSaveLoadEnd
// (Final, Native, Private)
// Parameters:
// bool                                    IsSuccess                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXcmnSystemIcon::OnSystemSaveLoadEnd(bool IsSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnSystemIcon", "OnSystemSaveLoadEnd");

	Params::AT_UIXcmnSystemIcon_OnSystemSaveLoadEnd Parms{};

	Parms.IsSuccess = IsSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnWin02.CheckHovered
// (Final, Native, Public)

void UAT_UIXcmnWin02::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnWin02", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnWin02.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIXcmnWin02::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnWin02", "MouseClickDecide");

	Params::AT_UIXcmnWin02_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnWin02.MouseClickDownArrow
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIXcmnWin02::MouseClickDownArrow(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnWin02", "MouseClickDownArrow");

	Params::AT_UIXcmnWin02_MouseClickDownArrow Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXcmnWin02.MouseClickUpArrow
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAT_UIXcmnWin02::MouseClickUpArrow(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXcmnWin02", "MouseClickUpArrow");

	Params::AT_UIXcmnWin02_MouseClickUpArrow Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXList_Detail00.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UAT_UIXList_Detail00::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXList_Detail00", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.AT_UIXListBar01.DebugRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InNo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::DebugRequest(int32 InNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "DebugRequest");

	Params::AT_UIXListBar01_DebugRequest Parms{};

	Parms.InNo = InNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.Focus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::Focus(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "Focus");

	Params::AT_UIXListBar01_Focus Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.GetNotSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXListBar01::GetNotSelect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "GetNotSelect");

	Params::AT_UIXListBar01_GetNotSelect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXListBar01.IsBusy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXListBar01::IsBusy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "IsBusy");

	Params::AT_UIXListBar01_IsBusy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXListBar01.LoseFocus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::LoseFocus(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "LoseFocus");

	Params::AT_UIXListBar01_LoseFocus Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.SetItemName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::SetItemName(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "SetItemName");

	Params::AT_UIXListBar01_SetItemName Parms{};

	Parms.InString = std::move(InString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.SetNotSelect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NotSelect                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::SetNotSelect(bool NotSelect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "SetNotSelect");

	Params::AT_UIXListBar01_SetNotSelect Parms{};

	Parms.NotSelect = NotSelect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EUIXLISTBAR01_STATE_ID                  InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::SetState(EUIXLISTBAR01_STATE_ID InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "SetState");

	Params::AT_UIXListBar01_SetState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.SetSubMenuParam
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXListBar01::SetSubMenuParam(int32 Index_0, const class FString& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "SetSubMenuParam");

	Params::AT_UIXListBar01_SetSubMenuParam Parms{};

	Parms.Index_0 = Index_0;
	Parms.ItemName = std::move(ItemName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXListBar01.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EUIXLISTBAR01_STATE_ID                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EUIXLISTBAR01_STATE_ID UAT_UIXListBar01::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "GetState");

	Params::AT_UIXListBar01_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXListBar01.IsEnable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXListBar01::IsEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "IsEnable");

	Params::AT_UIXListBar01_IsEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXListBar01.IsEndEnter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXListBar01::IsEndEnter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "IsEndEnter");

	Params::AT_UIXListBar01_IsEndEnter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXListBar01.IsEndSubEnter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_UIXListBar01::IsEndSubEnter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXListBar01", "IsEndSubEnter");

	Params::AT_UIXListBar01_IsEndSubEnter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.AT_UIXlistBar04.Focus
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXlistBar04::Focus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistBar04", "Focus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXlistBar04.InputLeft
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXlistBar04::InputLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistBar04", "InputLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXlistBar04.InputRight
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXlistBar04::InputRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistBar04", "InputRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXlistBar04.LoseFocus
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXlistBar04::LoseFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistBar04", "LoseFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXlistBar04.Set
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FXlistBar04Info                  XlistBar04Info                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UAT_UIXlistBar04::Set(struct FXlistBar04Info* XlistBar04Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistBar04", "Set");

	Params::AT_UIXlistBar04_Set Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (XlistBar04Info != nullptr)
		*XlistBar04Info = std::move(Parms.XlistBar04Info);
}


// Function AT.ATActCpl013ShockWave.OnChangeProjectilePhase
// (Final, Native, Public)
// Parameters:
// bool                                    PlayerHit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActCpl013ShockWave::OnChangeProjectilePhase(bool PlayerHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl013ShockWave", "OnChangeProjectilePhase");

	Params::ATActCpl013ShockWave_OnChangeProjectilePhase Parms{};

	Parms.PlayerHit = PlayerHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl013ShockWave.OnEntryDamage
// (Final, Native, Public)

void UATActCpl013ShockWave::OnEntryDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl013ShockWave", "OnEntryDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXlistCustom00Item.Change_Txt
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXlistCustom00Item::Change_Txt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistCustom00Item", "Change_Txt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXlistCustom00.MouseWheel
// (Final, Native, Public)
// Parameters:
// float                                   Dir                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIXlistCustom00::MouseWheel(float Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXlistCustom00", "MouseWheel");

	Params::AT_UIXlistCustom00_MouseWheel Parms{};

	Parms.Dir = Dir;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXmenuCommu.InitAllStar
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXmenuCommu::InitAllStar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXmenuCommu", "InitAllStar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXmenuCommu.PlayInAllStar
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIXmenuCommu::PlayInAllStar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXmenuCommu", "PlayInAllStar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXmenuCommu.PlayOutAllStar
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIXmenuCommu::PlayOutAllStar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXmenuCommu", "PlayOutAllStar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIIconStar.OnEndOut
// (Final, Native, Protected, BlueprintCallable)

void UAT_UIIconStar::OnEndOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIIconStar", "OnEndOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIXtexPartsDb00.SetRandomDB
// (Final, Native, Public, BlueprintCallable)

void UAT_UIXtexPartsDb00::SetRandomDB()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIXtexPartsDb00", "SetRandomDB");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIZCWCompletion.OnBeginBattle
// (Final, Native, Public)

void UAT_UIZCWCompletion::OnBeginBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIZCWCompletion", "OnBeginBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIZCWCompletion.OnEndBattle
// (Final, Native, Public)

void UAT_UIZCWCompletion::OnEndBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIZCWCompletion", "OnEndBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIZCWCompletion.OnEndTalkEvent
// (Final, Native, Public)

void UAT_UIZCWCompletion::OnEndTalkEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIZCWCompletion", "OnEndTalkEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIZCWCompletion.OnEvtBattleStart
// (Final, Native, Public)

void UAT_UIZCWCompletion::OnEvtBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIZCWCompletion", "OnEvtBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_UIZCWNavigation.OnChangedExtendProgress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             InProgressId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_UIZCWNavigation::OnChangedExtendProgress(const class FName& InProgressId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_UIZCWNavigation", "OnChangedExtendProgress");

	Params::AT_UIZCWNavigation_OnChangedExtendProgress Parms{};

	Parms.InProgressId = InProgressId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialComponent.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialComponent::OnMontageEnded(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialComponent", "OnMontageEnded");

	Params::ATFacialComponent_OnMontageEnded Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialComponent.OnMontageStarted
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialComponent::OnMontageStarted(class UAnimMontage* PMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialComponent", "OnMontageStarted");

	Params::ATFacialComponent_OnMontageStarted Parms{};

	Parms.PMontage = PMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialComponent.OnPostChangeAnimationBlueprint
// (Final, Native, Public)
// Parameters:
// class UClass*                           InClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMesh                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialComponent::OnPostChangeAnimationBlueprint(const class UClass* InClass, const class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialComponent", "OnPostChangeAnimationBlueprint");

	Params::ATFacialComponent_OnPostChangeAnimationBlueprint Parms{};

	Parms.InClass = InClass;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialComponent.OnPreChangeAnimationBlueprint
// (Final, Native, Public)
// Parameters:
// class UClass*                           InClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMesh                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialComponent::OnPreChangeAnimationBlueprint(const class UClass* InClass, const class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialComponent", "OnPreChangeAnimationBlueprint");

	Params::ATFacialComponent_OnPreChangeAnimationBlueprint Parms{};

	Parms.InClass = InClass;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialComponent.ResetForceSetting
// (Final, Native, Public)
// Parameters:
// EQUEST_GENERAL_TALK_TIMING              Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialComponent::ResetForceSetting(EQUEST_GENERAL_TALK_TIMING Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialComponent", "ResetForceSetting");

	Params::ATFacialComponent_ResetForceSetting Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialComponent.SetFacialMontage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EFacialType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialComponent::SetFacialMontage(EFacialType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialComponent", "SetFacialMontage");

	Params::ATFacialComponent_SetFacialMontage Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDirectionRushQTE.OnInputQTEResult
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATDirectionRushQTE::OnInputQTEResult(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionRushQTE", "OnInputQTEResult");

	Params::ATDirectionRushQTE_OnInputQTEResult Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDirectionRushQTE.OnPressedInputRushQTE
// (Final, Native, Protected)

void UATDirectionRushQTE::OnPressedInputRushQTE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionRushQTE", "OnPressedInputRushQTE");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SuperTrainingComponent.OnCloseResult
// (Final, Native, Private)

void USuperTrainingComponent::OnCloseResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SuperTrainingComponent", "OnCloseResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SuperTrainingComponent.OnLoadWidget
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          InLoader                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USuperTrainingComponent::OnLoadWidget(class UATDataAssetUiAsyncLoad* InLoader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SuperTrainingComponent", "OnLoadWidget");

	Params::SuperTrainingComponent_OnLoadWidget Parms{};

	Parms.InLoader = InLoader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SuperTrainingComponent.ShowResult
// (Final, Native, Private)

void USuperTrainingComponent::ShowResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SuperTrainingComponent", "ShowResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl011BSkilll004.Cpl011BSkill104ResetCamera
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActCpl011BSkilll004::Cpl011BSkill104ResetCamera(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl011BSkilll004", "Cpl011BSkill104ResetCamera");

	Params::ATActCpl011BSkilll004_Cpl011BSkill104ResetCamera Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.BeginHeat
// (Final, Native, Public)

void UATEventBattleMission::BeginHeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "BeginHeat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.EventBattleResult
// (Final, Native, Public)

void UATEventBattleMission::EventBattleResult()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "EventBattleResult");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.GardBreakStart
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEventBattleMission::GardBreakStart(class AAT_Character* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "GardBreakStart");

	Params::ATEventBattleMission_GardBreakStart Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.JostleBeam
// (Final, Native, Public)

void UATEventBattleMission::JostleBeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "JostleBeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.OnActionChange
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEventBattleMission::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "OnActionChange");

	Params::ATEventBattleMission_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.OnComboAddEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATEventBattleMission::OnComboAddEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "OnComboAddEvent");

	Params::ATEventBattleMission_OnComboAddEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.OnComboEndEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATEventBattleMission::OnComboEndEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "OnComboEndEvent");

	Params::ATEventBattleMission_OnComboEndEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.OnDamageHitEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATEventBattleMission::OnDamageHitEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "OnDamageHitEvent");

	Params::ATEventBattleMission_OnDamageHitEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.OnRingoutEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EvParam                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATEventBattleMission::OnRingoutEvent(const struct FEventParam& EvParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "OnRingoutEvent");

	Params::ATEventBattleMission_OnRingoutEvent Parms{};

	Parms.EvParam = std::move(EvParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEventBattleMission.StunStart
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEventBattleMission::StunStart(class AAT_Character* TargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEventBattleMission", "StunStart");

	Params::ATEventBattleMission_StunStart Parms{};

	Parms.TargetCharacter = TargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelChanger.OnLevelShown
// (Final, Native, Protected)
// Parameters:
// class ULevelStreaming*                  StreamingLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATLevelChanger::OnLevelShown(class ULevelStreaming* StreamingLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelChanger", "OnLevelShown");

	Params::ATLevelChanger_OnLevelShown Parms{};

	Parms.StreamingLevel = StreamingLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl018SkillSpecial.OnEntryDamage
// (Final, Native, Public)

void UATActCpl018SkillSpecial::OnEntryDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl018SkillSpecial", "OnEntryDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.NativeInitialize
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATMapIconComponent::NativeInitialize(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "NativeInitialize");

	Params::ATMapIconComponent_NativeInitialize Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.RemoveLandMarkIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmarkIconType                       InLandmarkType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATMapIconComponent::RemoveLandMarkIcon(ELandmarkIconType InLandmarkType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "RemoveLandMarkIcon");

	Params::ATMapIconComponent_RemoveLandMarkIcon Parms{};

	Parms.InLandmarkType = InLandmarkType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.RemoveMapIcon
// (Final, Native, Public, BlueprintCallable)

void UATMapIconComponent::RemoveMapIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "RemoveMapIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.SetIsShowMapIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsShow                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATMapIconComponent::SetIsShowMapIcon(bool bIsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "SetIsShowMapIcon");

	Params::ATMapIconComponent_SetIsShowMapIcon Parms{};

	Parms.bIsShow = bIsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.SetLandMarkIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmarkIconType                       InLandmarkType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATMapIconComponent::SetLandMarkIcon(ELandmarkIconType InLandmarkType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "SetLandMarkIcon");

	Params::ATMapIconComponent_SetLandMarkIcon Parms{};

	Parms.InLandmarkType = InLandmarkType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.SetMapIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMapIcon                                InMapIconType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSearchRangeRadius                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATMapIconComponent::SetMapIcon(EMapIcon InMapIconType, float InSearchRangeRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "SetMapIcon");

	Params::ATMapIconComponent_SetMapIcon Parms{};

	Parms.InMapIconType = InMapIconType;
	Parms.InSearchRangeRadius = InSearchRangeRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMapIconComponent.SetMapIconAndName
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EMapIcon                                InMapIconType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSearchRangeRadius                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATMapIconComponent::SetMapIconAndName(EMapIcon InMapIconType, float InSearchRangeRadius, const class FName& QuestId, int32 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMapIconComponent", "SetMapIconAndName");

	Params::ATMapIconComponent_SetMapIconAndName Parms{};

	Parms.InMapIconType = InMapIconType;
	Parms.InSearchRangeRadius = InSearchRangeRadius;
	Parms.QuestId = QuestId;
	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl019BSkillSpecial.OnEntryDamage
// (Final, Native, Public)

void UATActCpl019BSkillSpecial::OnEntryDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl019BSkillSpecial", "OnEntryDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl041EVanishingBall.OnChangeProjectilePhase
// (Final, Native, Public)
// Parameters:
// bool                                    PlayerHit                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActCpl041EVanishingBall::OnChangeProjectilePhase(bool PlayerHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl041EVanishingBall", "OnChangeProjectilePhase");

	Params::ATActCpl041EVanishingBall_OnChangeProjectilePhase Parms{};

	Parms.PlayerHit = PlayerHit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl041EVanishingBall.OnEntryDamage
// (Final, Native, Public)

void UATActCpl041EVanishingBall::OnEntryDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl041EVanishingBall", "OnEntryDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl101SkillG006.IsHitWall
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComp                                                (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActCpl101SkillG006::IsHitWall(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl101SkillG006", "IsHitWall");

	Params::ATActCpl101SkillG006_IsHitWall Parms{};

	Parms.HitComp = HitComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActCpl107Skill002DmgBlowoff.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActCpl107Skill002DmgBlowoff::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActCpl107Skill002DmgBlowoff", "OnHitPhoton");

	Params::ATActCpl107Skill002DmgBlowoff_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDecalActor.CreateDynamicMaterialInstance
// (Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceDynamic*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstanceDynamic* AATDecalActor::CreateDynamicMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDecalActor", "CreateDynamicMaterialInstance");

	Params::ATDecalActor_CreateDynamicMaterialInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDecalActor.SetDecalMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               NewDecalMaterial                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDecalActor::SetDecalMaterial(class UMaterialInterface* NewDecalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDecalActor", "SetDecalMaterial");

	Params::ATDecalActor_SetDecalMaterial Parms{};

	Parms.NewDecalMaterial = NewDecalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDecalActor.GetDecalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInterface*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInterface* AATDecalActor::GetDecalMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDecalActor", "GetDecalMaterial");

	Params::ATDecalActor_GetDecalMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATSequencerDemoCtrl.RegisterSequenceActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DemoName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALevelSequenceActor*              SequenceActor                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSequencerDemoCtrl::RegisterSequenceActor(const class FName DemoName, class ALevelSequenceActor* SequenceActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSequencerDemoCtrl", "RegisterSequenceActor");

	Params::ATSequencerDemoCtrl_RegisterSequenceActor Parms{};

	Parms.DemoName = DemoName;
	Parms.SequenceActor = SequenceActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSequencerDemoCtrl.UnregisterSequenceActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DemoName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSequencerDemoCtrl::UnregisterSequenceActor(const class FName DemoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSequencerDemoCtrl", "UnregisterSequenceActor");

	Params::ATSequencerDemoCtrl_UnregisterSequenceActor Parms{};

	Parms.DemoName = DemoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LipSyncComponent.IsLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULipSyncComponent::IsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LipSyncComponent", "IsLoaded");

	Params::LipSyncComponent_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.LipSyncComponent.Load
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULipSyncComponent::Load(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LipSyncComponent", "Load");

	Params::LipSyncComponent_Load Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LipSyncComponent.Pause
// (Final, Native, Public, BlueprintCallable)

void ULipSyncComponent::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LipSyncComponent", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LipSyncComponent.Play
// (Final, Native, Public, BlueprintCallable)

void ULipSyncComponent::Play()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LipSyncComponent", "Play");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgDeathFall.HitCharacter
// (Final, Native, Protected)
// Parameters:
// struct FHitResult                       InHitResult                                            (Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActDmgDeathFall::HitCharacter(const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgDeathFall", "HitCharacter");

	Params::ATActDmgDeathFall_HitCharacter Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CookingState.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCookingState::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CookingState", "OnDemoTiming");

	Params::CookingState_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CookingState.OnMontageBlendingOut
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCookingState::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CookingState", "OnMontageBlendingOut");

	Params::CookingState_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CookingState.OnMontageBlendingOutStart
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCookingState::OnMontageBlendingOutStart(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CookingState", "OnMontageBlendingOutStart");

	Params::CookingState_OnMontageBlendingOutStart Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.GetSkillNotification
// (Final, Native, Public)

void ATrainingPointActor::GetSkillNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "GetSkillNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OnEventBattleEnd
// (Final, Native, Private)

void ATrainingPointActor::OnEventBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OnEventBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OnEventBattleNotify
// (Final, Native, Private)

void ATrainingPointActor::OnEventBattleNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OnEventBattleNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OnEventBattleStart
// (Final, Native, Private)

void ATrainingPointActor::OnEventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OnEventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OnLoadWidget
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          InLoader                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATrainingPointActor::OnLoadWidget(class UATDataAssetUiAsyncLoad* InLoader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OnLoadWidget");

	Params::TrainingPointActor_OnLoadWidget Parms{};

	Parms.InLoader = InLoader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OnResultEnd
// (Final, Native, Private)

void ATrainingPointActor::OnResultEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OnResultEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OnResultStart
// (Final, Native, Private)

void ATrainingPointActor::OnResultStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OnResultStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingPointActor.OpenMenu
// (Final, Native, Public)

void ATrainingPointActor::OpenMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingPointActor", "OpenMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgHoldRushQteFaceTrigger.OnInputQTEResult
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATActDmgHoldRushQteFaceTrigger::OnInputQTEResult(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgHoldRushQteFaceTrigger", "OnInputQTEResult");

	Params::ATActDmgHoldRushQteFaceTrigger_OnInputQTEResult Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkConditionDefeatEnemies.OnBattleStarted
// (Final, Native, Protected)

void UCrossTalkConditionDefeatEnemies::OnBattleStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkConditionDefeatEnemies", "OnBattleStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkConditionDefeatEnemies.OnDefeatedEnemy
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrossTalkConditionDefeatEnemies::OnDefeatedEnemy(class AAT_Character* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkConditionDefeatEnemies", "OnDefeatedEnemy");

	Params::CrossTalkConditionDefeatEnemies_OnDefeatedEnemy Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.BeginTransform
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleManager::BeginTransform(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "BeginTransform");

	Params::BattleManager_BeginTransform Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.OnBattleStart
// (Final, Native, Private)
// Parameters:
// class AAT_CharacterBase*                Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EnemyPartyID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   BattleType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleManager::OnBattleStart(class AAT_CharacterBase* Character, class FName EnemyPartyID, uint8 BattleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "OnBattleStart");

	Params::BattleManager_OnBattleStart Parms{};

	Parms.Character = Character;
	Parms.EnemyPartyID = EnemyPartyID;
	Parms.BattleType = BattleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.OnDeleteDeathCharacter
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleManager::OnDeleteDeathCharacter(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "OnDeleteDeathCharacter");

	Params::BattleManager_OnDeleteDeathCharacter Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBattleManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "OnDemoTiming");

	Params::BattleManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.OnEndEventBattle
// (Final, Native, Private)

void UBattleManager::OnEndEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "OnEndEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.OnSettleEventBattle
// (Final, Native, Private)

void UBattleManager::OnSettleEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "OnSettleEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.OnStartEventBattle
// (Final, Native, Private)

void UBattleManager::OnStartEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "OnStartEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BattleManager.ReceiveEvents
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBattleManager::ReceiveEvents(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleManager", "ReceiveEvents");

	Params::BattleManager_ReceiveEvents Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgLongBlowoff.OnHitPhoton
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActDmgLongBlowoff::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgLongBlowoff", "OnHitPhoton");

	Params::ATActDmgLongBlowoff_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActDmgLongBlowoffDirection.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActDmgLongBlowoffDirection::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActDmgLongBlowoffDirection", "OnHitPhoton");

	Params::ATActDmgLongBlowoffDirection_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDataAssetQuest.OnLoadedByProgress
// (Final, Native, Private)

void UATDataAssetQuest::OnLoadedByProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDataAssetQuest", "OnLoadedByProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDataAssetQuest.OnLoadedUseAsset
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             AssetName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDataAssetQuest::OnLoadedUseAsset(const class FName& AssetName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDataAssetQuest", "OnLoadedUseAsset");

	Params::ATDataAssetQuest_OnLoadedUseAsset Parms{};

	Parms.AssetName = AssetName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDataAssetQuest.OnProgressChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             NextProgressName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDataAssetQuest::OnProgressChanged(const class FName& NextProgressName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDataAssetQuest", "OnProgressChanged");

	Params::ATDataAssetQuest_OnProgressChanged Parms{};

	Parms.NextProgressName = NextProgressName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenuComponent.GetMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOptionMenu*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UOptionMenu* UOptionMenuComponent::GetMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenuComponent", "GetMenu");

	Params::OptionMenuComponent_GetMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.OptionMenuComponent.MenuActivate
// (Final, Native, Public, BlueprintCallable)

void UOptionMenuComponent::MenuActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenuComponent", "MenuActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenuComponent.MenuDeactivate
// (Final, Native, Public, BlueprintCallable)

void UOptionMenuComponent::MenuDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenuComponent", "MenuDeactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingManager.GetFishingResource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFishingResource*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFishingResource* UFishingManager::GetFishingResource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "GetFishingResource");

	Params::FishingManager_GetFishingResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.FishingManager.GetFishingStartPointClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UFishingManager::GetFishingStartPointClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "GetFishingStartPointClass");

	Params::FishingManager_GetFishingStartPointClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.FishingManager.GetSignsOfFishClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UFishingManager::GetSignsOfFishClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "GetSignsOfFishClass");

	Params::FishingManager_GetSignsOfFishClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.FishingManager.OnLeftStickXAxis
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector2D                        InInputAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFishingManager::OnLeftStickXAxis(const struct FVector2D& InInputAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "OnLeftStickXAxis");

	Params::FishingManager_OnLeftStickXAxis Parms{};

	Parms.InInputAxis = std::move(InInputAxis);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingManager.OnMessageGameWindowClosed
// (Final, Native, Private)
// Parameters:
// int32                                   InSelectNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFishingManager::OnMessageGameWindowClosed(int32 InSelectNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "OnMessageGameWindowClosed");

	Params::FishingManager_OnMessageGameWindowClosed Parms{};

	Parms.InSelectNum = InSelectNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingManager.OnPressedButton_RD
// (Final, Native, Public)

void UFishingManager::OnPressedButton_RD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "OnPressedButton_RD");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingManager.OnPressedButton_RL
// (Final, Native, Public)

void UFishingManager::OnPressedButton_RL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "OnPressedButton_RL");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingManager.OnPressedButton_RR
// (Final, Native, Public)

void UFishingManager::OnPressedButton_RR()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "OnPressedButton_RR");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingManager.OnPressedButton_RU
// (Final, Native, Public)

void UFishingManager::OnPressedButton_RU()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingManager", "OnPressedButton_RU");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.BackTalkTimes
// (Final, Native, Public, BlueprintCallable)

void UNpcTalkComponent::BackTalkTimes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "BackTalkTimes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.InitializeTalk
// (Final, Native, Public)

void UNpcTalkComponent::InitializeTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "InitializeTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.InitTalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TalkID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceReset                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcTalkComponent::InitTalk(const class FString& TalkID, bool bForceReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "InitTalk");

	Params::NpcTalkComponent_InitTalk Parms{};

	Parms.TalkID = std::move(TalkID);
	Parms.bForceReset = bForceReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcTalkComponent.OnBattleEnd
// (Final, Native, Private)

void UNpcTalkComponent::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.OnEncountStart
// (Final, Native, Private)

void UNpcTalkComponent::OnEncountStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "OnEncountStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.OnFinishedCooking
// (Final, Native, Private)
// Parameters:
// EEventTimingType                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcTalkComponent::OnFinishedCooking(EEventTimingType Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "OnFinishedCooking");

	Params::NpcTalkComponent_OnFinishedCooking Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.OnFinishedDevelopment
// (Final, Native, Private)
// Parameters:
// EEventTimingType                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcTalkComponent::OnFinishedDevelopment(EEventTimingType Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "OnFinishedDevelopment");

	Params::NpcTalkComponent_OnFinishedDevelopment Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.OnLoadCompleted
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNpcTalkComponent::OnLoadCompleted(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "OnLoadCompleted");

	Params::NpcTalkComponent_OnLoadCompleted Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.SetSpeakerId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SpeakerID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcTalkComponent::SetSpeakerId(const class FString& SpeakerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "SetSpeakerId");

	Params::NpcTalkComponent_SetSpeakerId Parms{};

	Parms.SpeakerID = std::move(SpeakerID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.SetupTalkComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InitComponent                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TalkID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcTalkComponent::SetupTalkComponent(bool InitComponent, const class FString& TalkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "SetupTalkComponent");

	Params::NpcTalkComponent_SetupTalkComponent Parms{};

	Parms.InitComponent = InitComponent;
	Parms.TalkID = std::move(TalkID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.SetVisibleTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcTalkComponent::SetVisibleTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "SetVisibleTime");

	Params::NpcTalkComponent_SetVisibleTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkComponent.GetTalkId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UNpcTalkComponent::GetTalkId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkComponent", "GetTalkId");

	Params::NpcTalkComponent_GetTalkId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDinosaurMoveAreaVolume.OnBeginOverlap
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDinosaurMoveAreaVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDinosaurMoveAreaVolume", "OnBeginOverlap");

	Params::ATDinosaurMoveAreaVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDinosaurMoveAreaVolume.OnEndOverlap
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDinosaurMoveAreaVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDinosaurMoveAreaVolume", "OnEndOverlap");

	Params::ATDinosaurMoveAreaVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrossTalkVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkVolume", "OnOverlapBegin");

	Params::CrossTalkVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrossTalkVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkVolume", "OnOverlapEnd");

	Params::CrossTalkVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgBoundC001FSKL003.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActGroundBattleDmgBoundC001FSKL003::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgBoundC001FSKL003", "OnHitPhoton");

	Params::ATActGroundBattleDmgBoundC001FSKL003_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgBoundC001FSKL003.OnReachedJumpApex
// (Final, Native, Protected)

void UATActGroundBattleDmgBoundC001FSKL003::OnReachedJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgBoundC001FSKL003", "OnReachedJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUIBannedSkill.RipOffBannedSkillOnRetryStart
// (Final, Native, Public)

void UATUIBannedSkill::RipOffBannedSkillOnRetryStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUIBannedSkill", "RipOffBannedSkillOnRetryStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCostumeChanger.OnLoadedFacialParts
// (Final, Native, Private)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestCostumeChanger::OnLoadedFacialParts(class UATDataAssetFacialAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCostumeChanger", "OnLoadedFacialParts");

	Params::QuestCostumeChanger_OnLoadedFacialParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCostumeChanger.OnLoadedFormParts
// (Final, Native, Private)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestCostumeChanger::OnLoadedFormParts(class UATDataAssetFormMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCostumeChanger", "OnLoadedFormParts");

	Params::QuestCostumeChanger_OnLoadedFormParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCostumeChanger.OnLoadedVariationParts
// (Final, Native, Private)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestCostumeChanger::OnLoadedVariationParts(class UATDataAssetVariationMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCostumeChanger", "OnLoadedVariationParts");

	Params::QuestCostumeChanger_OnLoadedVariationParts Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCostumeChanger.OnTimer
// (Final, Native, Private)

void UQuestCostumeChanger::OnTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCostumeChanger", "OnTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelScriptActor.OnLevelLoaded
// (Event, Public, BlueprintEvent)

void AATLevelScriptActor::OnLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelScriptActor", "OnLevelLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.ATLevelScriptActor.ReceiveDemoEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATLevelScriptActor::ReceiveDemoEvent(class FName DemoName, EDEMO_TIMING_TYPE Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelScriptActor", "ReceiveDemoEvent");

	Params::ATLevelScriptActor_ReceiveDemoEvent Parms{};

	Parms.DemoName = DemoName;
	Parms.Timing = Timing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.ATTitleLevelScriptActor.OnCloseLoadMenu
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnCloseLoadMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnCloseLoadMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATTitleLevelScriptActor.OnCloseOptionMenu
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnCloseOptionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnCloseOptionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATTitleLevelScriptActor.OnEndUILoadingFade
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnEndUILoadingFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnEndUILoadingFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATTitleLevelScriptActor.OnLoadedAllLoadMenu
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnLoadedAllLoadMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnLoadedAllLoadMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATTitleLevelScriptActor.OnLoadedAllOptionMenu
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnLoadedAllOptionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnLoadedAllOptionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATTitleLevelScriptActor.OnOpenLoadMenu
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnOpenLoadMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnOpenLoadMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATTitleLevelScriptActor.OnOpenOptionMenu
// (Final, Native, Private)

void AATTitleLevelScriptActor::OnOpenOptionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATTitleLevelScriptActor", "OnOpenOptionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgUpper.OnHitPhoton
// (Final, Native, Protected, HasOutParams)
// Parameters:
// TArray<struct FHitResult>               InResults                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   InShouldPassingActors                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UATActGroundBattleDmgUpper::OnHitPhoton(const TArray<struct FHitResult>& InResults, const TArray<class AActor*>& InShouldPassingActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgUpper", "OnHitPhoton");

	Params::ATActGroundBattleDmgUpper_OnHitPhoton Parms{};

	Parms.InResults = std::move(InResults);
	Parms.InShouldPassingActors = std::move(InShouldPassingActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActGroundBattleDmgUpper.OnReachedJumpApex
// (Final, Native, Protected)

void UATActGroundBattleDmgUpper::OnReachedJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleDmgUpper", "OnReachedJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSaveManager.AutoSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESaveGameSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSaveManager::AutoSave(ESaveGameSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSaveManager", "AutoSave");

	Params::ATSaveManager_AutoSave Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSaveManager.Delete
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESaveGameSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSaveManager::Delete(ESaveGameSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSaveManager", "Delete");

	Params::ATSaveManager_Delete Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSaveManager.DoesSaveGameExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESaveGameSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATSaveManager::DoesSaveGameExist(ESaveGameSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSaveManager", "DoesSaveGameExist");

	Params::ATSaveManager_DoesSaveGameExist Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATSaveManager.Load
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESaveGameSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsNotDlcLost                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSaveManager::Load(ESaveGameSlot Slot, bool IsNotDlcLost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSaveManager", "Load");

	Params::ATSaveManager_Load Parms{};

	Parms.Slot = Slot;
	Parms.IsNotDlcLost = IsNotDlcLost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSaveManager.Save
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESaveGameSlot                           Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSaveManager::Save(ESaveGameSlot Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSaveManager", "Save");

	Params::ATSaveManager_Save Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSaveManager.IsSystemLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATSaveManager::IsSystemLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSaveManager", "IsSystemLoaded");

	Params::ATSaveManager_IsSystemLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATActGroundBattleHighBoost.DamageApplied
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActGroundBattleHighBoost::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActGroundBattleHighBoost", "DamageApplied");

	Params::ATActGroundBattleHighBoost_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacterAnimationSwitcher.OnUpdateAnimation
// (Final, Native, Private)
// Parameters:
// EATCharacterMoveState                   InMoveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestCharacterAnimationSwitcher::OnUpdateAnimation(EATCharacterMoveState InMoveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacterAnimationSwitcher", "OnUpdateAnimation");

	Params::QuestCharacterAnimationSwitcher_OnUpdateAnimation Parms{};

	Parms.InMoveType = InMoveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestBalloonTalk.CloseCurrentTalkIcon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsImmediateClose                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestBalloonTalk::CloseCurrentTalkIcon(bool IsImmediateClose)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestBalloonTalk", "CloseCurrentTalkIcon");

	Params::QuestBalloonTalk_CloseCurrentTalkIcon Parms{};

	Parms.IsImmediateClose = IsImmediateClose;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestBalloonTalk.InitializeTalkInformation
// (Final, Native, Public)

void UQuestBalloonTalk::InitializeTalkInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestBalloonTalk", "InitializeTalkInformation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGamePitcherCharacter.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseballGamePitcherCharacter::OnMontageBlendingOut(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGamePitcherCharacter", "OnMontageBlendingOut");

	Params::BaseballGamePitcherCharacter_OnMontageBlendingOut Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGamePitcherCharacter.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseballGamePitcherCharacter::OnMontageEnded(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGamePitcherCharacter", "OnMontageEnded");

	Params::BaseballGamePitcherCharacter_OnMontageEnded Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGamePitcherCharacter.OnMontageStarted
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABaseballGamePitcherCharacter::OnMontageStarted(class UAnimMontage* PMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGamePitcherCharacter", "OnMontageStarted");

	Params::BaseballGamePitcherCharacter_OnMontageStarted Parms{};

	Parms.PMontage = PMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUiCaptureManager.CreateCaptureSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCreateCaptureSetParameter       Parameter                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UTextureRenderTarget2D*           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Code                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedSkelMesh                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NeedLighting                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUiCaptureSet*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUiCaptureSet* UATUiCaptureManager::CreateCaptureSet(const struct FCreateCaptureSetParameter& Parameter, class UTextureRenderTarget2D* Target, class FName Code, bool NeedSkelMesh, bool NeedLighting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUiCaptureManager", "CreateCaptureSet");

	Params::ATUiCaptureManager_CreateCaptureSet Parms{};

	Parms.Parameter = std::move(Parameter);
	Parms.Target = Target;
	Parms.Code = Code;
	Parms.NeedSkelMesh = NeedSkelMesh;
	Parms.NeedLighting = NeedLighting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATUiCaptureManager.DestroyCaptureSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Code                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATUiCaptureManager::DestroyCaptureSet(class FName Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUiCaptureManager", "DestroyCaptureSet");

	Params::ATUiCaptureManager_DestroyCaptureSet Parms{};

	Parms.Code = Code;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActSearch.OnBeginBattle
// (Final, Native, Public)

void UATActSearch::OnBeginBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActSearch", "OnBeginBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActSearch.OnChangeMoveState
// (Final, Native, Public)
// Parameters:
// int32                                   OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActSearch::OnChangeMoveState(int32 OldState, int32 ActiveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActSearch", "OnChangeMoveState");

	Params::ATActSearch_OnChangeMoveState Parms{};

	Parms.OldState = OldState;
	Parms.ActiveState = ActiveState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUIFullscreenMovie.ConstructFirstOnly
// (Event, Protected, BlueprintEvent)

void UATUIFullscreenMovie::ConstructFirstOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUIFullscreenMovie", "ConstructFirstOnly");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.CharacterLocationUpdator.OnUpdatedMovement
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterLocationUpdator::OnUpdatedMovement(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterLocationUpdator", "OnUpdatedMovement");

	Params::CharacterLocationUpdator_OnUpdatedMovement Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralDestructFISMComponent.OnParticlePreActivate
// (Final, Native, Static, Public)
// Parameters:
// class UParticleSystemComponent*         InComponent                                            (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bActivating                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProceduralDestructFISMComponent::OnParticlePreActivate(class UParticleSystemComponent* InComponent, bool bActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralDestructFISMComponent", "OnParticlePreActivate");

	Params::ProceduralDestructFISMComponent_OnParticlePreActivate Parms{};

	Parms.InComponent = InComponent;
	Parms.bActivating = bActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralDestructFISMComponent.OnPointDamage
// (Final, Native, Public, HasDefaults)
// Parameters:
// int32                                   InstanceIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Damage                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InstigatedBy                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          HitLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ShotFromDirection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDamageType*                      DamageType                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProceduralDestructFISMComponent::OnPointDamage(int32 InstanceIndex, float Damage, class AController* InstigatedBy, const struct FVector& HitLocation, const struct FVector& ShotFromDirection, const class UDamageType* DamageType, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralDestructFISMComponent", "OnPointDamage");

	Params::ProceduralDestructFISMComponent_OnPointDamage Parms{};

	Parms.InstanceIndex = InstanceIndex;
	Parms.Damage = Damage;
	Parms.InstigatedBy = InstigatedBy;
	Parms.HitLocation = std::move(HitLocation);
	Parms.ShotFromDirection = std::move(ShotFromDirection);
	Parms.DamageType = DamageType;
	Parms.DamageCauser = DamageCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralDestructFISMComponent.OverlapTestForPlacedVolume
// (Final, Native, Protected)

void UProceduralDestructFISMComponent::OverlapTestForPlacedVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralDestructFISMComponent", "OverlapTestForPlacedVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActSpecialMoveGroundZigzag.DamageApplied
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATActSpecialMoveGroundZigzag::DamageApplied(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActSpecialMoveGroundZigzag", "DamageApplied");

	Params::ATActSpecialMoveGroundZigzag_DamageApplied Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialPartsLoader.CompleteClear
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialPartsLoader::CompleteClear(class UATDataAssetFacialAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialPartsLoader", "CompleteClear");

	Params::ATFacialPartsLoader_CompleteClear Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFacialPartsLoader.CompleteLoad
// (Final, Native, Public)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFacialPartsLoader::CompleteLoad(class UATDataAssetFacialAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFacialPartsLoader", "CompleteLoad");

	Params::ATFacialPartsLoader_CompleteLoad Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_Sit.OnMontageBlendingOut_Call
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_Sit::OnMontageBlendingOut_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_Sit", "OnMontageBlendingOut_Call");

	Params::NpcAction_Sit_OnMontageBlendingOut_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATActUseRadar.OnChangeMapState
// (Final, Native, Public)
// Parameters:
// uint8                                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InSubState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATActUseRadar::OnChangeMapState(uint8 InState, uint8 InSubState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATActUseRadar", "OnChangeMapState");

	Params::ATActUseRadar_OnChangeMapState Parms{};

	Parms.InState = InState;
	Parms.InSubState = InSubState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AndroidAssaultObserver.OnAndroidAssaultSpawnable
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             CountName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAndroidAssaultObserver::OnAndroidAssaultSpawnable(class FName CountName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultObserver", "OnAndroidAssaultSpawnable");

	Params::AndroidAssaultObserver_OnAndroidAssaultSpawnable Parms{};

	Parms.CountName = CountName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.AndroidAssaultObserver.OnDefeatedDroneAreaName
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             AreaName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAndroidAssaultObserver::OnDefeatedDroneAreaName(class FName AreaName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AndroidAssaultObserver", "OnDefeatedDroneAreaName");

	Params::AndroidAssaultObserver_OnDefeatedDroneAreaName Parms{};

	Parms.AreaName = AreaName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.ATWindRoad.ForceAppeared
// (Final, Native, Public, BlueprintCallable)

void AATWindRoad::ForceAppeared()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWindRoad", "ForceAppeared");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWindRoad.OnBeginOverlapExitTrigger
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATWindRoad::OnBeginOverlapExitTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWindRoad", "OnBeginOverlapExitTrigger");

	Params::ATWindRoad_OnBeginOverlapExitTrigger Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWindRoad.OnBeginOverlapStartTrigger
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATWindRoad::OnBeginOverlapStartTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWindRoad", "OnBeginOverlapStartTrigger");

	Params::ATWindRoad_OnBeginOverlapStartTrigger Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Portal.OnSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SelectedNo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APortal::OnSelected(int32 SelectedNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Portal", "OnSelected");

	Params::Portal_OnSelected Parms{};

	Parms.SelectedNo = SelectedNo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Portal.OpenYesNoWindow
// (Final, Native, Private, BlueprintCallable)

void APortal::OpenYesNoWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Portal", "OpenYesNoWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Portal.SetPortalIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APortal::SetPortalIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Portal", "SetPortalIndex");

	Params::Portal_SetPortalIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Portal.TeleportToArea
// (Final, Native, Private, BlueprintCallable)

void APortal::TeleportToArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Portal", "TeleportToArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Portal.GetPortalIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APortal::GetPortalIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Portal", "GetPortalIndex");

	Params::Portal_GetPortalIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATAnimNotify_PlayParticleEffectCustom.OnSpawnedParticle
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UParticleSystemComponent*         SpawnedParticle                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATAnimNotify_PlayParticleEffectCustom::OnSpawnedParticle(class UParticleSystemComponent* SpawnedParticle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATAnimNotify_PlayParticleEffectCustom", "OnSpawnedParticle");

	Params::ATAnimNotify_PlayParticleEffectCustom_OnSpawnedParticle Parms{};

	Parms.SpawnedParticle = SpawnedParticle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Wolf_Component.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWolf_Component::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Wolf_Component", "OnComponentHit");

	Params::Wolf_Component_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Wolf_Component.OnProjectileLanding
// (Final, Native, Public)
// Parameters:
// class AATProjectileField*               Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWolf_Component::OnProjectileLanding(class AATProjectileField* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Wolf_Component", "OnProjectileLanding");

	Params::Wolf_Component_OnProjectileLanding Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Wolf_Component.OnVisibleChangedCallBack
// (Final, Native, Public)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWolf_Component::OnVisibleChangedCallBack(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Wolf_Component", "OnVisibleChangedCallBack");

	Params::Wolf_Component_OnVisibleChangedCallBack Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATProjectileField.HitRootSphere
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATProjectileField::HitRootSphere(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATProjectileField", "HitRootSphere");

	Params::ATProjectileField_HitRootSphere Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Spawnable.SetSpawned
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSpawned                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpawnable::SetSpawned(bool bSpawned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spawnable", "SetSpawned");

	Params::Spawnable_SetSpawned Parms{};

	Parms.bSpawned = bSpawned;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Spawnable.IsSpawned
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISpawnable::IsSpawned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Spawnable", "IsSpawned");

	Params::Spawnable_IsSpawned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPartyManager.OnBattleEnd
// (Final, Native, Public)

void UATPartyManager::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPartyManager", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPartyManager.OnChangedPlayer
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPartyManager::OnChangedPlayer(class AAT_Character* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPartyManager", "OnChangedPlayer");

	Params::ATPartyManager_OnChangedPlayer Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPartyManager.OnEventBattleBegin
// (Final, Native, Public)

void UATPartyManager::OnEventBattleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPartyManager", "OnEventBattleBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPartyManager.OnNormalBattleBegin
// (Final, Native, Public)

void UATPartyManager::OnNormalBattleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPartyManager", "OnNormalBattleBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl082_SKL003_Sign.OnFinishedParticleST
// (Final, Native, Private)
// Parameters:
// class UParticleSystemComponent*         InParticle                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl082_SKL003_Sign::OnFinishedParticleST(class UParticleSystemComponent* InParticle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl082_SKL003_Sign", "OnFinishedParticleST");

	Params::Projectile_Cpl082_SKL003_Sign_OnFinishedParticleST Parms{};

	Parms.InParticle = InParticle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AnimNotifyState_PlayParticleEffectCustom.OnSpawnedParticle
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UParticleSystemComponent*         SpawnedParticle                                        (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimNotifyState_PlayParticleEffectCustom::OnSpawnedParticle(class UParticleSystemComponent* SpawnedParticle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotifyState_PlayParticleEffectCustom", "OnSpawnedParticle");

	Params::AnimNotifyState_PlayParticleEffectCustom_OnSpawnedParticle Parms{};

	Parms.SpawnedParticle = SpawnedParticle;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.QuestPhase_WishDragonBall.TryClear
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<int32>                           WishedIds                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestPhase_WishDragonBall::TryClear(const TArray<int32>& WishedIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_WishDragonBall", "TryClear");

	Params::QuestPhase_WishDragonBall_TryClear Parms{};

	Parms.WishedIds = std::move(WishedIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATAsyncLoader.OnLoaded
// (Final, Native, Private)

void UATAsyncLoader::OnLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATAsyncLoader", "OnLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATAtrociousManager.OnCompleteBeginDirection
// (Final, Native, Private)

void UATAtrociousManager::OnCompleteBeginDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATAtrociousManager", "OnCompleteBeginDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATAtrociousManager.OnCompletePhase
// (Final, Native, Private)

void UATAtrociousManager::OnCompletePhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATAtrociousManager", "OnCompletePhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATAtrociousPreBattleBase.OnBeginPlayLevelTiming
// (Final, Native, Public)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATAtrociousPreBattleBase::OnBeginPlayLevelTiming(const class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATAtrociousPreBattleBase", "OnBeginPlayLevelTiming");

	Params::ATAtrociousPreBattleBase_OnBeginPlayLevelTiming Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DlcMenu.CheckHovered
// (Final, Native, Public)

void UDlcMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DlcMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.DlcMenu.EndSaveState
// (Final, Native, Private)

void UDlcMenu::EndSaveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DlcMenu", "EndSaveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.DlcMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDlcMenu::MouseClickDecide(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DlcMenu", "MouseClickDecide");

	Params::DlcMenu_MouseClickDecide Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUISubtitles.OnBattleEnd
// (Final, Native, Public)

void UATUISubtitles::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUISubtitles", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUISubtitles.OnBattleStart
// (Final, Native, Public)

void UATUISubtitles::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUISubtitles", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWindRoadManager.ChangeVisibleAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDelay                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATWindRoadManager::ChangeVisibleAll(bool InbVisible, float InDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWindRoadManager", "ChangeVisibleAll");

	Params::ATWindRoadManager_ChangeVisibleAll Parms{};

	Parms.InbVisible = InbVisible;
	Parms.InDelay = InDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWindRoadManager.OnInGameBeginPlay
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATWindRoadManager::OnInGameBeginPlay(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWindRoadManager", "OnInGameBeginPlay");

	Params::ATWindRoadManager_OnInGameBeginPlay Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CameraEffectVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACameraEffectVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraEffectVolume", "OnOverlapBegin");

	Params::CameraEffectVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CameraEffectVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACameraEffectVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CameraEffectVolume", "OnOverlapEnd");

	Params::CameraEffectVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerQuestStart.OnTouchSphereCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerQuestStart::OnTouchSphereCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerQuestStart", "OnTouchSphereCollision");

	Params::TriggerQuestStart_OnTouchSphereCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BonfireCharacterAnimationPlayer.OnCompleteFullAnimation
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABonfireCharacterAnimationPlayer::OnCompleteFullAnimation(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BonfireCharacterAnimationPlayer", "OnCompleteFullAnimation");

	Params::BonfireCharacterAnimationPlayer_OnCompleteFullAnimation Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BonfireCharacterAnimationPlayer.OnCompleteLoad
// (Final, Native, Private)

void ABonfireCharacterAnimationPlayer::OnCompleteLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BonfireCharacterAnimationPlayer", "OnCompleteLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BonfireCharacterAnimationPlayer.OnCompleteSitdownAnimation
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABonfireCharacterAnimationPlayer::OnCompleteSitdownAnimation(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BonfireCharacterAnimationPlayer", "OnCompleteSitdownAnimation");

	Params::BonfireCharacterAnimationPlayer_OnCompleteSitdownAnimation Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BonfireCharacterAnimationPlayer.OnCompleteStandupAnimation
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ABonfireCharacterAnimationPlayer::OnCompleteStandupAnimation(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BonfireCharacterAnimationPlayer", "OnCompleteStandupAnimation");

	Params::BonfireCharacterAnimationPlayer_OnCompleteStandupAnimation Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LandmarkVolume.OnOverlapBegin
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmarkVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmarkVolume", "OnOverlapBegin");

	Params::LandmarkVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LandmarkVolume.OnOverlapEnd
// (Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmarkVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmarkVolume", "OnOverlapEnd");

	Params::LandmarkVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterDamageCollision.OnCollisionOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATCharacterDamageCollision::OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterDamageCollision", "OnCollisionOverlapBegin");

	Params::ATCharacterDamageCollision_OnCollisionOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterDamageCollision.OnCollisionOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterDamageCollision::OnCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterDamageCollision", "OnCollisionOverlapEnd");

	Params::ATCharacterDamageCollision_OnCollisionOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.CheckPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATPlayerAutoControlTrigger::CheckPlayerState(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "CheckPlayerState");

	Params::ATPlayerAutoControlTrigger_CheckPlayerState Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerAutoControlTrigger.GetCurrentTalkEventId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AATPlayerAutoControlTrigger::GetCurrentTalkEventId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "GetCurrentTalkEventId");

	Params::ATPlayerAutoControlTrigger_GetCurrentTalkEventId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerAutoControlTrigger.OnBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "OnBeginOverlap");

	Params::ATPlayerAutoControlTrigger_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "OnEndOverlap");

	Params::ATPlayerAutoControlTrigger_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.OnHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "OnHit");

	Params::ATPlayerAutoControlTrigger_OnHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoMoveBackwardLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BackwardLength                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAutoMoveSpeed                          MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoMoveBackwardLocation(class AActor* Player, float BackwardLength, EAutoMoveSpeed MoveSpeed, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoMoveBackwardLocation");

	Params::ATPlayerAutoControlTrigger_PlayerAutoMoveBackwardLocation Parms{};

	Parms.Player = Player;
	Parms.BackwardLength = BackwardLength;
	Parms.MoveSpeed = MoveSpeed;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoMoveForwardLocation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForwardLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAutoMoveSpeed                          MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoMoveForwardLocation(class AActor* Player, float ForwardLength, EAutoMoveSpeed MoveSpeed, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoMoveForwardLocation");

	Params::ATPlayerAutoControlTrigger_PlayerAutoMoveForwardLocation Parms{};

	Parms.Player = Player;
	Parms.ForwardLength = ForwardLength;
	Parms.MoveSpeed = MoveSpeed;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoMoveLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAutoMoveSpeed                          MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoMoveLocation(class AActor* Player, const struct FVector& Location, EAutoMoveSpeed MoveSpeed, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoMoveLocation");

	Params::ATPlayerAutoControlTrigger_PlayerAutoMoveLocation Parms{};

	Parms.Player = Player;
	Parms.Location = std::move(Location);
	Parms.MoveSpeed = MoveSpeed;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoMoveParentActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAutoMoveSpeed                          MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoMoveParentActor(class AActor* Player, EAutoMoveSpeed MoveSpeed, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoMoveParentActor");

	Params::ATPlayerAutoControlTrigger_PlayerAutoMoveParentActor Parms{};

	Parms.Player = Player;
	Parms.MoveSpeed = MoveSpeed;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoMoveTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAutoMoveSpeed                          MoveSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoMoveTargetActor(class AActor* Player, class AActor* TargetActor, EAutoMoveSpeed MoveSpeed, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoMoveTargetActor");

	Params::ATPlayerAutoControlTrigger_PlayerAutoMoveTargetActor Parms{};

	Parms.Player = Player;
	Parms.TargetActor = TargetActor;
	Parms.MoveSpeed = MoveSpeed;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoTalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TalkEventID                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoTalk(class AActor* Player, const class FString& TalkEventID, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoTalk");

	Params::ATPlayerAutoControlTrigger_PlayerAutoTalk Parms{};

	Parms.Player = Player;
	Parms.TalkEventID = std::move(TalkEventID);
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoTurn(class AActor* Player, class AActor* TargetActor, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoTurn");

	Params::ATPlayerAutoControlTrigger_PlayerAutoTurn Parms{};

	Parms.Player = Player;
	Parms.TargetActor = TargetActor;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoTurnNearestTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   TargetActors                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoTurnNearestTarget(class AActor* Player, const TArray<class AActor*>& TargetActors, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoTurnNearestTarget");

	Params::ATPlayerAutoControlTrigger_PlayerAutoTurnNearestTarget Parms{};

	Parms.Player = Player;
	Parms.TargetActors = std::move(TargetActors);
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.PlayerAutoTurnOrderQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DelayTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::PlayerAutoTurnOrderQuest(class AActor* Player, float DelayTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "PlayerAutoTurnOrderQuest");

	Params::ATPlayerAutoControlTrigger_PlayerAutoTurnOrderQuest Parms{};

	Parms.Player = Player;
	Parms.DelayTime = DelayTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerAutoControlTrigger.QuestChangePhaseTiming
// (Final, Native, Private)
// Parameters:
// int32                                   NextPhase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerAutoControlTrigger::QuestChangePhaseTiming(int32 NextPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerAutoControlTrigger", "QuestChangePhaseTiming");

	Params::ATPlayerAutoControlTrigger_QuestChangePhaseTiming Parms{};

	Parms.NextPhase = NextPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BoostPointComponent.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBoostPointComponent::BeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoostPointComponent", "BeginOverlap");

	Params::BoostPointComponent_BeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BoostPointComponent.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBoostPointComponent::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BoostPointComponent", "EndOverlap");

	Params::BoostPointComponent_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterEffectControlComponent.Start
// (Final, Native, Public, BlueprintCallable)

void UATCharacterEffectControlComponent::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterEffectControlComponent", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterEffectControlComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UATCharacterEffectControlComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterEffectControlComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterFootIKManager.OnMontageEnded
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterFootIKManager::OnMontageEnded(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterFootIKManager", "OnMontageEnded");

	Params::ATCharacterFootIKManager_OnMontageEnded Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterFootIKManager.OnMontageStarted
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterFootIKManager::OnMontageStarted(class UAnimMontage* PMontage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterFootIKManager", "OnMontageStarted");

	Params::ATCharacterFootIKManager_OnMontageStarted Parms{};

	Parms.PMontage = PMontage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterFootIKManager.OnPostChangeAnimationBlueprint
// (Final, Native, Public)
// Parameters:
// class UClass*                           InClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMesh                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterFootIKManager::OnPostChangeAnimationBlueprint(const class UClass* InClass, const class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterFootIKManager", "OnPostChangeAnimationBlueprint");

	Params::ATCharacterFootIKManager_OnPostChangeAnimationBlueprint Parms{};

	Parms.InClass = InClass;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterFootIKManager.OnPreChangeAnimationBlueprint
// (Final, Native, Public)
// Parameters:
// class UClass*                           InClass                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           InMesh                                                 (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterFootIKManager::OnPreChangeAnimationBlueprint(const class UClass* InClass, const class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterFootIKManager", "OnPreChangeAnimationBlueprint");

	Params::ATCharacterFootIKManager_OnPreChangeAnimationBlueprint Parms{};

	Parms.InClass = InClass;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CharacterSkillComponent.OnBeginSupportSkill
// (Final, Native, Public)
// Parameters:
// class USkill*                           InSkill                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSkillComponent::OnBeginSupportSkill(class USkill* InSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSkillComponent", "OnBeginSupportSkill");

	Params::CharacterSkillComponent_OnBeginSupportSkill Parms{};

	Parms.InSkill = InSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CharacterSkillComponent.OnChangeAction
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSkillComponent::OnChangeAction(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSkillComponent", "OnChangeAction");

	Params::CharacterSkillComponent_OnChangeAction Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnChangeAction
// (Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterMoveState::OnChangeAction(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnChangeAction");

	Params::ATCharacterMoveState_OnChangeAction Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnChangeMoveState
// (Final, Native, Protected)
// Parameters:
// int32                                   OldState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActiveState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterMoveState::OnChangeMoveState(int32 OldState, int32 ActiveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnChangeMoveState");

	Params::ATCharacterMoveState_OnChangeMoveState Parms{};

	Parms.OldState = OldState;
	Parms.ActiveState = ActiveState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnCookingDemoEnd
// (Final, Native, Public)

void UATCharacterMoveState::OnCookingDemoEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnCookingDemoEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnCookingDemoStart
// (Final, Native, Public)
// Parameters:
// int8                                    CutNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterMoveState::OnCookingDemoStart(int8 CutNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnCookingDemoStart");

	Params::ATCharacterMoveState_OnCookingDemoStart Parms{};

	Parms.CutNum = CutNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnLanded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       InHit                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATCharacterMoveState::OnLanded(const struct FHitResult& InHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnLanded");

	Params::ATCharacterMoveState_OnLanded Parms{};

	Parms.InHit = std::move(InHit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCharacterMoveState::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnMovementModeChanged");

	Params::ATCharacterMoveState_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnReachedGroundBattleJumpApex
// (Final, Native, Protected)

void UATCharacterMoveState::OnReachedGroundBattleJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnReachedGroundBattleJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterMoveState.OnReachedJumpApex
// (Final, Native, Protected)

void UATCharacterMoveState::OnReachedJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterMoveState", "OnReachedJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVariationPartsLoader.CompleteClear
// (Final, Native, Public)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATVariationPartsLoader::CompleteClear(class UATDataAssetVariationMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVariationPartsLoader", "CompleteClear");

	Params::ATVariationPartsLoader_CompleteClear Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVariationPartsLoader.CompleteLoad
// (Final, Native, Public)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*PartsLoad                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATVariationPartsLoader::CompleteLoad(class UATDataAssetVariationMeshAsyncLoad* PartsLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVariationPartsLoader", "CompleteLoad");

	Params::ATVariationPartsLoader_CompleteLoad Parms{};

	Parms.PartsLoad = PartsLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkManager.OnEndPlayCharacter
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrossTalkManager::OnEndPlayCharacter(class AAT_Character* InCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkManager", "OnEndPlayCharacter");

	Params::CrossTalkManager_OnEndPlayCharacter Parms{};

	Parms.InCharacter = InCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkManager.OnFinishedVoice
// (Final, Native, Private)
// Parameters:
// int32                                   Ch                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrossTalkManager::OnFinishedVoice(int32 Ch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkManager", "OnFinishedVoice");

	Params::CrossTalkManager_OnFinishedVoice Parms{};

	Parms.Ch = Ch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterRestrictGate.OnBeginOverlapGateTrigger
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATCharacterRestrictGate::OnBeginOverlapGateTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterRestrictGate", "OnBeginOverlapGateTrigger");

	Params::ATCharacterRestrictGate_OnBeginOverlapGateTrigger Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCharacterRestrictGate.OnEndOverlapGateTrigger
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATCharacterRestrictGate::OnEndOverlapGateTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCharacterRestrictGate", "OnEndOverlapGateTrigger");

	Params::ATCharacterRestrictGate_OnEndOverlapGateTrigger Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATActiveSubLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATActiveSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATActiveSubLevel");

	Params::ATCheatManager_ATActiveSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATAsyncLoadCharacter
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             MasterId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATAsyncLoadCharacter(const class FName& MasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATAsyncLoadCharacter");

	Params::ATCheatManager_ATAsyncLoadCharacter Parms{};

	Parms.MasterId = MasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATAttachPhotonForCharacter
// (Final, Exec, Native, Public)

void UATCheatManager::ATAttachPhotonForCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATAttachPhotonForCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATBaseballGameBattlePower
// (Final, Exec, Native, Public)
// Parameters:
// double                                  Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATBaseballGameBattlePower(double Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATBaseballGameBattlePower");

	Params::ATCheatManager_ATBaseballGameBattlePower Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATBattleDemoStart
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InDemoId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATBattleDemoStart(class FName InDemoId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATBattleDemoStart");

	Params::ATCheatManager_ATBattleDemoStart Parms{};

	Parms.InDemoId = InDemoId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATChangePersistent
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATChangePersistent(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATChangePersistent");

	Params::ATCheatManager_ATChangePersistent Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDeactiveSubLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDeactiveSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDeactiveSubLevel");

	Params::ATCheatManager_ATDeactiveSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddExp
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PartyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddExp(int32 Exp, uint8 PartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddExp");

	Params::ATCheatManager_ATDebugAddExp Parms{};

	Parms.Exp = Exp;
	Parms.PartyIndex = PartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddMoney
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddMoney(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddMoney");

	Params::ATCheatManager_ATDebugAddMoney Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddPartyExp
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddPartyExp(int32 Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddPartyExp");

	Params::ATCheatManager_ATDebugAddPartyExp Parms{};

	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddQuestCompletedCount
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddQuestCompletedCount(const class FName& QuestId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddQuestCompletedCount");

	Params::ATCheatManager_ATDebugAddQuestCompletedCount Parms{};

	Parms.QuestId = QuestId;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddQuestNavigateIcon
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddQuestNavigateIcon(const class FName& QuestId, const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddQuestNavigateIcon");

	Params::ATCheatManager_ATDebugAddQuestNavigateIcon Parms{};

	Parms.QuestId = QuestId;
	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddStateIcon
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddStateIcon(uint8 InTarget, int32 InType, float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddStateIcon");

	Params::ATCheatManager_ATDebugAddStateIcon Parms{};

	Parms.InTarget = InTarget;
	Parms.InType = InType;
	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddStateIcon3
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InType_1                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InType_2                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InType_3                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddStateIcon3(uint8 InTarget, int32 InType_1, int32 InType_2, int32 InType_3, float InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddStateIcon3");

	Params::ATCheatManager_ATDebugAddStateIcon3 Parms{};

	Parms.InTarget = InTarget;
	Parms.InType_1 = InType_1;
	Parms.InType_2 = InType_2;
	Parms.InType_3 = InType_3;
	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAddZOrb
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Type                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAddZOrb(int32 Num, const class FString& Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAddZOrb");

	Params::ATCheatManager_ATDebugAddZOrb Parms{};

	Parms.Num = Num;
	Parms.Type = std::move(Type);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAIActive
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugAIActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAIActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAndroidAssaultAreaActivate
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAndroidAssaultAreaActivate(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAndroidAssaultAreaActivate");

	Params::ATCheatManager_ATDebugAndroidAssaultAreaActivate Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAndroidAssaultAreaDeactivate
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAndroidAssaultAreaDeactivate(class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAndroidAssaultAreaDeactivate");

	Params::ATCheatManager_ATDebugAndroidAssaultAreaDeactivate Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAndroidAssaultFinishDemoPointCheck
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bErrorOnly                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DrawTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAndroidAssaultFinishDemoPointCheck(bool bErrorOnly, float DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAndroidAssaultFinishDemoPointCheck");

	Params::ATCheatManager_ATDebugAndroidAssaultFinishDemoPointCheck Parms{};

	Parms.bErrorOnly = bErrorOnly;
	Parms.DrawTime = DrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAreaChangeTrainingEnd
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugAreaChangeTrainingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAreaChangeTrainingEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAreaChangeTrainingForceOpenItem
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAreaChangeTrainingForceOpenItem(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAreaChangeTrainingForceOpenItem");

	Params::ATCheatManager_ATDebugAreaChangeTrainingForceOpenItem Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAtrociousBegin
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugAtrociousBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAtrociousBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugAtrociousComplete
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InLevelName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InPhase                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugAtrociousComplete(class FName InLevelName, uint8 InPhase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugAtrociousComplete");

	Params::ATCheatManager_ATDebugAtrociousComplete Parms{};

	Parms.InLevelName = InLevelName;
	Parms.InPhase = InPhase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBannedTest
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Op                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBanned                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSkill                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugBannedTest(int32 Op, bool bBanned, class FName InSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBannedTest");

	Params::ATCheatManager_ATDebugBannedTest Parms{};

	Parms.Op = Op;
	Parms.bBanned = bBanned;
	Parms.InSkill = InSkill;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBeginQuest
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugBeginQuest(const class FName& QuestId, int32 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBeginQuest");

	Params::ATCheatManager_ATDebugBeginQuest Parms{};

	Parms.QuestId = QuestId;
	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBeginQuestDemo
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugBeginQuestDemo(const class FName& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBeginQuestDemo");

	Params::ATCheatManager_ATDebugBeginQuestDemo Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBGMDebugMode
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugBGMDebugMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBGMDebugMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBgmManagerTest
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugBgmManagerTest(int32 TestCase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBgmManagerTest");

	Params::ATCheatManager_ATDebugBgmManagerTest Parms{};

	Parms.TestCase = TestCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBindControl
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugBindControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBindControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugBNIDQuestUnlock
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugBNIDQuestUnlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugBNIDQuestUnlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangeAirCar
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugChangeAirCar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangeAirCar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangeDlcOwnership
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             DlcCommonId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugChangeDlcOwnership(const class FName& DlcCommonId, bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangeDlcOwnership");

	Params::ATCheatManager_ATDebugChangeDlcOwnership Parms{};

	Parms.DlcCommonId = DlcCommonId;
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangeDlcOwnershipAll
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugChangeDlcOwnershipAll(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangeDlcOwnershipAll");

	Params::ATCheatManager_ATDebugChangeDlcOwnershipAll Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangeDragonBallUsedState
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugChangeDragonBallUsedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangeDragonBallUsedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangePlayer
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugChangePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangerLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Tag                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugChangerLevel(const class FName& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangerLevel");

	Params::ATCheatManager_ATDebugChangerLevel Parms{};

	Parms.Tag = Tag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugChangeTwinFoot
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugChangeTwinFoot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugChangeTwinFoot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCharaDamageRate
// (Final, Exec, Native, Public)
// Parameters:
// float                                   DamageRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PartyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCharaDamageRate(float DamageRate, uint8 PartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCharaDamageRate");

	Params::ATCheatManager_ATDebugCharaDamageRate Parms{};

	Parms.DamageRate = DamageRate;
	Parms.PartyIndex = PartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCharaLifeRate
// (Final, Exec, Native, Public)
// Parameters:
// float                                   LifeRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PartyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCharaLifeRate(float LifeRate, uint8 PartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCharaLifeRate");

	Params::ATCheatManager_ATDebugCharaLifeRate Parms{};

	Parms.LifeRate = LifeRate;
	Parms.PartyIndex = PartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCheckCurrentSubQuestIds
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             StartQuestId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StartPhaseNo                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EndQuestId                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EndPhaseNo                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCheckCurrentSubQuestIds(const class FName& StartQuestId, const int32 StartPhaseNo, const class FName& EndQuestId, const int32 EndPhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCheckCurrentSubQuestIds");

	Params::ATCheatManager_ATDebugCheckCurrentSubQuestIds Parms{};

	Parms.StartQuestId = StartQuestId;
	Parms.StartPhaseNo = StartPhaseNo;
	Parms.EndQuestId = EndQuestId;
	Parms.EndPhaseNo = EndPhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCheckImpLogTest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCheckImpLogTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCheckImpLogTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCheckMovableEvents
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCheckMovableEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCheckMovableEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugClearMainQuest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugClearMainQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugClearMainQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugClearSubQuest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugClearSubQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugClearSubQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCollectionOpen
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCollectionOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCollectionOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCombineParts
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCombineParts(uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCombineParts");

	Params::ATCheatManager_ATDebugCombineParts Parms{};

	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCombinePartsSupportLeft
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCombinePartsSupportLeft(uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCombinePartsSupportLeft");

	Params::ATCheatManager_ATDebugCombinePartsSupportLeft Parms{};

	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCombinePartsSupportRight
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCombinePartsSupportRight(uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCombinePartsSupportRight");

	Params::ATCheatManager_ATDebugCombinePartsSupportRight Parms{};

	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCombinePartsTarget
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCombinePartsTarget(uint8 Variation, uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCombinePartsTarget");

	Params::ATCheatManager_ATDebugCombinePartsTarget Parms{};

	Parms.Variation = Variation;
	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommandPaletteChangeActive
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCommandPaletteChangeActive(int32 Idx, int32 IsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommandPaletteChangeActive");

	Params::ATCheatManager_ATDebugCommandPaletteChangeActive Parms{};

	Parms.Idx = Idx;
	Parms.IsOn = IsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommandPaletteCoopSkill
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCommandPaletteCoopSkill(int32 IsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommandPaletteCoopSkill");

	Params::ATCheatManager_ATDebugCommandPaletteCoopSkill Parms{};

	Parms.IsOn = IsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommCalc
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCommCalc(int32 Val, float Rate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommCalc");

	Params::ATCheatManager_ATDebugCommCalc Parms{};

	Parms.Val = Val;
	Parms.Rate = Rate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommunityBoard
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCommunityBoard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommunityBoard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommunityBoardEdit
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Cate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCommunityBoardEdit(int32 Cate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommunityBoardEdit");

	Params::ATCheatManager_ATDebugCommunityBoardEdit Parms{};

	Parms.Cate = Cate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommunityCTest
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCommunityCTest(int32 TestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommunityCTest");

	Params::ATCheatManager_ATDebugCommunityCTest Parms{};

	Parms.TestId = TestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommunityRankTest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCommunityRankTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommunityRankTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCommunitySkill
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Lv                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCommunitySkill(int32 Category, int32 Lv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCommunitySkill");

	Params::ATCheatManager_ATDebugCommunitySkill Parms{};

	Parms.Category = Category;
	Parms.Lv = Lv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCompleteQuest
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugCompleteQuest(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCompleteQuest");

	Params::ATCheatManager_ATDebugCompleteQuest Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCompleteReplaying
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCompleteReplaying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCompleteReplaying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugConsistencyCheckQuestCharacter
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugConsistencyCheckQuestCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugConsistencyCheckQuestCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugControllerStatusDisplay
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugControllerStatusDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugControllerStatusDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugCreateLeafVolume
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugCreateLeafVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugCreateLeafVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDataInstallProgress
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugDataInstallProgress(int32 InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDataInstallProgress");

	Params::ATCheatManager_ATDebugDataInstallProgress Parms{};

	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDelaySublevelActivation
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bDelay                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugDelaySublevelActivation(bool bDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDelaySublevelActivation");

	Params::ATCheatManager_ATDebugDelaySublevelActivation Parms{};

	Parms.bDelay = bDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDeleteFriend
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDeleteFriend()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDeleteFriend");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDeleteLeafVolume
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDeleteLeafVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDeleteLeafVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDeleteQuestDataAll
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDeleteQuestDataAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDeleteQuestDataAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDeleteSaveData
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugDeleteSaveData(uint8 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDeleteSaveData");

	Params::ATCheatManager_ATDebugDeleteSaveData Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisableDrawFullScreenMovie
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDisableDrawFullScreenMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisableDrawFullScreenMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisableItemHit
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDisableItemHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisableItemHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisableNpcTalk
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugDisableNpcTalk(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisableNpcTalk");

	Params::ATCheatManager_ATDebugDisableNpcTalk Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisableQuestNavigation
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDisableQuestNavigation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisableQuestNavigation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisableTickUI
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugDisableTickUI(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisableTickUI");

	Params::ATCheatManager_ATDebugDisableTickUI Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisableTps
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDisableTps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisableTps");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDisplayPurpose
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDisplayPurpose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDisplayPurpose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDLCListCheck
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDLCListCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDLCListCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugDLCListLog
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugDLCListLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugDLCListLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnableDrawFullScreenMovie
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugEnableDrawFullScreenMovie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnableDrawFullScreenMovie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnabledUniquenessObserver
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEnabledUniquenessObserver(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnabledUniquenessObserver");

	Params::ATCheatManager_ATDebugEnabledUniquenessObserver Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnableQuestErrorLog
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEnableQuestErrorLog(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnableQuestErrorLog");

	Params::ATCheatManager_ATDebugEnableQuestErrorLog Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnableQuestLog
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEnableQuestLog(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnableQuestLog");

	Params::ATCheatManager_ATDebugEnableQuestLog Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnableQuestLogList
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEnableQuestLogList(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnableQuestLogList");

	Params::ATCheatManager_ATDebugEnableQuestLogList Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnableTimemachineMode
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEnableTimemachineMode(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnableTimemachineMode");

	Params::ATCheatManager_ATDebugEnableTimemachineMode Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEndFastForward
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugEndFastForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEndFastForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnemyMotionCheck
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugEnemyMotionCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnemyMotionCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEnemyTeamBreakDamage
// (Final, Exec, Native, Public)
// Parameters:
// float                                   BreakDamage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEnemyTeamBreakDamage(float BreakDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEnemyTeamBreakDamage");

	Params::ATCheatManager_ATDebugEnemyTeamBreakDamage Parms{};

	Parms.BreakDamage = BreakDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEntryBuff
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   BuffType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             BuffName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PartyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MembetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEntryBuff(int32 BuffType, class FName BuffName, float Time, int32 PartyIndex, int32 MembetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEntryBuff");

	Params::ATCheatManager_ATDebugEntryBuff Parms{};

	Parms.BuffType = BuffType;
	Parms.BuffName = BuffName;
	Parms.Time = Time;
	Parms.PartyIndex = PartyIndex;
	Parms.MembetType = MembetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugEulaCheck
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugEulaCheck(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugEulaCheck");

	Params::ATCheatManager_ATDebugEulaCheck Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugExterminationChangeLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugExterminationChangeLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugExterminationChangeLevel");

	Params::ATCheatManager_ATDebugExterminationChangeLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugExterminationDirectDamage
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugExterminationDirectDamage(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugExterminationDirectDamage");

	Params::ATCheatManager_ATDebugExterminationDirectDamage Parms{};

	Parms.IsActive = IsActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFacialChange
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFacialChange(uint8 Variation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFacialChange");

	Params::ATCheatManager_ATDebugFacialChange Parms{};

	Parms.Variation = Variation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFacialChangeSupportLeft
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFacialChangeSupportLeft(uint8 Variation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFacialChangeSupportLeft");

	Params::ATCheatManager_ATDebugFacialChangeSupportLeft Parms{};

	Parms.Variation = Variation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFacialChangeSupportRight
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFacialChangeSupportRight(uint8 Variation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFacialChangeSupportRight");

	Params::ATCheatManager_ATDebugFacialChangeSupportRight Parms{};

	Parms.Variation = Variation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFacialMotionCheckBegin
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFacialMotionCheckBegin(uint8 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFacialMotionCheckBegin");

	Params::ATCheatManager_ATDebugFacialMotionCheckBegin Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFacialMotionCheckEnd
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugFacialMotionCheckEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFacialMotionCheckEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFadeBugCheck
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Check                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFadeBugCheck(bool Check)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFadeBugCheck");

	Params::ATCheatManager_ATDebugFadeBugCheck Parms{};

	Parms.Check = Check;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFadeIn
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFadeOut
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InFadeType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFadeOut(int32 InFadeType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFadeOut");

	Params::ATCheatManager_ATDebugFadeOut Parms{};

	Parms.InFadeType = InFadeType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFieldTalkWin
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Speaker                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    buttonVisible                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFieldTalkWin(const class FString& Speaker, const class FString& Message, bool buttonVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFieldTalkWin");

	Params::ATCheatManager_ATDebugFieldTalkWin Parms{};

	Parms.Speaker = std::move(Speaker);
	Parms.Message = std::move(Message);
	Parms.buttonVisible = buttonVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFixedRandomBGM
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   bgmID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFixedRandomBGM(int32 bgmID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFixedRandomBGM");

	Params::ATCheatManager_ATDebugFixedRandomBGM Parms{};

	Parms.bgmID = bgmID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugForceGarbageCollection
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugForceGarbageCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugForceGarbageCollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugForceOpenCurrentMission
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugForceOpenCurrentMission()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugForceOpenCurrentMission");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFormChange
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFormChange(uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFormChange");

	Params::ATCheatManager_ATDebugFormChange Parms{};

	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFormChangeSupportLeft
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFormChangeSupportLeft(uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFormChangeSupportLeft");

	Params::ATCheatManager_ATDebugFormChangeSupportLeft Parms{};

	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFormChangeSupportRight
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Form                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugFormChangeSupportRight(uint8 Form)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFormChangeSupportRight");

	Params::ATCheatManager_ATDebugFormChangeSupportRight Parms{};

	Parms.Form = Form;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFreeCameraMode
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugFreeCameraMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFreeCameraMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugFreeCameraStop
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugFreeCameraStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugFreeCameraStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGameover
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugGameover()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGameover");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGeneralQuestDemo
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             DirectionId                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugGeneralQuestDemo(const class FName& DirectionId, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGeneralQuestDemo");

	Params::ATCheatManager_ATDebugGeneralQuestDemo Parms{};

	Parms.DirectionId = DirectionId;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGetEmbList
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InNum                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugGetEmbList(int32 InNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGetEmbList");

	Params::ATCheatManager_ATDebugGetEmbList Parms{};

	Parms.InNum = InNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGetMissionProgressMessage
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             TargetMissionId                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugGetMissionProgressMessage(const class FName& TargetMissionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGetMissionProgressMessage");

	Params::ATCheatManager_ATDebugGetMissionProgressMessage Parms{};

	Parms.TargetMissionId = TargetMissionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGetMissionTitleMessage
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugGetMissionTitleMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGetMissionTitleMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGiveHermitReward
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugGiveHermitReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGiveHermitReward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGiveQuestExp
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Exp                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugGiveQuestExp(int32 Exp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGiveQuestExp");

	Params::ATCheatManager_ATDebugGiveQuestExp Parms{};

	Parms.Exp = Exp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugGiveQuestReward
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             RewardId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugGiveQuestReward(const class FName& RewardId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugGiveQuestReward");

	Params::ATCheatManager_ATDebugGiveQuestReward Parms{};

	Parms.RewardId = RewardId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugHiddenInGame
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugHiddenInGame(class FName TargetCharacter, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugHiddenInGame");

	Params::ATCheatManager_ATDebugHiddenInGame Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugHideSpGaugeOverlay
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugHideSpGaugeOverlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugHideSpGaugeOverlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugHideUI
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugHideUI(bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugHideUI");

	Params::ATCheatManager_ATDebugHideUI Parms{};

	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugIncreaseCommunityLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugIncreaseCommunityLevel(int32 Category, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugIncreaseCommunityLevel");

	Params::ATCheatManager_ATDebugIncreaseCommunityLevel Parms{};

	Parms.Category = Category;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugItemAdd
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugItemAdd(const class FName& ItemId, int32 AddNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugItemAdd");

	Params::ATCheatManager_ATDebugItemAdd Parms{};

	Parms.ItemId = ItemId;
	Parms.AddNum = AddNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugLevelUp
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   PartyIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugLevelUp(uint8 PartyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugLevelUp");

	Params::ATCheatManager_ATDebugLevelUp Parms{};

	Parms.PartyIndex = PartyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugLinkedBonusTitleCheck
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugLinkedBonusTitleCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugLinkedBonusTitleCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugLipSyncTime
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugLipSyncTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugLipSyncTime");

	Params::ATCheatManager_ATDebugLipSyncTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugLipSyncTimeDefault
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugLipSyncTimeDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugLipSyncTimeDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugLoadRandomPadKeyWeight
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InPath                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugLoadRandomPadKeyWeight(const class FString& InPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugLoadRandomPadKeyWeight");

	Params::ATCheatManager_ATDebugLoadRandomPadKeyWeight Parms{};

	Parms.InPath = std::move(InPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugLookAtInformation
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugLookAtInformation(const class FString& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugLookAtInformation");

	Params::ATCheatManager_ATDebugLookAtInformation Parms{};

	Parms.ActorName = std::move(ActorName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMapMove
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             MapName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugMapMove(const class FName& MapName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMapMove");

	Params::ATCheatManager_ATDebugMapMove Parms{};

	Parms.MapName = MapName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMessageCheck
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DummyString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugMessageCheck(bool IsEnable, const class FString& DummyString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMessageCheck");

	Params::ATCheatManager_ATDebugMessageCheck Parms{};

	Parms.IsEnable = IsEnable;
	Parms.DummyString = std::move(DummyString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMessageStringIdCheck
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugMessageStringIdCheck(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMessageStringIdCheck");

	Params::ATCheatManager_ATDebugMessageStringIdCheck Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMiniGamePop
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   StartOrEnd                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InTop                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InBottom                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugMiniGamePop(int32 StartOrEnd, const class FString& InTop, const class FString& InBottom)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMiniGamePop");

	Params::ATCheatManager_ATDebugMiniGamePop Parms{};

	Parms.StartOrEnd = StartOrEnd;
	Parms.InTop = std::move(InTop);
	Parms.InBottom = std::move(InBottom);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugModifySpGaugeAppearance
// (Final, Exec, Native, Public)
// Parameters:
// ESpGaugeOverlayAppearance               InAppearance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugModifySpGaugeAppearance(ESpGaugeOverlayAppearance InAppearance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugModifySpGaugeAppearance");

	Params::ATCheatManager_ATDebugModifySpGaugeAppearance Parms{};

	Parms.InAppearance = InAppearance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugModifySpGaugeValue
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInMakeVisible                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugModifySpGaugeValue(int32 InValue, bool bInMakeVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugModifySpGaugeValue");

	Params::ATCheatManager_ATDebugModifySpGaugeValue Parms{};

	Parms.InValue = InValue;
	Parms.bInMakeVisible = bInMakeVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMotionCheck
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Name_0                                                 (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugMotionCheck(const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMotionCheck");

	Params::ATCheatManager_ATDebugMotionCheck Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMpInfinity
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugMpInfinity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMpInfinity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugMpInfinityPlayer
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugMpInfinityPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugMpInfinityPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugNameUiChangeLarge
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsLarge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugNameUiChangeLarge(bool IsLarge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugNameUiChangeLarge");

	Params::ATCheatManager_ATDebugNameUiChangeLarge Parms{};

	Parms.IsLarge = IsLarge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugNavigateQuestId
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugNavigateQuestId(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugNavigateQuestId");

	Params::ATCheatManager_ATDebugNavigateQuestId Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugNoDead
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugNoDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugNoDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugNotCheckPartyOrganize
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugNotCheckPartyOrganize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugNotCheckPartyOrganize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugNotPlayNextFadeOut
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugNotPlayNextFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugNotPlayNextFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOneHitDeath
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOneHitDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOneHitDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOpenGameWindow
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             StringID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugOpenGameWindow(class FName StringID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOpenGameWindow");

	Params::ATCheatManager_ATDebugOpenGameWindow Parms{};

	Parms.StringID = StringID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOpenGameWindowByIndex
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugOpenGameWindowByIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOpenGameWindowByIndex");

	Params::ATCheatManager_ATDebugOpenGameWindowByIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOpenProgressMission
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOpenProgressMission()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOpenProgressMission");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOpenProgressSubjugationMission
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOpenProgressSubjugationMission()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOpenProgressSubjugationMission");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOpenTips
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InTipsID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugOpenTips(const class FName& InTipsID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOpenTips");

	Params::ATCheatManager_ATDebugOpenTips Parms{};

	Parms.InTipsID = InTipsID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOpenTurtleSchool
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOpenTurtleSchool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOpenTurtleSchool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOutAllBattleHud
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOutAllBattleHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOutAllBattleHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOutputQuestCompletedCount
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugOutputQuestCompletedCount(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOutputQuestCompletedCount");

	Params::ATCheatManager_ATDebugOutputQuestCompletedCount Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOutputSaveDataDocument
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOutputSaveDataDocument()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOutputSaveDataDocument");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOutputSaveDataText
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOutputSaveDataText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOutputSaveDataText");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugOutputTcgLinkedBonusLog
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugOutputTcgLinkedBonusLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugOutputTcgLinkedBonusLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPassiveSkillForgetTest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPassiveSkillForgetTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPassiveSkillForgetTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPassiveSkillLearnTest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPassiveSkillLearnTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPassiveSkillLearnTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPatchNoticeCheck
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPatchNoticeCheck(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPatchNoticeCheck");

	Params::ATCheatManager_ATDebugPatchNoticeCheck Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayBattleCutin
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CutinType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayBattleCutin(int32 CutinType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayBattleCutin");

	Params::ATCheatManager_ATDebugPlayBattleCutin Parms{};

	Parms.CutinType = CutinType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayBGMFromBGMPlayer
// (Final, Exec, Native, Public)
// Parameters:
// EBGMCategory                            bgmType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBgmCode                                bgmID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayBGMFromBGMPlayer(EBGMCategory bgmType, EBgmCode bgmID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayBGMFromBGMPlayer");

	Params::ATCheatManager_ATDebugPlayBGMFromBGMPlayer Parms{};

	Parms.bgmType = bgmType;
	Parms.bgmID = bgmID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayDemo
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InDemoName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayDemo(const class FName& InDemoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayDemo");

	Params::ATCheatManager_ATDebugPlayDemo Parms{};

	Parms.InDemoName = InDemoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayDemoAndLoadStreaming
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InDemoName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayDemoAndLoadStreaming(const class FName& InDemoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayDemoAndLoadStreaming");

	Params::ATCheatManager_ATDebugPlayDemoAndLoadStreaming Parms{};

	Parms.InDemoName = InDemoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayDemoAndProgressSet
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InDemoName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InProgressId                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayDemoAndProgressSet(const class FName& InDemoName, const class FName& InProgressId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayDemoAndProgressSet");

	Params::ATCheatManager_ATDebugPlayDemoAndProgressSet Parms{};

	Parms.InDemoName = InDemoName;
	Parms.InProgressId = InProgressId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayerDiesInOneHit
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPlayerDiesInOneHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayerDiesInOneHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayerHidden
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayerHidden(bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayerHidden");

	Params::ATCheatManager_ATDebugPlayerHidden Parms{};

	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayerLevel
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayerLevel(float Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayerLevel");

	Params::ATCheatManager_ATDebugPlayerLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayerStatusDisplay
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPlayerStatusDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayerStatusDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayerTeamBreakDamage
// (Final, Exec, Native, Public)
// Parameters:
// float                                   BreakDamage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayerTeamBreakDamage(float BreakDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayerTeamBreakDamage");

	Params::ATCheatManager_ATDebugPlayerTeamBreakDamage Parms{};

	Parms.BreakDamage = BreakDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayQuestDirection
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             FindName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayQuestDirection(const class FName& FindName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayQuestDirection");

	Params::ATCheatManager_ATDebugPlayQuestDirection Parms{};

	Parms.FindName = FindName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlaySpOverlayBreak
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPlaySpOverlayBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlaySpOverlayBreak");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlaySpOverlaySupercharge
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPlaySpOverlaySupercharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlaySpOverlaySupercharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlaySpOverlaySuperchargeAttack
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPlaySpOverlaySuperchargeAttack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlaySpOverlaySuperchargeAttack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayTalkMontage
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TalkMontageId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayTalkMontage(const class FString& ActorName, const class FString& TalkMontageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayTalkMontage");

	Params::ATCheatManager_ATDebugPlayTalkMontage Parms{};

	Parms.ActorName = std::move(ActorName);
	Parms.TalkMontageId = std::move(TalkMontageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPlayZoomCamera
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BlendType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendExp                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLockOutgoing                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPlayZoomCamera(const class FString& ActorName, float Duration, int32 BlendType, float BlendExp, bool bLockOutgoing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPlayZoomCamera");

	Params::ATCheatManager_ATDebugPlayZoomCamera Parms{};

	Parms.ActorName = std::move(ActorName);
	Parms.Duration = Duration;
	Parms.BlendType = BlendType;
	Parms.BlendExp = BlendExp;
	Parms.bLockOutgoing = bLockOutgoing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPostProcessStat
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugPostProcessStat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPostProcessStat");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPrintEncountWarning
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Toggle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPrintEncountWarning(bool Toggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPrintEncountWarning");

	Params::ATCheatManager_ATDebugPrintEncountWarning Parms{};

	Parms.Toggle = Toggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugPrintPreloadEnemyWarning
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Toggle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugPrintPreloadEnemyWarning(bool Toggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugPrintPreloadEnemyWarning");

	Params::ATCheatManager_ATDebugPrintPreloadEnemyWarning Parms{};

	Parms.Toggle = Toggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugQuestCommand
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           QuestCommand                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugQuestCommand(const class FString& QuestCommand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugQuestCommand");

	Params::ATCheatManager_ATDebugQuestCommand Parms{};

	Parms.QuestCommand = std::move(QuestCommand);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugQuestNavigationSubTest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugQuestNavigationSubTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugQuestNavigationSubTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugQuestNavigationTest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugQuestNavigationTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugQuestNavigationTest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugQuestReplaying
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ChapterId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EpisodeId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugQuestReplaying(int32 ChapterId, int32 EpisodeId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugQuestReplaying");

	Params::ATCheatManager_ATDebugQuestReplaying Parms{};

	Parms.ChapterId = ChapterId;
	Parms.EpisodeId = EpisodeId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugQuestSave
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugQuestSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugQuestSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugReleasedCollection
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugReleasedCollection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugReleasedCollection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRemoveCurrentQuest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugRemoveCurrentQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRemoveCurrentQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRemoveStateIcon
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRemoveStateIcon(uint8 InTarget, int32 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRemoveStateIcon");

	Params::ATCheatManager_ATDebugRemoveStateIcon Parms{};

	Parms.InTarget = InTarget;
	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugReportMission
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugReportMission()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugReportMission");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRequestActionTarget
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ActId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRequestActionTarget(const class FName& ActId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRequestActionTarget");

	Params::ATCheatManager_ATDebugRequestActionTarget Parms{};

	Parms.ActId = ActId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRequestMission
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// int32                                   MissionType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TargetID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRequestMission(int32 MissionType, int32 Value, const class FName& TargetID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRequestMission");

	Params::ATCheatManager_ATDebugRequestMission Parms{};

	Parms.MissionType = MissionType;
	Parms.Value = Value;
	Parms.TargetID = TargetID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRequestOffsetHighBoost
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bDirect                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRequestOffsetHighBoost(bool bDirect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRequestOffsetHighBoost");

	Params::ATCheatManager_ATDebugRequestOffsetHighBoost Parms{};

	Parms.bDirect = bDirect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRequestSkillTarget
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ActId                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRequestSkillTarget(const class FName& ActId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRequestSkillTarget");

	Params::ATCheatManager_ATDebugRequestSkillTarget Parms{};

	Parms.ActId = ActId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRequestStep
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRequestStep(float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRequestStep");

	Params::ATCheatManager_ATDebugRequestStep Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRequestTurn
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Angle                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRequestTurn(float Angle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRequestTurn");

	Params::ATCheatManager_ATDebugRequestTurn Parms{};

	Parms.Angle = Angle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugResetDragonBallUseTime
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugResetDragonBallUseTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugResetDragonBallUseTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugResetEventCpl071
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugResetEventCpl071()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugResetEventCpl071");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugRideMachineDiscard
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsAirCar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugRideMachineDiscard(bool IsAirCar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugRideMachineDiscard");

	Params::ATCheatManager_ATDebugRideMachineDiscard Parms{};

	Parms.IsAirCar = IsAirCar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveDataLoad
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSaveDataLoad(uint8 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveDataLoad");

	Params::ATCheatManager_ATDebugSaveDataLoad Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveDataSave
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Slot                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSaveDataSave(uint8 Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveDataSave");

	Params::ATCheatManager_ATDebugSaveDataSave Parms{};

	Parms.Slot = Slot;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveForcedCorrupt
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSaveForcedCorrupt(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveForcedCorrupt");

	Params::ATCheatManager_ATDebugSaveForcedCorrupt Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveMonitoringData
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Filename                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSaveMonitoringData(const class FString& Filename)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveMonitoringData");

	Params::ATCheatManager_ATDebugSaveMonitoringData Parms{};

	Parms.Filename = std::move(Filename);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveParty
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSaveParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveSystemLoad
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSaveSystemLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveSystemLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveVersionDifferences
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSaveVersionDifferences(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveVersionDifferences");

	Params::ATCheatManager_ATDebugSaveVersionDifferences Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSaveVersionSame
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSaveVersionSame(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSaveVersionSame");

	Params::ATCheatManager_ATDebugSaveVersionSame Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSelectDLC
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             SelectDLC                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSelectDLC(const class FName SelectDLC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSelectDLC");

	Params::ATCheatManager_ATDebugSelectDLC Parms{};

	Parms.SelectDLC = SelectDLC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSendEventCrossTalk
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSendEventCrossTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSendEventCrossTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSendFeverNotice
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSendFeverNotice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSendFeverNotice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSendNormalCrossTalk
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSendNormalCrossTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSendNormalCrossTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSendReusableNotice
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSendReusableNotice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSendReusableNotice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSendTelepathyNotice
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSendTelepathyNotice()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSendTelepathyNotice");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetAvailableTrunks
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    FlagAvailable                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetAvailableTrunks(bool FlagAvailable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetAvailableTrunks");

	Params::ATCheatManager_ATDebugSetAvailableTrunks Parms{};

	Parms.FlagAvailable = FlagAvailable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetCommunityFavor
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             SoulEmId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetCommunityFavor(const class FName& SoulEmId, int32 Value, int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetCommunityFavor");

	Params::ATCheatManager_ATDebugSetCommunityFavor Parms{};

	Parms.SoulEmId = SoulEmId;
	Parms.Value = Value;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetDefaultPositionDebugMenu
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSetDefaultPositionDebugMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetDefaultPositionDebugMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetEnableCrossTalkLipSync
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetEnableCrossTalkLipSync(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetEnableCrossTalkLipSync");

	Params::ATCheatManager_ATDebugSetEnableCrossTalkLipSync Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetEnableDeveloperMode_TimingObserver
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    bEnbale                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetEnableDeveloperMode_TimingObserver(bool bEnbale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetEnableDeveloperMode_TimingObserver");

	Params::ATCheatManager_ATDebugSetEnableDeveloperMode_TimingObserver Parms{};

	Parms.bEnbale = bEnbale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetEnableDLCId
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ID                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContentId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetEnableDLCId(const class FName& ID, const class FName& ContentId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetEnableDLCId");

	Params::ATCheatManager_ATDebugSetEnableDLCId Parms{};

	Parms.ID = ID;
	Parms.ContentId = ContentId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetExtendProgress
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetExtendProgress(const class FName& InProgress, int32 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetExtendProgress");

	Params::ATCheatManager_ATDebugSetExtendProgress Parms{};

	Parms.InProgress = InProgress;
	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetItemPalette
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Pallete                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetItemPalette(const class FName& Pallete, const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetItemPalette");

	Params::ATCheatManager_ATDebugSetItemPalette Parms{};

	Parms.Pallete = Pallete;
	Parms.ItemId = ItemId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetJumpToSeconds
// (Final, Exec, Native, Public)
// Parameters:
// float                                   TimeInSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetJumpToSeconds(float TimeInSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetJumpToSeconds");

	Params::ATCheatManager_ATDebugSetJumpToSeconds Parms{};

	Parms.TimeInSeconds = TimeInSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetJumpToSecondsFromCutName
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InCutName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetJumpToSecondsFromCutName(const class FName& InCutName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetJumpToSecondsFromCutName");

	Params::ATCheatManager_ATDebugSetJumpToSecondsFromCutName Parms{};

	Parms.InCutName = InCutName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetLayerTranslucencyRenderTargetTextureSize
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Height                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetLayerTranslucencyRenderTargetTextureSize(int32 Width, int32 Height)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetLayerTranslucencyRenderTargetTextureSize");

	Params::ATCheatManager_ATDebugSetLayerTranslucencyRenderTargetTextureSize Parms{};

	Parms.Width = Width;
	Parms.Height = Height;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetLevelCondition
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetLevelCondition(const class FString& Key, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetLevelCondition");

	Params::ATCheatManager_ATDebugSetLevelCondition Parms{};

	Parms.Key = std::move(Key);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetMainProgress
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             InProgress                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetMainProgress(const class FName& InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetMainProgress");

	Params::ATCheatManager_ATDebugSetMainProgress Parms{};

	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetPlayerLocationToActor
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ActorName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetPlayerLocationToActor(const class FName& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetPlayerLocationToActor");

	Params::ATCheatManager_ATDebugSetPlayerLocationToActor Parms{};

	Parms.ActorName = ActorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetPlayerLocationToHitPosition
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSetPlayerLocationToHitPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetPlayerLocationToHitPosition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetPositionDebugMenu
// (Final, Exec, Native, Public)
// Parameters:
// float                                   PosX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PosY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetPositionDebugMenu(float PosX, float PosY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetPositionDebugMenu");

	Params::ATCheatManager_ATDebugSetPositionDebugMenu Parms{};

	Parms.PosX = PosX;
	Parms.PosY = PosY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetSkillEnemyIcon
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetSkillEnemyIcon(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetSkillEnemyIcon");

	Params::ATCheatManager_ATDebugSetSkillEnemyIcon Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetSkillLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             CharaId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkillLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetSkillLevel(const class FName& CharaId, const class FName& SkillId, int32 SkillLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetSkillLevel");

	Params::ATCheatManager_ATDebugSetSkillLevel Parms{};

	Parms.CharaId = CharaId;
	Parms.SkillId = SkillId;
	Parms.SkillLevel = SkillLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetSkillLevelAll
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             CharaId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkillLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetSkillLevelAll(const class FName& CharaId, int32 SkillLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetSkillLevelAll");

	Params::ATCheatManager_ATDebugSetSkillLevelAll Parms{};

	Parms.CharaId = CharaId;
	Parms.SkillLevel = SkillLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetSkillLevelViewer
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetSkillLevelViewer(int32 Index_0, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetSkillLevelViewer");

	Params::ATCheatManager_ATDebugSetSkillLevelViewer Parms{};

	Parms.Index_0 = Index_0;
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetSkillPalette
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Palette                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SkillId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetSkillPalette(const class FName& Palette, const class FName& SkillId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetSkillPalette");

	Params::ATCheatManager_ATDebugSetSkillPalette Parms{};

	Parms.Palette = Palette;
	Parms.SkillId = SkillId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetSoulEmProficiency
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             SoulEmId                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Lv                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetSoulEmProficiency(const class FName& SoulEmId, int32 Category, int32 Lv)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetSoulEmProficiency");

	Params::ATCheatManager_ATDebugSetSoulEmProficiency Parms{};

	Parms.SoulEmId = SoulEmId;
	Parms.Category = Category;
	Parms.Lv = Lv;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSetTrainingRoomLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSetTrainingRoomLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSetTrainingRoomLevel");

	Params::ATCheatManager_ATDebugSetTrainingRoomLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowCharacterExp
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           TargetType                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowCharacterExp(const class FString& TargetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowCharacterExp");

	Params::ATCheatManager_ATDebugShowCharacterExp Parms{};

	Parms.TargetType = std::move(TargetType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowConfigFiles
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowConfigFiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowConfigFiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowCrossTalkVolume
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowCrossTalkVolume(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowCrossTalkVolume");

	Params::ATCheatManager_ATDebugShowCrossTalkVolume Parms{};

	Parms.IsShow = IsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowDLCInfoToTitle
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowDLCInfoToTitle(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowDLCInfoToTitle");

	Params::ATCheatManager_ATDebugShowDLCInfoToTitle Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowDLCInfoToTitleSaveClear
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowDLCInfoToTitleSaveClear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowDLCInfoToTitleSaveClear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowItemActor
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             ItemCategory                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowItemActor(class FName ItemCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowItemActor");

	Params::ATCheatManager_ATDebugShowItemActor Parms{};

	Parms.ItemCategory = ItemCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowLevelCondition
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowLevelCondition(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowLevelCondition");

	Params::ATCheatManager_ATDebugShowLevelCondition Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowNoneGeneralCrossTalkVolume
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsShow                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowNoneGeneralCrossTalkVolume(bool IsShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowNoneGeneralCrossTalkVolume");

	Params::ATCheatManager_ATDebugShowNoneGeneralCrossTalkVolume Parms{};

	Parms.IsShow = IsShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowPartyOrganizeFromQuestID
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             InID                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowPartyOrganizeFromQuestID(class FName InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowPartyOrganizeFromQuestID");

	Params::ATCheatManager_ATDebugShowPartyOrganizeFromQuestID Parms{};

	Parms.InID = InID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowPlayerControlMode
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowPlayerControlMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowPlayerControlMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowQuestCharacterHidden
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowQuestCharacterHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowQuestCharacterHidden");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowQuestFindListId
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowQuestFindListId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowQuestFindListId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowQuestNotification
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             NotificationId                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowQuestNotification(const class FName& NotificationId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowQuestNotification");

	Params::ATCheatManager_ATDebugShowQuestNotification Parms{};

	Parms.NotificationId = NotificationId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowQuestResult
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowQuestResult(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowQuestResult");

	Params::ATCheatManager_ATDebugShowQuestResult Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowQuestSymbol
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowQuestSymbol()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowQuestSymbol");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowRestrictControlMode
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowRestrictControlMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowRestrictControlMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowUniquenessObserver
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugShowUniquenessObserver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowUniquenessObserver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugShowWorldBlockingVolume
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             StringID                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugShowWorldBlockingVolume(class FName StringID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugShowWorldBlockingVolume");

	Params::ATCheatManager_ATDebugShowWorldBlockingVolume Parms{};

	Parms.StringID = StringID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSkipQuest
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSkipQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSkipQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoulEmAllRarity
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Rarity                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoulEmAllRarity(int32 Rarity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoulEmAllRarity");

	Params::ATCheatManager_ATDebugSoulEmAllRarity Parms{};

	Parms.Rarity = Rarity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoulEmAllUnlock
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   ExecId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoulEmAllUnlock(int32 ExecId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoulEmAllUnlock");

	Params::ATCheatManager_ATDebugSoulEmAllUnlock Parms{};

	Parms.ExecId = ExecId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoulEmItemGet
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSoulEmItemGet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoulEmItemGet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSound3D
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSound3D(bool Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSound3D");

	Params::ATCheatManager_ATDebugSound3D Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundCategoryVolume
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CateID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundCategoryVolume(int32 CateID, float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundCategoryVolume");

	Params::ATCheatManager_ATDebugSoundCategoryVolume Parms{};

	Parms.CateID = CateID;
	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundListener
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Param                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundListener(bool Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundListener");

	Params::ATCheatManager_ATDebugSoundListener Parms{};

	Parms.Param = Param;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundLoadCharacter
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CharType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundLoadCharacter(int32 CharType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundLoadCharacter");

	Params::ATCheatManager_ATDebugSoundLoadCharacter Parms{};

	Parms.CharType = CharType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundPlayBGM
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   bgmID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundPlayBGM(int32 bgmID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundPlayBGM");

	Params::ATCheatManager_ATDebugSoundPlayBGM Parms{};

	Parms.bgmID = bgmID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundPlaySE
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CueId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundPlaySE(int32 CueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundPlaySE");

	Params::ATCheatManager_ATDebugSoundPlaySE Parms{};

	Parms.CueId = CueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundPlVoice
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CueId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CharType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundPlVoice(int32 CueId, int32 CharType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundPlVoice");

	Params::ATCheatManager_ATDebugSoundPlVoice Parms{};

	Parms.CueId = CueId;
	Parms.CharType = CharType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundStopBGM
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSoundStopBGM()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundStopBGM");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundStopSE
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSoundStopSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundStopSE");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSoundUnLoadCharacter
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   CharType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSoundUnLoadCharacter(int32 CharType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSoundUnLoadCharacter");

	Params::ATCheatManager_ATDebugSoundUnLoadCharacter Parms{};

	Parms.CharType = CharType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSpawmFriend
// (Final, Exec, Native, Public)
// Parameters:
// float                                   FriendId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSpawmFriend(float FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSpawmFriend");

	Params::ATCheatManager_ATDebugSpawmFriend Parms{};

	Parms.FriendId = FriendId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStartAutoDebugUI
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugStartAutoDebugUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStartAutoDebugUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStartFastForward
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugStartFastForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStartFastForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStatLoading
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugStatLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStatLoading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStopAmbient
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugStopAmbient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStopAmbient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStopBGMFromBGMPlayer
// (Final, Exec, Native, Public)
// Parameters:
// EBGMCategory                            bgmType                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugStopBGMFromBGMPlayer(EBGMCategory bgmType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStopBGMFromBGMPlayer");

	Params::ATCheatManager_ATDebugStopBGMFromBGMPlayer Parms{};

	Parms.bgmType = bgmType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStopTalkMontage
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TalkMontageId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugStopTalkMontage(const class FString& ActorName, const class FString& TalkMontageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStopTalkMontage");

	Params::ATCheatManager_ATDebugStopTalkMontage Parms{};

	Parms.ActorName = std::move(ActorName);
	Parms.TalkMontageId = std::move(TalkMontageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugStoryResultOpen
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugStoryResultOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugStoryResultOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSubscribe
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugSubscribe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSubscribe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSubTitle
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           StringID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DispTime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSubTitle(const class FString& StringID, float DispTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSubTitle");

	Params::ATCheatManager_ATDebugSubTitle Parms{};

	Parms.StringID = std::move(StringID);
	Parms.DispTime = DispTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugSystemSaveEveryTimeLoad
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugSystemSaveEveryTimeLoad(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugSystemSaveEveryTimeLoad");

	Params::ATCheatManager_ATDebugSystemSaveEveryTimeLoad Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTalkWindowOff
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugTalkWindowOff()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTalkWindowOff");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTargetController
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugTargetController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTargetController");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTeleportPlayer
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Range                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugTeleportPlayer(float Range)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTeleportPlayer");

	Params::ATCheatManager_ATDebugTeleportPlayer Parms{};

	Parms.Range = Range;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTeleportToItemActor
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugTeleportToItemActor(const class FName& ItemId, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTeleportToItemActor");

	Params::ATCheatManager_ATDebugTeleportToItemActor Parms{};

	Parms.ItemId = ItemId;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTestLockOrganize
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugTestLockOrganize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTestLockOrganize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTestPartyOrganize
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugTestPartyOrganize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTestPartyOrganize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugToggleRecordingMode
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugToggleRecordingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugToggleRecordingMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTrophyLogType
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugTrophyLogType(int32 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTrophyLogType");

	Params::ATCheatManager_ATDebugTrophyLogType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugTutorialFlagSet
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   SaveId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsView                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugTutorialFlagSet(int32 SaveId, bool IsView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugTutorialFlagSet");

	Params::ATCheatManager_ATDebugTutorialFlagSet Parms{};

	Parms.SaveId = SaveId;
	Parms.IsView = IsView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiAddMapIconOffset
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InIconId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InOffsetX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InOffsetY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiAddMapIconOffset(int32 InIconId, float InOffsetX, float InOffsetY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiAddMapIconOffset");

	Params::ATCheatManager_ATDebugUiAddMapIconOffset Parms{};

	Parms.InIconId = InIconId;
	Parms.InOffsetX = InOffsetX;
	Parms.InOffsetY = InOffsetY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiAddWidgetLog
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUiAddWidgetLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiAddWidgetLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiBattleCharenge
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUiBattleCharenge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiBattleCharenge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiChangeConfirmButton
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsAButton                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiChangeConfirmButton(bool IsAButton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiChangeConfirmButton");

	Params::ATCheatManager_ATDebugUiChangeConfirmButton Parms{};

	Parms.IsAButton = IsAButton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiChangeLanguage
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           LangCode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiChangeLanguage(const class FString& LangCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiChangeLanguage");

	Params::ATCheatManager_ATDebugUiChangeLanguage Parms{};

	Parms.LangCode = std::move(LangCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiChangePlatform
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           PlatformCode                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiChangePlatform(const class FString& PlatformCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiChangePlatform");

	Params::ATCheatManager_ATDebugUiChangePlatform Parms{};

	Parms.PlatformCode = std::move(PlatformCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiChangeRegion
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           RegionCode                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiChangeRegion(const class FString& RegionCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiChangeRegion");

	Params::ATCheatManager_ATDebugUiChangeRegion Parms{};

	Parms.RegionCode = std::move(RegionCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiDbGet
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   GetIdx                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiDbGet(int32 GetIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiDbGet");

	Params::ATCheatManager_ATDebugUiDbGet Parms{};

	Parms.GetIdx = GetIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiDispVisibleList
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUiDispVisibleList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiDispVisibleList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiEnableCmnInput
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiEnableCmnInput(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiEnableCmnInput");

	Params::ATCheatManager_ATDebugUiEnableCmnInput Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiFieldMemory
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             CollectionId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiFieldMemory(class FName CollectionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiFieldMemory");

	Params::ATCheatManager_ATDebugUiFieldMemory Parms{};

	Parms.CollectionId = CollectionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiLoadingCheck
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUiLoadingCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiLoadingCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiLoadingHide
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsHide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiLoadingHide(bool IsHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiLoadingHide");

	Params::ATCheatManager_ATDebugUiLoadingHide Parms{};

	Parms.IsHide = IsHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUILog
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             LogLv                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LogMode                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FatalBreak                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUILog(class FName LogLv, int32 LogMode, bool FatalBreak)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUILog");

	Params::ATCheatManager_ATDebugUILog Parms{};

	Parms.LogLv = LogLv;
	Parms.LogMode = LogMode;
	Parms.FatalBreak = FatalBreak;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUILogDisplay
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             LogLv                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsOn                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUILogDisplay(class FName LogLv, bool IsOn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUILogDisplay");

	Params::ATCheatManager_ATDebugUILogDisplay Parms{};

	Parms.LogLv = LogLv;
	Parms.IsOn = IsOn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiMap
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Anim                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiMap(int32 State, int32 Anim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiMap");

	Params::ATCheatManager_ATDebugUiMap Parms{};

	Parms.State = State;
	Parms.Anim = Anim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiNaviWindowStart
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiNaviWindowStart(class FName UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiNaviWindowStart");

	Params::ATCheatManager_ATDebugUiNaviWindowStart Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiNaviWindowStop
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsStop                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiNaviWindowStop(bool IsStop)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiNaviWindowStop");

	Params::ATCheatManager_ATDebugUiNaviWindowStop Parms{};

	Parms.IsStop = IsStop;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiOutputWidgetInfo
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUiOutputWidgetInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiOutputWidgetInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiRemoveMapIconOffset
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InIconId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiRemoveMapIconOffset(int32 InIconId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiRemoveMapIconOffset");

	Params::ATCheatManager_ATDebugUiRemoveMapIconOffset Parms{};

	Parms.InIconId = InIconId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiSetDummyTextType
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiSetDummyTextType(int32 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiSetDummyTextType");

	Params::ATCheatManager_ATDebugUiSetDummyTextType Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiTestSwitch
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiTestSwitch(int32 TestCase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiTestSwitch");

	Params::ATCheatManager_ATDebugUiTestSwitch Parms{};

	Parms.TestCase = TestCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiTestSwitch1_F
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiTestSwitch1_F(int32 TestCase, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiTestSwitch1_F");

	Params::ATCheatManager_ATDebugUiTestSwitch1_F Parms{};

	Parms.TestCase = TestCase;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiTestSwitch1_I
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiTestSwitch1_I(int32 TestCase, int32 Value1)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiTestSwitch1_I");

	Params::ATCheatManager_ATDebugUiTestSwitch1_I Parms{};

	Parms.TestCase = TestCase;
	Parms.Value1 = Value1;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiTestSwitch1_N
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiTestSwitch1_N(int32 TestCase, class FName Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiTestSwitch1_N");

	Params::ATCheatManager_ATDebugUiTestSwitch1_N Parms{};

	Parms.TestCase = TestCase;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiTestSwitch2_I
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiTestSwitch2_I(int32 TestCase, int32 Value1, int32 Value2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiTestSwitch2_I");

	Params::ATCheatManager_ATDebugUiTestSwitch2_I Parms{};

	Parms.TestCase = TestCase;
	Parms.Value1 = Value1;
	Parms.Value2 = Value2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiTestSwitch3_FFV
// (Final, Exec, Native, Public, HasDefaults)
// Parameters:
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Value3                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiTestSwitch3_FFV(int32 TestCase, float Value1, float Value2, const struct FVector& Value3)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiTestSwitch3_FFV");

	Params::ATCheatManager_ATDebugUiTestSwitch3_FFV Parms{};

	Parms.TestCase = TestCase;
	Parms.Value1 = Value1;
	Parms.Value2 = Value2;
	Parms.Value3 = std::move(Value3);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUiUnlockMapInfo
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   AreaID                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUiUnlockMapInfo(int32 AreaID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUiUnlockMapInfo");

	Params::ATCheatManager_ATDebugUiUnlockMapInfo Parms{};

	Parms.AreaID = AreaID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUnloadDataAssets
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUnloadDataAssets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUnloadDataAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUnlockAllArea
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUnlockAllArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUnlockAllArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUnlockCommunity
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugUnlockCommunity(int32 Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUnlockCommunity");

	Params::ATCheatManager_ATDebugUnlockCommunity Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUnlockGroupBattleTraining
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUnlockGroupBattleTraining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUnlockGroupBattleTraining");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUnsubscribe
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUnsubscribe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUnsubscribe");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugUpdateCurrentMission
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugUpdateCurrentMission()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugUpdateCurrentMission");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugVariationChange
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugVariationChange(uint8 Variation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugVariationChange");

	Params::ATCheatManager_ATDebugVariationChange Parms{};

	Parms.Variation = Variation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugVariationChangeSupportLeft
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugVariationChangeSupportLeft(uint8 Variation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugVariationChangeSupportLeft");

	Params::ATCheatManager_ATDebugVariationChangeSupportLeft Parms{};

	Parms.Variation = Variation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugVariationChangeSupportRight
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Variation                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugVariationChangeSupportRight(uint8 Variation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugVariationChangeSupportRight");

	Params::ATCheatManager_ATDebugVariationChangeSupportRight Parms{};

	Parms.Variation = Variation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugViewLookAtLay_Character
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           ActorName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugViewLookAtLay_Character(const class FString& ActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugViewLookAtLay_Character");

	Params::ATCheatManager_ATDebugViewLookAtLay_Character Parms{};

	Parms.ActorName = std::move(ActorName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugViewLookAtLay_Player
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugViewLookAtLay_Player()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugViewLookAtLay_Player");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugViewLookAtLay_Support
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Number                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugViewLookAtLay_Support(int32 Number)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugViewLookAtLay_Support");

	Params::ATCheatManager_ATDebugViewLookAtLay_Support Parms{};

	Parms.Number = Number;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugViewMissionProgress
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             MissionId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugViewMissionProgress(const class FName& MissionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugViewMissionProgress");

	Params::ATCheatManager_ATDebugViewMissionProgress Parms{};

	Parms.MissionId = MissionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugVisibleBattleHudFlag
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugVisibleBattleHudFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugVisibleBattleHudFlag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugVisibleSkeletalMeshes
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             TargetCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugVisibleSkeletalMeshes(class FName TargetCharacter, bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugVisibleSkeletalMeshes");

	Params::ATCheatManager_ATDebugVisibleSkeletalMeshes Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugWindowTest
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   WindowKind                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WindowType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TestCase                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugWindowTest(int32 WindowKind, int32 WindowType, int32 TestCase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugWindowTest");

	Params::ATCheatManager_ATDebugWindowTest Parms{};

	Parms.WindowKind = WindowKind;
	Parms.WindowType = WindowType;
	Parms.TestCase = TestCase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugWishDragonBall
// (Final, Exec, Native, Public)

void UATCheatManager::ATDebugWishDragonBall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugWishDragonBall");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugXOneEnableSignOutWatch
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsEnable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugXOneEnableSignOutWatch(bool IsEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugXOneEnableSignOutWatch");

	Params::ATCheatManager_ATDebugXOneEnableSignOutWatch Parms{};

	Parms.IsEnable = IsEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugXOneSkipSignIn
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsSkip                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugXOneSkipSignIn(bool IsSkip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugXOneSkipSignIn");

	Params::ATCheatManager_ATDebugXOneSkipSignIn Parms{};

	Parms.IsSkip = IsSkip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugZBlastGaugeLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugZBlastGaugeLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugZBlastGaugeLevel");

	Params::ATCheatManager_ATDebugZBlastGaugeLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATDebugZBlastLevel
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATDebugZBlastLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATDebugZBlastLevel");

	Params::ATCheatManager_ATDebugZBlastLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATEventBattleLoad
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             BattleName                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATEventBattleLoad(const class FName& BattleName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATEventBattleLoad");

	Params::ATCheatManager_ATEventBattleLoad Parms{};

	Parms.BattleName = BattleName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATEventBattleRetire
// (Final, Exec, Native, Public)

void UATCheatManager::ATEventBattleRetire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATEventBattleRetire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATEventBattleRetry
// (Final, Exec, Native, Public)

void UATCheatManager::ATEventBattleRetry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATEventBattleRetry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATEventBattleStart
// (Final, Exec, Native, Public)

void UATCheatManager::ATEventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATEventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATFrameRateFixed
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InFrameRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATFrameRateFixed(int32 InFrameRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATFrameRateFixed");

	Params::ATCheatManager_ATFrameRateFixed Parms{};

	Parms.InFrameRate = InFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATFrameRateVariable
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InFrameRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATFrameRateVariable(int32 InFrameRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATFrameRateVariable");

	Params::ATCheatManager_ATFrameRateVariable Parms{};

	Parms.InFrameRate = InFrameRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATHuntingDinoAble
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    Src                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATHuntingDinoAble(bool Src)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATHuntingDinoAble");

	Params::ATCheatManager_ATHuntingDinoAble Parms{};

	Parms.Src = Src;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNID_Disable
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNID_Disable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNID_Disable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNID_Enable
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNID_Enable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNID_Enable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNID_Incompatible
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNID_Incompatible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNID_Incompatible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNID_Maintenance
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNID_Maintenance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNID_Maintenance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_A
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNIDEntryTips_A()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_A");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_A_Option
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InCompressionSettings                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLODGroup                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFilter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoTiling                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSRGB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeverStream                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFix64Scale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiBNIDEntryTips_A_Option(int32 InCompressionSettings, int32 InLODGroup, int32 InFilter, bool bNoTiling, bool bSRGB, bool bNeverStream, int32 InFix64Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_A_Option");

	Params::ATCheatManager_ATKpiBNIDEntryTips_A_Option Parms{};

	Parms.InCompressionSettings = InCompressionSettings;
	Parms.InLODGroup = InLODGroup;
	Parms.InFilter = InFilter;
	Parms.bNoTiling = bNoTiling;
	Parms.bSRGB = bSRGB;
	Parms.bNeverStream = bNeverStream;
	Parms.InFix64Scale = InFix64Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_A_Size
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InFix64Scale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiBNIDEntryTips_A_Size(int32 InFix64Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_A_Size");

	Params::ATCheatManager_ATKpiBNIDEntryTips_A_Size Parms{};

	Parms.InFix64Scale = InFix64Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_B
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNIDEntryTips_B()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_B");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_B_Option
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InCompressionSettings                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLODGroup                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFilter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoTiling                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSRGB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeverStream                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFix64Scale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiBNIDEntryTips_B_Option(int32 InCompressionSettings, int32 InLODGroup, int32 InFilter, bool bNoTiling, bool bSRGB, bool bNeverStream, int32 InSize, int32 InFix64Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_B_Option");

	Params::ATCheatManager_ATKpiBNIDEntryTips_B_Option Parms{};

	Parms.InCompressionSettings = InCompressionSettings;
	Parms.InLODGroup = InLODGroup;
	Parms.InFilter = InFilter;
	Parms.bNoTiling = bNoTiling;
	Parms.bSRGB = bSRGB;
	Parms.bNeverStream = bNeverStream;
	Parms.InSize = InSize;
	Parms.InFix64Scale = InFix64Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_B_Size
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFix64Scale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiBNIDEntryTips_B_Size(int32 InSize, int32 InFix64Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_B_Size");

	Params::ATCheatManager_ATKpiBNIDEntryTips_B_Size Parms{};

	Parms.InSize = InSize;
	Parms.InFix64Scale = InFix64Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_C
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiBNIDEntryTips_C()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_C");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_C_Option
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InCompressionSettings                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLODGroup                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFilter                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoTiling                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSRGB                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNeverStream                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFix64Scale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiBNIDEntryTips_C_Option(int32 InCompressionSettings, int32 InLODGroup, int32 InFilter, bool bNoTiling, bool bSRGB, bool bNeverStream, int32 InSize, int32 InFix64Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_C_Option");

	Params::ATCheatManager_ATKpiBNIDEntryTips_C_Option Parms{};

	Parms.InCompressionSettings = InCompressionSettings;
	Parms.InLODGroup = InLODGroup;
	Parms.InFilter = InFilter;
	Parms.bNoTiling = bNoTiling;
	Parms.bSRGB = bSRGB;
	Parms.bNeverStream = bNeverStream;
	Parms.InSize = InSize;
	Parms.InFix64Scale = InFix64Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiBNIDEntryTips_C_Size
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InSize                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InFix64Scale                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiBNIDEntryTips_C_Size(int32 InSize, int32 InFix64Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiBNIDEntryTips_C_Size");

	Params::ATCheatManager_ATKpiBNIDEntryTips_C_Size Parms{};

	Parms.InSize = InSize;
	Parms.InFix64Scale = InFix64Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiDevAccess
// (Final, Exec, Native, Public)

void UATCheatManager::ATKpiDevAccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiDevAccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATKpiLogin
// (Final, Exec, Native, Public)
// Parameters:
// bool                                    IsLogIn                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATKpiLogin(bool IsLogIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATKpiLogin");

	Params::ATCheatManager_ATKpiLogin Parms{};

	Parms.IsLogIn = IsLogIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATLoadSubLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATLoadSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATLoadSubLevel");

	Params::ATCheatManager_ATLoadSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATMiniGameTestStart
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   MiniGamaType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATMiniGameTestStart(int32 MiniGamaType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATMiniGameTestStart");

	Params::ATCheatManager_ATMiniGameTestStart Parms{};

	Parms.MiniGamaType = MiniGamaType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATMoveToActionPoint
// (Final, Exec, Native, Public)
// Parameters:
// int32                                   InMethodNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATMoveToActionPoint(int32 InMethodNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATMoveToActionPoint");

	Params::ATCheatManager_ATMoveToActionPoint Parms{};

	Parms.InMethodNum = InMethodNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATPrintMainProgress
// (Final, Exec, Native, Public)

void UATCheatManager::ATPrintMainProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATPrintMainProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATPrintSubProgress
// (Final, Exec, Native, Public)

void UATCheatManager::ATPrintSubProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATPrintSubProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATRingoutTest
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATRingoutTest(uint8 InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATRingoutTest");

	Params::ATCheatManager_ATRingoutTest Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATSetBattleTime
// (Final, Exec, Native, Public)
// Parameters:
// float                                   InRequestedBattleTime                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATSetBattleTime(float InRequestedBattleTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATSetBattleTime");

	Params::ATCheatManager_ATSetBattleTime Parms{};

	Parms.InRequestedBattleTime = InRequestedBattleTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATSetEventBattleRemainingTime
// (Final, Exec, Native, Public)
// Parameters:
// float                                   InRequestedTimeRemaining                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATSetEventBattleRemainingTime(float InRequestedTimeRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATSetEventBattleRemainingTime");

	Params::ATCheatManager_ATSetEventBattleRemainingTime Parms{};

	Parms.InRequestedTimeRemaining = InRequestedTimeRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATSetProgress
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             Progress                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Phase_no                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATSetProgress(const class FName& Progress, int32 Phase_no)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATSetProgress");

	Params::ATCheatManager_ATSetProgress Parms{};

	Parms.Progress = Progress;
	Parms.Phase_no = Phase_no;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATShowNearestActionPoint
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           InFunctionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATShowNearestActionPoint(const class FString& InFunctionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATShowNearestActionPoint");

	Params::ATCheatManager_ATShowNearestActionPoint Parms{};

	Parms.InFunctionName = std::move(InFunctionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATShowPhotonRoute
// (Final, Exec, Native, Public)

void UATCheatManager::ATShowPhotonRoute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATShowPhotonRoute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATShowStoreUI
// (Final, Exec, Native, Public)

void UATCheatManager::ATShowStoreUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATShowStoreUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATStatSummaryAndRaw
// (Final, Exec, Native, Public)

void UATCheatManager::ATStatSummaryAndRaw()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATStatSummaryAndRaw");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATToggleHideDirectionCursor
// (Final, Exec, Native, Public)

void UATCheatManager::ATToggleHideDirectionCursor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATToggleHideDirectionCursor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATToggleShowDamageCollision
// (Final, Exec, Native, Public)

void UATCheatManager::ATToggleShowDamageCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATToggleShowDamageCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATToggleShowDirectionCursorLog
// (Final, Exec, Native, Public)

void UATCheatManager::ATToggleShowDirectionCursorLog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATToggleShowDirectionCursorLog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATUnloadCharacter
// (Final, Exec, Native, Public)

void UATCheatManager::ATUnloadCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATUnloadCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.ATUnloadSubLevel
// (Final, Exec, Native, Public, HasOutParams)
// Parameters:
// class FName                             LevelName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::ATUnloadSubLevel(const class FName& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "ATUnloadSubLevel");

	Params::ATCheatManager_ATUnloadSubLevel Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.OnLoadedCharacter
// (Final, Native, Private)
// Parameters:
// class UATDataAssetCharacterAsyncLoad*   CharLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::OnLoadedCharacter(class UATDataAssetCharacterAsyncLoad* CharLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "OnLoadedCharacter");

	Params::ATCheatManager_OnLoadedCharacter Parms{};

	Parms.CharLoad = CharLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.OnVisibledLevel
// (Final, Native, Private)
// Parameters:
// class FName                             InDemoName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::OnVisibledLevel(const class FName InDemoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "OnVisibledLevel");

	Params::ATCheatManager_OnVisibledLevel Parms{};

	Parms.InDemoName = InDemoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.OnVisibledLevelByProgress
// (Final, Native, Private)
// Parameters:
// class FName                             InDemoName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::OnVisibledLevelByProgress(const class FName InDemoName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "OnVisibledLevelByProgress");

	Params::ATCheatManager_OnVisibledLevelByProgress Parms{};

	Parms.InDemoName = InDemoName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATCheatManager.RequestDemoOnLevelVisible
// (Final, Native, Private)
// Parameters:
// class ULevelStreaming*                  LevelStreaming                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATCheatManager::RequestDemoOnLevelVisible(class ULevelStreaming* LevelStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATCheatManager", "RequestDemoOnLevelVisible");

	Params::ATCheatManager_RequestDemoOnLevelVisible Parms{};

	Parms.LevelStreaming = LevelStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.GetSkillNotification
// (Final, Native, Private)

void UShopComponent::GetSkillNotification()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "GetSkillNotification");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.GotoSimulationBattleField
// (Final, Native, Private)
// Parameters:
// class FName                             EventBattleID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopComponent::GotoSimulationBattleField(class FName EventBattleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "GotoSimulationBattleField");

	Params::ShopComponent_GotoSimulationBattleField Parms{};

	Parms.EventBattleID = EventBattleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.GotoTrainingRoomBattleField
// (Final, Native, Private)
// Parameters:
// class FName                             EventBattleID                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopComponent::GotoTrainingRoomBattleField(class FName EventBattleID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "GotoTrainingRoomBattleField");

	Params::ShopComponent_GotoTrainingRoomBattleField Parms{};

	Parms.EventBattleID = EventBattleID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.OnFinishedSimulationBattleEndTalking
// (Final, Native, Private)

void UShopComponent::OnFinishedSimulationBattleEndTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "OnFinishedSimulationBattleEndTalking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.OnFinishedTalking
// (Final, Native, Private)

void UShopComponent::OnFinishedTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "OnFinishedTalking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.OnFinishedTrainingEndTalking
// (Final, Native, Private)

void UShopComponent::OnFinishedTrainingEndTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "OnFinishedTrainingEndTalking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.OnFinishGetSoulEmblem
// (Final, Native, Private)

void UShopComponent::OnFinishGetSoulEmblem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "OnFinishGetSoulEmblem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.OnLoadWidget
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          InLoader                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopComponent::OnLoadWidget(class UATDataAssetUiAsyncLoad* InLoader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "OnLoadWidget");

	Params::ShopComponent_OnLoadWidget Parms{};

	Parms.InLoader = InLoader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.OpenSimulatorTIPs
// (Final, Native, Private)

void UShopComponent::OpenSimulatorTIPs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "OpenSimulatorTIPs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ShopComponent.PopUpUnlockedMessage
// (Final, Native, Private)

void UShopComponent::PopUpUnlockedMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopComponent", "PopUpUnlockedMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CostumeLoader.OnLoadedFacial
// (Final, Native, Private)
// Parameters:
// class UATDataAssetFacialAsyncLoad*      Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCostumeLoader::OnLoadedFacial(class UATDataAssetFacialAsyncLoad* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CostumeLoader", "OnLoadedFacial");

	Params::CostumeLoader_OnLoadedFacial Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CostumeLoader.OnLoadedForm
// (Final, Native, Private)
// Parameters:
// class UATDataAssetFormMeshAsyncLoad*    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCostumeLoader::OnLoadedForm(class UATDataAssetFormMeshAsyncLoad* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CostumeLoader", "OnLoadedForm");

	Params::CostumeLoader_OnLoadedForm Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CostumeLoader.OnLoadedVariation
// (Final, Native, Private)
// Parameters:
// class UATDataAssetVariationMeshAsyncLoad*Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCostumeLoader::OnLoadedVariation(class UATDataAssetVariationMeshAsyncLoad* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CostumeLoader", "OnLoadedVariation");

	Params::CostumeLoader_OnLoadedVariation Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.GetQuestDebugConfigId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UQuestManager::GetQuestDebugConfigId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestManager", "GetQuestDebugConfigId");

	Params::QuestManager_GetQuestDebugConfigId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.GetQuestSymbol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UQuestManager::GetQuestSymbol()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestManager", "GetQuestSymbol");

	Params::QuestManager_GetQuestSymbol Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.SetQuestDebugConfigId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InConfigId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetQuestDebugConfigId(class FName InConfigId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestManager", "SetQuestDebugConfigId");

	Params::QuestManager_SetQuestDebugConfigId Parms{};

	Parms.InConfigId = InConfigId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.SetQuestSymbol
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FName                             InSymbol                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetQuestSymbol(class FName InSymbol)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("QuestManager", "SetQuestSymbol");

	Params::QuestManager_SetQuestSymbol Parms{};

	Parms.InSymbol = InSymbol;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.AddQuestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Group_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeHeadupIcon                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::AddQuestActor(class FName Quest_id, class AActor* Actor, class FName Group_name, bool bChangeHeadupIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "AddQuestActor");

	Params::QuestManager_AddQuestActor Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Actor = Actor;
	Parms.Group_name = Group_name;
	Parms.bChangeHeadupIcon = bChangeHeadupIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.AddQuestActorName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Group_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeHeadupIcon                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::AddQuestActorName(class FName Quest_id, class FName Actor_name, class FName Group_name, bool bChangeHeadupIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "AddQuestActorName");

	Params::QuestManager_AddQuestActorName Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Actor_name = Actor_name;
	Parms.Group_name = Group_name;
	Parms.bChangeHeadupIcon = bChangeHeadupIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.AddQuestNameInMap
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActorName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQUEST_GENRE_TYPE                       QuestType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeHeadupIcon                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::AddQuestNameInMap(class FName QuestId, class FName ActorName, EQUEST_GENRE_TYPE QuestType, bool bChangeHeadupIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "AddQuestNameInMap");

	Params::QuestManager_AddQuestNameInMap Parms{};

	Parms.QuestId = QuestId;
	Parms.ActorName = ActorName;
	Parms.QuestType = QuestType;
	Parms.bChangeHeadupIcon = bChangeHeadupIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.AddSubQuestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bChangeHeadupIcon                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHiddenIcon                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::AddSubQuestActor(class FName Quest_id, class FName Actor_name, bool bChangeHeadupIcon, bool bHiddenIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "AddSubQuestActor");

	Params::QuestManager_AddSubQuestActor Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Actor_name = Actor_name;
	Parms.bChangeHeadupIcon = bChangeHeadupIcon;
	Parms.bHiddenIcon = bHiddenIcon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ClearReserveNotificationAndCrossTalk
// (Final, Native, Public, BlueprintCallable)

void UQuestManager::ClearReserveNotificationAndCrossTalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ClearReserveNotificationAndCrossTalk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.DisableQuestCharacters
// (Final, Native, Public)

void UQuestManager::DisableQuestCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "DisableQuestCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.EnableQuestCharacters
// (Final, Native, Public)

void UQuestManager::EnableQuestCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "EnableQuestCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ExtendPhaseChangeTiming
// (Final, Native, Private)
// Parameters:
// int32                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::ExtendPhaseChangeTiming(int32 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ExtendPhaseChangeTiming");

	Params::QuestManager_ExtendPhaseChangeTiming Parms{};

	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ExtendProgressChangeTiming
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             NextProgressName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::ExtendProgressChangeTiming(const class FName& NextProgressName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ExtendProgressChangeTiming");

	Params::QuestManager_ExtendProgressChangeTiming Parms{};

	Parms.NextProgressName = NextProgressName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.FetchDataTable
// (Final, Native, Private)

void UQuestManager::FetchDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "FetchDataTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.GetActorByFindListId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             FindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UQuestManager::GetActorByFindListId(class FName FindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetActorByFindListId");

	Params::QuestManager_GetActorByFindListId Parms{};

	Parms.FindId = FindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.GetActorByType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UQuestManager::GetActorByType(ECHARACTER_TYPE CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetActorByType");

	Params::QuestManager_GetActorByType Parms{};

	Parms.CharacterType = CharacterType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.GetAutoTurnCameraSeconds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UQuestManager::GetAutoTurnCameraSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetAutoTurnCameraSeconds");

	Params::QuestManager_GetAutoTurnCameraSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.GetBlockingVolumeCameraSeconds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UQuestManager::GetBlockingVolumeCameraSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetBlockingVolumeCameraSeconds");

	Params::QuestManager_GetBlockingVolumeCameraSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.GetCharacterFindList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             FindId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AQuestCharacter*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AQuestCharacter* UQuestManager::GetCharacterFindList(class FName FindId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetCharacterFindList");

	Params::QuestManager_GetCharacterFindList Parms{};

	Parms.FindId = FindId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.GetPhaseId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UQuestManager::GetPhaseId(const class FName& QuestId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "GetPhaseId");

	Params::QuestManager_GetPhaseId Parms{};

	Parms.QuestId = QuestId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.IsActiveQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsActiveQuest(class FName Quest_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsActiveQuest");

	Params::QuestManager_IsActiveQuest Parms{};

	Parms.Quest_id = Quest_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.IsEnableOrderQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsEnableOrderQuest(class FName Quest_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsEnableOrderQuest");

	Params::QuestManager_IsEnableOrderQuest Parms{};

	Parms.Quest_id = Quest_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.IsQuestEndPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Phase_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsQuestEndPhase(class FName Quest_id, class FName Phase_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsQuestEndPhase");

	Params::QuestManager_IsQuestEndPhase Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Phase_id = Phase_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.IsRepeatQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsRepeatQuest(class FName Quest_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsRepeatQuest");

	Params::QuestManager_IsRepeatQuest Parms{};

	Parms.Quest_id = Quest_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestManager.OnChangedProgress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::OnChangedProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnChangedProgress");

	Params::QuestManager_OnChangedProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnCompletedInitialize
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestManager::OnCompletedInitialize(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnCompletedInitialize");

	Params::QuestManager_OnCompletedInitialize Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnEndTalkMiniQuest
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestManager::OnEndTalkMiniQuest(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnEndTalkMiniQuest");

	Params::QuestManager_OnEndTalkMiniQuest Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnEventBattleDecision
// (Final, Native, Private)

void UQuestManager::OnEventBattleDecision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnEventBattleDecision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnEventBattleEnd
// (Final, Native, Private)

void UQuestManager::OnEventBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnEventBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnEventBattleStart
// (Final, Native, Private)

void UQuestManager::OnEventBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnEventBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnLoadComplete
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestManager::OnLoadComplete(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnLoadComplete");

	Params::QuestManager_OnLoadComplete Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnNormalBattleEnd
// (Final, Native, Private)

void UQuestManager::OnNormalBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnNormalBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnNormalBattleStart
// (Final, Native, Private)

void UQuestManager::OnNormalBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnNormalBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnNormalEncountStart
// (Final, Native, Private)

void UQuestManager::OnNormalEncountStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnNormalEncountStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnReceiveSubQuest
// (Final, Native, Public, BlueprintCallable)

void UQuestManager::OnReceiveSubQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnReceiveSubQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnRideVehicle
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestManager::OnRideVehicle(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnRideVehicle");

	Params::QuestManager_OnRideVehicle Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnSubQuestNavigationUpdate
// (Final, Native, Private)
// Parameters:
// class FName                             PhaseID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQUEST_PHASE_TYPE                       Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::OnSubQuestNavigationUpdate(class FName PhaseID, EQUEST_PHASE_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnSubQuestNavigationUpdate");

	Params::QuestManager_OnSubQuestNavigationUpdate Parms{};

	Parms.PhaseID = PhaseID;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.OnTalkParticleLoad
// (Final, Native, Private)

void UQuestManager::OnTalkParticleLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "OnTalkParticleLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.PhaseChangeTiming
// (Final, Native, Private)
// Parameters:
// int32                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::PhaseChangeTiming(int32 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "PhaseChangeTiming");

	Params::QuestManager_PhaseChangeTiming Parms{};

	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ProgressChangeTiming
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             NextProgressName                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::ProgressChangeTiming(const class FName& NextProgressName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ProgressChangeTiming");

	Params::QuestManager_ProgressChangeTiming Parms{};

	Parms.NextProgressName = NextProgressName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ProgressPhaseChangeTiming
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             New_name                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::ProgressPhaseChangeTiming(const class FName& New_name, int32 Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ProgressPhaseChangeTiming");

	Params::QuestManager_ProgressPhaseChangeTiming Parms{};

	Parms.New_name = New_name;
	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.QuestActorTiming
// (Final, Native, Private)
// Parameters:
// EQUEST_ACTOR_TIMING_TYPE                Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InActor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::QuestActorTiming(EQUEST_ACTOR_TIMING_TYPE Timing, class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "QuestActorTiming");

	Params::QuestManager_QuestActorTiming Parms{};

	Parms.Timing = Timing;
	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.RemoveActiveMainQuestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RemoveActiveMainQuestActor(class FName Actor_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RemoveActiveMainQuestActor");

	Params::QuestManager_RemoveActiveMainQuestActor Parms{};

	Parms.Actor_name = Actor_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.RemoveActiveSubQuestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RemoveActiveSubQuestActor(class FName Actor_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RemoveActiveSubQuestActor");

	Params::QuestManager_RemoveActiveSubQuestActor Parms{};

	Parms.Actor_name = Actor_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.RemoveQuestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RemoveQuestActor(class FName Quest_id, class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RemoveQuestActor");

	Params::QuestManager_RemoveQuestActor Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.RemoveQuestActorName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Actor_name                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RemoveQuestActorName(class FName Quest_id, class FName Actor_name)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RemoveQuestActorName");

	Params::QuestManager_RemoveQuestActorName Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Actor_name = Actor_name;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.RequestFadeAfterDemo
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RequestFadeAfterDemo(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RequestFadeAfterDemo");

	Params::QuestManager_RequestFadeAfterDemo Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.RequestFadeBeforeDemo
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::RequestFadeBeforeDemo(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "RequestFadeBeforeDemo");

	Params::QuestManager_RequestFadeBeforeDemo Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ReserveQuestNotificationOrCrossTalk
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ActionCommands                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UQuestManager::ReserveQuestNotificationOrCrossTalk(const TArray<class FString>& ActionCommands)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ReserveQuestNotificationOrCrossTalk");

	Params::QuestManager_ReserveQuestNotificationOrCrossTalk Parms{};

	Parms.ActionCommands = std::move(ActionCommands);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.ReuqestStartMainQuest
// (Final, Native, Public)

void UQuestManager::ReuqestStartMainQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "ReuqestStartMainQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.SetAutoTurnCameraSeconds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetAutoTurnCameraSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "SetAutoTurnCameraSeconds");

	Params::QuestManager_SetAutoTurnCameraSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.SetBlockingVolumeCameraSeconds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetBlockingVolumeCameraSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "SetBlockingVolumeCameraSeconds");

	Params::QuestManager_SetBlockingVolumeCameraSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.SetForceEndPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Phase_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SetForceEndPhase(class FName Quest_id, class FName Phase_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "SetForceEndPhase");

	Params::QuestManager_SetForceEndPhase Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Phase_id = Phase_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.SubLevelBeginPlayTiming
// (Final, Native, Private)
// Parameters:
// class FName                             SubLevelName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestManager::SubLevelBeginPlayTiming(const class FName SubLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "SubLevelBeginPlayTiming");

	Params::QuestManager_SubLevelBeginPlayTiming Parms{};

	Parms.SubLevelName = SubLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestManager.IsClearedId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Quest_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UQuestManager::IsClearedId(class FName Quest_id) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestManager", "IsClearedId");

	Params::QuestManager_IsClearedId Parms{};

	Parms.Quest_id = Quest_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATRoomCharaManager.OnJoinedSupportCharacter
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPartyMember                     PartyInMember                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   MemberType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATRoomCharaManager::OnJoinedSupportCharacter(const struct FPartyMember& PartyInMember, uint8 MemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRoomCharaManager", "OnJoinedSupportCharacter");

	Params::ATRoomCharaManager_OnJoinedSupportCharacter Parms{};

	Parms.PartyInMember = std::move(PartyInMember);
	Parms.MemberType = MemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRoomCharaManager.OnOutSupportCharacter
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FPartyMember                     PartyOutMember                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   MemberType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATRoomCharaManager::OnOutSupportCharacter(const struct FPartyMember& PartyOutMember, uint8 MemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRoomCharaManager", "OnOutSupportCharacter");

	Params::ATRoomCharaManager_OnOutSupportCharacter Parms{};

	Parms.PartyOutMember = std::move(PartyOutMember);
	Parms.MemberType = MemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRoomCharaManager.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATRoomCharaManager::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRoomCharaManager", "OnOverlapBegin");

	Params::ATRoomCharaManager_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRoomCharaManager.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATRoomCharaManager::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRoomCharaManager", "OnOverlapEnd");

	Params::ATRoomCharaManager_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATBattleAILoader.CompleteLoad
// (Final, Native, Protected)
// Parameters:
// class UATDataAssetBattleAIAsyncLoad*    Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATBattleAILoader::CompleteLoad(class UATDataAssetBattleAIAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleAILoader", "CompleteLoad");

	Params::ATBattleAILoader_CompleteLoad Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATBattleAILoader.CompleteLoadGroup
// (Final, Native, Protected)
// Parameters:
// class UATDataAssetBattleGroupAIAsyncLoad*Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATBattleAILoader::CompleteLoadGroup(class UATDataAssetBattleGroupAIAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATBattleAILoader", "CompleteLoadGroup");

	Params::ATBattleAILoader_CompleteLoadGroup Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATProjectileMine.HitRootSphere
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATProjectileMine::HitRootSphere(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATProjectileMine", "HitRootSphere");

	Params::ATProjectileMine_HitRootSphere Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATProjectileMine.OnBattleEnd
// (Final, Native, Public)

void AATProjectileMine::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATProjectileMine", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl005GSkill003.SpawnFallProjectile
// (Final, Native, Private)
// Parameters:
// int32                                   SpawnNumber                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl005GSkill003::SpawnFallProjectile(int32 SpawnNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl005GSkill003", "SpawnFallProjectile");

	Params::Projectile_Cpl005GSkill003_SpawnFallProjectile Parms{};

	Parms.SpawnNumber = SpawnNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl005GSkill003.SpawnOmenEffect
// (Final, Native, Private)
// Parameters:
// int32                                   SpawnNumber                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl005GSkill003::SpawnOmenEffect(int32 SpawnNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl005GSkill003", "SpawnOmenEffect");

	Params::Projectile_Cpl005GSkill003_SpawnOmenEffect Parms{};

	Parms.SpawnNumber = SpawnNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TimeOrbManager.OnLottery
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTimeOrbManager::OnLottery(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeOrbManager", "OnLottery");

	Params::TimeOrbManager_OnLottery Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TimeOrbManager.OnOrbLevelLoaded
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTimeOrbManager::OnOrbLevelLoaded(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TimeOrbManager", "OnOrbLevelLoaded");

	Params::TimeOrbManager_OnOrbLevelLoaded Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpawnerItemVolumeBase.OnDemoTiming
// (Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerItemVolumeBase::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerItemVolumeBase", "OnDemoTiming");

	Params::SpawnerItemVolumeBase_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDataAssetUiAsyncLoad.CompleteLoadAlways
// (Final, Native, Public)

void UATDataAssetUiAsyncLoad::CompleteLoadAlways()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDataAssetUiAsyncLoad", "CompleteLoadAlways");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDebugUICharaIconManager.Instance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UATDebugUICharaIconManager*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATDebugUICharaIconManager* UATDebugUICharaIconManager::Instance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATDebugUICharaIconManager", "Instance");

	Params::ATDebugUICharaIconManager_Instance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDemoInputComponent.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       InTiming                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInContinue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDemoInputComponent::OnDemoTiming(EDEMO_TYPE InType, EDEMO_TIMING_TYPE InTiming, class FName InName, bool bInContinue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoInputComponent", "OnDemoTiming");

	Params::ATDemoInputComponent_OnDemoTiming Parms{};

	Parms.InType = InType;
	Parms.InTiming = InTiming;
	Parms.InName = InName;
	Parms.bInContinue = bInContinue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDemoManageComponent.BroadcastDemoEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DemoName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EventName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDemoManageComponent::BroadcastDemoEvent(const class FName DemoName, const class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "BroadcastDemoEvent");

	Params::ATDemoManageComponent_BroadcastDemoEvent Parms{};

	Parms.DemoName = DemoName;
	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDemoManageComponent.DemoSkip
// (Final, Native, Public)

void UATDemoManageComponent::DemoSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "DemoSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDemoManageComponent.GetCinemaDemoCtrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UATCinemaDemoCtrl*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATCinemaDemoCtrl* UATDemoManageComponent::GetCinemaDemoCtrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "GetCinemaDemoCtrl");

	Params::ATDemoManageComponent_GetCinemaDemoCtrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDemoManageComponent.GetGeneralDemoCtrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UATGeneralDemoCtrl*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATGeneralDemoCtrl* UATDemoManageComponent::GetGeneralDemoCtrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "GetGeneralDemoCtrl");

	Params::ATDemoManageComponent_GetGeneralDemoCtrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDemoManageComponent.GetIngameDemoCtrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UATIngameDemoCtrl*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATIngameDemoCtrl* UATDemoManageComponent::GetIngameDemoCtrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "GetIngameDemoCtrl");

	Params::ATDemoManageComponent_GetIngameDemoCtrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDemoManageComponent.GetPreRenderDemoCtrl
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UATPreRenderDemoCtrl*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UATPreRenderDemoCtrl* UATDemoManageComponent::GetPreRenderDemoCtrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "GetPreRenderDemoCtrl");

	Params::ATDemoManageComponent_GetPreRenderDemoCtrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDemoManageComponent.RequestDemo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDEMO_TYPE                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InDurationAfterDirection                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNotFadeinInDemoSkip                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDemoBGMSeamlessType                    BGMSeamlessType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDemoManageComponent::RequestDemo(EDEMO_TYPE Type, EDEMO_TIMING_TYPE Timing, class FName Name_0, bool bImmediate, float InDurationAfterDirection, bool bNotFadeinInDemoSkip, EDemoBGMSeamlessType BGMSeamlessType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "RequestDemo");

	Params::ATDemoManageComponent_RequestDemo Parms{};

	Parms.Type = Type;
	Parms.Timing = Timing;
	Parms.Name_0 = Name_0;
	Parms.bImmediate = bImmediate;
	Parms.InDurationAfterDirection = InDurationAfterDirection;
	Parms.bNotFadeinInDemoSkip = bNotFadeinInDemoSkip;
	Parms.BGMSeamlessType = BGMSeamlessType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDemoManageComponent.SetDemoLevelOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             DemoLevelName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Offset                                                 (ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UATDemoManageComponent::SetDemoLevelOffset(const class FName DemoLevelName, const struct FTransform& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "SetDemoLevelOffset");

	Params::ATDemoManageComponent_SetDemoLevelOffset Parms{};

	Parms.DemoLevelName = DemoLevelName;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDemoManageComponent.SubLevelBeginPlayTiming
// (Final, Native, Public)
// Parameters:
// class FName                             SubLevelName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDemoManageComponent::SubLevelBeginPlayTiming(const class FName SubLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDemoManageComponent", "SubLevelBeginPlayTiming");

	Params::ATDemoManageComponent_SubLevelBeginPlayTiming Parms{};

	Parms.SubLevelName = SubLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDevelopManager.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATDevelopManager::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDevelopManager", "MouseClickDecide");

	Params::ATDevelopManager_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDevelopManager.MouseClickTabLeft
// (Final, Native, Public)

void UATDevelopManager::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDevelopManager", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDevelopManager.MouseClickTabRight
// (Final, Native, Public)

void UATDevelopManager::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDevelopManager", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateEntityBase.OnRent
// (Native, Event, Public, BlueprintEvent)

void UTerrainDecorateEntityBase::OnRent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateEntityBase", "OnRent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateEntityBase.OnReturn
// (Native, Event, Public, BlueprintEvent)

void UTerrainDecorateEntityBase::OnReturn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateEntityBase", "OnReturn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDirectionReinforce.OnFinishedVoice
// (Final, Native, Protected)
// Parameters:
// int32                                   Ch                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATDirectionReinforce::OnFinishedVoice(int32 Ch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDirectionReinforce", "OnFinishedVoice");

	Params::ATDirectionReinforce_OnFinishedVoice Parms{};

	Parms.Ch = Ch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDoorVolume.FixPostProcessFromTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InTag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APostProcessVolume*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APostProcessVolume* AATDoorVolume::FixPostProcessFromTag(class FName InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "FixPostProcessFromTag");

	Params::ATDoorVolume_FixPostProcessFromTag Parms{};

	Parms.InTag = InTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATDoorVolume.NotSetPlayer
// (Final, Native, Public, BlueprintCallable)

void AATDoorVolume::NotSetPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "NotSetPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDoorVolume.OnActionChange
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDoorVolume::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "OnActionChange");

	Params::ATDoorVolume_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDoorVolume.OnActorBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDoorVolume::OnActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "OnActorBeginOverlap");

	Params::ATDoorVolume_OnActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDoorVolume.OnLevelShown
// (Final, Native, Private)
// Parameters:
// class ULevelStreaming*                  LevelStreaming                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDoorVolume::OnLevelShown(class ULevelStreaming* LevelStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "OnLevelShown");

	Params::ATDoorVolume_OnLevelShown Parms{};

	Parms.LevelStreaming = LevelStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDoorVolume.Open
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InForceTrainingMove                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InTrainingBattleStart                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATDoorVolume::Open(bool InForceTrainingMove, bool InTrainingBattleStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "Open");

	Params::ATDoorVolume_Open Parms{};

	Parms.InForceTrainingMove = InForceTrainingMove;
	Parms.InTrainingBattleStart = InTrainingBattleStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATDoorVolume.ResetActorStates
// (Final, Native, Public, BlueprintCallable)

void AATDoorVolume::ResetActorStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATDoorVolume", "ResetActorStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EasingMovement.Pause
// (Final, Native, Public, BlueprintCallable)

void UEasingMovement::Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EasingMovement", "Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EasingMovement.SetDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEasingMovement::SetDuration(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EasingMovement", "SetDuration");

	Params::EasingMovement_SetDuration Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EasingMovement.SetTargetPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEasingMovement::SetTargetPoint(class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EasingMovement", "SetTargetPoint");

	Params::EasingMovement_SetTargetPoint Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EasingMovement.Start
// (Final, Native, Public, BlueprintCallable)

void UEasingMovement::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EasingMovement", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Enable.SetEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IEnable::SetEnable(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Enable", "SetEnable");

	Params::Enable_SetEnable Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Enable.IsEnable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IEnable::IsEnable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Enable", "IsEnable");

	Params::Enable_IsEnable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestPhase_AssaultBattle.OnFinishedBattle
// (Final, Native, Private)

void UQuestPhase_AssaultBattle::OnFinishedBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_AssaultBattle", "OnFinishedBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_AssaultBattle.OnFinishedPhase
// (Final, Native, Private)

void UQuestPhase_AssaultBattle::OnFinishedPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_AssaultBattle", "OnFinishedPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl024SkillBarrierMineBarrier.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl024SkillBarrierMineBarrier::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl024SkillBarrierMineBarrier", "OnSpawnProjectile");

	Params::Projectile_Cpl024SkillBarrierMineBarrier_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.GetSequenceAnimationNum
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PatternNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTalkAnimInstance::GetSequenceAnimationNum(int32 PatternNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetSequenceAnimationNum");

	Params::TalkAnimInstance_GetSequenceAnimationNum Parms{};

	Parms.PatternNum = PatternNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableIdlingLoop
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableIdlingLoop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableIdlingLoop");

	Params::TalkAnimInstance_IsEnableIdlingLoop Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.OnIdlingLoopCountUp
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::OnIdlingLoopCountUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "OnIdlingLoopCountUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.OnLeftIdlingState
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::OnLeftIdlingState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "OnLeftIdlingState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.PlayBlinkAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BlendTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::PlayBlinkAnimation(class UAnimMontage* Montage, float BlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "PlayBlinkAnimation");

	Params::TalkAnimInstance_PlayBlinkAnimation Parms{};

	Parms.Montage = Montage;
	Parms.BlendTime = BlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.ResetIdlingLoopCount
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::ResetIdlingLoopCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "ResetIdlingLoopCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetDefaltProperty_Implementation
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::SetDefaltProperty_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetDefaltProperty_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetEnableBlink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetEnableBlink(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetEnableBlink");

	Params::TalkAnimInstance_SetEnableBlink Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetEnableIdlingSequence_Implementation
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetEnableIdlingSequence_Implementation(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetEnableIdlingSequence_Implementation");

	Params::TalkAnimInstance_SetEnableIdlingSequence_Implementation Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetEnableMove_Implementation
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetEnableMove_Implementation(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetEnableMove_Implementation");

	Params::TalkAnimInstance_SetEnableMove_Implementation Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetEnableUpperFaceAnimation_Implementation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetEnableUpperFaceAnimation_Implementation(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetEnableUpperFaceAnimation_Implementation");

	Params::TalkAnimInstance_SetEnableUpperFaceAnimation_Implementation Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetIdlingActionTimingCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TimingCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetIdlingActionTimingCount(int32 TimingCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetIdlingActionTimingCount");

	Params::TalkAnimInstance_SetIdlingActionTimingCount Parms{};

	Parms.TimingCount = TimingCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetIdlingSequencePattern_Implementation
// (Final, Native, Public)
// Parameters:
// int32                                   PatternNo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetIdlingSequencePattern_Implementation(int32 PatternNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetIdlingSequencePattern_Implementation");

	Params::TalkAnimInstance_SetIdlingSequencePattern_Implementation Parms{};

	Parms.PatternNo = PatternNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetMaxIdlingLoopCount
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LoopCount                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetMaxIdlingLoopCount(int32 LoopCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetMaxIdlingLoopCount");

	Params::TalkAnimInstance_SetMaxIdlingLoopCount Parms{};

	Parms.LoopCount = LoopCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetNearPlayer_Implementation
// (Final, Native, Public)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetNearPlayer_Implementation(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetNearPlayer_Implementation");

	Params::TalkAnimInstance_SetNearPlayer_Implementation Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.SetTriggerThreasholdLookAt_Implementation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::SetTriggerThreasholdLookAt_Implementation(float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "SetTriggerThreasholdLookAt_Implementation");

	Params::TalkAnimInstance_SetTriggerThreasholdLookAt_Implementation Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.ToDefaultProperty_Implementation
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::ToDefaultProperty_Implementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "ToDefaultProperty_Implementation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.UpdateBlinkEye
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDeltaTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTalkAnimInstance::UpdateBlinkEye(float InDeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "UpdateBlinkEye");

	Params::TalkAnimInstance_UpdateBlinkEye Parms{};

	Parms.InDeltaTime = InDeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.UpdateEyePupilScale
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::UpdateEyePupilScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "UpdateEyePupilScale");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.UpdateGazeOffset
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::UpdateGazeOffset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "UpdateGazeOffset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.UpdateLookAtLocation
// (Final, Native, Public, BlueprintCallable)

void UTalkAnimInstance::UpdateLookAtLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "UpdateLookAtLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TalkAnimInstance.GetBlendSpaceTypeForLipSync
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTalkAnimInstance::GetBlendSpaceTypeForLipSync() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetBlendSpaceTypeForLipSync");

	Params::TalkAnimInstance_GetBlendSpaceTypeForLipSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetBlendTimeLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetBlendTimeLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetBlendTimeLookAt");

	Params::TalkAnimInstance_GetBlendTimeLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetBlendTimeLookAtCancel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetBlendTimeLookAtCancel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetBlendTimeLookAtCancel");

	Params::TalkAnimInstance_GetBlendTimeLookAtCancel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetCharacterActionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EQuestCharacterState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EQuestCharacterState UTalkAnimInstance::GetCharacterActionType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetCharacterActionType");

	Params::TalkAnimInstance_GetCharacterActionType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetClampAngleHeadBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetClampAngleHeadBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetClampAngleHeadBone");

	Params::TalkAnimInstance_GetClampAngleHeadBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetClampAngleHeadBoneUpDown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetClampAngleHeadBoneUpDown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetClampAngleHeadBoneUpDown");

	Params::TalkAnimInstance_GetClampAngleHeadBoneUpDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetClampAnglePelvisBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetClampAnglePelvisBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetClampAnglePelvisBone");

	Params::TalkAnimInstance_GetClampAnglePelvisBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetClampAngleSpineBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetClampAngleSpineBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetClampAngleSpineBone");

	Params::TalkAnimInstance_GetClampAngleSpineBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetEnableGazing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::GetEnableGazing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetEnableGazing");

	Params::TalkAnimInstance_GetEnableGazing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetEnableLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::GetEnableLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetEnableLookAt");

	Params::TalkAnimInstance_GetEnableLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetEyePupilScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTalkAnimInstance::GetEyePupilScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetEyePupilScale");

	Params::TalkAnimInstance_GetEyePupilScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetGazeOffsetLH
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetGazeOffsetLH() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetGazeOffsetLH");

	Params::TalkAnimInstance_GetGazeOffsetLH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetGazeOffsetLV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetGazeOffsetLV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetGazeOffsetLV");

	Params::TalkAnimInstance_GetGazeOffsetLV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetGazeOffsetRH
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetGazeOffsetRH() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetGazeOffsetRH");

	Params::TalkAnimInstance_GetGazeOffsetRH Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetGazeOffsetRV
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetGazeOffsetRV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetGazeOffsetRV");

	Params::TalkAnimInstance_GetGazeOffsetRV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetHeadTranslationClampRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetHeadTranslationClampRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetHeadTranslationClampRate");

	Params::TalkAnimInstance_GetHeadTranslationClampRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetIdlingActionTimingCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTalkAnimInstance::GetIdlingActionTimingCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetIdlingActionTimingCount");

	Params::TalkAnimInstance_GetIdlingActionTimingCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetIdlingLoopCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTalkAnimInstance::GetIdlingLoopCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetIdlingLoopCount");

	Params::TalkAnimInstance_GetIdlingLoopCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetIdlingSequencePattern_Implementation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UTalkAnimInstance::GetIdlingSequencePattern_Implementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetIdlingSequencePattern_Implementation");

	Params::TalkAnimInstance_GetIdlingSequencePattern_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetInterpolationBlendTypeForLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInterpolationBlend                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EInterpolationBlend UTalkAnimInstance::GetInterpolationBlendTypeForLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetInterpolationBlendTypeForLookAt");

	Params::TalkAnimInstance_GetInterpolationBlendTypeForLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetLipSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UTalkAnimInstance::GetLipSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetLipSize");

	Params::TalkAnimInstance_GetLipSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetLipWeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetLipWeight() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetLipWeight");

	Params::TalkAnimInstance_GetLipWeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetLookAtCalculator
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULookAtCalculator*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULookAtCalculator* UTalkAnimInstance::GetLookAtCalculator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetLookAtCalculator");

	Params::TalkAnimInstance_GetLookAtCalculator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetLookAtLocationForward
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTalkAnimInstance::GetLookAtLocationForward(float Length) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetLookAtLocationForward");

	Params::TalkAnimInstance_GetLookAtLocationForward Parms{};

	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetLookAtTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UTalkAnimInstance::GetLookAtTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetLookAtTarget");

	Params::TalkAnimInstance_GetLookAtTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetLookAtTargetLocation
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UTalkAnimInstance::GetLookAtTargetLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetLookAtTargetLocation");

	Params::TalkAnimInstance_GetLookAtTargetLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetTriggerThreasholdLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetTriggerThreasholdLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetTriggerThreasholdLookAt");

	Params::TalkAnimInstance_GetTriggerThreasholdLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.GetTriggerThreasholdLookAt_Implementation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UTalkAnimInstance::GetTriggerThreasholdLookAt_Implementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "GetTriggerThreasholdLookAt_Implementation");

	Params::TalkAnimInstance_GetTriggerThreasholdLookAt_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsChangeLookAtRootNo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsChangeLookAtRootNo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsChangeLookAtRootNo");

	Params::TalkAnimInstance_IsChangeLookAtRootNo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableBlink
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableBlink() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableBlink");

	Params::TalkAnimInstance_IsEnableBlink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableBoostAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableBoostAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableBoostAnimation");

	Params::TalkAnimInstance_IsEnableBoostAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableGazing
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableGazing() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableGazing");

	Params::TalkAnimInstance_IsEnableGazing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableIdlingAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   IdlingPatternNum                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableIdlingAction(int32 IdlingPatternNum) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableIdlingAction");

	Params::TalkAnimInstance_IsEnableIdlingAction Parms{};

	Parms.IdlingPatternNum = IdlingPatternNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableIdlingSequence_Implementation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableIdlingSequence_Implementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableIdlingSequence_Implementation");

	Params::TalkAnimInstance_IsEnableIdlingSequence_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableLipSync
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableLipSync() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableLipSync");

	Params::TalkAnimInstance_IsEnableLipSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableLookAt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableLookAt");

	Params::TalkAnimInstance_IsEnableLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableMove_Implementation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableMove_Implementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableMove_Implementation");

	Params::TalkAnimInstance_IsEnableMove_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableRotateHeadBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableRotateHeadBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableRotateHeadBone");

	Params::TalkAnimInstance_IsEnableRotateHeadBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableRotatePelvisBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableRotatePelvisBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableRotatePelvisBone");

	Params::TalkAnimInstance_IsEnableRotatePelvisBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableRotateSpineBone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableRotateSpineBone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableRotateSpineBone");

	Params::TalkAnimInstance_IsEnableRotateSpineBone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableTalkingAnimation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableTalkingAnimation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableTalkingAnimation");

	Params::TalkAnimInstance_IsEnableTalkingAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsEnableUpperFaceAnimation_Implementation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsEnableUpperFaceAnimation_Implementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsEnableUpperFaceAnimation_Implementation");

	Params::TalkAnimInstance_IsEnableUpperFaceAnimation_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsLookAtBlendMethod
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsLookAtBlendMethod() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsLookAtBlendMethod");

	Params::TalkAnimInstance_IsLookAtBlendMethod Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TalkAnimInstance.IsNearPlayer_Implementation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTalkAnimInstance::IsNearPlayer_Implementation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TalkAnimInstance", "IsNearPlayer_Implementation");

	Params::TalkAnimInstance_IsNearPlayer_Implementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.OptionMenu.GetUIWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIStartOption*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIStartOption* UOptionMenu::GetUIWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "GetUIWidget");

	Params::OptionMenu_GetUIWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.OptionMenu.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "MouseClickDecide");

	Params::OptionMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenu.MouseClickDownArrow
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionMenu::MouseClickDownArrow(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "MouseClickDownArrow");

	Params::OptionMenu_MouseClickDownArrow Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenu.MouseClickTabLeft
// (Final, Native, Private)

void UOptionMenu::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenu.MouseClickTabRight
// (Final, Native, Private)

void UOptionMenu::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenu.MouseClickUpArrow
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOptionMenu::MouseClickUpArrow(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "MouseClickUpArrow");

	Params::OptionMenu_MouseClickUpArrow Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenu.SetUIInput
// (Final, Native, Public)

void UOptionMenu::SetUIInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "SetUIInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.OptionMenu.UnsetUIInput
// (Final, Native, Public)

void UOptionMenu::UnsetUIInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OptionMenu", "UnsetUIInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFeverManager.OnQuestChangeTiming
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             Quest_id                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestTimingType                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFeverManager::OnQuestChangeTiming(const class FName& Quest_id, EQuestTimingType Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFeverManager", "OnQuestChangeTiming");

	Params::ATFeverManager_OnQuestChangeTiming Parms{};

	Parms.Quest_id = Quest_id;
	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFieldManager.OnAreaMapClose
// (Final, Native, Public)

void UATFieldManager::OnAreaMapClose()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFieldManager", "OnAreaMapClose");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFieldManager.OnInnerAreaMove
// (Final, Native, Public)

void UATFieldManager::OnInnerAreaMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFieldManager", "OnInnerAreaMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFieldManager.OnMapControl
// (Final, Native, Public)

void UATFieldManager::OnMapControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFieldManager", "OnMapControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFlyingNimbus.OnDestroyedOwnerActor
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFlyingNimbus::OnDestroyedOwnerActor(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFlyingNimbus", "OnDestroyedOwnerActor");

	Params::ATFlyingNimbus_OnDestroyedOwnerActor Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFlyingNimbus.PlayIdleSE
// (Final, Native, Public, BlueprintCallable)

void UATFlyingNimbus::PlayIdleSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFlyingNimbus", "PlayIdleSE");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFlyingNimbus.SetActiveNimbusParticle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbActive                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATFlyingNimbus::SetActiveNimbusParticle(bool InbActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFlyingNimbus", "SetActiveNimbusParticle");

	Params::ATFlyingNimbus_SetActiveNimbusParticle Parms{};

	Parms.InbActive = InbActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFutureVisionActionCommand.EndOmen
// (Final, Native, Public)

void AATFutureVisionActionCommand::EndOmen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFutureVisionActionCommand", "EndOmen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATFutureVisionTrack.EndOmen
// (Final, Native, Public)

void AATFutureVisionTrack::EndOmen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATFutureVisionTrack", "EndOmen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGameMode.CreateTerrainDecorateManager
// (Final, Native, Protected)

void AATGameMode::CreateTerrainDecorateManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGameMode", "CreateTerrainDecorateManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGameMode.GetLevelManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AATLevelManager*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AATLevelManager* AATGameMode::GetLevelManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGameMode", "GetLevelManager");

	Params::ATGameMode_GetLevelManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATGameMode.OnBattleBegin
// (Final, Native, Protected)

void AATGameMode::OnBattleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGameMode", "OnBattleBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGameMode.OnBattleEnd
// (Final, Native, Protected)

void AATGameMode::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGameMode", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGameMode.OnPlayerInitialized
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATGameMode::OnPlayerInitialized(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGameMode", "OnPlayerInitialized");

	Params::ATGameMode_OnPlayerInitialized Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CompanionAI.StopEvent
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    Chara                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCompanionAI::StopEvent(class AAT_Character* Chara)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CompanionAI", "StopEvent");

	Params::CompanionAI_StopEvent Parms{};

	Parms.Chara = Chara;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGeneralDemoAnimInstance.InitializeLipSync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InMessageId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpace*                      InBlendSpace                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATGeneralDemoAnimInstance::InitializeLipSync(const class FString& InMessageId, class UBlendSpace* InBlendSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoAnimInstance", "InitializeLipSync");

	Params::ATGeneralDemoAnimInstance_InitializeLipSync Parms{};

	Parms.InMessageId = std::move(InMessageId);
	Parms.InBlendSpace = InBlendSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGeneralDemoAnimInstance.SetEnableLipSync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATGeneralDemoAnimInstance::SetEnableLipSync(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoAnimInstance", "SetEnableLipSync");

	Params::ATGeneralDemoAnimInstance_SetEnableLipSync Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGeneralDemoAnimInstance.GetLipSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UATGeneralDemoAnimInstance::GetLipSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoAnimInstance", "GetLipSize");

	Params::ATGeneralDemoAnimInstance_GetLipSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATGeneralDemoAnimInstance.IsEnableLipSync
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATGeneralDemoAnimInstance::IsEnableLipSync() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoAnimInstance", "IsEnableLipSync");

	Params::ATGeneralDemoAnimInstance_IsEnableLipSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATGeneralDemoCharacter.InitializeLipSync
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InMessageId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlendSpace*                      BlendSpaceAsset                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATGeneralDemoCharacter::InitializeLipSync(const class FString& InMessageId, class UBlendSpace* BlendSpaceAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoCharacter", "InitializeLipSync");

	Params::ATGeneralDemoCharacter_InitializeLipSync Parms{};

	Parms.InMessageId = std::move(InMessageId);
	Parms.BlendSpaceAsset = BlendSpaceAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGeneralDemoCharacter.PlayLipAnimation
// (Native, Public, BlueprintCallable)

void AATGeneralDemoCharacter::PlayLipAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoCharacter", "PlayLipAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGeneralDemoCharacter.SetEnableLipSync
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATGeneralDemoCharacter::SetEnableLipSync(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoCharacter", "SetEnableLipSync");

	Params::ATGeneralDemoCharacter_SetEnableLipSync Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATGeneralDemoCharacter.StopLipAnimation
// (Native, Public, BlueprintCallable)

void AATGeneralDemoCharacter::StopLipAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATGeneralDemoCharacter", "StopLipAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.GeneralTalkAnimationProperty.SetDefaltProperty
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IGeneralTalkAnimationProperty::SetDefaltProperty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneralTalkAnimationProperty", "SetDefaltProperty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.GeneralTalkAnimationProperty.ToDefaultProperty
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IGeneralTalkAnimationProperty::ToDefaultProperty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneralTalkAnimationProperty", "ToDefaultProperty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.IdlingSequentialAnimation.SetEnableIdlingSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIdlingSequentialAnimation::SetEnableIdlingSequence(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdlingSequentialAnimation", "SetEnableIdlingSequence");

	Params::IdlingSequentialAnimation_SetEnableIdlingSequence Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.IdlingSequentialAnimation.SetIdlingSequencePattern
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   PatternNo                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIdlingSequentialAnimation::SetIdlingSequencePattern(int32 PatternNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdlingSequentialAnimation", "SetIdlingSequencePattern");

	Params::IdlingSequentialAnimation_SetIdlingSequencePattern Parms{};

	Parms.PatternNo = PatternNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.IdlingSequentialAnimation.SetNearPlayer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIdlingSequentialAnimation::SetNearPlayer(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdlingSequentialAnimation", "SetNearPlayer");

	Params::IdlingSequentialAnimation_SetNearPlayer Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.IdlingSequentialAnimation.GetIdlingSequencePattern
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IIdlingSequentialAnimation::GetIdlingSequencePattern() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdlingSequentialAnimation", "GetIdlingSequencePattern");

	Params::IdlingSequentialAnimation_GetIdlingSequencePattern Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.IdlingSequentialAnimation.IsEnableIdlingSequence
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IIdlingSequentialAnimation::IsEnableIdlingSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdlingSequentialAnimation", "IsEnableIdlingSequence");

	Params::IdlingSequentialAnimation_IsEnableIdlingSequence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.IdlingSequentialAnimation.IsNearPlayer
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IIdlingSequentialAnimation::IsNearPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdlingSequentialAnimation", "IsNearPlayer");

	Params::IdlingSequentialAnimation_IsNearPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATInteractComponent.BeginOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UATInteractComponent::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATInteractComponent", "BeginOverlap");

	Params::ATInteractComponent_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATInteractComponent.EndOverlap
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATInteractComponent::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATInteractComponent", "EndOverlap");

	Params::ATInteractComponent_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATInteractComponent.OnPressedFieldAction
// (Final, Native, Private)

void UATInteractComponent::OnPressedFieldAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATInteractComponent", "OnPressedFieldAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATInteractComponent.OnPressedFieldSubAction
// (Final, Native, Private)

void UATInteractComponent::OnPressedFieldSubAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATInteractComponent", "OnPressedFieldSubAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_QuestClear.OnQuestClearTiming
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestTimingType                        TimingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestPhase_QuestClear::OnQuestClearTiming(const class FName& QuestId, EQuestTimingType TimingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_QuestClear", "OnQuestClearTiming");

	Params::QuestPhase_QuestClear_OnQuestClearTiming Parms{};

	Parms.QuestId = QuestId;
	Parms.TimingType = TimingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATJostleBeam.OnPressedButton_RL
// (Final, Native, Public)

void UATJostleBeam::OnPressedButton_RL()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATJostleBeam", "OnPressedButton_RL");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl102SkillCurveShot.HitRootSphere
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile_Cpl102SkillCurveShot::HitRootSphere(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl102SkillCurveShot", "HitRootSphere");

	Params::Projectile_Cpl102SkillCurveShot_HitRootSphere Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.KPIRequester.ResAPI
// (Final, Native, Private)
// Parameters:
// class FString                           Data                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKPIRequester::ResAPI(const class FString& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KPIRequester", "ResAPI");

	Params::KPIRequester_ResAPI Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelManager.OnLevelLoaded
// (Final, Native, Private)
// Parameters:
// class ULevelStreaming*                  StreamingLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATLevelManager::OnLevelLoaded(class ULevelStreaming* StreamingLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelManager", "OnLevelLoaded");

	Params::ATLevelManager_OnLevelLoaded Parms{};

	Parms.StreamingLevel = StreamingLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelManager.OnLoadedStreaming
// (Final, Native, Private)

void AATLevelManager::OnLoadedStreaming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelManager", "OnLoadedStreaming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelManager.OnPlayerChanged
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATLevelManager::OnPlayerChanged(class AAT_Character* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelManager", "OnPlayerChanged");

	Params::ATLevelManager_OnPlayerChanged Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelManager.OnProgressChangeTiming
// (Final, Native, Private)

void AATLevelManager::OnProgressChangeTiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelManager", "OnProgressChangeTiming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATLevelManager.OnVisibilityChanged
// (Final, Native, Private)
// Parameters:
// class ULevelStreaming*                  StreamingLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATLevelManager::OnVisibilityChanged(class ULevelStreaming* StreamingLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATLevelManager", "OnVisibilityChanged");

	Params::ATLevelManager_OnVisibilityChanged Parms{};

	Parms.StreamingLevel = StreamingLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.EventCalledAfterFade
// (Event, Protected, BlueprintEvent)

void ALevelNavigator::EventCalledAfterFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "EventCalledAfterFade");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.LevelNavigator.OnCallEventAfterFade
// (Final, Native, Private, BlueprintCallable)

void ALevelNavigator::OnCallEventAfterFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnCallEventAfterFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.OnCanceled
// (Final, Native, Private, BlueprintCallable)

void ALevelNavigator::OnCanceled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnCanceled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.OnCloseWindowProcForce
// (Final, Native, Private, BlueprintCallable)

void ALevelNavigator::OnCloseWindowProcForce()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnCloseWindowProcForce");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.OnNavigate
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InNavigateLevelName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelNavigator::OnNavigate(const class FName& InNavigateLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnNavigate");

	Params::LevelNavigator_OnNavigate Parms{};

	Parms.InNavigateLevelName = InNavigateLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.OnNavigateMainStory
// (Final, Native, Public, BlueprintCallable)

void ALevelNavigator::OnNavigateMainStory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnNavigateMainStory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.OnSelected
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   SelectedNo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelNavigator::OnSelected(int32 SelectedNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnSelected");

	Params::LevelNavigator_OnSelected Parms{};

	Parms.SelectedNo = SelectedNo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.LevelNavigator.OnUsed
// (Event, Public, BlueprintEvent)

void ALevelNavigator::OnUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OnUsed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.LevelNavigator.OpenMultiSelectableWindow
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InSelectableWindowTitleId                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSelectableWindowBodyId                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     InSelectableItemMessageIds                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bCancelable                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelNavigator::OpenMultiSelectableWindow(const class FName InSelectableWindowTitleId, const class FName InSelectableWindowBodyId, const TArray<class FName>& InSelectableItemMessageIds, bool bCancelable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OpenMultiSelectableWindow");

	Params::LevelNavigator_OpenMultiSelectableWindow Parms{};

	Parms.InSelectableWindowTitleId = InSelectableWindowTitleId;
	Parms.InSelectableWindowBodyId = InSelectableWindowBodyId;
	Parms.InSelectableItemMessageIds = std::move(InSelectableItemMessageIds);
	Parms.bCancelable = bCancelable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.OpenYesNoWindow
// (Final, Native, Private, BlueprintCallable)

void ALevelNavigator::OpenYesNoWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "OpenYesNoWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelNavigator.GetNavigateLevelName
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName ALevelNavigator::GetNavigateLevelName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelNavigator", "GetNavigateLevelName");

	Params::LevelNavigator_GetNavigateLevelName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.PreRenderDemoActor.OnSubtitleChanged
// (Final, Native, Public)
// Parameters:
// class FText                             NewSubtitle                                            (Parm, NativeAccessSpecifierPublic)

void APreRenderDemoActor::OnSubtitleChanged(const class FText& NewSubtitle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreRenderDemoActor", "OnSubtitleChanged");

	Params::PreRenderDemoActor_OnSubtitleChanged Parms{};

	Parms.NewSubtitle = std::move(NewSubtitle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMechaDevManager.BeginMechaDev
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwnerCharacter_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATMechaDevManager::BeginMechaDev(class AActor* OwnerCharacter_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMechaDevManager", "BeginMechaDev");

	Params::ATMechaDevManager_BeginMechaDev Parms{};

	Parms.OwnerCharacter_0 = OwnerCharacter_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATMechaDevManager.IsMechaDevActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATMechaDevManager::IsMechaDevActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATMechaDevManager", "IsMechaDevActive");

	Params::ATMechaDevManager_IsMechaDevActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.MiniQuest.OnAddedItem
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMiniQuest::OnAddedItem(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniQuest", "OnAddedItem");

	Params::MiniQuest_OnAddedItem Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.MiniQuest.OnBrokeObject
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             TriggerId                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMiniQuest::OnBrokeObject(const class FName& TriggerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniQuest", "OnBrokeObject");

	Params::MiniQuest_OnBrokeObject Parms{};

	Parms.TriggerId = TriggerId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.MiniQuest.OnIngameBegan
// (Event, Public, BlueprintEvent)

void AMiniQuest::OnIngameBegan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniQuest", "OnIngameBegan");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.MissionStore.OnFinishedBattle
// (Final, Native, Private)

void UMissionStore::OnFinishedBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionStore", "OnFinishedBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.MissionStore.OnFinishedEventBattle
// (Final, Native, Private)

void UMissionStore::OnFinishedEventBattle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MissionStore", "OnFinishedEventBattle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.MoveAnimation.SetEnableMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMoveAnimation::SetEnableMove(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAnimation", "SetEnableMove");

	Params::MoveAnimation_SetEnableMove Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.MoveAnimation.IsEnableMove
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMoveAnimation::IsEnableMove() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAnimation", "IsEnableMove");

	Params::MoveAnimation_IsEnableMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATParticleManager.DeactiveParticleComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InUID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATParticleManager::DeactiveParticleComponent(int32 InUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATParticleManager", "DeactiveParticleComponent");

	Params::ATParticleManager_DeactiveParticleComponent Parms{};

	Parms.InUID = InUID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATParticleManager.GetParticleComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InUID                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UParticleSystemComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UParticleSystemComponent* UATParticleManager::GetParticleComponent(int32 InUID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATParticleManager", "GetParticleComponent");

	Params::ATParticleManager_GetParticleComponent Parms{};

	Parms.InUID = InUID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATParticleManager.OnSystemFinished
// (Final, Native, Public)
// Parameters:
// class UParticleSystemComponent*         InFinishedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATParticleManager::OnSystemFinished(class UParticleSystemComponent* InFinishedComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATParticleManager", "OnSystemFinished");

	Params::ATParticleManager_OnSystemFinished Parms{};

	Parms.InFinishedComponent = InFinishedComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPillarThrowManager.EndWindRoadBlur
// (Final, Native, Public)

void UATPillarThrowManager::EndWindRoadBlur()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarThrowManager", "EndWindRoadBlur");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPillarThrowManager.OnBeginReadyCameraInterp
// (Final, Native, Public)

void UATPillarThrowManager::OnBeginReadyCameraInterp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarThrowManager", "OnBeginReadyCameraInterp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPillarThrowManager.OnChangeAction
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActionIdPrev                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ActionIdNext                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPillarThrowManager::OnChangeAction(class AAT_Character* Character, int32 ActionIdPrev, int32 ActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarThrowManager", "OnChangeAction");

	Params::ATPillarThrowManager_OnChangeAction Parms{};

	Parms.Character = Character;
	Parms.ActionIdPrev = ActionIdPrev;
	Parms.ActionIdNext = ActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPillarThrowManager.OnChangePlayer
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    NextCharacter                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATPillarThrowManager::OnChangePlayer(class AAT_Character* NextCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarThrowManager", "OnChangePlayer");

	Params::ATPillarThrowManager_OnChangePlayer Parms{};

	Parms.NextCharacter = NextCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPillarThrowManager.OnEndReadyCameraInterp
// (Final, Native, Public)

void UATPillarThrowManager::OnEndReadyCameraInterp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPillarThrowManager", "OnEndReadyCameraInterp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerCameraManager.ChangeView
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECameraMode                             EMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           POwner                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PSubActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForcedChange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReserveChange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerCameraManager::ChangeView(ECameraMode EMode, class AActor* POwner, class AActor* PSubActor, bool ForcedChange, bool bReset, bool ReserveChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerCameraManager", "ChangeView");

	Params::ATPlayerCameraManager_ChangeView Parms{};

	Parms.EMode = EMode;
	Parms.POwner = POwner;
	Parms.PSubActor = PSubActor;
	Parms.ForcedChange = ForcedChange;
	Parms.bReset = bReset;
	Parms.ReserveChange = ReserveChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerCameraManager.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueFlag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCallSelf                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerCameraManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool bContinueFlag, bool bCallSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerCameraManager", "OnDemoTiming");

	Params::ATPlayerCameraManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.bContinueFlag = bContinueFlag;
	Parms.bCallSelf = bCallSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerCameraManager.OnInGameBeginPlay
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AATPlayerCameraManager::OnInGameBeginPlay(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerCameraManager", "OnInGameBeginPlay");

	Params::ATPlayerCameraManager_OnInGameBeginPlay Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerCameraManager.SetViewByControlCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InbImmediate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerCameraManager::SetViewByControlCharacter(bool InbImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerCameraManager", "SetViewByControlCharacter");

	Params::ATPlayerCameraManager_SetViewByControlCharacter Parms{};

	Parms.InbImmediate = InbImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerCameraManager.SetViewByControlCharacterWithBlemdTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   FBlendTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerCameraManager::SetViewByControlCharacterWithBlemdTime(float FBlendTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerCameraManager", "SetViewByControlCharacterWithBlemdTime");

	Params::ATPlayerCameraManager_SetViewByControlCharacterWithBlemdTime Parms{};

	Parms.FBlendTime = FBlendTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerCameraManager.GetViewActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECameraMode                             EMode                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AATPlayerCameraManager::GetViewActor(ECameraMode EMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerCameraManager", "GetViewActor");

	Params::ATPlayerCameraManager_GetViewActor Parms{};

	Parms.EMode = EMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.BindActionDefault
// (Final, Native, Public, BlueprintCallable)

void AATPlayerController::BindActionDefault()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "BindActionDefault");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.GetAxisValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_AXIS                  AxisType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PastTickNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AATPlayerController::GetAxisValue(EAT_CONTROL_INPUT_AXIS AxisType, uint8 PastTickNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "GetAxisValue");

	Params::ATPlayerController_GetAxisValue Parms{};

	Parms.AxisType = AxisType;
	Parms.PastTickNum = PastTickNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.getViewRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AATPlayerController::GetViewRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "getViewRotation");

	Params::ATPlayerController_GetViewRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.IsPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATPlayerController::IsPressed(EAT_CONTROL_INPUT_ACTION ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "IsPressed");

	Params::ATPlayerController_IsPressed Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.OnEndNimbusRoll
// (Final, Native, Protected)

void AATPlayerController::OnEndNimbusRoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnEndNimbusRoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.OnEndStandDash
// (Final, Native, Protected)

void AATPlayerController::OnEndStandDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnEndStandDash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.OnStartNimbusRoll
// (Final, Native, Protected)

void AATPlayerController::OnStartNimbusRoll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnStartNimbusRoll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.OnStartStandDash
// (Final, Native, Protected)

void AATPlayerController::OnStartStandDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnStartStandDash");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.OnWindRoadChangeCamera
// (Final, Native, Protected)
// Parameters:
// struct FATWindRoadCameraParam           InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AATPlayerController::OnWindRoadChangeCamera(const struct FATWindRoadCameraParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnWindRoadChangeCamera");

	Params::ATPlayerController_OnWindRoadChangeCamera Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.OnWindRoadEnter
// (Final, Native, Protected)
// Parameters:
// struct FATWindRoadEnterParam            InParam                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AATPlayerController::OnWindRoadEnter(const struct FATWindRoadEnterParam& InParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnWindRoadEnter");

	Params::ATPlayerController_OnWindRoadEnter Parms{};

	Parms.InParam = std::move(InParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.OnWindRoadExit
// (Final, Native, Protected)

void AATPlayerController::OnWindRoadExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "OnWindRoadExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.PressedSimultaneous
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType1                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAT_CONTROL_INPUT_ACTION                ActionType2                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PastTickNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPermitHoldDown                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATPlayerController::PressedSimultaneous(EAT_CONTROL_INPUT_ACTION ActionType1, EAT_CONTROL_INPUT_ACTION ActionType2, uint8 PastTickNum, bool bPermitHoldDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "PressedSimultaneous");

	Params::ATPlayerController_PressedSimultaneous Parms{};

	Parms.ActionType1 = ActionType1;
	Parms.ActionType2 = ActionType2;
	Parms.PastTickNum = PastTickNum;
	Parms.bPermitHoldDown = bPermitHoldDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.SetBattlePauseMenu
// (Final, Native, Private)
// Parameters:
// bool                                    bMenuPauseOff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerController::SetBattlePauseMenu(bool bMenuPauseOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "SetBattlePauseMenu");

	Params::ATPlayerController_SetBattlePauseMenu Parms{};

	Parms.bMenuPauseOff = bMenuPauseOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.SetKeepViewTargetChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerController::SetKeepViewTargetChange(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "SetKeepViewTargetChange");

	Params::ATPlayerController_SetKeepViewTargetChange Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.SetPauseMenu
// (Final, Native, Private)
// Parameters:
// bool                                    bMenuPauseOff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerController::SetPauseMenu(bool bMenuPauseOff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "SetPauseMenu");

	Params::ATPlayerController_SetPauseMenu Parms{};

	Parms.bMenuPauseOff = bMenuPauseOff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.TargetChangedHandler
// (Final, Native, Private)
// Parameters:
// class AActor*                           InNewTargetCharacter                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerController::TargetChangedHandler(class AActor* InNewTargetCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "TargetChangedHandler");

	Params::ATPlayerController_TargetChangedHandler Parms{};

	Parms.InNewTargetCharacter = InNewTargetCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.UnbindActionDefault
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bLeaveBaseInput                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATPlayerController::UnbindActionDefault(bool bLeaveBaseInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "UnbindActionDefault");

	Params::ATPlayerController_UnbindActionDefault Parms{};

	Parms.bLeaveBaseInput = bLeaveBaseInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATPlayerController.WasJustPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATPlayerController::WasJustPressed(EAT_CONTROL_INPUT_ACTION ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "WasJustPressed");

	Params::ATPlayerController_WasJustPressed Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.WasJustReleased
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATPlayerController::WasJustReleased(EAT_CONTROL_INPUT_ACTION ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "WasJustReleased");

	Params::ATPlayerController_WasJustReleased Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATPlayerController.WasPressed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAT_CONTROL_INPUT_ACTION                ActionType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PastTickNum                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPermitHoldDown                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATPlayerController::WasPressed(EAT_CONTROL_INPUT_ACTION ActionType, uint8 PastTickNum, bool bPermitHoldDown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATPlayerController", "WasPressed");

	Params::ATPlayerController_WasPressed Parms{};

	Parms.ActionType = ActionType;
	Parms.PastTickNum = PastTickNum;
	Parms.bPermitHoldDown = bPermitHoldDown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATProjectileEnemyField.HitRootSphere
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATProjectileEnemyField::HitRootSphere(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATProjectileEnemyField", "HitRootSphere");

	Params::ATProjectileEnemyField_HitRootSphere Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacter.HiddenInEvents
// (Final, Native, Protected)
// Parameters:
// EQUEST_GENERAL_TALK_TIMING              Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuestCharacter::HiddenInEvents(EQUEST_GENERAL_TALK_TIMING Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacter", "HiddenInEvents");

	Params::QuestCharacter_HiddenInEvents Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacter.OnJoinedSupportCharacter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   MemberType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuestCharacter::OnJoinedSupportCharacter(const struct FPartyMember& InMember, uint8 MemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacter", "OnJoinedSupportCharacter");

	Params::QuestCharacter_OnJoinedSupportCharacter Parms{};

	Parms.InMember = std::move(InMember);
	Parms.MemberType = MemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacter.OnOutSupportCharacter
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FPartyMember                     InMember                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// uint8                                   MemberType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuestCharacter::OnOutSupportCharacter(const struct FPartyMember& InMember, uint8 MemberType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacter", "OnOutSupportCharacter");

	Params::QuestCharacter_OnOutSupportCharacter Parms{};

	Parms.InMember = std::move(InMember);
	Parms.MemberType = MemberType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacter.SetEnableAbsenceObserver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuestCharacter::SetEnableAbsenceObserver(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacter", "SetEnableAbsenceObserver");

	Params::QuestCharacter_SetEnableAbsenceObserver Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacter.IsBeginPlayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuestCharacter::IsBeginPlayed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacter", "IsBeginPlayed");

	Params::QuestCharacter_IsBeginPlayed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestCharacter.IsCostumeInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuestCharacter::IsCostumeInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacter", "IsCostumeInitialized");

	Params::QuestCharacter_IsCostumeInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.QuestCharacterAnimatorCpl002.OnUpdatedMovement
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          OldVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestCharacterAnimatorCpl002::OnUpdatedMovement(float DeltaSeconds, const struct FVector& OldLocation, const struct FVector& OldVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacterAnimatorCpl002", "OnUpdatedMovement");

	Params::QuestCharacterAnimatorCpl002_OnUpdatedMovement Parms{};

	Parms.DeltaSeconds = DeltaSeconds;
	Parms.OldLocation = std::move(OldLocation);
	Parms.OldVelocity = std::move(OldVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacterAura.Finalize
// (Final, Native, Public, BlueprintCallable)

void UQuestCharacterAura::Finalize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacterAura", "Finalize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacterAura.Initialize
// (Final, Native, Public, BlueprintCallable)

void UQuestCharacterAura::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacterAura", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacterAura.OnEventEnd
// (Final, Native, Private)

void UQuestCharacterAura::OnEventEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacterAura", "OnEventEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestCharacterAura.OnEventStart
// (Final, Native, Private)

void UQuestCharacterAura::OnEventStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestCharacterAura", "OnEventStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestDirector.Finish
// (Final, Native, Public, BlueprintCallable)

void AQuestDirector::Finish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestDirector", "Finish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestDirector.OnPlay
// (Event, Public, BlueprintEvent)

void AQuestDirector::OnPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestDirector", "OnPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.QuestEventObservable.OnQuestGeneralTalkEvent
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGeneralTalkEventArgment         Argment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IQuestEventObservable::OnQuestGeneralTalkEvent(const struct FGeneralTalkEventArgment& Argment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestEventObservable", "OnQuestGeneralTalkEvent");

	Params::QuestEventObservable_OnQuestGeneralTalkEvent Parms{};

	Parms.Argment = std::move(Argment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestHiddenSwitcher.OnQuestActivated
// (Final, Native, Private)
// Parameters:
// class FName                             QuestId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             PreQuestId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bBegin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestHiddenSwitcher::OnQuestActivated(class FName QuestId, class FName PreQuestId, bool bBegin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestHiddenSwitcher", "OnQuestActivated");

	Params::QuestHiddenSwitcher_OnQuestActivated Parms{};

	Parms.QuestId = QuestId;
	Parms.PreQuestId = PreQuestId;
	Parms.bBegin = bBegin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestHiddenSwitcher.OnQuestClear
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             QuestId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQuestTimingType                        TimingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestHiddenSwitcher::OnQuestClear(const class FName& QuestId, EQuestTimingType TimingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestHiddenSwitcher", "OnQuestClear");

	Params::QuestHiddenSwitcher_OnQuestClear Parms{};

	Parms.QuestId = QuestId;
	Parms.TimingType = TimingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_ChangeCharacter.OnChangedPlayer
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestPhase_ChangeCharacter::OnChangedPlayer(class AAT_Character* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_ChangeCharacter", "OnChangedPlayer");

	Params::QuestPhase_ChangeCharacter_OnChangedPlayer Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATQuestRetryActor.BeginQuestRetry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATQuestRetryActor::BeginQuestRetry(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATQuestRetryActor", "BeginQuestRetry");

	Params::ATQuestRetryActor_BeginQuestRetry Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATQuestRetryActor.IsQuestRetryActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AATQuestRetryActor::IsQuestRetryActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATQuestRetryActor", "IsQuestRetryActive");

	Params::ATQuestRetryActor_IsQuestRetryActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATQuestRetryManager.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UATQuestRetryManager::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATQuestRetryManager", "MouseClickDecide");

	Params::ATQuestRetryManager_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATQuestRetryMenuOpener.OpenQuestRetryMenu
// (Final, Native, Protected, BlueprintCallable)

void UATQuestRetryMenuOpener::OpenQuestRetryMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATQuestRetryMenuOpener", "OpenQuestRetryMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestSpawner.FetchDataTable
// (Final, Native, Private)

void UQuestSpawner::FetchDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestSpawner", "FetchDataTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestSpawner.OnChangedProgress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             Progress                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestSpawner::OnChangedProgress(const class FName& Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestSpawner", "OnChangedProgress");

	Params::QuestSpawner_OnChangedProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestTimingObserver.OnBattleEnd
// (Event, Public, BlueprintEvent)

void AQuestTimingObserver::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "OnBattleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.QuestTimingObserver.OnCompletedQuest
// (Event, Public, BlueprintEvent)

void AQuestTimingObserver::OnCompletedQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "OnCompletedQuest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.QuestTimingObserver.OnGotAway
// (Event, Public, BlueprintEvent)

void AQuestTimingObserver::OnGotAway()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "OnGotAway");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.QuestTimingObserver.OnIntervalHasPassed
// (Event, Public, BlueprintEvent)

void AQuestTimingObserver::OnIntervalHasPassed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "OnIntervalHasPassed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.QuestTimingObserver.ResetInterval
// (Final, Native, Public, BlueprintCallable)

void AQuestTimingObserver::ResetInterval()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "ResetInterval");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestTimingObserver.SetBattleEndDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuestTimingObserver::SetBattleEndDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "SetBattleEndDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestTimingObserver.GetCurrentDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AQuestTimingObserver::GetCurrentDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestTimingObserver", "GetCurrentDistance");

	Params::QuestTimingObserver_GetCurrentDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TriggerSphereFieldBase.OnPressedFieldAction
// (Native, Public)

void ATriggerSphereFieldBase::OnPressedFieldAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerSphereFieldBase", "OnPressedFieldAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerSphereFieldCooking.OnTouchSphereCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerSphereFieldCooking::OnTouchSphereCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerSphereFieldCooking", "OnTouchSphereCollision");

	Params::TriggerSphereFieldCooking_OnTouchSphereCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerSphereFieldCooking.OnUntouchSphereCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerSphereFieldCooking::OnUntouchSphereCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerSphereFieldCooking", "OnUntouchSphereCollision");

	Params::TriggerSphereFieldCooking_OnUntouchSphereCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.ResetAll
// (Final, Native, Public, BlueprintCallable)

void UATRestrictMoveControl::ResetAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "ResetAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InJump                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InStandFirst                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InStandSecond                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InStandBoost                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InFloatBoost                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InTargetLanding                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InRide                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlB                 InFloatMove                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlB                 InNimbusMove                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InFieldShot                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InSearch                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InMultiJump                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InHighJump                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InMiniMapOpen                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InWorldMapOpen                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InStandHighSpeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetAll(EATRestrictMoveControlA InJump, EATRestrictMoveControlA InStandFirst, EATRestrictMoveControlA InStandSecond, EATRestrictMoveControlA InStandBoost, EATRestrictMoveControlA InFloatBoost, EATRestrictMoveControlA InTargetLanding, EATRestrictMoveControlA InRide, EATRestrictMoveControlB InFloatMove, EATRestrictMoveControlB InNimbusMove, EATRestrictMoveControlA InFieldShot, EATRestrictMoveControlA InSearch, EATRestrictMoveControlA InMultiJump, EATRestrictMoveControlA InHighJump, EATRestrictMoveControlA InMiniMapOpen, EATRestrictMoveControlA InWorldMapOpen, EATRestrictMoveControlA InStandHighSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetAll");

	Params::ATRestrictMoveControl_SetAll Parms{};

	Parms.InJump = InJump;
	Parms.InStandFirst = InStandFirst;
	Parms.InStandSecond = InStandSecond;
	Parms.InStandBoost = InStandBoost;
	Parms.InFloatBoost = InFloatBoost;
	Parms.InTargetLanding = InTargetLanding;
	Parms.InRide = InRide;
	Parms.InFloatMove = InFloatMove;
	Parms.InNimbusMove = InNimbusMove;
	Parms.InFieldShot = InFieldShot;
	Parms.InSearch = InSearch;
	Parms.InMultiJump = InMultiJump;
	Parms.InHighJump = InHighJump;
	Parms.InMiniMapOpen = InMiniMapOpen;
	Parms.InWorldMapOpen = InWorldMapOpen;
	Parms.InStandHighSpeed = InStandHighSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetByPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlPreset            InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetByPreset(EATRestrictMoveControlPreset InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetByPreset");

	Params::ATRestrictMoveControl_SetByPreset Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetFieldShot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetFieldShot(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetFieldShot");

	Params::ATRestrictMoveControl_SetFieldShot Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetFloatBoost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetFloatBoost(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetFloatBoost");

	Params::ATRestrictMoveControl_SetFloatBoost Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetFloatMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlB                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetFloatMove(EATRestrictMoveControlB InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetFloatMove");

	Params::ATRestrictMoveControl_SetFloatMove Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetJump
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetJump(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetJump");

	Params::ATRestrictMoveControl_SetJump Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetNimbusBoost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetNimbusBoost(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetNimbusBoost");

	Params::ATRestrictMoveControl_SetNimbusBoost Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetNimbusMove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlB                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetNimbusMove(EATRestrictMoveControlB InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetNimbusMove");

	Params::ATRestrictMoveControl_SetNimbusMove Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetRideAll
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InNimbus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InAirCar                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 InTwinFoot                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATRestrictMoveControlA                 Pillar                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetRideAll(EATRestrictMoveControlA InNimbus, EATRestrictMoveControlA InAirCar, EATRestrictMoveControlA InTwinFoot, EATRestrictMoveControlA Pillar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetRideAll");

	Params::ATRestrictMoveControl_SetRideAll Parms{};

	Parms.InNimbus = InNimbus;
	Parms.InAirCar = InAirCar;
	Parms.InTwinFoot = InTwinFoot;
	Parms.Pillar = Pillar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetSearch
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetSearch(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetSearch");

	Params::ATRestrictMoveControl_SetSearch Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetStandBoost
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetStandBoost(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetStandBoost");

	Params::ATRestrictMoveControl_SetStandBoost Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetStandFirst
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetStandFirst(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetStandFirst");

	Params::ATRestrictMoveControl_SetStandFirst Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetStandSecond
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetStandSecond(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetStandSecond");

	Params::ATRestrictMoveControl_SetStandSecond Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATRestrictMoveControl.SetTargetLanding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EATRestrictMoveControlA                 InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATRestrictMoveControl::SetTargetLanding(EATRestrictMoveControlA InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATRestrictMoveControl", "SetTargetLanding");

	Params::ATRestrictMoveControl_SetTargetLanding Parms{};

	Parms.InType = InType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSceneCaptureComponent2D.SetCaptureEveryFrame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewCaptureEveryFrame                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSceneCaptureComponent2D::SetCaptureEveryFrame(bool bNewCaptureEveryFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSceneCaptureComponent2D", "SetCaptureEveryFrame");

	Params::ATSceneCaptureComponent2D_SetCaptureEveryFrame Parms{};

	Parms.bNewCaptureEveryFrame = bNewCaptureEveryFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSequencerPlayNotifyState.ForceStopSequence
// (Final, Native, Protected, Const)

void UATSequencerPlayNotifyState::ForceStopSequence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSequencerPlayNotifyState", "ForceStopSequence");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSoundBlueprintFunctionLibrary.SetAmbientSoundBlockFlag
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    NewFlag                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSoundBlueprintFunctionLibrary::SetAmbientSoundBlockFlag(bool NewFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ATSoundBlueprintFunctionLibrary", "SetAmbientSoundBlockFlag");

	Params::ATSoundBlueprintFunctionLibrary_SetAmbientSoundBlockFlag Parms{};

	Parms.NewFlag = NewFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodBehaviour.AddBeforeLaunchStopComponent
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class UActorComponent*                  StopComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USpacePodBehaviour::AddBeforeLaunchStopComponent(class UActorComponent* StopComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodBehaviour", "AddBeforeLaunchStopComponent");

	Params::SpacePodBehaviour_AddBeforeLaunchStopComponent Parms{};

	Parms.StopComponent = StopComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodBehaviour.AddBeforeLaunchStopComponentArray
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TArray<class UActorComponent*>          StopComponents                                         (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void USpacePodBehaviour::AddBeforeLaunchStopComponentArray(const TArray<class UActorComponent*>& StopComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodBehaviour", "AddBeforeLaunchStopComponentArray");

	Params::SpacePodBehaviour_AddBeforeLaunchStopComponentArray Parms{};

	Parms.StopComponents = std::move(StopComponents);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodBehaviour.OnLaunched
// (Final, Native, Private)

void USpacePodBehaviour::OnLaunched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodBehaviour", "OnLaunched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodSpawner.DestroyPods
// (Final, Native, Public, BlueprintCallable)

void ASpacePodSpawner::DestroyPods()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "DestroyPods");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodSpawner.OnFloated
// (Final, Native, Private)
// Parameters:
// EEventTimingType                        TimingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpacePodSpawner::OnFloated(EEventTimingType TimingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "OnFloated");

	Params::SpacePodSpawner_OnFloated Parms{};

	Parms.TimingType = TimingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodSpawner.OnInGameBeginPlay
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASpacePodSpawner::OnInGameBeginPlay(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "OnInGameBeginPlay");

	Params::SpacePodSpawner_OnInGameBeginPlay Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodSpawner.OnLaunched
// (Final, Native, Private)

void ASpacePodSpawner::OnLaunched()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "OnLaunched");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodSpawner.SetEnable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpacePodSpawner::SetEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "SetEnable");

	Params::SpacePodSpawner_SetEnable Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpacePodSpawner.SpawnPods
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpacePodSpawner::SpawnPods()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "SpawnPods");

	Params::SpacePodSpawner_SpawnPods Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.SpacePodSpawner.HasSpawnedPods
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpacePodSpawner::HasSpawnedPods() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "HasSpawnedPods");

	Params::SpacePodSpawner_HasSpawnedPods Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.SpacePodSpawner.isAllowLaunch
// (Final, Native, Private, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASpacePodSpawner::IsAllowLaunch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodSpawner", "isAllowLaunch");

	Params::SpacePodSpawner_IsAllowLaunch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.SpacePodTractor.OnHit
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASpacePodTractor::OnHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpacePodTractor", "OnHit");

	Params::SpacePodTractor_OnHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSpawnerFieldMemories.OnChangePhase
// (Final, Native, Public)
// Parameters:
// int32                                   ProgressID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATSpawnerFieldMemories::OnChangePhase(int32 ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSpawnerFieldMemories", "OnChangePhase");

	Params::ATSpawnerFieldMemories_OnChangePhase Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSpawnerFieldMemories.OnChangeProgress
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATSpawnerFieldMemories::OnChangeProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSpawnerFieldMemories", "OnChangeProgress");

	Params::ATSpawnerFieldMemories_OnChangeProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Speakable.SetEnableLipSync
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpeakable::SetEnableLipSync(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Speakable", "SetEnableLipSync");

	Params::Speakable_SetEnableLipSync Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Speakable.GetSpeakerId
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ISpeakable::GetSpeakerId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Speakable", "GetSpeakerId");

	Params::Speakable_GetSpeakerId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Speakable.IsEnableLipSync
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ISpeakable::IsEnableLipSync() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Speakable", "IsEnableLipSync");

	Params::Speakable_IsEnableLipSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATSplineMovement.SetTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTarget                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATSplineMovement::SetTargetActor(class AActor* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSplineMovement", "SetTargetActor");

	Params::ATSplineMovement_SetTargetActor Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATSplineMovement.Start
// (Final, Native, Public, BlueprintCallable)

void UATSplineMovement::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATSplineMovement", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AttackRangeEffectEntity.OnRent
// (Native, Event, Public, BlueprintEvent)

void UAttackRangeEffectEntity::OnRent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackRangeEffectEntity", "OnRent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AttackRangeEffectEntity.OnReturn
// (Native, Event, Public, BlueprintEvent)

void UAttackRangeEffectEntity::OnReturn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AttackRangeEffectEntity", "OnReturn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TrainingDataTableAccessor.IsLoaded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTrainingDataTableAccessor::IsLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TrainingDataTableAccessor", "IsLoaded");

	Params::TrainingDataTableAccessor_IsLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TreasureAccessPoint.OnActionChange
// (Final, Native, Protected)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureAccessPoint::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureAccessPoint", "OnActionChange");

	Params::TreasureAccessPoint_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TreasureAccessPoint.OnEnableItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATreasureAccessPoint::OnEnableItem(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureAccessPoint", "OnEnableItem");

	Params::TreasureAccessPoint_OnEnableItem Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TreasureAccessPoint.OnSearchEnd
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATreasureAccessPoint::OnSearchEnd(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureAccessPoint", "OnSearchEnd");

	Params::TreasureAccessPoint_OnSearchEnd Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TreasureAccessPoint.OnSearchStart
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATreasureAccessPoint::OnSearchStart(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureAccessPoint", "OnSearchStart");

	Params::TreasureAccessPoint_OnSearchStart Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATUiCaptureLoader.CompleteLoad
// (Final, Native, Public)
// Parameters:
// class UATDataAssetUiCaptureAsyncLoad*   Loader                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATUiCaptureLoader::CompleteLoad(class UATDataAssetUiCaptureAsyncLoad* Loader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATUiCaptureLoader", "CompleteLoad");

	Params::ATUiCaptureLoader_CompleteLoad Parms{};

	Parms.Loader = Loader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.StartActingBoost
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InTargetPos                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATCharacterActingBoostEndState         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAngle                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbTerrainDamage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbApplyBlur                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbApplyCameraShake                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATVirtualController::StartActingBoost(const struct FVector& InTargetPos, EATCharacterActingBoostEndState InState, float InAngle, float InRadius, bool InbTerrainDamage, bool InbApplyBlur, bool InbApplyCameraShake, float InSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "StartActingBoost");

	Params::ATVirtualController_StartActingBoost Parms{};

	Parms.InTargetPos = std::move(InTargetPos);
	Parms.InState = InState;
	Parms.InAngle = InAngle;
	Parms.InRadius = InRadius;
	Parms.InbTerrainDamage = InbTerrainDamage;
	Parms.InbApplyBlur = InbApplyBlur;
	Parms.InbApplyCameraShake = InbApplyCameraShake;
	Parms.InSpeed = InSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.StartAutoMoveToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EATCharacterAutoMove                    InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InTargetPos                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InGoalRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATVirtualController::StartAutoMoveToLocation(EATCharacterAutoMove InType, const struct FVector& InTargetPos, float InGoalRadius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "StartAutoMoveToLocation");

	Params::ATVirtualController_StartAutoMoveToLocation Parms{};

	Parms.InType = InType;
	Parms.InTargetPos = std::move(InTargetPos);
	Parms.InGoalRadius = InGoalRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.StartAutoTurn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTurnPointActor                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATVirtualController::StartAutoTurn(class AActor* InTurnPointActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "StartAutoTurn");

	Params::ATVirtualController_StartAutoTurn Parms{};

	Parms.InTurnPointActor = InTurnPointActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.StartAutoTurnToLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InTargetPos                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATVirtualController::StartAutoTurnToLocation(const struct FVector& InTargetPos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "StartAutoTurnToLocation");

	Params::ATVirtualController_StartAutoTurnToLocation Parms{};

	Parms.InTargetPos = std::move(InTargetPos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.StopActingBoost
// (Final, Native, Public, BlueprintCallable)

void UATVirtualController::StopActingBoost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "StopActingBoost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.StopAutoMove
// (Final, Native, Public, BlueprintCallable)

void UATVirtualController::StopAutoMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "StopAutoMove");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATVirtualController.IsAutoMoving
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATVirtualController::IsAutoMoving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "IsAutoMoving");

	Params::ATVirtualController_IsAutoMoving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ATVirtualController.IsAutoTurning
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UATVirtualController::IsAutoTurning() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATVirtualController", "IsAutoTurning");

	Params::ATVirtualController_IsAutoTurning Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Waitable.SetEnableWaiting
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IWaitable::SetEnableWaiting(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Waitable", "SetEnableWaiting");

	Params::Waitable_SetEnableWaiting Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWaterVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWaterVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWaterVolume", "OnOverlapBegin");

	Params::ATWaterVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWaterVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWaterVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWaterVolume", "OnOverlapEnd");

	Params::ATWaterVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.OnActorHitEvent
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATWorldBlockingVolume::OnActorHitEvent(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "OnActorHitEvent");

	Params::ATWorldBlockingVolume_OnActorHitEvent Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.OnActorHitEventWithPlayGoProgress
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATWorldBlockingVolume::OnActorHitEventWithPlayGoProgress(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "OnActorHitEventWithPlayGoProgress");

	Params::ATWorldBlockingVolume_OnActorHitEventWithPlayGoProgress Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.OnBattleEnd
// (Final, Native, Private)

void AATWorldBlockingVolume::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.OnBattleStart
// (Final, Native, Private)

void AATWorldBlockingVolume::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.OnBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWorldBlockingVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "OnBeginOverlap");

	Params::ATWorldBlockingVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.OnEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWorldBlockingVolume::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "OnEndOverlap");

	Params::ATWorldBlockingVolume_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBlockingVolume.RemoveAllOverllapedWarning
// (Final, Native, Private)
// Parameters:
// bool                                    bIsEndFadeIn                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWorldBlockingVolume::RemoveAllOverllapedWarning(bool bIsEndFadeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBlockingVolume", "RemoveAllOverllapedWarning");

	Params::ATWorldBlockingVolume_RemoveAllOverllapedWarning Parms{};

	Parms.bIsEndFadeIn = bIsEndFadeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBorder.OnBeginOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWorldBorder::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBorder", "OnBeginOverlap");

	Params::ATWorldBorder_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATWorldBorder.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AATWorldBorder::OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATWorldBorder", "OnEndOverlap");

	Params::ATWorldBorder_OnEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGameManager.CheckStrikeOut
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseballGameManager::CheckStrikeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGameManager", "CheckStrikeOut");

	Params::BaseballGameManager_CheckStrikeOut Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.BaseballGameManager.OnPressedButton
// (Final, Native, Public)

void UBaseballGameManager::OnPressedButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGameManager", "OnPressedButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGameManager.OnPressedPause
// (Final, Native, Public)

void UBaseballGameManager::OnPressedPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGameManager", "OnPressedPause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGameManager.ReceiveEvents
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBaseballGameManager::ReceiveEvents(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGameManager", "ReceiveEvents");

	Params::BaseballGameManager_ReceiveEvents Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BaseballGameManager.IsInterrupt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBaseballGameManager::IsInterrupt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseballGameManager", "IsInterrupt");

	Params::BaseballGameManager_IsInterrupt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.BattleAI_MoveManager.SetArmorInvisibleAfterSetAction
// (Final, Native, Private)

void UBattleAI_MoveManager::SetArmorInvisibleAfterSetAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattleAI_MoveManager", "SetArmorInvisibleAfterSetAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BonfireItem.CompleteLoad
// (Final, Native, Private)

void ABonfireItem::CompleteLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BonfireItem", "CompleteLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BookAnimInstance.ClearPhase
// (Final, Native, Public, BlueprintCallable)

void UBookAnimInstance::ClearPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BookAnimInstance", "ClearPhase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BookAnimInstance.EndNotify
// (Native, Public, BlueprintCallable)

void UBookAnimInstance::EndNotify()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BookAnimInstance", "EndNotify");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BookAnimInstance.GetPhase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EZCW_Phase                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EZCW_Phase UBookAnimInstance::GetPhase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BookAnimInstance", "GetPhase");

	Params::BookAnimInstance_GetPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.BreakableStaticMeshActor.Breaking
// (Event, Protected, BlueprintEvent)

void ABreakableStaticMeshActor::Breaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableStaticMeshActor", "Breaking");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.BreakableStaticMeshActor.Damage
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABreakableStaticMeshActor::Damage(class AActor* OtherActor, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableStaticMeshActor", "Damage");

	Params::BreakableStaticMeshActor_Damage Parms{};

	Parms.OtherActor = OtherActor;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BreakableStaticMeshActor.NextStep
// (Final, Native, Public, BlueprintCallable)

void ABreakableStaticMeshActor::NextStep()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableStaticMeshActor", "NextStep");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.BreakableStaticMeshActor.OnHit
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           SelfActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ABreakableStaticMeshActor::OnHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakableStaticMeshActor", "OnHit");

	Params::BreakableStaticMeshActor_OnHit Parms{};

	Parms.SelfActor = SelfActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.BreakingDetectorComponent.OnBroken
// (Final, Native, Protected)
// Parameters:
// EBrokenReason                           BrokenReason                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBreakingDetectorComponent::OnBroken(EBrokenReason BrokenReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BreakingDetectorComponent", "OnBroken");

	Params::BreakingDetectorComponent_OnBroken Parms{};

	Parms.BrokenReason = BrokenReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.DemoEnd
// (Final, Native, Public)

void UCarSplineManager::DemoEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "DemoEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.DemoStart
// (Final, Native, Public)

void UCarSplineManager::DemoStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "DemoStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.GeneralTalkEnd
// (Final, Native, Public)

void UCarSplineManager::GeneralTalkEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "GeneralTalkEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.GeneralTalkStart
// (Final, Native, Public)

void UCarSplineManager::GeneralTalkStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "GeneralTalkStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.OnBattleEnd
// (Final, Native, Public)

void UCarSplineManager::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.OnBattleStart
// (Final, Native, Public)

void UCarSplineManager::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CarSplineManager.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCarSplineManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CarSplineManager", "OnDemoTiming");

	Params::CarSplineManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CharacterAuraComponent.GetPowerCompareRank
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCharacterAuraComponent::GetPowerCompareRank()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAuraComponent", "GetPowerCompareRank");

	Params::CharacterAuraComponent_GetPowerCompareRank Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.CharacterAuraComponent.OnSearchEnd
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterAuraComponent::OnSearchEnd(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAuraComponent", "OnSearchEnd");

	Params::CharacterAuraComponent_OnSearchEnd Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CharacterAuraComponent.OnSearchStart
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCharacterAuraComponent::OnSearchStart(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterAuraComponent", "OnSearchStart");

	Params::CharacterAuraComponent_OnSearchStart Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CollectivelyCollectVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACollectivelyCollectVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CollectivelyCollectVolume", "OnOverlapBegin");

	Params::CollectivelyCollectVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CookingDemoDataManager.LoadForMealTimeSideCharacters
// (Final, Native, Private)

void ACookingDemoDataManager::LoadForMealTimeSideCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CookingDemoDataManager", "LoadForMealTimeSideCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CookingManager.OnLoadedRecipeParam
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          LoadOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCookingManager::OnLoadedRecipeParam(class UATDataAssetUiAsyncLoad* LoadOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CookingManager", "OnLoadedRecipeParam");

	Params::CookingManager_OnLoadedRecipeParam Parms{};

	Parms.LoadOwner = LoadOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CookingManager.OnLoadedRestaurantRecipeParam
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          LoadOwner                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCookingManager::OnLoadedRestaurantRecipeParam(class UATDataAssetUiAsyncLoad* LoadOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CookingManager", "OnLoadedRestaurantRecipeParam");

	Params::CookingManager_OnLoadedRestaurantRecipeParam Parms{};

	Parms.LoadOwner = LoadOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RaceCheckPoint.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void URaceCheckPoint::BeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaceCheckPoint", "BeginOverlap");

	Params::RaceCheckPoint_BeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RaceCheckPoint.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URaceCheckPoint::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaceCheckPoint", "EndOverlap");

	Params::RaceCheckPoint_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkConditionContinueBattle.OnBattleStarted
// (Final, Native, Protected)

void UCrossTalkConditionContinueBattle::OnBattleStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkConditionContinueBattle", "OnBattleStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkConditionContinueBattle.OnDefeatedEnemy
// (Final, Native, Protected)

void UCrossTalkConditionContinueBattle::OnDefeatedEnemy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkConditionContinueBattle", "OnDefeatedEnemy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateEffectColorMultiByAreaData.CompleteAsyncLoad
// (Final, Native, Private)

void UTerrainDecorateEffectColorMultiByAreaData::CompleteAsyncLoad()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateEffectColorMultiByAreaData", "CompleteAsyncLoad");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcActionComponent.ChangeNpcState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENpcState                               State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcActionComponent::ChangeNpcState(ENpcState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcActionComponent", "ChangeNpcState");

	Params::NpcActionComponent_ChangeNpcState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcActionComponent.EnableFootIK
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcActionComponent::EnableFootIK(bool Right, bool Left)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcActionComponent", "EnableFootIK");

	Params::NpcActionComponent_EnableFootIK Parms{};

	Parms.Right = Right;
	Parms.Left = Left;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcActionComponent.GetNpcState
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENpcState                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENpcState UNpcActionComponent::GetNpcState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcActionComponent", "GetNpcState");

	Params::NpcActionComponent_GetNpcState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcActionComponent.GetNpcStateBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ENpcState                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ENpcState UNpcActionComponent::GetNpcStateBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcActionComponent", "GetNpcStateBack");

	Params::NpcActionComponent_GetNpcStateBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcActionComponent.SetAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// E_NPC_ACTIONTYPE                        State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcActionComponent::SetAction(E_NPC_ACTIONTYPE State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcActionComponent", "SetAction");

	Params::NpcActionComponent_SetAction Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SimpleTalkWindow.BeginTalkWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           TalkID                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USimpleTalkWindow::BeginTalkWindow(const class FString& TalkID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTalkWindow", "BeginTalkWindow");

	Params::SimpleTalkWindow_BeginTalkWindow Parms{};

	Parms.TalkID = std::move(TalkID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SimpleTalkWindow.OnPressedFieldAction
// (Final, Native, Public, BlueprintCallable)

void USimpleTalkWindow::OnPressedFieldAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTalkWindow", "OnPressedFieldAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SimpleTalkWindow.SetVisibleTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USimpleTalkWindow::SetVisibleTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SimpleTalkWindow", "SetVisibleTime");

	Params::SimpleTalkWindow_SetVisibleTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_Cooking.OnCookingTiming
// (Final, Native, Public)
// Parameters:
// EEventTimingType                        TimingType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestPhase_Cooking::OnCookingTiming(EEventTimingType TimingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_Cooking", "OnCookingTiming");

	Params::QuestPhase_Cooking_OnCookingTiming Parms{};

	Parms.TimingType = TimingType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_Hunting.OnAddedInventory
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Num                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestPhase_Hunting::OnAddedInventory(const class FName& ItemId, int32 Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_Hunting", "OnAddedInventory");

	Params::QuestPhase_Hunting_OnAddedInventory Parms{};

	Parms.ItemId = ItemId;
	Parms.Num = Num;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.CrossTalkConditionTouchNoEntryVolume.OnBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrossTalkConditionTouchNoEntryVolume::OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrossTalkConditionTouchNoEntryVolume", "OnBeginOverlap");

	Params::CrossTalkConditionTouchNoEntryVolume_OnBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DebugMapInfo.OnLoadedSaveData
// (Final, Native, Private)
// Parameters:
// bool                                    bIsSuccess                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAT_DebugMapInfo::OnLoadedSaveData(bool bIsSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DebugMapInfo", "OnLoadedSaveData");

	Params::AT_DebugMapInfo_OnLoadedSaveData Parms{};

	Parms.bIsSuccess = bIsSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DebugMapInfo.RequestLoadQuest
// (Final, Native, Public, BlueprintCallable)

void UAT_DebugMapInfo::RequestLoadQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DebugMapInfo", "RequestLoadQuest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DebugMapInfo.RequestNextLanguage
// (Final, Native, Public, BlueprintCallable)

void UAT_DebugMapInfo::RequestNextLanguage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DebugMapInfo", "RequestNextLanguage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DebugMapInfo.RequestNextRegion
// (Final, Native, Public, BlueprintCallable)

void UAT_DebugMapInfo::RequestNextRegion()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DebugMapInfo", "RequestNextRegion");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.AT_DebugMapInfo.IsLoadedQest
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAT_DebugMapInfo::IsLoadedQest() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AT_DebugMapInfo", "IsLoadedQest");

	Params::AT_DebugMapInfo_IsLoadedQest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DebugMenu.GetQuestFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDebugMenu::GetQuestFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "GetQuestFlag");

	Params::DebugMenu_GetQuestFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DebugMenu.SetBoolValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SStringId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenu::SetBoolValue(const class FString& SStringId, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "SetBoolValue");

	Params::DebugMenu_SetBoolValue Parms{};

	Parms.SStringId = std::move(SStringId);
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DebugMenu.SetFloatValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SStringId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Fvalue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenu::SetFloatValue(const class FString& SStringId, float Fvalue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "SetFloatValue");

	Params::DebugMenu_SetFloatValue Parms{};

	Parms.SStringId = std::move(SStringId);
	Parms.Fvalue = Fvalue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DebugMenu.SetIntValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           SStringId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenu::SetIntValue(const class FString& SStringId, int32 IValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "SetIntValue");

	Params::DebugMenu_SetIntValue Parms{};

	Parms.SStringId = std::move(SStringId);
	Parms.IValue = IValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DebugMenu.SetQuestFlag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFlag                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDebugMenu::SetQuestFlag(bool bFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "SetQuestFlag");

	Params::DebugMenu_SetQuestFlag Parms{};

	Parms.bFlag = bFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DebugMenu.GetBoolValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           SStringId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDebugMenu::GetBoolValue(const class FString& SStringId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "GetBoolValue");

	Params::DebugMenu_GetBoolValue Parms{};

	Parms.SStringId = std::move(SStringId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DebugMenu.GetFloatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           SStringId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDebugMenu::GetFloatValue(const class FString& SStringId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "GetFloatValue");

	Params::DebugMenu_GetFloatValue Parms{};

	Parms.SStringId = std::move(SStringId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DebugMenu.GetIntValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           SStringId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDebugMenu::GetIntValue(const class FString& SStringId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DebugMenu", "GetIntValue");

	Params::DebugMenu_GetIntValue Parms{};

	Parms.SStringId = std::move(SStringId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Deer_Component.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDeer_Component::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Deer_Component", "OnComponentHit");

	Params::Deer_Component_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Deer_Component.OnProjectileLanding
// (Final, Native, Public)
// Parameters:
// class AATProjectileField*               Projectile                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeer_Component::OnProjectileLanding(class AATProjectileField* Projectile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Deer_Component", "OnProjectileLanding");

	Params::Deer_Component_OnProjectileLanding Parms{};

	Parms.Projectile = Projectile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Deer_Component.OnVisibleChangedCallBack
// (Final, Native, Public)
// Parameters:
// bool                                    IsVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDeer_Component::OnVisibleChangedCallBack(bool IsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Deer_Component", "OnVisibleChangedCallBack");

	Params::Deer_Component_OnVisibleChangedCallBack Parms{};

	Parms.IsVisible = IsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DestructibleBlueprintLibrary.DrawDebugActorChunks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ADestructibleActor*               Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDestructibleBlueprintLibrary::DrawDebugActorChunks(class ADestructibleActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DestructibleBlueprintLibrary", "DrawDebugActorChunks");

	Params::DestructibleBlueprintLibrary_DrawDebugActorChunks Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DestructibleBlueprintLibrary.DrawDebugComponentChunks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UDestructibleComponent*           Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDestructibleBlueprintLibrary::DrawDebugComponentChunks(class UDestructibleComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DestructibleBlueprintLibrary", "DrawDebugComponentChunks");

	Params::DestructibleBlueprintLibrary_DrawDebugComponentChunks Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Dinosaur_Component.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDinosaur_Component::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dinosaur_Component", "OnComponentHit");

	Params::Dinosaur_Component_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Dinosaur_Component.OnQuestGeneralTalkEvent
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeneralTalkEventArgment         Argment                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UDinosaur_Component::OnQuestGeneralTalkEvent(const struct FGeneralTalkEventArgment& Argment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dinosaur_Component", "OnQuestGeneralTalkEvent");

	Params::Dinosaur_Component_OnQuestGeneralTalkEvent Parms{};

	Parms.Argment = std::move(Argment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Dinosaur_Component.OnVisibleChangedCallBack
// (Final, Native, Public)
// Parameters:
// bool                                    State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDinosaur_Component::OnVisibleChangedCallBack(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dinosaur_Component", "OnVisibleChangedCallBack");

	Params::Dinosaur_Component_OnVisibleChangedCallBack Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Dinosaur_MoveArea.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDinosaur_MoveArea::BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dinosaur_MoveArea", "BeginOverlap");

	Params::Dinosaur_MoveArea_BeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Dinosaur_MoveArea.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDinosaur_MoveArea::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Dinosaur_MoveArea", "EndOverlap");

	Params::Dinosaur_MoveArea_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_PathWalk.OnMontageBlendingOut_Call
// (Final, Native, Private)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_PathWalk::OnMontageBlendingOut_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_PathWalk", "OnMontageBlendingOut_Call");

	Params::NpcAction_PathWalk_OnMontageBlendingOut_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_PathWalk.OnNpcGeneralDelegateMap_LoopEnd
// (Final, Native, Private)
// Parameters:
// class UNpcAction*                       PAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_PathWalk::OnNpcGeneralDelegateMap_LoopEnd(class UNpcAction* PAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_PathWalk", "OnNpcGeneralDelegateMap_LoopEnd");

	Params::NpcAction_PathWalk_OnNpcGeneralDelegateMap_LoopEnd Parms{};

	Parms.PAction = PAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_PathWalk.OnNpcGeneralDelegateMap_MoveStop
// (Final, Native, Private)
// Parameters:
// class UNpcAction*                       PAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_PathWalk::OnNpcGeneralDelegateMap_MoveStop(class UNpcAction* PAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_PathWalk", "OnNpcGeneralDelegateMap_MoveStop");

	Params::NpcAction_PathWalk_OnNpcGeneralDelegateMap_MoveStop Parms{};

	Parms.PAction = PAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_PathWalk.OnNpcVisibleChanged
// (Final, Native, Private)
// Parameters:
// bool                                    State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_PathWalk::OnNpcVisibleChanged(bool State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_PathWalk", "OnNpcVisibleChanged");

	Params::NpcAction_PathWalk_OnNpcVisibleChanged Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DirectionManager.GetCurrentDirectionTypeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UDirectionManager::GetCurrentDirectionTypeName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionManager", "GetCurrentDirectionTypeName");

	Params::DirectionManager_GetCurrentDirectionTypeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DirectionManager.IsDirection
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDirectionManager::IsDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionManager", "IsDirection");

	Params::DirectionManager_IsDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DirectionManager.IsDirectionType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIRECTION_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDirectionManager::IsDirectionType(EDIRECTION_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionManager", "IsDirectionType");

	Params::DirectionManager_IsDirectionType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DirectionManager.IsRequestType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EDIRECTION_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDirectionManager::IsRequestType(EDIRECTION_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionManager", "IsRequestType");

	Params::DirectionManager_IsRequestType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DirectionManager.RequestBeginDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIRECTION_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDirectionParameter              InParameter                                            (Parm, NativeAccessSpecifierPublic)

void UDirectionManager::RequestBeginDirection(EDIRECTION_TYPE Type, const struct FDirectionParameter& InParameter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionManager", "RequestBeginDirection");

	Params::DirectionManager_RequestBeginDirection Parms{};

	Parms.Type = Type;
	Parms.InParameter = std::move(InParameter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DirectionManager.RequestEndDirection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDIRECTION_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDirectionManager::RequestEndDirection(EDIRECTION_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DirectionManager", "RequestEndDirection");

	Params::DirectionManager_RequestEndDirection Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DLC4AdditionalStoryNavigator.NavigateDLC4AdditionalStory
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             NavigateLevelName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDLC4AdditionalStoryNavigator::NavigateDLC4AdditionalStory(class FName NavigateLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLC4AdditionalStoryNavigator", "NavigateDLC4AdditionalStory");

	Params::DLC4AdditionalStoryNavigator_NavigateDLC4AdditionalStory Parms{};

	Parms.NavigateLevelName = NavigateLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DLC4AdditionalStoryNavigator.NavigateDLC4MainStory
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             NavigateLevelName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDLC4AdditionalStoryNavigator::NavigateDLC4MainStory(class FName NavigateLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DLC4AdditionalStoryNavigator", "NavigateDLC4MainStory");

	Params::DLC4AdditionalStoryNavigator_NavigateDLC4MainStory Parms{};

	Parms.NavigateLevelName = NavigateLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.IsStoneDragonBall
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const bool UDragonBallManager::IsStoneDragonBall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "IsStoneDragonBall");

	Params::DragonBallManager_IsStoneDragonBall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.DragonBallManager.OnChangeProgress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonBallManager::OnChangeProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "OnChangeProgress");

	Params::DragonBallManager_OnChangeProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.OnCloseDebugMenuLocationEditor
// (Final, Native, Private)

void UDragonBallManager::OnCloseDebugMenuLocationEditor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "OnCloseDebugMenuLocationEditor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.OnCloseDebugMenuResetDragonBallUseTime
// (Final, Native, Private)

void UDragonBallManager::OnCloseDebugMenuResetDragonBallUseTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "OnCloseDebugMenuResetDragonBallUseTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.OnCompletedInitialize
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDragonBallManager::OnCompletedInitialize(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "OnCompletedInitialize");

	Params::DragonBallManager_OnCompletedInitialize Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonBallManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "OnDemoTiming");

	Params::DragonBallManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.ProgressPhaseChangePhaseTiming
// (Final, Native, Public)
// Parameters:
// int32                                   Phase                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonBallManager::ProgressPhaseChangePhaseTiming(int32 Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "ProgressPhaseChangePhaseTiming");

	Params::DragonBallManager_ProgressPhaseChangePhaseTiming Parms{};

	Parms.Phase = Phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.ProgressPhaseChangeQuestTiming
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             NewName                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonBallManager::ProgressPhaseChangeQuestTiming(const class FName& NewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "ProgressPhaseChangeQuestTiming");

	Params::DragonBallManager_ProgressPhaseChangeQuestTiming Parms{};

	Parms.NewName = NewName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.ResetDragonBallUseTime
// (Final, Native, Public, BlueprintCallable)

void UDragonBallManager::ResetDragonBallUseTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "ResetDragonBallUseTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallManager.TestDragonBallSpawn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDragonBallManager::TestDragonBallSpawn(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallManager", "TestDragonBallSpawn");

	Params::DragonBallManager_TestDragonBallSpawn Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_Wait.OnNpcGeneralDelegateMap_End
// (Final, Native, Protected)
// Parameters:
// class UNpcAction*                       PAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_Wait::OnNpcGeneralDelegateMap_End(class UNpcAction* PAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_Wait", "OnNpcGeneralDelegateMap_End");

	Params::NpcAction_Wait_OnNpcGeneralDelegateMap_End Parms{};

	Parms.PAction = PAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DragonBallStaticActor.OnActionChange
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADragonBallStaticActor::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DragonBallStaticActor", "OnActionChange");

	Params::DragonBallStaticActor_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.DynamicLandscapeDirtComponent.SpawnDestructibleActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FIntVector4_AT>           InVectors                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDynamicLandscapeDirtComponent::SpawnDestructibleActor(const TArray<struct FIntVector4_AT>& InVectors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DynamicLandscapeDirtComponent", "SpawnDestructibleActor");

	Params::DynamicLandscapeDirtComponent_SpawnDestructibleActor Parms{};

	Parms.InVectors = std::move(InVectors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl024SkillBarrierMine.OnBattleEnd
// (Final, Native, Public)

void AProjectile_Cpl024SkillBarrierMine::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl024SkillBarrierMine", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupDuration(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupDuration");

	Params::EaseTansformMovement_SetupDuration Parms{};

	Parms.InDuration = InDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupEasingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InEasingType                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InExp                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupEasingType(int32 InEasingType, float InExp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupEasingType");

	Params::EaseTansformMovement_SetupEasingType Parms{};

	Parms.InEasingType = InEasingType;
	Parms.InExp = InExp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupFlags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    UseLocation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAllOwnedComponentMode                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupFlags(bool UseLocation, bool UseRotation, bool UseScale, bool InAllOwnedComponentMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupFlags");

	Params::EaseTansformMovement_SetupFlags Parms{};

	Parms.UseLocation = UseLocation;
	Parms.UseRotation = UseRotation;
	Parms.UseScale = UseScale;
	Parms.InAllOwnedComponentMode = InAllOwnedComponentMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupStartLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupStartLocation(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupStartLocation");

	Params::EaseTansformMovement_SetupStartLocation Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupStartRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         InRotation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupStartRotation(const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupStartRotation");

	Params::EaseTansformMovement_SetupStartRotation Parms{};

	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupStartScale
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InScale                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupStartScale(const struct FVector& InScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupStartScale");

	Params::EaseTansformMovement_SetupStartScale Parms{};

	Parms.InScale = std::move(InScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupTargetLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InTargetLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupTargetLocation(const struct FVector& InTargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupTargetLocation");

	Params::EaseTansformMovement_SetupTargetLocation Parms{};

	Parms.InTargetLocation = std::move(InTargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupTargetRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         InTargetRotation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupTargetRotation(const struct FRotator& InTargetRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupTargetRotation");

	Params::EaseTansformMovement_SetupTargetRotation Parms{};

	Parms.InTargetRotation = std::move(InTargetRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.SetupTargetScale
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InTargetScale                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEaseTansformMovement::SetupTargetScale(const struct FVector& InTargetScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "SetupTargetScale");

	Params::EaseTansformMovement_SetupTargetScale Parms{};

	Parms.InTargetScale = std::move(InTargetScale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EaseTansformMovement.Start
// (Final, Native, Public, BlueprintCallable)

void UEaseTansformMovement::Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EaseTansformMovement", "Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountCheckComponent.OverlapBeginEncountCheckFlowDirection
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEncountCheckComponent::OverlapBeginEncountCheckFlowDirection(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountCheckComponent", "OverlapBeginEncountCheckFlowDirection");

	Params::EncountCheckComponent_OverlapBeginEncountCheckFlowDirection Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountCheckComponent.OverlapBeginEncountCheckFlowDirectionArea
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEncountCheckComponent::OverlapBeginEncountCheckFlowDirectionArea(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountCheckComponent", "OverlapBeginEncountCheckFlowDirectionArea");

	Params::EncountCheckComponent_OverlapBeginEncountCheckFlowDirectionArea Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountCheckComponent.OverlapBeginEncountCheckOwnerLocation
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UEncountCheckComponent::OverlapBeginEncountCheckOwnerLocation(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountCheckComponent", "OverlapBeginEncountCheckOwnerLocation");

	Params::EncountCheckComponent_OverlapBeginEncountCheckOwnerLocation Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountCheckComponent.OverlapEndEncountCheckFlowDirection
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEncountCheckComponent::OverlapEndEncountCheckFlowDirection(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountCheckComponent", "OverlapEndEncountCheckFlowDirection");

	Params::EncountCheckComponent_OverlapEndEncountCheckFlowDirection Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountCheckComponent.OverlapEndEncountCheckFlowDirectionArea
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEncountCheckComponent::OverlapEndEncountCheckFlowDirectionArea(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountCheckComponent", "OverlapEndEncountCheckFlowDirectionArea");

	Params::EncountCheckComponent_OverlapEndEncountCheckFlowDirectionArea Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountCheckComponent.OverlapEndEncountCheckOwnerLocation
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEncountCheckComponent::OverlapEndEncountCheckOwnerLocation(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountCheckComponent", "OverlapEndEncountCheckOwnerLocation");

	Params::EncountCheckComponent_OverlapEndEncountCheckOwnerLocation Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EncountDisableComponent.SetDisableVolumes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Disable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEncountDisableComponent::SetDisableVolumes(bool Disable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EncountDisableComponent", "SetDisableVolumes");

	Params::EncountDisableComponent_SetDisableVolumes Parms{};

	Parms.Disable = Disable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATEnenmyManager.OnBattleStart
// (Final, Native, Public)
// Parameters:
// class AAT_CharacterBase*                Chara                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EnemyPartyID                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   BattleType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UATEnenmyManager::OnBattleStart(class AAT_CharacterBase* Chara, class FName EnemyPartyID, uint8 BattleType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATEnenmyManager", "OnBattleStart");

	Params::ATEnenmyManager_OnBattleStart Parms{};

	Parms.Chara = Chara;
	Parms.EnemyPartyID = EnemyPartyID;
	Parms.BattleType = BattleType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl041ESkillVanishingBall.OnCollisionOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile_Cpl041ESkillVanishingBall::OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl041ESkillVanishingBall", "OnCollisionOverlapBegin");

	Params::Projectile_Cpl041ESkillVanishingBall_OnCollisionOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl041ESkillVanishingBall.OnCollisionOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl041ESkillVanishingBall::OnCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl041ESkillVanishingBall", "OnCollisionOverlapEnd");

	Params::Projectile_Cpl041ESkillVanishingBall_OnCollisionOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl041ESkillVanishingBall.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl041ESkillVanishingBall::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl041ESkillVanishingBall", "OnSpawnProjectile");

	Params::Projectile_Cpl041ESkillVanishingBall_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventManager.IsRequestType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEVENT_TYPE                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEventManager::IsRequestType(EEVENT_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "IsRequestType");

	Params::EventManager_IsRequestType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.EventManager.RequestEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEVENT_TYPE                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::RequestEvent(EEVENT_TYPE Type, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "RequestEvent");

	Params::EventManager_RequestEvent Parms{};

	Parms.Type = Type;
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventManager.RequestEventF
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEVENT_TYPE                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Arg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::RequestEventF(EEVENT_TYPE Type, float Arg, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "RequestEventF");

	Params::EventManager_RequestEventF Parms{};

	Parms.Type = Type;
	Parms.Arg = Arg;
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventManager.RequestEventI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEVENT_TYPE                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Arg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::RequestEventI(EEVENT_TYPE Type, int32 Arg, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "RequestEventI");

	Params::EventManager_RequestEventI Parms{};

	Parms.Type = Type;
	Parms.Arg = Arg;
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.EventManager.RequestEventParam
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bImmediate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEventManager::RequestEventParam(const struct FEventParam& Param, bool bImmediate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EventManager", "RequestEventParam");

	Params::EventManager_RequestEventParam Parms{};

	Parms.Param = std::move(Param);
	Parms.bImmediate = bImmediate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FieldActionGashaponActor.Entry
// (Final, Native, Private)

void AFieldActionGashaponActor::Entry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionGashaponActor", "Entry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FieldActionTCGMachineActor.EndSaveState
// (Final, Native, Public)

void AFieldActionTCGMachineActor::EndSaveState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FieldActionTCGMachineActor", "EndSaveState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATInteractTalkObject.OnPressedFieldAction
// (Native, Public)

void UATInteractTalkObject::OnPressedFieldAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATInteractTalkObject", "OnPressedFieldAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SubQuest_MissionCompleteState.OnLoadedQuestdata
// (Final, Native, Private)

void USubQuest_MissionCompleteState::OnLoadedQuestdata()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubQuest_MissionCompleteState", "OnLoadedQuestdata");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FishingStartPoint.OnActionChange
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    InCharacter                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdPrev                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InActionIdNext                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFishingStartPoint::OnActionChange(class AAT_Character* InCharacter, int32 InActionIdPrev, int32 InActionIdNext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FishingStartPoint", "OnActionChange");

	Params::FishingStartPoint_OnActionChange Parms{};

	Parms.InCharacter = InCharacter;
	Parms.InActionIdPrev = InActionIdPrev;
	Parms.InActionIdNext = InActionIdNext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FlyingDragon_Component.OnComponentHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFlyingDragon_Component::OnComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyingDragon_Component", "OnComponentHit");

	Params::FlyingDragon_Component_OnComponentHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FutureVisionVolume.EndOmen
// (Final, Native, Public)

void AFutureVisionVolume::EndOmen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FutureVisionVolume", "EndOmen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.FutureVisionVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFutureVisionVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FutureVisionVolume", "OnOverlapBegin");

	Params::FutureVisionVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FutureVisionVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFutureVisionVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FutureVisionVolume", "OnOverlapEnd");

	Params::FutureVisionVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.FutureVisionVolume.RequestEnd
// (Final, Native, Public)

void AFutureVisionVolume::RequestEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FutureVisionVolume", "RequestEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.GravitySphereVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravitySphereVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GravitySphereVolume", "OnOverlapBegin");

	Params::GravitySphereVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.GravitySphereVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGravitySphereVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GravitySphereVolume", "OnOverlapEnd");

	Params::GravitySphereVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.HudManager.InvisibleHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// E_HUD_TYPE                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHudVisibleCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudManager::InvisibleHud(E_HUD_TYPE Type, EHudVisibleCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudManager", "InvisibleHud");

	Params::HudManager_InvisibleHud Parms{};

	Parms.Type = Type;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.HudManager.IsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// E_HUD_TYPE                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHudManager::IsVisible(E_HUD_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudManager", "IsVisible");

	Params::HudManager_IsVisible Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.HudManager.OnlyVisibleHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// E_HUD_TYPE                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHudVisibleCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudManager::OnlyVisibleHud(E_HUD_TYPE Type, EHudVisibleCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudManager", "OnlyVisibleHud");

	Params::HudManager_OnlyVisibleHud Parms{};

	Parms.Type = Type;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.HudManager.ResetVisibleMask
// (Final, Native, Public, BlueprintCallable)

void UHudManager::ResetVisibleMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudManager", "ResetVisibleMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.HudManager.SetHudVisible
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// E_HUD_TYPE                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudManager::SetHudVisible(bool Visible, E_HUD_TYPE Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudManager", "SetHudVisible");

	Params::HudManager_SetHudVisible Parms{};

	Parms.Visible = Visible;
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.HudManager.VisibleHud
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// E_HUD_TYPE                              Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EHudVisibleCategory                     InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHudManager::VisibleHud(E_HUD_TYPE Type, EHudVisibleCategory InCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HudManager", "VisibleHud");

	Params::HudManager_VisibleHud Parms{};

	Parms.Type = Type;
	Parms.InCategory = InCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ItemInventoryMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UItemInventoryMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInventoryMenu", "MouseClickDecide");

	Params::ItemInventoryMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ItemInventoryMenu.MouseClickTabLeft
// (Final, Native, Public)

void UItemInventoryMenu::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInventoryMenu", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ItemInventoryMenu.MouseClickTabRight
// (Final, Native, Public)

void UItemInventoryMenu::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemInventoryMenu", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.KiSearchComponent.OnAuraSearchEnd
// (Final, Native, Public)

void UKiSearchComponent::OnAuraSearchEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KiSearchComponent", "OnAuraSearchEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.KiSearchComponent.OnAuraSearchStart
// (Final, Native, Public)

void UKiSearchComponent::OnAuraSearchStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KiSearchComponent", "OnAuraSearchStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SaveBreakablePoint.OnBroken
// (Final, Native, Private)
// Parameters:
// EBrokenReason                           Reason                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASaveBreakablePoint::OnBroken(EBrokenReason Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveBreakablePoint", "OnBroken");

	Params::SaveBreakablePoint_OnBroken Parms{};

	Parms.Reason = Reason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelLimitSaveBreakablePoint.CheckBreakLevel
// (Final, Native, Public)

void ALevelLimitSaveBreakablePoint::CheckBreakLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLimitSaveBreakablePoint", "CheckBreakLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelLimitSaveBreakablePoint.OnBeginOverlapMessageTrigger
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALevelLimitSaveBreakablePoint::OnBeginOverlapMessageTrigger(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLimitSaveBreakablePoint", "OnBeginOverlapMessageTrigger");

	Params::LevelLimitSaveBreakablePoint_OnBeginOverlapMessageTrigger Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelLimitSaveBreakablePoint.OnCloseMessageWindow
// (Final, Native, Public)
// Parameters:
// int32                                   SELECT                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelLimitSaveBreakablePoint::OnCloseMessageWindow(int32 SELECT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLimitSaveBreakablePoint", "OnCloseMessageWindow");

	Params::LevelLimitSaveBreakablePoint_OnCloseMessageWindow Parms{};

	Parms.SELECT = SELECT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelLimitSaveBreakablePoint.OnCloseWindow
// (Final, Native, Public)
// Parameters:
// int32                                   SELECT                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALevelLimitSaveBreakablePoint::OnCloseWindow(int32 SELECT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLimitSaveBreakablePoint", "OnCloseWindow");

	Params::LevelLimitSaveBreakablePoint_OnCloseWindow Parms{};

	Parms.SELECT = SELECT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelLimitSaveBreakablePoint.OnSearchEnd
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALevelLimitSaveBreakablePoint::OnSearchEnd(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLimitSaveBreakablePoint", "OnSearchEnd");

	Params::LevelLimitSaveBreakablePoint_OnSearchEnd Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LevelLimitSaveBreakablePoint.OnSearchStart
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ALevelLimitSaveBreakablePoint::OnSearchStart(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelLimitSaveBreakablePoint", "OnSearchStart");

	Params::LevelLimitSaveBreakablePoint_OnSearchStart Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenu.CheckHovered
// (Final, Native, Private)

void ULoadMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenu.GetUIWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAT_UIStartSaveLoad*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAT_UIStartSaveLoad* ULoadMenu::GetUIWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenu", "GetUIWidget");

	Params::LoadMenu_GetUIWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.LoadMenu.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULoadMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenu", "MouseClickDecide");

	Params::LoadMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenu.MouseWheel
// (Final, Native, Private)
// Parameters:
// float                                   InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadMenu::MouseWheel(float InDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenu", "MouseWheel");

	Params::LoadMenu_MouseWheel Parms{};

	Parms.InDirection = InDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenu.SetUIInput
// (Final, Native, Public)

void ULoadMenu::SetUIInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenu", "SetUIInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenu.UnsetUIInput
// (Final, Native, Public)

void ULoadMenu::UnsetUIInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenu", "UnsetUIInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenuComponent.GetMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ULoadMenu*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULoadMenu* ULoadMenuComponent::GetMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenuComponent", "GetMenu");

	Params::LoadMenuComponent_GetMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.LoadMenuComponent.IsLoadData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULoadMenuComponent::IsLoadData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenuComponent", "IsLoadData");

	Params::LoadMenuComponent_IsLoadData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.LoadMenuComponent.MenuActivate
// (Final, Native, Public, BlueprintCallable)

void ULoadMenuComponent::MenuActivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenuComponent", "MenuActivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.LoadMenuComponent.MenuDeactivate
// (Final, Native, Public, BlueprintCallable)

void ULoadMenuComponent::MenuDeactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadMenuComponent", "MenuDeactivate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl064SkillBurstShoot.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl064SkillBurstShoot::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl064SkillBurstShoot", "OnSpawnProjectile");

	Params::Projectile_Cpl064SkillBurstShoot_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LookAtComponent.GetDistanceLookAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULookAtComponent::GetDistanceLookAt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtComponent", "GetDistanceLookAt");

	Params::LookAtComponent_GetDistanceLookAt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.LookAtComponent.SetDefaultLookAt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULookAtComponent::SetDefaultLookAt(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LookAtComponent", "SetDefaultLookAt");

	Params::LookAtComponent_SetDefaultLookAt Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.MenuManager.OnPlayerChange
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMenuManager::OnPlayerChange(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MenuManager", "OnPlayerChange");

	Params::MenuManager_OnPlayerChange Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.MiniGameComponent.OnFinishedTalking
// (Final, Native, Private)

void UMiniGameComponent::OnFinishedTalking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MiniGameComponent", "OnFinishedTalking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.PoolingObject.OnRent
// (Native, Event, Public, BlueprintEvent)

void IPoolingObject::OnRent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolingObject", "OnRent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.PoolingObject.OnReturn
// (Native, Event, Public, BlueprintEvent)

void IPoolingObject::OnReturn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoolingObject", "OnReturn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.MobIconComponent.HiddenIcon
// (Final, Native, Public, BlueprintCallable)

void UMobIconComponent::HiddenIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MobIconComponent", "HiddenIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.MobIconComponent.VisibleIcon
// (Final, Native, Public, BlueprintCallable)

void UMobIconComponent::VisibleIcon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MobIconComponent", "VisibleIcon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralManager.OnLevelHidden
// (Final, Native, Protected)
// Parameters:
// class ULevelStreaming*                  LevelStreaming                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProceduralManager::OnLevelHidden(class ULevelStreaming* LevelStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralManager", "OnLevelHidden");

	Params::ProceduralManager_OnLevelHidden Parms{};

	Parms.LevelStreaming = LevelStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralManager.OnLevelShown
// (Final, Native, Protected)
// Parameters:
// class ULevelStreaming*                  LevelStreaming                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProceduralManager::OnLevelShown(class ULevelStreaming* LevelStreaming)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralManager", "OnLevelShown");

	Params::ProceduralManager_OnLevelShown Parms{};

	Parms.LevelStreaming = LevelStreaming;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralManager.QueryLevelLoaded
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   IMapChipX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IMapChipY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FIntVector                       LevelOffset                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProceduralManager::QueryLevelLoaded(int32 IMapChipX, int32 IMapChipY, class ULevel* Level, const struct FIntVector& LevelOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralManager", "QueryLevelLoaded");

	Params::ProceduralManager_QueryLevelLoaded Parms{};

	Parms.IMapChipX = IMapChipX;
	Parms.IMapChipY = IMapChipY;
	Parms.Level = Level;
	Parms.LevelOffset = std::move(LevelOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralManager.QueryLevelUnloaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   IMapChipX                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   IMapChipY                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UProceduralManager::QueryLevelUnloaded(int32 IMapChipX, int32 IMapChipY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralManager", "QueryLevelUnloaded");

	Params::ProceduralManager_QueryLevelUnloaded Parms{};

	Parms.IMapChipX = IMapChipX;
	Parms.IMapChipY = IMapChipY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProceduralManager.TryRemoveInstancedMesh
// (Final, Native, Protected)

void UProceduralManager::TryRemoveInstancedMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralManager", "TryRemoveInstancedMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NoneGeneralCrossTalkVolume.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoneGeneralCrossTalkVolume::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoneGeneralCrossTalkVolume", "OnOverlapBegin");

	Params::NoneGeneralCrossTalkVolume_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NoneGeneralCrossTalkVolume.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANoneGeneralCrossTalkVolume::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NoneGeneralCrossTalkVolume", "OnOverlapEnd");

	Params::NoneGeneralCrossTalkVolume_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ProgressManager.GetNextExtendQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UProgressManager::GetNextExtendQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressManager", "GetNextExtendQuest");

	Params::ProgressManager_GetNextExtendQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ProgressManager.GetNextMainQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UProgressManager::GetNextMainQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressManager", "GetNextMainQuest");

	Params::ProgressManager_GetNextMainQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ProgressManager.GetPrevExtendQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UProgressManager::GetPrevExtendQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressManager", "GetPrevExtendQuest");

	Params::ProgressManager_GetPrevExtendQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ProgressManager.GetPrevMainQuest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UProgressManager::GetPrevMainQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressManager", "GetPrevMainQuest");

	Params::ProgressManager_GetPrevMainQuest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAction_Stagger.OnMontageBlendingOut_Call
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_Stagger::OnMontageBlendingOut_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_Stagger", "OnMontageBlendingOut_Call");

	Params::NpcAction_Stagger_OnMontageBlendingOut_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_Stagger.OnNpcGeneralDelegateMap_MoveEnd
// (Final, Native, Protected)
// Parameters:
// class UNpcAction*                       PAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_Stagger::OnNpcGeneralDelegateMap_MoveEnd(class UNpcAction* PAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_Stagger", "OnNpcGeneralDelegateMap_MoveEnd");

	Params::NpcAction_Stagger_OnNpcGeneralDelegateMap_MoveEnd Parms{};

	Parms.PAction = PAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAction_Surprise.OnMontageBlendingOut_Call
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAction_Surprise::OnMontageBlendingOut_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAction_Surprise", "OnMontageBlendingOut_Call");

	Params::NpcAction_Surprise_OnMontageBlendingOut_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAnimInstance.CheckLoopEndAndResetAnimation
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// EATNpcLoopAnimType                      CurrentLoopAnim                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EATNpcLoopAnimType                      NextLoopAnim                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcAnimInstance::CheckLoopEndAndResetAnimation(EATNpcLoopAnimType CurrentLoopAnim, EATNpcLoopAnimType NextLoopAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "CheckLoopEndAndResetAnimation");

	Params::NpcAnimInstance_CheckLoopEndAndResetAnimation Parms{};

	Parms.CurrentLoopAnim = CurrentLoopAnim;
	Parms.NextLoopAnim = NextLoopAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.GetNpcActionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNpcActionComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNpcActionComponent* UNpcAnimInstance::GetNpcActionComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetNpcActionComponent");

	Params::NpcAnimInstance_GetNpcActionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.GetOwnerActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UNpcAnimInstance::GetOwnerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetOwnerActor");

	Params::NpcAnimInstance_GetOwnerActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.IsApplyFootIK
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcAnimInstance::IsApplyFootIK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "IsApplyFootIK");

	Params::NpcAnimInstance_IsApplyFootIK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.Update
// (Final, Native, Public, BlueprintCallable)

void UNpcAnimInstance::Update()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "Update");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAnimInstance.UpdateLookAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAnimInstance::UpdateLookAngle(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "UpdateLookAngle");

	Params::NpcAnimInstance_UpdateLookAngle Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAnimInstance.GetLeftFootEffectorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNpcAnimInstance::GetLeftFootEffectorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetLeftFootEffectorLocation");

	Params::NpcAnimInstance_GetLeftFootEffectorLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.GetLeftJointTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNpcAnimInstance::GetLeftJointTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetLeftJointTarget");

	Params::NpcAnimInstance_GetLeftJointTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.GetLoopCountRemain
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNpcAnimInstance::GetLoopCountRemain() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetLoopCountRemain");

	Params::NpcAnimInstance_GetLoopCountRemain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.GetRightFootEffectorLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNpcAnimInstance::GetRightFootEffectorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetRightFootEffectorLocation");

	Params::NpcAnimInstance_GetRightFootEffectorLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAnimInstance.GetRightJointTarget
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNpcAnimInstance::GetRightJointTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAnimInstance", "GetRightJointTarget");

	Params::NpcAnimInstance_GetRightJointTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.SetAcceptanceHeight
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetAcceptanceHeight(class AActor* Target, float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetAcceptanceHeight");

	Params::NpcAutoMoveComponent_SetAcceptanceHeight Parms{};

	Parms.Target = Target;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetAutoMove
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetAutoMove(class AActor* Target, bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetAutoMove");

	Params::NpcAutoMoveComponent_SetAutoMove Parms{};

	Parms.Target = Target;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetMaxPlayAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetMaxPlayAnim(class AActor* Target, int32 Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetMaxPlayAnim");

	Params::NpcAutoMoveComponent_SetMaxPlayAnim Parms{};

	Parms.Target = Target;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetMoveArea
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetMoveArea(class AActor* Target, float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetMoveArea");

	Params::NpcAutoMoveComponent_SetMoveArea Parms{};

	Parms.Target = Target;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetStartLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetStartLocation(class AActor* Target, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetStartLocation");

	Params::NpcAutoMoveComponent_SetStartLocation Parms{};

	Parms.Target = Target;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetStopGoal
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetStopGoal(class AActor* Target, bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetStopGoal");

	Params::NpcAutoMoveComponent_SetStopGoal Parms{};

	Parms.Target = Target;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetStopMoveAreaLength
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetStopMoveAreaLength(class AActor* Target, float Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetStopMoveAreaLength");

	Params::NpcAutoMoveComponent_SetStopMoveAreaLength Parms{};

	Parms.Target = Target;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetUseRayCast
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetUseRayCast(class AActor* Target, bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetUseRayCast");

	Params::NpcAutoMoveComponent_SetUseRayCast Parms{};

	Parms.Target = Target;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetWaitFrequency
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Length                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetWaitFrequency(class AActor* Target, int32 Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetWaitFrequency");

	Params::NpcAutoMoveComponent_SetWaitFrequency Parms{};

	Parms.Target = Target;
	Parms.Length = Length;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetWaitPause
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetWaitPause(class AActor* Target, bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetWaitPause");

	Params::NpcAutoMoveComponent_SetWaitPause Parms{};

	Parms.Target = Target;
	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetWaitPauseTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinWaitPauseTime_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWaitPauseTime_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetWaitPauseTime(class AActor* Target, float MinWaitPauseTime_0, float MaxWaitPauseTime_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetWaitPauseTime");

	Params::NpcAutoMoveComponent_SetWaitPauseTime Parms{};

	Parms.Target = Target;
	Parms.MinWaitPauseTime_0 = MinWaitPauseTime_0;
	Parms.MaxWaitPauseTime_0 = MaxWaitPauseTime_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.SetWaitTime
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinWaitTime_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWaitTime_0                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::SetWaitTime(class AActor* Target, float MinWaitTime_0, float MaxWaitTime_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NpcAutoMoveComponent", "SetWaitTime");

	Params::NpcAutoMoveComponent_SetWaitTime Parms{};

	Parms.Target = Target;
	Parms.MinWaitTime_0 = MinWaitTime_0;
	Parms.MaxWaitTime_0 = MaxWaitTime_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.GetAcceptanceHeight
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNpcAutoMoveComponent::GetAcceptanceHeight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetAcceptanceHeight");

	Params::NpcAutoMoveComponent_GetAcceptanceHeight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetAutoMove
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcAutoMoveComponent::GetAutoMove()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetAutoMove");

	Params::NpcAutoMoveComponent_GetAutoMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetMaxPlayAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNpcAutoMoveComponent::GetMaxPlayAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetMaxPlayAnim");

	Params::NpcAutoMoveComponent_GetMaxPlayAnim Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetMoveArea
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNpcAutoMoveComponent::GetMoveArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetMoveArea");

	Params::NpcAutoMoveComponent_GetMoveArea Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetStartLocation
// (Final, Native, Public, HasDefaults)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNpcAutoMoveComponent::GetStartLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetStartLocation");

	Params::NpcAutoMoveComponent_GetStartLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetStopGoal
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcAutoMoveComponent::GetStopGoal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetStopGoal");

	Params::NpcAutoMoveComponent_GetStopGoal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetStopMoveAreaLength
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNpcAutoMoveComponent::GetStopMoveAreaLength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetStopMoveAreaLength");

	Params::NpcAutoMoveComponent_GetStopMoveAreaLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetUseRayCast
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcAutoMoveComponent::GetUseRayCast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetUseRayCast");

	Params::NpcAutoMoveComponent_GetUseRayCast Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetWaitFrequency
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UNpcAutoMoveComponent::GetWaitFrequency()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetWaitFrequency");

	Params::NpcAutoMoveComponent_GetWaitFrequency Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetWaitPause
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNpcAutoMoveComponent::GetWaitPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetWaitPause");

	Params::NpcAutoMoveComponent_GetWaitPause Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcAutoMoveComponent.GetWaitPauseTime
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InMinWaitPauseTime                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxWaitPauseTime                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::GetWaitPauseTime(float* InMinWaitPauseTime, float* InMaxWaitPauseTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetWaitPauseTime");

	Params::NpcAutoMoveComponent_GetWaitPauseTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InMinWaitPauseTime != nullptr)
		*InMinWaitPauseTime = Parms.InMinWaitPauseTime;

	if (InMaxWaitPauseTime != nullptr)
		*InMaxWaitPauseTime = Parms.InMaxWaitPauseTime;
}


// Function AT.NpcAutoMoveComponent.GetWaitTime
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InMinWaitTime                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxWaitTime                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::GetWaitTime(float* InMinWaitTime, float* InMaxWaitTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "GetWaitTime");

	Params::NpcAutoMoveComponent_GetWaitTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InMinWaitTime != nullptr)
		*InMinWaitTime = Parms.InMinWaitTime;

	if (InMaxWaitTime != nullptr)
		*InMaxWaitTime = Parms.InMaxWaitTime;
}


// Function AT.NpcAutoMoveComponent.OnChangeNpcState
// (Final, Native, Public)
// Parameters:
// ENpcState                               State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcAutoMoveComponent::OnChangeNpcState(ENpcState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "OnChangeNpcState");

	Params::NpcAutoMoveComponent_OnChangeNpcState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcAutoMoveComponent.OnExitIdlingSequentialAnimation
// (Final, Native, Public)

void UNpcAutoMoveComponent::OnExitIdlingSequentialAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcAutoMoveComponent", "OnExitIdlingSequentialAnimation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeAction.OnNpcActionEnd
// (Final, Native, Public)
// Parameters:
// class UNpcAction*                       PAction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcEventVolumeAction::OnNpcActionEnd(class UNpcAction* PAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeAction", "OnNpcActionEnd");

	Params::NpcEventVolumeAction_OnNpcActionEnd Parms{};

	Parms.PAction = PAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeAction.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcEventVolumeAction::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeAction", "OnOverlapBegin");

	Params::NpcEventVolumeAction_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeAction.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcEventVolumeAction::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeAction", "OnOverlapEnd");

	Params::NpcEventVolumeAction_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeComponent.BeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UNpcEventVolumeComponent::BeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeComponent", "BeginOverlap");

	Params::NpcEventVolumeComponent_BeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeComponent.EndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcEventVolumeComponent::EndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeComponent", "EndOverlap");

	Params::NpcEventVolumeComponent_EndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeFromPlayer.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcEventVolumeFromPlayer::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeFromPlayer", "OnOverlapBegin");

	Params::NpcEventVolumeFromPlayer_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcEventVolumeFromPlayer.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANpcEventVolumeFromPlayer::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcEventVolumeFromPlayer", "OnOverlapEnd");

	Params::NpcEventVolumeFromPlayer_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.Demo_End
// (Final, Native, Public)

void UNpcManager::Demo_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "Demo_End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.Demo_Start
// (Final, Native, Public)

void UNpcManager::Demo_Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "Demo_Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.GeneralTalk_End
// (Final, Native, Public)

void UNpcManager::GeneralTalk_End()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "GeneralTalk_End");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.GeneralTalk_Start
// (Final, Native, Public)

void UNpcManager::GeneralTalk_Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "GeneralTalk_Start");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnBattleEnd
// (Final, Native, Public)

void UNpcManager::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnBattleStart
// (Final, Native, Public)

void UNpcManager::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnCooking
// (Final, Native, Public)
// Parameters:
// EEventTimingType                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnCooking(EEventTimingType Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnCooking");

	Params::NpcManager_OnCooking Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnDemoTiming");

	Params::NpcManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnGeneralTalk
// (Final, Native, Public)
// Parameters:
// EQUEST_GENERAL_TALK_TIMING              Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnGeneralTalk(EQUEST_GENERAL_TALK_TIMING Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnGeneralTalk");

	Params::NpcManager_OnGeneralTalk Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnLoaded_AnimMontage
// (Final, Native, Private)
// Parameters:
// class UATDataAssetNpcMobAsyncLoad*      NpcMobLoad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnLoaded_AnimMontage(class UATDataAssetNpcMobAsyncLoad* NpcMobLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnLoaded_AnimMontage");

	Params::NpcManager_OnLoaded_AnimMontage Parms{};

	Parms.NpcMobLoad = NpcMobLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnLoaded_NpcMobAnimBP
// (Final, Native, Private)
// Parameters:
// class UATDataAssetNpcMobAsyncLoad*      NpcMobLoad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnLoaded_NpcMobAnimBP(class UATDataAssetNpcMobAsyncLoad* NpcMobLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnLoaded_NpcMobAnimBP");

	Params::NpcManager_OnLoaded_NpcMobAnimBP Parms{};

	Parms.NpcMobLoad = NpcMobLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnLoaded_NpcMobMesh
// (Final, Native, Private)
// Parameters:
// class UATDataAssetNpcMobAsyncLoad*      NpcMobLoad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnLoaded_NpcMobMesh(class UATDataAssetNpcMobAsyncLoad* NpcMobLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnLoaded_NpcMobMesh");

	Params::NpcManager_OnLoaded_NpcMobMesh Parms{};

	Parms.NpcMobLoad = NpcMobLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnLoaded_TownMobClass
// (Final, Native, Private)
// Parameters:
// class UATDataAssetNpcMobAsyncLoad*      NpcMobLoad                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnLoaded_TownMobClass(class UATDataAssetNpcMobAsyncLoad* NpcMobLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnLoaded_TownMobClass");

	Params::NpcManager_OnLoaded_TownMobClass Parms{};

	Parms.NpcMobLoad = NpcMobLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnPlayerChange
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnPlayerChange(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnPlayerChange");

	Params::NpcManager_OnPlayerChange Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcManager.OnQuest
// (Final, Native, Public)
// Parameters:
// EQUEST_UI_ACTIVE_TIMING                 Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcManager::OnQuest(EQUEST_UI_ACTIVE_TIMING Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcManager", "OnQuest");

	Params::NpcManager_OnQuest Parms{};

	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.AddInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          WorldAccel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::AddInputVector(const struct FVector& WorldAccel, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "AddInputVector");

	Params::NpcMovementComponent_AddInputVector Parms{};

	Parms.WorldAccel = std::move(WorldAccel);
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.ChangeMoveMode
// (Native, Public, BlueprintCallable)
// Parameters:
// EMovementMode                           NewMoveMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewCustomMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::ChangeMoveMode(EMovementMode NewMoveMode, uint8 NewCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "ChangeMoveMode");

	Params::NpcMovementComponent_ChangeMoveMode Parms{};

	Parms.NewMoveMode = NewMoveMode;
	Parms.NewCustomMode = NewCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.ConsumeInputVector
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UNpcMovementComponent::ConsumeInputVector()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "ConsumeInputVector");

	Params::NpcMovementComponent_ConsumeInputVector Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcMovementComponent.SetAvoidanceGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GroupFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetAvoidanceGroup(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetAvoidanceGroup");

	Params::NpcMovementComponent_SetAvoidanceGroup Parms{};

	Parms.GroupFlags = GroupFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetAvoidanceGroupMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask                GroupMask                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetAvoidanceGroupMask(const struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetAvoidanceGroupMask");

	Params::NpcMovementComponent_SetAvoidanceGroupMask Parms{};

	Parms.GroupMask = std::move(GroupMask);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetGroupsToAvoid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GroupFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetGroupsToAvoid(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetGroupsToAvoid");

	Params::NpcMovementComponent_SetGroupsToAvoid Parms{};

	Parms.GroupFlags = GroupFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetGroupsToAvoidMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask                GroupMask                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetGroupsToAvoidMask(const struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetGroupsToAvoidMask");

	Params::NpcMovementComponent_SetGroupsToAvoidMask Parms{};

	Parms.GroupMask = std::move(GroupMask);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetGroupsToIgnore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   GroupFlags                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetGroupsToIgnore(int32 GroupFlags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetGroupsToIgnore");

	Params::NpcMovementComponent_SetGroupsToIgnore Parms{};

	Parms.GroupFlags = GroupFlags;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetGroupsToIgnoreMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNavAvoidanceMask                GroupMask                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetGroupsToIgnoreMask(const struct FNavAvoidanceMask& GroupMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetGroupsToIgnoreMask");

	Params::NpcMovementComponent_SetGroupsToIgnoreMask Parms{};

	Parms.GroupMask = std::move(GroupMask);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetWalkableFloorAngle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorAngle                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetWalkableFloorAngle(float InWalkableFloorAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetWalkableFloorAngle");

	Params::NpcMovementComponent_SetWalkableFloorAngle Parms{};

	Parms.InWalkableFloorAngle = InWalkableFloorAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.SetWalkableFloorZ
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWalkableFloorZ                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcMovementComponent::SetWalkableFloorZ(float InWalkableFloorZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "SetWalkableFloorZ");

	Params::NpcMovementComponent_SetWalkableFloorZ Parms{};

	Parms.InWalkableFloorZ = InWalkableFloorZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcMovementComponent.GetPerchRadiusThreshold
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNpcMovementComponent::GetPerchRadiusThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "GetPerchRadiusThreshold");

	Params::NpcMovementComponent_GetPerchRadiusThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcMovementComponent.GetValidPerchRadius
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UNpcMovementComponent::GetValidPerchRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcMovementComponent", "GetValidPerchRadius");

	Params::NpcMovementComponent_GetValidPerchRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.NpcTalkManager.FetchDataTable
// (Final, Native, Public)

void UNpcTalkManager::FetchDataTable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkManager", "FetchDataTable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkManager.OnLoadedPlayableCharacter
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      Param                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNpcTalkManager::OnLoadedPlayableCharacter(const struct FEventParam& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkManager", "OnLoadedPlayableCharacter");

	Params::NpcTalkManager_OnLoadedPlayableCharacter Parms{};

	Parms.Param = std::move(Param);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcTalkManager.OnPlayerChange
// (Final, Native, Public)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcTalkManager::OnPlayerChange(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcTalkManager", "OnPlayerChange");

	Params::NpcTalkManager_OnPlayerChange Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.LipSyncInfoObj.OnFinishedVoice
// (Final, Native, Public)
// Parameters:
// int32                                   Ch                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULipSyncInfoObj::OnFinishedVoice(int32 Ch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LipSyncInfoObj", "OnFinishedVoice");

	Params::LipSyncInfoObj_OnFinishedVoice Parms{};

	Parms.Ch = Ch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcVisibleMeshManager.OnBattleEnd
// (Final, Native, Private)

void UNpcVisibleMeshManager::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcVisibleMeshManager", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcVisibleMeshManager.OnBattleStart
// (Final, Native, Private)

void UNpcVisibleMeshManager::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcVisibleMeshManager", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcVisibleMeshManager.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcVisibleMeshManager::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcVisibleMeshManager", "OnDemoTiming");

	Params::NpcVisibleMeshManager_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.NpcVisibleMeshManager.OnTalkingEventsEnabled
// (Final, Native, Private)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNpcVisibleMeshManager::OnTalkingEventsEnabled(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NpcVisibleMeshManager", "OnTalkingEventsEnabled");

	Params::NpcVisibleMeshManager_OnTalkingEventsEnabled Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.PartyMenu.OnLoadWidget
// (Final, Native, Private)
// Parameters:
// class UATDataAssetUiAsyncLoad*          InLoader                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPartyMenu::OnLoadWidget(class UATDataAssetUiAsyncLoad* InLoader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyMenu", "OnLoadWidget");

	Params::PartyMenu_OnLoadWidget Parms{};

	Parms.InLoader = InLoader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.PlayerManager.StartFlyToWorldMap
// (Final, Native, Static, Public)

void UPlayerManager::StartFlyToWorldMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerManager", "StartFlyToWorldMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.PlayerManager.StartTeleportToWorldMap
// (Final, Native, Static, Public)

void UPlayerManager::StartTeleportToWorldMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerManager", "StartTeleportToWorldMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.PlayerManager.TransitionToWorldMap
// (Final, Native, Static, Public)

void UPlayerManager::TransitionToWorldMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerManager", "TransitionToWorldMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl024SkillSpecialParent.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl024SkillSpecialParent::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl024SkillSpecialParent", "OnSpawnProjectile");

	Params::Projectile_Cpl024SkillSpecialParent_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl040CrossClaw.OnCollisionOverlapBegin
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile_Cpl040CrossClaw::OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl040CrossClaw", "OnCollisionOverlapBegin");

	Params::Projectile_Cpl040CrossClaw_OnCollisionOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl058SkillBarrierMine.OnBattleEnd
// (Final, Native, Public)

void AProjectile_Cpl058SkillBarrierMine::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl058SkillBarrierMine", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl058SkillBarrierMineBarrier.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_Cpl058SkillBarrierMineBarrier::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl058SkillBarrierMineBarrier", "OnSpawnProjectile");

	Params::Projectile_Cpl058SkillBarrierMineBarrier_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_Cpl058SkillFloatMine.OnBattleEnd
// (Final, Native, Public)

void AProjectile_Cpl058SkillFloatMine::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_Cpl058SkillFloatMine", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_FallingBulletParent.OnSpawnProjectile
// (Final, Native, Public)
// Parameters:
// class AProjectile*                      InProjectile                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InOwner                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_FallingBulletParent::OnSpawnProjectile(class AProjectile* InProjectile, class AActor* InOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_FallingBulletParent", "OnSpawnProjectile");

	Params::Projectile_FallingBulletParent_OnSpawnProjectile Parms{};

	Parms.InProjectile = InProjectile;
	Parms.InOwner = InOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ATProjectile_NPA_DeluxeBomber.HitCollision
// (Native, Protected, HasOutParams)
// Parameters:
// struct FHitResult                       HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AATProjectile_NPA_DeluxeBomber::HitCollision(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ATProjectile_NPA_DeluxeBomber", "HitCollision");

	Params::ATProjectile_NPA_DeluxeBomber_HitCollision Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_NPA_ShockWave.OnCollisionOverlapBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AProjectile_NPA_ShockWave::OnCollisionOverlapBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_NPA_ShockWave", "OnCollisionOverlapBegin");

	Params::Projectile_NPA_ShockWave_OnCollisionOverlapBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Projectile_NPA_ShockWave.OnCollisionOverlapEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProjectile_NPA_ShockWave::OnCollisionOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Projectile_NPA_ShockWave", "OnCollisionOverlapEnd");

	Params::Projectile_NPA_ShockWave_OnCollisionOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.AddCharacterMoveStateChangedDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::AddCharacterMoveStateChangedDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "AddCharacterMoveStateChangedDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.AddMapIconOffset
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// EMapIcon                                InIconId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        InOffset                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::AddMapIconOffset(EMapIcon InIconId, const struct FVector2D& InOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "AddMapIconOffset");

	Params::Quest_General_AddMapIconOffset Parms{};

	Parms.InIconId = InIconId;
	Parms.InOffset = std::move(InOffset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.AddTresureDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::AddTresureDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "AddTresureDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.AddViewedTips
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InMasterId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::AddViewedTips(class FName InMasterId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "AddViewedTips");

	Params::Quest_General_AddViewedTips Parms{};

	Parms.InMasterId = InMasterId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.AreaChangeTrainingEnd
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::AreaChangeTrainingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "AreaChangeTrainingEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.DestroyAllQuestActor
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::DestroyAllQuestActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "DestroyAllQuestActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.DestroyQuestActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::DestroyQuestActor(const class FString& ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "DestroyQuestActor");

	Params::Quest_General_DestroyQuestActor Parms{};

	Parms.ID = std::move(ID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.EnablePhaseTimingCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Phase_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQUEST_GENERAL_TIMING                   Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::EnablePhaseTimingCheck(class FName Phase_id, EQUEST_GENERAL_TIMING Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "EnablePhaseTimingCheck");

	Params::Quest_General_EnablePhaseTimingCheck Parms{};

	Parms.Phase_id = Phase_id;
	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.ExecuteVisibledSubLevelEvent
// (Final, Native, Private)
// Parameters:
// class FName                             SubLevelName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::ExecuteVisibledSubLevelEvent(const class FName SubLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "ExecuteVisibledSubLevelEvent");

	Params::Quest_General_ExecuteVisibledSubLevelEvent Parms{};

	Parms.SubLevelName = SubLevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.GetPhaseId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AQuest_General::GetPhaseId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetPhaseId");

	Params::Quest_General_GetPhaseId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetPhaseIdImmediate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AQuest_General::GetPhaseIdImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetPhaseIdImmediate");

	Params::Quest_General_GetPhaseIdImmediate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetQuestPhaseParamObjectName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Phase_id                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AQuest_General::GetQuestPhaseParamObjectName(class FName Phase_id)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetQuestPhaseParamObjectName");

	Params::Quest_General_GetQuestPhaseParamObjectName Parms{};

	Parms.Phase_id = Phase_id;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetQuestSymbol
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AQuest_General::GetQuestSymbol()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetQuestSymbol");

	Params::Quest_General_GetQuestSymbol Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetVariableString2Message
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AQuest_General::GetVariableString2Message()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetVariableString2Message");

	Params::Quest_General_GetVariableString2Message Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetVariableString2Speaker
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AQuest_General::GetVariableString2Speaker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetVariableString2Speaker");

	Params::Quest_General_GetVariableString2Speaker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.IsDisableOpeningMainMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuest_General::IsDisableOpeningMainMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "IsDisableOpeningMainMenu");

	Params::Quest_General_IsDisableOpeningMainMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.MainQuestChangePhaseTiming
// (Final, Native, Public)
// Parameters:
// int32                                   New_phase                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::MainQuestChangePhaseTiming(int32 New_phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "MainQuestChangePhaseTiming");

	Params::Quest_General_MainQuestChangePhaseTiming Parms{};

	Parms.New_phase = New_phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.MoveScene
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             LevelName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::MoveScene(class FName LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "MoveScene");

	Params::Quest_General_MoveScene Parms{};

	Parms.LevelName = LevelName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.OnAddedItem
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             ItemId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnAddedItem(const class FName& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnAddedItem");

	Params::Quest_General_OnAddedItem Parms{};

	Parms.ItemId = ItemId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnAddedPartyMember
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnAddedPartyMember(int32 Index_0, ECHARACTER_TYPE CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnAddedPartyMember");

	Params::Quest_General_OnAddedPartyMember Parms{};

	Parms.Index_0 = Index_0;
	Parms.CharacterType = CharacterType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnAndroidAssaultSpawnable
// (Event, Public, BlueprintEvent)

void AQuest_General::OnAndroidAssaultSpawnable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnAndroidAssaultSpawnable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnBattleBegin
// (Event, Public, BlueprintEvent)

void AQuest_General::OnBattleBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnBattleBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnBattleEnd
// (Event, Public, BlueprintEvent)

void AQuest_General::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnBattleEnd");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnBattleSetup
// (Event, Public, BlueprintEvent)

void AQuest_General::OnBattleSetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnBattleSetup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnBeganSubQuestDirection
// (Event, Public, BlueprintEvent)
// Parameters:
// ESubQuestDirectionTiming                Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnBeganSubQuestDirection(ESubQuestDirectionTiming Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnBeganSubQuestDirection");

	Params::Quest_General_OnBeganSubQuestDirection Parms{};

	Parms.Timing = Timing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnBegin
// (Event, Public, BlueprintEvent)

void AQuest_General::OnBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnBonfireEvent
// (Event, Public, BlueprintEvent)

void AQuest_General::OnBonfireEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnBonfireEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnCallBPEventCommand
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnCallBPEventCommand(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCallBPEventCommand");

	Params::Quest_General_OnCallBPEventCommand Parms{};

	Parms.ID = ID;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnCancelSubQuest
// (Event, Public, BlueprintEvent)

void AQuest_General::OnCancelSubQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCancelSubQuest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnCancelSubQuestAfter
// (Event, Public, BlueprintEvent)

void AQuest_General::OnCancelSubQuestAfter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCancelSubQuestAfter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnCancelSubQuestTransition
// (Event, Public, BlueprintEvent)

void AQuest_General::OnCancelSubQuestTransition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCancelSubQuestTransition");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnChangedPlayer
// (Final, Native, Private)
// Parameters:
// class AAT_Character*                    Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnChangedPlayer(class AAT_Character* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnChangedPlayer");

	Params::Quest_General_OnChangedPlayer Parms{};

	Parms.Character = Character;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.OnChangedPlayerCharacter
// (Event, Public, BlueprintEvent)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnChangedPlayerCharacter(ECHARACTER_TYPE CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnChangedPlayerCharacter");

	Params::Quest_General_OnChangedPlayerCharacter Parms{};

	Parms.CharacterType = CharacterType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnChangedShopTrainingTiming
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bBegan                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnChangedShopTrainingTiming(bool bBegan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnChangedShopTrainingTiming");

	Params::Quest_General_OnChangedShopTrainingTiming Parms{};

	Parms.bBegan = bBegan;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnChangedTrainingTiming
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bBegan                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnChangedTrainingTiming(bool bBegan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnChangedTrainingTiming");

	Params::Quest_General_OnChangedTrainingTiming Parms{};

	Parms.bBegan = bBegan;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnCharacterMoveStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EATCharacterMoveState                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnCharacterMoveStateChanged(EATCharacterMoveState Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCharacterMoveStateChanged");

	Params::Quest_General_OnCharacterMoveStateChanged Parms{};

	Parms.Type = Type;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnClosedDoor
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInRoom                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DoorName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnClosedDoor(bool bInRoom, class FName DoorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnClosedDoor");

	Params::Quest_General_OnClosedDoor Parms{};

	Parms.bInRoom = bInRoom;
	Parms.DoorName = DoorName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnCloseMenu
// (Event, Public, BlueprintEvent)
// Parameters:
// EMenuType                               MenuType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECloseMenuReason                        CloseReason                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Param                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnCloseMenu(EMenuType MenuType, ECloseMenuReason CloseReason, const class FString& Param)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCloseMenu");

	Params::Quest_General_OnCloseMenu Parms{};

	Parms.MenuType = MenuType;
	Parms.CloseReason = CloseReason;
	Parms.Param = std::move(Param);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnCooking
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// EEventTimingType                        Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCooked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCompletedQuestPhase                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     CookedList                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AQuest_General::OnCooking(EEventTimingType Timing, bool bCooked, bool bCompletedQuestPhase, const TArray<class FName>& CookedList)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCooking");

	Params::Quest_General_OnCooking Parms{};

	Parms.Timing = Timing;
	Parms.bCooked = bCooked;
	Parms.bCompletedQuestPhase = bCompletedQuestPhase;
	Parms.CookedList = std::move(CookedList);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnCookingCanceled
// (Event, Public, BlueprintEvent)

void AQuest_General::OnCookingCanceled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCookingCanceled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnCookingExit
// (Event, Public, BlueprintEvent)

void AQuest_General::OnCookingExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCookingExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnCryingEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// EQuestCharacterBehaveState              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnCryingEvent(EQuestCharacterBehaveState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnCryingEvent");

	Params::Quest_General_OnCryingEvent Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnDefeatedEnemy
// (Event, Public, BlueprintEvent)
// Parameters:
// ECHARACTER_TYPE                         Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequireCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnDefeatedEnemy(ECHARACTER_TYPE Type, int32 CurrentCount, int32 RequireCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnDefeatedEnemy");

	Params::Quest_General_OnDefeatedEnemy Parms{};

	Parms.Type = Type;
	Parms.CurrentCount = CurrentCount;
	Parms.RequireCount = RequireCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ContinueFlag                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool ContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnDemoTiming");

	Params::Quest_General_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.ContinueFlag = ContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.OnDoorEvent
// (Event, Public, BlueprintEvent)

void AQuest_General::OnDoorEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnDoorEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnEventStart_UpdateQuestNavigation
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AQuest_General::OnEventStart_UpdateQuestNavigation(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnEventStart_UpdateQuestNavigation");

	Params::Quest_General_OnEventStart_UpdateQuestNavigation Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.OnExterminationBastionDestroy
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             BastionId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnExterminationBastionDestroy(class FName BastionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnExterminationBastionDestroy");

	Params::Quest_General_OnExterminationBastionDestroy Parms{};

	Parms.BastionId = BastionId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnGetTresure
// (Final, Native, Public)
// Parameters:
// class AActor*                           TresureActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnGetTresure(class AActor* TresureActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnGetTresure");

	Params::Quest_General_OnGetTresure Parms{};

	Parms.TresureActor = TresureActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.OnGetTresureEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TresureActor                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnGetTresureEvent(class AActor* TresureActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnGetTresureEvent");

	Params::Quest_General_OnGetTresureEvent Parms{};

	Parms.TresureActor = TresureActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnHunted
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             TargetID                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RequireNum                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnHunted(const class FName& TargetID, int32 CurrentNum, int32 RequireNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnHunted");

	Params::Quest_General_OnHunted Parms{};

	Parms.TargetID = TargetID;
	Parms.CurrentNum = CurrentNum;
	Parms.RequireNum = RequireNum;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnIngameBegan
// (Event, Public, BlueprintEvent)

void AQuest_General::OnIngameBegan()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnIngameBegan");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnInputPlayerMove
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             InputName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnInputPlayerMove(const class FName& InputName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnInputPlayerMove");

	Params::Quest_General_OnInputPlayerMove Parms{};

	Parms.InputName = InputName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnLoadCompleted
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   GenericFlg                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnLoadCompleted(int32 GenericFlg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnLoadCompleted");

	Params::Quest_General_OnLoadCompleted Parms{};

	Parms.GenericFlg = GenericFlg;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnLoadedPlayerIsInvalidLocation
// (Event, Public, BlueprintEvent)

void AQuest_General::OnLoadedPlayerIsInvalidLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnLoadedPlayerIsInvalidLocation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnMechaDevCanceled
// (Event, Public, BlueprintEvent)

void AQuest_General::OnMechaDevCanceled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnMechaDevCanceled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnMechaDevExit
// (Event, Public, BlueprintEvent)

void AQuest_General::OnMechaDevExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnMechaDevExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnOpenSimpleTalk
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             SimpleTalkId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             MessageId                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnOpenSimpleTalk(class FName SimpleTalkId, class FName MessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnOpenSimpleTalk");

	Params::Quest_General_OnOpenSimpleTalk Parms{};

	Parms.SimpleTalkId = SimpleTalkId;
	Parms.MessageId = MessageId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnReceiveSubQuest
// (Event, Public, BlueprintEvent)

void AQuest_General::OnReceiveSubQuest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnReceiveSubQuest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnSpawnedPartyMember
// (Event, Public, BlueprintEvent)
// Parameters:
// ECHARACTER_TYPE                         CharacterType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnSpawnedPartyMember(ECHARACTER_TYPE CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnSpawnedPartyMember");

	Params::Quest_General_OnSpawnedPartyMember Parms{};

	Parms.CharacterType = CharacterType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnTalkedQuestActor
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FName                             QuestActorName                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnTalkedQuestActor(const class FName& QuestActorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnTalkedQuestActor");

	Params::Quest_General_OnTalkedQuestActor Parms{};

	Parms.QuestActorName = QuestActorName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.OnTrainingCanceled
// (Event, Public, BlueprintEvent)

void AQuest_General::OnTrainingCanceled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnTrainingCanceled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnTrainingExit
// (Event, Public, BlueprintEvent)

void AQuest_General::OnTrainingExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnTrainingExit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.OnVisibledSubLevel
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             SubLevelName                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::OnVisibledSubLevel(const class FName SubLevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "OnVisibledSubLevel");

	Params::Quest_General_OnVisibledSubLevel Parms{};

	Parms.SubLevelName = SubLevelName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.PhaseEvent
// (Event, Public, BlueprintEvent)

void AQuest_General::PhaseEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "PhaseEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AT.Quest_General.PhaseRangeCheckBeginTimingOnly
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             InPhaseStartId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InPhaseEndId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuest_General::PhaseRangeCheckBeginTimingOnly(class FName InPhaseStartId, class FName InPhaseEndId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "PhaseRangeCheckBeginTimingOnly");

	Params::Quest_General_PhaseRangeCheckBeginTimingOnly Parms{};

	Parms.InPhaseStartId = InPhaseStartId;
	Parms.InPhaseEndId = InPhaseEndId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.PhaseTimingCheck
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             PhaseID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQUEST_GENERAL_TIMING                   Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuest_General::PhaseTimingCheck(class FName PhaseID, EQUEST_GENERAL_TIMING Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "PhaseTimingCheck");

	Params::Quest_General_PhaseTimingCheck Parms{};

	Parms.PhaseID = PhaseID;
	Parms.Timing = Timing;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.PhaseTimingCheckFromList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FName>                     PhaseIdList                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// EQUEST_GENERAL_TIMING                   Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FunctionId                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AQuest_General::PhaseTimingCheckFromList(const TArray<class FName>& PhaseIdList, EQUEST_GENERAL_TIMING Timing, const class FName& FunctionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "PhaseTimingCheckFromList");

	Params::Quest_General_PhaseTimingCheckFromList Parms{};

	Parms.PhaseIdList = std::move(PhaseIdList);
	Parms.Timing = Timing;
	Parms.FunctionId = FunctionId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.ReceiveDemoEvent
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       Timing                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::ReceiveDemoEvent(class FName DemoName, EDEMO_TIMING_TYPE Timing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "ReceiveDemoEvent");

	Params::Quest_General_ReceiveDemoEvent Parms{};

	Parms.DemoName = DemoName;
	Parms.Timing = Timing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AT.Quest_General.RemoveBattleEndDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::RemoveBattleEndDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "RemoveBattleEndDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.RemoveCharacterChangeDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::RemoveCharacterChangeDelegate(class FName UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "RemoveCharacterChangeDelegate");

	Params::Quest_General_RemoveCharacterChangeDelegate Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.RemoveCharacterMoveStateChangedDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::RemoveCharacterMoveStateChangedDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "RemoveCharacterMoveStateChangedDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.RemoveMapIconOffset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMapIcon                                InIconId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::RemoveMapIconOffset(EMapIcon InIconId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "RemoveMapIconOffset");

	Params::Quest_General_RemoveMapIconOffset Parms{};

	Parms.InIconId = InIconId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.RemoveTresureDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::RemoveTresureDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "RemoveTresureDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.ResetTimingObserverInterval
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InTimingObserver                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::ResetTimingObserverInterval(class AActor* InTimingObserver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "ResetTimingObserverInterval");

	Params::Quest_General_ResetTimingObserverInterval Parms{};

	Parms.InTimingObserver = InTimingObserver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SetBattleEndDelegate
// (Final, Native, Public, BlueprintCallable)

void AQuest_General::SetBattleEndDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SetBattleEndDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SetCharacterChangeDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             UniqueId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::SetCharacterChangeDelegate(class FName UniqueId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SetCharacterChangeDelegate");

	Params::Quest_General_SetCharacterChangeDelegate Parms{};

	Parms.UniqueId = UniqueId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SetDisableNavigation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::SetDisableNavigation(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SetDisableNavigation");

	Params::Quest_General_SetDisableNavigation Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SetGenericFlg
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Flg                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::SetGenericFlg(int32 Flg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SetGenericFlg");

	Params::Quest_General_SetGenericFlg Parms{};

	Parms.Flg = Flg;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SetVariableStringMessageId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           MessageId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::SetVariableStringMessageId(const class FString& MessageId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SetVariableStringMessageId");

	Params::Quest_General_SetVariableStringMessageId Parms{};

	Parms.MessageId = std::move(MessageId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SetVisibilityMenuBG
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bIsVisibe                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AQuest_General::SetVisibilityMenuBG(const bool bIsVisibe)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SetVisibilityMenuBG");

	Params::Quest_General_SetVisibilityMenuBG Parms{};

	Parms.bIsVisibe = bIsVisibe;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.Quest_General.SpawnQuestActor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           ID                                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ClassName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       Transform                                              (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AQuest_General::SpawnQuestActor(const class FString& ID, class UClass* ClassName, const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "SpawnQuestActor");

	Params::Quest_General_SpawnQuestActor Parms{};

	Parms.ID = std::move(ID);
	Parms.ClassName = ClassName;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetGenericFlg
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AQuest_General::GetGenericFlg() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetGenericFlg");

	Params::Quest_General_GetGenericFlg Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.GetVariableStringMessageId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString AQuest_General::GetVariableStringMessageId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "GetVariableStringMessageId");

	Params::Quest_General_GetVariableStringMessageId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.Quest_General.TryExecuteTutorialForDLC6ExtraMode
// (Final, Native, Public, BlueprintCallable, Const)

void AQuest_General::TryExecuteTutorialForDLC6ExtraMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Quest_General", "TryExecuteTutorialForDLC6ExtraMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UQuestMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestMenu", "MouseClickDecide");

	Params::QuestMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestMenu.MouseClickTabLeft
// (Final, Native, Public)

void UQuestMenu::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestMenu", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestMenu.MouseClickTabRight
// (Final, Native, Public)

void UQuestMenu::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestMenu", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_BattleEnd.OnBattleEnd
// (Final, Native, Public)
// Parameters:
// class FName                             ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestPhase_BattleEnd::OnBattleEnd(class FName ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_BattleEnd", "OnBattleEnd");

	Params::QuestPhase_BattleEnd_OnBattleEnd Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.QuestPhase_Demo.OnDemoTiming
// (Final, Native, Private)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             DemoName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueFlag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UQuestPhase_Demo::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName DemoName, bool bContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("QuestPhase_Demo", "OnDemoTiming");

	Params::QuestPhase_Demo_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.DemoName = DemoName;
	Parms.bContinueFlag = bContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RaceGameManager.GetRetireFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URaceGameManager::GetRetireFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaceGameManager", "GetRetireFlag");

	Params::RaceGameManager_GetRetireFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RaceGameManager.GetTimeUpFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URaceGameManager::GetTimeUpFlag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RaceGameManager", "GetTimeUpFlag");

	Params::RaceGameManager_GetTimeUpFlag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.CalcCylinderBoneScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bRight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector URideAnimInstance::CalcCylinderBoneScale(bool bRight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "CalcCylinderBoneScale");

	Params::RideAnimInstance_CalcCylinderBoneScale Parms{};

	Parms.bRight = bRight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.CalcPistonBoneRocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bRight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpper                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator URideAnimInstance::CalcPistonBoneRocation(bool bRight, bool bUpper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "CalcPistonBoneRocation");

	Params::RideAnimInstance_CalcPistonBoneRocation Parms{};

	Parms.bRight = bRight;
	Parms.bUpper = bUpper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.GetTwinFootCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ATwinFoot*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ATwinFoot* URideAnimInstance::GetTwinFootCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "GetTwinFootCharacter");

	Params::RideAnimInstance_GetTwinFootCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsFall
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsFall()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsFall");

	Params::RideAnimInstance_IsFall Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsJump
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsJump");

	Params::RideAnimInstance_IsJump Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsJumpAnt
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsJumpAnt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsJumpAnt");

	Params::RideAnimInstance_IsJumpAnt Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsLand
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsLand");

	Params::RideAnimInstance_IsLand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsOwnerCharaMachine
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsOwnerCharaMachine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsOwnerCharaMachine");

	Params::RideAnimInstance_IsOwnerCharaMachine Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsRun
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsRun");

	Params::RideAnimInstance_IsRun Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsStand
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsStand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsStand");

	Params::RideAnimInstance_IsStand Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.IsWalk
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URideAnimInstance::IsWalk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "IsWalk");

	Params::RideAnimInstance_IsWalk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.RideAnimInstance.UpdateAfterIK
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InDTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URideAnimInstance::UpdateAfterIK(float InDTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideAnimInstance", "UpdateAfterIK");

	Params::RideAnimInstance_UpdateAfterIK Parms{};

	Parms.InDTime = InDTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RideManager.OnLoadCompleted
// (Final, Native, Private)

void URideManager::OnLoadCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideManager", "OnLoadCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.RideManager.OnNormalEncounterStart
// (Final, Native, Public)

void URideManager::OnNormalEncounterStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RideManager", "OnNormalEncounterStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.RootMenu.CheckHovered
// (Final, Native, Public)

void URootMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.RootMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URootMenu::MouseClickDecide(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMenu", "MouseClickDecide");

	Params::RootMenu_MouseClickDecide Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RootMenu.MouseClickYB
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void URootMenu::MouseClickYB(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMenu", "MouseClickYB");

	Params::RootMenu_MouseClickYB Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RootMenu.OnSelectItem
// (Final, Native, Private)
// Parameters:
// int32                                   SELECT                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMenu::OnSelectItem(int32 SELECT)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMenu", "OnSelectItem");

	Params::RootMenu_OnSelectItem Parms{};

	Parms.SELECT = SELECT;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RootMenu.PlayTownBGMWhenMainMenuRetryOpenModeWasFadeOut
// (Final, Native, Public)
// Parameters:
// bool                                    bIsFadeIn                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URootMenu::PlayTownBGMWhenMainMenuRetryOpenModeWasFadeOut(bool bIsFadeIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMenu", "PlayTownBGMWhenMainMenuRetryOpenModeWasFadeOut");

	Params::RootMenu_PlayTownBGMWhenMainMenuRetryOpenModeWasFadeOut Parms{};

	Parms.bIsFadeIn = bIsFadeIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.RootMenu.ShowKeyHelp
// (Final, Native, Public)

void URootMenu::ShowKeyHelp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RootMenu", "ShowKeyHelp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SaveMenu.CheckHovered
// (Final, Native, Private)

void USaveMenu::CheckHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMenu", "CheckHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.SaveMenu.MouseClickDecide
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USaveMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMenu", "MouseClickDecide");

	Params::SaveMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SaveMenu.MouseWheel
// (Final, Native, Private)
// Parameters:
// float                                   InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USaveMenu::MouseWheel(float InDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SaveMenu", "MouseWheel");

	Params::SaveMenu_MouseWheel Parms{};

	Parms.InDirection = InDirection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.SpawnerFruitVolume.OnChangeProgress
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASpawnerFruitVolume::OnChangeProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnerFruitVolume", "OnChangeProgress");

	Params::SpawnerFruitVolume_OnChangeProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecoratePhotonEntity.OnLevelRemoved
// (Final, Native, Public)
// Parameters:
// class ULevel*                           InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTerrainDecoratePhotonEntity::OnLevelRemoved(class ULevel* InLevel, class UWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecoratePhotonEntity", "OnLevelRemoved");

	Params::TerrainDecoratePhotonEntity_OnLevelRemoved Parms{};

	Parms.InLevel = InLevel;
	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecoratePhotonEntity.OnRent
// (Native, Event, Public, BlueprintEvent)

void UTerrainDecoratePhotonEntity::OnRent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecoratePhotonEntity", "OnRent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecoratePhotonEntity.OnReturn
// (Native, Event, Public, BlueprintEvent)

void UTerrainDecoratePhotonEntity::OnReturn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecoratePhotonEntity", "OnReturn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateManager.CompleteAsyncLoadingGroundBattleResources
// (Final, Native, Private)

void UTerrainDecorateManager::CompleteAsyncLoadingGroundBattleResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateManager", "CompleteAsyncLoadingGroundBattleResources");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateManager.CompleteAsyncLoadingMultiColorData
// (Final, Native, Private)

void UTerrainDecorateManager::CompleteAsyncLoadingMultiColorData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateManager", "CompleteAsyncLoadingMultiColorData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateManager.CompleteAsyncLoadingUniqueResources
// (Final, Native, Private)

void UTerrainDecorateManager::CompleteAsyncLoadingUniqueResources()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateManager", "CompleteAsyncLoadingUniqueResources");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateManager.DeactivateAllEntities
// (Final, Native, Public)

void UTerrainDecorateManager::DeactivateAllEntities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateManager", "DeactivateAllEntities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TerrainDecorateManager.ForbidCreatingPhoton
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeneralTalkEventArgment         GeneralTalkEvent                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UTerrainDecorateManager::ForbidCreatingPhoton(const struct FGeneralTalkEventArgment& GeneralTalkEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TerrainDecorateManager", "ForbidCreatingPhoton");

	Params::TerrainDecorateManager_ForbidCreatingPhoton Parms{};

	Parms.GeneralTalkEvent = std::move(GeneralTalkEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TestFieldBGMTriggerBox.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       OverlapInfo                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ATestFieldBGMTriggerBox::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& OverlapInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestFieldBGMTriggerBox", "OnBeginOverlap");

	Params::TestFieldBGMTriggerBox_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.OverlapInfo = std::move(OverlapInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TestFieldBGMTriggerBox.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestFieldBGMTriggerBox::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestFieldBGMTriggerBox", "OnEndOverlap");

	Params::TestFieldBGMTriggerBox_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TestFieldBGMTriggerBox.OnOverlapBegin
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestFieldBGMTriggerBox::OnOverlapBegin(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestFieldBGMTriggerBox", "OnOverlapBegin");

	Params::TestFieldBGMTriggerBox_OnOverlapBegin Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TestFieldBGMTriggerBox.OnOverlapEnd
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATestFieldBGMTriggerBox::OnOverlapEnd(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestFieldBGMTriggerBox", "OnOverlapEnd");

	Params::TestFieldBGMTriggerBox_OnOverlapEnd Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TestStartBGMActor.OnCompletedInitialize
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FEventParam                      EventParam                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ATestStartBGMActor::OnCompletedInitialize(const struct FEventParam& EventParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TestStartBGMActor", "OnCompletedInitialize");

	Params::TestStartBGMActor_OnCompletedInitialize Parms{};

	Parms.EventParam = std::move(EventParam);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TipsMenu.MouseClickDecide
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGeometry                        InGeometry                                             (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    InMouseEvent                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UTipsMenu::MouseClickDecide(const struct FGeometry& InGeometry, const struct FPointerEvent& InMouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsMenu", "MouseClickDecide");

	Params::TipsMenu_MouseClickDecide Parms{};

	Parms.InGeometry = std::move(InGeometry);
	Parms.InMouseEvent = std::move(InMouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TipsMenu.MouseClickTabLeft
// (Final, Native, Public)

void UTipsMenu::MouseClickTabLeft()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsMenu", "MouseClickTabLeft");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TipsMenu.MouseClickTabRight
// (Final, Native, Public)

void UTipsMenu::MouseClickTabRight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TipsMenu", "MouseClickTabRight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TitleHud.DrawLoadHud
// (Final, Native, Public, BlueprintCallable)

void ATitleHud::DrawLoadHud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleHud", "DrawLoadHud");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TitleHud.GetMapInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Quest_phase                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ATitleHud::GetMapInfo(int32 Index_0, int32 Quest_phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleHud", "GetMapInfo");

	Params::TitleHud_GetMapInfo Parms{};

	Parms.Index_0 = Index_0;
	Parms.Quest_phase = Quest_phase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TitleHud.IsSystemLoaded
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATitleHud::IsSystemLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleHud", "IsSystemLoaded");

	Params::TitleHud_IsSystemLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TitleHud.SystemLoadRequest
// (Final, Native, Public, BlueprintCallable)

void ATitleHud::SystemLoadRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TitleHud", "SystemLoadRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TownMobComponent.OnCollisionHit_FromOwner
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTownMobComponent::OnCollisionHit_FromOwner(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TownMobComponent", "OnCollisionHit_FromOwner");

	Params::TownMobComponent_OnCollisionHit_FromOwner Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TownMobComponent.OnFinishedTalking_Call
// (Final, Native, Public)

void UTownMobComponent::OnFinishedTalking_Call()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TownMobComponent", "OnFinishedTalking_Call");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TownMobComponent.OnMontageEnded_Greeting_Call
// (Native, Public)
// Parameters:
// class UAnimMontage*                     PMontage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTownMobComponent::OnMontageEnded_Greeting_Call(class UAnimMontage* PMontage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TownMobComponent", "OnMontageEnded_Greeting_Call");

	Params::TownMobComponent_OnMontageEnded_Greeting_Call Parms{};

	Parms.PMontage = PMontage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TownMobComponent.OnStartTalking_Call
// (Final, Native, Public)

void UTownMobComponent::OnStartTalking_Call()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TownMobComponent", "OnStartTalking_Call");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TreasureAccessPointTable.GetTreasureAccessPointTable
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           AWorld                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTreasureAccessPointTable*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTreasureAccessPointTable* UTreasureAccessPointTable::GetTreasureAccessPointTable(class UWorld* AWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TreasureAccessPointTable", "GetTreasureAccessPointTable");

	Params::TreasureAccessPointTable_GetTreasureAccessPointTable Parms{};

	Parms.AWorld = AWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.TreasureManager.OnChangePhase
// (Final, Native, Public)
// Parameters:
// int32                                   PhaseNo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTreasureManager::OnChangePhase(int32 PhaseNo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureManager", "OnChangePhase");

	Params::TreasureManager_OnChangePhase Parms{};

	Parms.PhaseNo = PhaseNo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TreasureManager.OnChangeProgress
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             ProgressID                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTreasureManager::OnChangeProgress(const class FName& ProgressID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TreasureManager", "OnChangeProgress");

	Params::TreasureManager_OnChangeProgress Parms{};

	Parms.ProgressID = ProgressID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerBoxPerceptionAI.AreaIn
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerBoxPerceptionAI::AreaIn(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerBoxPerceptionAI", "AreaIn");

	Params::TriggerBoxPerceptionAI_AreaIn Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerBoxPerceptionAI.AreaOut
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerBoxPerceptionAI::AreaOut(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerBoxPerceptionAI", "AreaOut");

	Params::TriggerBoxPerceptionAI_AreaOut Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActorBox.OnBattleEnd
// (Final, Native, Public)

void ATriggerStaticActorBox::OnBattleEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActorBox", "OnBattleEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActorBox.OnBattleStart
// (Final, Native, Public)

void ATriggerStaticActorBox::OnBattleStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActorBox", "OnBattleStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActorBox.OnTouchBoxCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerStaticActorBox::OnTouchBoxCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActorBox", "OnTouchBoxCollision");

	Params::TriggerStaticActorBox_OnTouchBoxCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TriggerStaticActorBox.OnUntouchBoxCollision
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATriggerStaticActorBox::OnUntouchBoxCollision(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TriggerStaticActorBox", "OnUntouchBoxCollision");

	Params::TriggerStaticActorBox_OnUntouchBoxCollision Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TwinFootMoveState.OnLanded
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FHitResult                       InHit                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UTwinFootMoveState::OnLanded(const struct FHitResult& InHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwinFootMoveState", "OnLanded");

	Params::TwinFootMoveState_OnLanded Parms{};

	Parms.InHit = std::move(InHit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TwinFootMoveState.OnMovementModeChanged
// (Final, Native, Public)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UTwinFootMoveState::OnMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwinFootMoveState", "OnMovementModeChanged");

	Params::TwinFootMoveState_OnMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.TwinFootMoveState.OnReachedJumpApex
// (Final, Native, Public)

void UTwinFootMoveState::OnReachedJumpApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TwinFootMoveState", "OnReachedJumpApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.ChangeCamera
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Playflag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::ChangeCamera(bool Playflag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "ChangeCamera");

	Params::ZCW_BookActor_ChangeCamera Parms{};

	Parms.Playflag = Playflag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.ChangeTexture
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EZCW_BookPage                           Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Tex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        TexCoord                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::ChangeTexture(EZCW_BookPage Page, class UTexture* Tex, const struct FVector2D& TexCoord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "ChangeTexture");

	Params::ZCW_BookActor_ChangeTexture Parms{};

	Parms.Page = Page;
	Parms.Tex = Tex;
	Parms.TexCoord = std::move(TexCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.CloseBook
// (Final, Native, Public, BlueprintCallable)

void AZCW_BookActor::CloseBook()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "CloseBook");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.GetCameraPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AZCW_BookActor::GetCameraPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "GetCameraPosition");

	Params::ZCW_BookActor_GetCameraPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ZCW_BookActor.GetCameraRotation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator AZCW_BookActor::GetCameraRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "GetCameraRotation");

	Params::ZCW_BookActor_GetCameraRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ZCW_BookActor.GetSkyLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkyLightComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkyLightComponent* AZCW_BookActor::GetSkyLight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "GetSkyLight");

	Params::ZCW_BookActor_GetSkyLight Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ZCW_BookActor.GetSpotLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USpotLightComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USpotLightComponent* AZCW_BookActor::GetSpotLight(bool Left)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "GetSpotLight");

	Params::ZCW_BookActor_GetSpotLight Parms{};

	Parms.Left = Left;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ZCW_BookActor.IsPlayingAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AZCW_BookActor::IsPlayingAnimation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "IsPlayingAnimation");

	Params::ZCW_BookActor_IsPlayingAnimation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AT.ZCW_BookActor.OpenBook
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LeftCoord                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RightCoord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::OpenBook(class UTexture* Left, const struct FVector2D& LeftCoord, class UTexture* Right, const struct FVector2D& RightCoord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "OpenBook");

	Params::ZCW_BookActor_OpenBook Parms{};

	Parms.Left = Left;
	Parms.LeftCoord = std::move(LeftCoord);
	Parms.Right = Right;
	Parms.RightCoord = std::move(RightCoord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SetCameraPosition
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Pos                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SetCameraPosition(const struct FVector& Pos)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SetCameraPosition");

	Params::ZCW_BookActor_SetCameraPosition Parms{};

	Parms.Pos = std::move(Pos);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SetCameraRotation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FRotator                         Rot                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void AZCW_BookActor::SetCameraRotation(const struct FRotator& Rot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SetCameraRotation");

	Params::ZCW_BookActor_SetCameraRotation Parms{};

	Parms.Rot = std::move(Rot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SkipBackPage
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LeftCoord                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RightCoord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    One                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    baseChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SkipBackPage(class UTexture* Left, const struct FVector2D& LeftCoord, class UTexture* Right, const struct FVector2D& RightCoord, bool One, bool baseChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SkipBackPage");

	Params::ZCW_BookActor_SkipBackPage Parms{};

	Parms.Left = Left;
	Parms.LeftCoord = std::move(LeftCoord);
	Parms.Right = Right;
	Parms.RightCoord = std::move(RightCoord);
	Parms.One = One;
	Parms.baseChange = baseChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SkipBackPages
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LeftCoord                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RightCoord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    baseChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SkipBackPages(class UTexture* Left, const struct FVector2D& LeftCoord, class UTexture* Right, const struct FVector2D& RightCoord, int32 Count, bool baseChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SkipBackPages");

	Params::ZCW_BookActor_SkipBackPages Parms{};

	Parms.Left = Left;
	Parms.LeftCoord = std::move(LeftCoord);
	Parms.Right = Right;
	Parms.RightCoord = std::move(RightCoord);
	Parms.Count = Count;
	Parms.baseChange = baseChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SkipNextPage
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LeftCoord                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RightCoord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    One                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    baseChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SkipNextPage(class UTexture* Left, const struct FVector2D& LeftCoord, class UTexture* Right, const struct FVector2D& RightCoord, bool One, bool baseChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SkipNextPage");

	Params::ZCW_BookActor_SkipNextPage Parms{};

	Parms.Left = Left;
	Parms.LeftCoord = std::move(LeftCoord);
	Parms.Right = Right;
	Parms.RightCoord = std::move(RightCoord);
	Parms.One = One;
	Parms.baseChange = baseChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SkipNextPages
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        LeftCoord                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         Right                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        RightCoord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    baseChange                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SkipNextPages(class UTexture* Left, const struct FVector2D& LeftCoord, class UTexture* Right, const struct FVector2D& RightCoord, int32 Count, bool baseChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SkipNextPages");

	Params::ZCW_BookActor_SkipNextPages Parms{};

	Parms.Left = Left;
	Parms.LeftCoord = std::move(LeftCoord);
	Parms.Right = Right;
	Parms.RightCoord = std::move(RightCoord);
	Parms.Count = Count;
	Parms.baseChange = baseChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SlideMemoIn
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UTexture*                         Tex                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        TexCoord                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SlideMemoIn(class UTexture* Tex, const struct FVector2D& TexCoord, bool Left)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SlideMemoIn");

	Params::ZCW_BookActor_SlideMemoIn Parms{};

	Parms.Tex = Tex;
	Parms.TexCoord = std::move(TexCoord);
	Parms.Left = Left;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SlideMemoOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Left                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SlideMemoOut(bool Left)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SlideMemoOut");

	Params::ZCW_BookActor_SlideMemoOut Parms{};

	Parms.Left = Left;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SwichLeftLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SwichLeftLight(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SwichLeftLight");

	Params::ZCW_BookActor_SwichLeftLight Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_BookActor.SwichRightLight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_BookActor::SwichRightLight(bool Flag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_BookActor", "SwichRightLight");

	Params::ZCW_BookActor_SwichRightLight Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AT.ZCW_PreRenderDemoActor.OnDemoTiming
// (Final, Native, Public)
// Parameters:
// EDEMO_TYPE                              DemoType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDEMO_TIMING_TYPE                       DemoTiming                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InDemoName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bContinueFlag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AZCW_PreRenderDemoActor::OnDemoTiming(EDEMO_TYPE DemoType, EDEMO_TIMING_TYPE DemoTiming, class FName InDemoName, bool bContinueFlag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ZCW_PreRenderDemoActor", "OnDemoTiming");

	Params::ZCW_PreRenderDemoActor_OnDemoTiming Parms{};

	Parms.DemoType = DemoType;
	Parms.DemoTiming = DemoTiming;
	Parms.InDemoName = InDemoName;
	Parms.bContinueFlag = bContinueFlag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

