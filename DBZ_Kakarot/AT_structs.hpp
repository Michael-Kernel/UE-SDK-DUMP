#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AT

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "AnimGraphRuntime_structs.hpp"
#include "CFramework_structs.hpp"


namespace SDK
{

// Enum AT.EFISHING_TIMING_TYPE
// NumValues: 0x0003
enum class EFISHING_TIMING_TYPE : uint8
{
	OVERRIDE_FISHING_VOLUME_BEGIN            = 0,
	OVERRIDE_FISHING_VOLUME_END              = 1,
	OVERRIDE_FISHING_VOLUME_MAX              = 2,
};

// Enum AT.EDEMO_TIMING_TYPE
// NumValues: 0x000B
enum class EDEMO_TIMING_TYPE : uint8
{
	NONE                                     = 0,
	BEGIN                                    = 1,
	END                                      = 2,
	SKIP                                     = 3,
	INTERRUPT_BEGIN                          = 4,
	INTERRUPT_END                            = 5,
	BEGIN_DIRECTION                          = 6,
	END_DIRECTION                            = 7,
	AFTER_DIRECTION                          = 8,
	INGAME_CAM_BLEND_START                   = 9,
	MAX                                      = 10,
};

// Enum AT.EDEMO_TYPE
// NumValues: 0x0006
enum class EDEMO_TYPE : uint8
{
	NONE                                     = 0,
	CINEMA_DEMO                              = 1,
	INGAME_DEMO                              = 2,
	GENERAL_DEMO                             = 3,
	PRERENDER_DEMO                           = 4,
	MAX                                      = 5,
};

// Enum AT.EQUEST_ACTOR_TIMING_TYPE
// NumValues: 0x0005
enum class EQUEST_ACTOR_TIMING_TYPE : uint8
{
	ACTIVE_MAIN_QUEST_ACTOR_ADD              = 0,
	ACTIVE_MAIN_QUEST_ACTOR_REMOVE           = 1,
	ACTIVE_SUB_QUEST_ACTOR_ADD               = 2,
	ACTIVE_SUB_QUEST_ACTOR_REMOVE            = 3,
	ACTIVE_MAX                               = 4,
};

// Enum AT.EMinigameState
// NumValues: 0x0004
enum class EMinigameState : uint8
{
	Begin                                    = 0,
	PlayGame                                 = 1,
	End                                      = 2,
	EMinigameState_MAX                       = 3,
};

// Enum AT.EMECHA_DEV_TIMING
// NumValues: 0x0004
enum class EMECHA_DEV_TIMING : uint8
{
	NONE                                     = 0,
	BEGIN                                    = 1,
	END                                      = 2,
	MAX                                      = 3,
};

// Enum AT.EBattleCutin_AnimType
// NumValues: 0x0007
enum class EBattleCutin_AnimType : uint8
{
	NONE                                     = 0,
	BATTLE                                   = 1,
	FINISH                                   = 2,
	BACK_ATTACK                              = 3,
	ESCAPE                                   = 4,
	STAR_SCALE_FINISH                        = 5,
	MAX                                      = 6,
};

// Enum AT.EEventBattleResult
// NumValues: 0x0006
enum class EEventBattleResult : uint8
{
	None                                     = 0,
	Clear                                    = 1,
	Retry                                    = 2,
	Retire                                   = 3,
	Lose                                     = 4,
	EEventBattleResult_MAX                   = 5,
};

// Enum AT.EQUEST_UI_ACTIVE_TIMING
// NumValues: 0x0003
enum class EQUEST_UI_ACTIVE_TIMING : uint8
{
	START                                    = 0,
	END                                      = 1,
	EQUEST_UI_ACTIVE_MAX                     = 2,
};

// Enum AT.EGameoverSelectType
// NumValues: 0x0009
enum class EGameoverSelectType : uint32
{
	RetryBattle                              = 0,
	ExitTraining                             = 1,
	ExitLearning                             = 2,
	ExitChallengeToGodOfDestruction          = 3,
	ExitChallengeFreezerF                    = 4,
	LoadSaveData                             = 5,
	BackToTitle                              = 6,
	ExitRetire                               = 7,
	EGameoverSelectType_MAX                  = 8,
};

// Enum AT.EInteractAccessPointType
// NumValues: 0x0003
enum class EInteractAccessPointType : uint8
{
	Type_Mesh                                = 0,
	Type_Skeletal                            = 1,
	Type_MAX                                 = 2,
};

// Enum AT.EAccessPointState
// NumValues: 0x000D
enum class EAccessPointState : uint8
{
	State_Wait                               = 0,
	State_UIWait                             = 1,
	State_PlayerStopWait                     = 2,
	State_PlayerActionStart                  = 3,
	State_PlayerActionWait                   = 4,
	State_PlayerActionComplete               = 5,
	State_DemoStart                          = 6,
	State_DemoWait                           = 7,
	State_ItemSpawn                          = 8,
	State_ItemWait                           = 9,
	State_EndActionWait                      = 10,
	State_Taken                              = 11,
	State_MAX                                = 12,
};

// Enum AT.ACCOMPANYAI_MOVE_RIDE
// NumValues: 0x0004
enum class EACCOMPANYAI_MOVE_RIDE : uint8
{
	NONE                                     = 0,
	WAIT                                     = 1,
	END                                      = 2,
	ACCOMPANYAI_MOVE_MAX                     = 3,
};

// Enum AT.ACCOMPANYAI_MOVE_ACTION
// NumValues: 0x0009
enum class EACCOMPANYAI_MOVE_ACTION : uint8
{
	NONE                                     = 0,
	WAIT                                     = 1,
	JUMP                                     = 2,
	FALL                                     = 3,
	JUMP_FLOAT                               = 4,
	FLOAT                                    = 5,
	STANDBOOST                               = 6,
	WARP                                     = 7,
	ACCOMPANYAI_MOVE_MAX                     = 8,
};

// Enum AT.ACCOMPANY_MOVE_SEQ_LAND
// NumValues: 0x0007
enum class EACCOMPANY_MOVE_SEQ_LAND : uint8
{
	_WAIT                                    = 0,
	_MOVE                                    = 1,
	_JUMP                                    = 2,
	_FALL                                    = 3,
	_FLOATMOVE                               = 4,
	_WARP                                    = 5,
	ACCOMPANY_MOVE_SEQ_LAND_MAX              = 6,
};

// Enum AT.ACCOMPANY_MOVE_SEQ
// NumValues: 0x000A
enum class EACCOMPANY_MOVE_SEQ : uint8
{
	SEQ_WAIT                                 = 0,
	SEQ_MOVE                                 = 1,
	SEQ_AUTO                                 = 2,
	SEQ_PREBRAKE                             = 3,
	SEQ_BRAKE                                = 4,
	SEQ_STOP                                 = 5,
	SEQ_ONGROUND                             = 6,
	SEQ_UPDOWN                               = 7,
	SEQ_FALING                               = 8,
	SEQ_MAX                                  = 9,
};

// Enum AT.E_AI_VOLUMETYPE
// NumValues: 0x0008
enum class E_AI_VOLUMETYPE : uint8
{
	NONE                                     = 0,
	SHORT_ATK                                = 1,
	LONG_ATK                                 = 2,
	FAST_MOVING                              = 3,
	SKILL_SHORT                              = 4,
	SKILL_LOMG                               = 5,
	SKILL_FAST_MOVING                        = 6,
	E_AI_MAX                                 = 7,
};

// Enum AT.E_AI_CONDITIONAL_EXPRESSION
// NumValues: 0x0004
enum class E_AI_CONDITIONAL_EXPRESSION : uint8
{
	NONE                                     = 0,
	AND                                      = 1,
	OR                                       = 2,
	E_AI_CONDITIONAL_MAX                     = 3,
};

// Enum AT.E_AI_TARGET
// NumValues: 0x000D
enum class E_AI_TARGET : uint8
{
	NONE                                     = 0,
	HIMSELF                                  = 1,
	PLAYER                                   = 2,
	HIMSELF_TARGET                           = 3,
	MOST_HP_HIGT_FRIEND                      = 4,
	MOST_HP_LOW_FRIEND                       = 5,
	MOST_ATK_HIGT_FRIEND                     = 6,
	MOST_ATK_LOW_FRIEND                      = 7,
	SAME_TARGET                              = 8,
	RANDOM_FRIEND                            = 9,
	FRIEND                                   = 10,
	ENEMY                                    = 11,
	E_AI_MAX                                 = 12,
};

// Enum AT.E_AI_CONDITIONS_GROUP
// NumValues: 0x0045
enum class E_AI_CONDITIONS_GROUP : uint8
{
	NONE                                     = 0,
	HP_XX_OVER                               = 1,
	HP_XX_UNDER                              = 2,
	HP_XX_LESSTHAN                           = 3,
	MP_XX_OVER                               = 4,
	MP_XX_UNDER                              = 5,
	MP_XX_LESSTHAN                           = 6,
	BREAK_XX_OVER                            = 7,
	BREAK_XX_UNDER                           = 8,
	BREAK_XX_LESSTHAN                        = 9,
	TARGET_XXM_OVER                          = 10,
	TARGET_XXM_UNDER                         = 11,
	TARGET_XXM_LESSTHAN                      = 12,
	TARGET_XXNUM_OVER                        = 13,
	TARGET_XXNUM_UNDER                       = 14,
	TARGET_XXNUM_LESSTHAN                    = 15,
	TARGET_SKILL_INVOCATION                  = 16,
	TARGET_SKILL_NONE                        = 17,
	TARGET_RESTRAINT_SKILL                   = 18,
	TARGET_LONG_SKILL                        = 19,
	TARGET_SHORT_SKILL                       = 20,
	TARGET_HIGHSPEED_SKILL                   = 21,
	TARGET_COMBO_ATK                         = 22,
	TARGET_COMBO_NOATK                       = 23,
	TARGET_ATK                               = 24,
	TARGET_NOATK                             = 25,
	REINFORCEMENT_LESSTHAN                   = 26,
	PHEASE_FIRST                             = 27,
	DIRECT_VOLUME                            = 28,
	LONGATK_VOLUME                           = 29,
	FASTMOVING_VOLUME                        = 30,
	DIRECT_ATK_VOLUME                        = 31,
	LONGATK_ATK_VOLUME                       = 32,
	FASTMOVING_ATK_VOLUME                    = 33,
	DIRECT_SKILL_VOLUME                      = 34,
	LONGATK_SKILL_VOLUME                     = 35,
	FASTMOVING_SKILL_VOLUME                  = 36,
	DAMAGE                                   = 37,
	DAMAGE_SHORT                             = 38,
	DAMAGE_LONG                              = 39,
	DAMAGE_SHORT_SKILL                       = 40,
	DAMAGE_LONG_SKILL                        = 41,
	COUNTER_XX                               = 42,
	COUNTER_XX_ADD                           = 43,
	MOVE                                     = 44,
	WAIT                                     = 45,
	BREAK                                    = 46,
	SPARKING                                 = 47,
	COLLISION                                = 48,
	RESTRAINT                                = 49,
	CAMERA_IN                                = 50,
	BATTLE_STARTTIME_WITHIN                  = 51,
	BATTLE_STARTTIME_PASSAGE                 = 52,
	TARGET_ANGLE_V_XX_OVER                   = 53,
	TARGET_ANGLE_V_XX_UNDER                  = 54,
	TARGET_ANGLE_H_XX_OVER                   = 55,
	TARGET_ANGLE_H_XX_UNDER                  = 56,
	TARGET_ANGLE_SUB_V_XX_OVER               = 57,
	TARGET_ANGLE_SUB_V_XX_UNDER              = 58,
	TARGET_ANGLE_SUB_H_XX_OVER               = 59,
	TARGET_ANGLE_SUB_H_XX_UNDER              = 60,
	TARGET_DISTANCE_H_XX_OVER                = 61,
	TARGET_DISTANCE_H_XX_UNDER               = 62,
	PARTY_MEMBER_NUM_XX_OVER                 = 63,
	PARTY_MEMBER_NUM_XX_UNDER                = 64,
	PARTY_MEMBER_NUM_OMITBIT_XX_OVER         = 65,
	PARTY_MEMBER_NUM_OMITBIT_XX_UNDER        = 66,
	NOT_USED_SUMMON_SKILL                    = 67,
	E_AI_CONDITIONS_MAX                      = 68,
};

// Enum AT.E_AI_PHEASE
// NumValues: 0x0003
enum class E_AI_PHEASE : uint8
{
	NONE                                     = 0,
	PHEASE                                   = 1,
	E_AI_MAX                                 = 2,
};

// Enum AT.E_AI_SPECIAL
// NumValues: 0x0016
enum class E_AI_SPECIAL : uint8
{
	INIT                                     = 0,
	PASSIVE                                  = 1,
	SPSKILL_LEAVE                            = 2,
	WARNING_POS                              = 3,
	RETURN_POS                               = 4,
	RESTART                                  = 5,
	WAIT                                     = 6,
	LOT_STOP                                 = 7,
	CHAINASSIST                              = 8,
	CHAINASSIST_WAIT                         = 9,
	PLAYER_MOVE                              = 10,
	OUTSIDE_SET                              = 11,
	RUSH_START                               = 12,
	PLAYER_FROM_ESCAPE                       = 13,
	PLAYER_TRACKING                          = 14,
	TPS_WAIT                                 = 15,
	TPS_MOVE                                 = 16,
	RUSH_EVACUATE                            = 17,
	SUPPORT_01                               = 18,
	SUPPORT_02                               = 19,
	SUPPORT_03                               = 20,
	E_AI_MAX                                 = 21,
};

// Enum AT.E_AI_STATE
// NumValues: 0x0005
enum class E_AI_STATE : uint8
{
	NOMAL                                    = 0,
	SPECIAL                                  = 1,
	RUSH                                     = 2,
	MINIGAME                                 = 3,
	E_AI_MAX                                 = 4,
};

// Enum AT.E_SEQ_AI
// NumValues: 0x0006
enum class E_SEQ_AI : uint8
{
	INIT                                     = 0,
	LOT                                      = 1,
	ANIM_SET                                 = 2,
	END_CHECK                                = 3,
	REQUEST_CHECK                            = 4,
	E_SEQ_MAX                                = 5,
};

// Enum AT.E_AI_PLAYER_CHASE_POS
// NumValues: 0x0003
enum class E_AI_PLAYER_CHASE_POS : uint8
{
	RIGHT                                    = 0,
	LEFT                                     = 1,
	MAX                                      = 2,
};

// Enum AT.E_AI_MINIGAME_RESULT
// NumValues: 0x0004
enum class E_AI_MINIGAME_RESULT : uint8
{
	None                                     = 0,
	Failure                                  = 1,
	Success                                  = 2,
	E_AI_MINIGAME_MAX                        = 3,
};

// Enum AT.E_AI_MINIGAME
// NumValues: 0x0004
enum class E_AI_MINIGAME : uint8
{
	NONE                                     = 0,
	DEATHBEAM_QTE                            = 1,
	DEATHBEAM_QTE_3_2                        = 2,
	E_AI_MAX                                 = 3,
};

// Enum AT.E_AI_BEHAVIOR_END
// NumValues: 0x0032
enum class E_AI_BEHAVIOR_END : uint8
{
	AI_BEHAVIOR_END_NONE                     = 0,
	AI_BEHAVIOR_END_POS                      = 1,
	AI_BEHAVIOR_END_MOVE                     = 2,
	AI_BEHAVIOR_END_ANIM                     = 3,
	AI_BEHAVIOR_END_DISTANCE                 = 4,
	AI_BEHAVIOR_TARGET_DIST_003              = 5,
	AI_BEHAVIOR_TARGET_DIST_005              = 6,
	AI_BEHAVIOR_TARGET_DIST_010              = 7,
	AI_BEHAVIOR_TARGET_DIST_015              = 8,
	AI_BEHAVIOR_TARGET_DIST_020              = 9,
	AI_BEHAVIOR_TARGET_DIST_025              = 10,
	AI_BEHAVIOR_TARGET_DIST_030              = 11,
	AI_BEHAVIOR_TARGET_DIST_035              = 12,
	AI_BEHAVIOR_TARGET_DIST_040              = 13,
	AI_BEHAVIOR_TARGET_DIST_045              = 14,
	AI_BEHAVIOR_TARGET_DIST_050              = 15,
	AI_BEHAVIOR_TARGET_DIST_055              = 16,
	AI_BEHAVIOR_TARGET_DIST_060              = 17,
	AI_BEHAVIOR_TARGET_DIST_065              = 18,
	AI_BEHAVIOR_TARGET_DIST_003_OVER         = 19,
	AI_BEHAVIOR_TARGET_DIST_005_OVER         = 20,
	AI_BEHAVIOR_TARGET_DIST_010_OVER         = 21,
	AI_BEHAVIOR_TARGET_DIST_015_OVER         = 22,
	AI_BEHAVIOR_TARGET_DIST_020_OVER         = 23,
	AI_BEHAVIOR_TARGET_DIST_025_OVER         = 24,
	AI_BEHAVIOR_TARGET_DIST_030_OVER         = 25,
	AI_BEHAVIOR_TARGET_DIST_035_OVER         = 26,
	AI_BEHAVIOR_TARGET_DIST_040_OVER         = 27,
	AI_BEHAVIOR_TARGET_DIST_045_OVER         = 28,
	AI_BEHAVIOR_TARGET_DIST_050_OVER         = 29,
	AI_BEHAVIOR_TARGET_DIST_055_OVER         = 30,
	AI_BEHAVIOR_TARGET_DIST_060_OVER         = 31,
	AI_BEHAVIOR_TARGET_DIST_065_OVER         = 32,
	AI_BEHAVIOR_10M_30M_LEAVE                = 33,
	AI_BEHAVIOR_10M_30M_OVER                 = 34,
	AI_BEHAVIOR_10M_30M_LESSTHAN             = 35,
	AI_BEHAVIOR_30M_50M_LEAVE                = 36,
	AI_BEHAVIOR_30M_50M_OVER                 = 37,
	AI_BEHAVIOR_30M_50M_LESSTHAN             = 38,
	AI_BEHAVIOR_50M_70M_LEAVE                = 39,
	AI_BEHAVIOR_50M_70M_OVER                 = 40,
	AI_BEHAVIOR_50M_70M_LESSTHAN             = 41,
	AI_BEHAVIOR_10M_50M_LEAVE                = 42,
	AI_BEHAVIOR_10M_50M_OVER                 = 43,
	AI_BEHAVIOR_10M_50M_LESSTHAN             = 44,
	AI_BEHAVIOR_TARGET_DIST_H_XXM_OVER       = 45,
	AI_BEHAVIOR_TARGET_DIST_H_XXM_UNDER      = 46,
	AI_BEHAVIOR_ACT_CANCEL                   = 47,
	AI_BEHAVIOR_END_MAX                      = 48,
	AI_BEHAVIOR_MAX                          = 49,
};

// Enum AT.E_AI_BEHAVIOR
// NumValues: 0x00AA
enum class E_AI_BEHAVIOR : uint8
{
	AI_BEHAVIOR_WAIT                         = 0,
	AI_BEHAVIOR_ATK_ZYAKU                    = 1,
	AI_BEHAVIOR_ATK_ZYAKU_CHARGE             = 2,
	AI_BEHAVIOR_ATK_KYO_KERI                 = 3,
	AI_BEHAVIOR_ATK_KYO_DOWN                 = 4,
	AI_BEHAVIOR_ATK_BODYBLOW                 = 5,
	AI_BEHAVIOR_ATK_KYO_CHARGE               = 6,
	AI_BEHAVIOR_ATK_COMBO_01                 = 7,
	AI_BEHAVIOR_ATK_COMBO_02                 = 8,
	AI_BEHAVIOR_ATK_COMBO_03                 = 9,
	AI_BEHAVIOR_ATK_COMBO_04                 = 10,
	AI_BEHAVIOR_ATK_COMBO_05                 = 11,
	AI_BEHAVIOR_ATK_COMBO_06                 = 12,
	AI_BEHAVIOR_ATK_COMBO_07                 = 13,
	AI_BEHAVIOR_ATK_COMBO_08                 = 14,
	AI_BEHAVIOR_ATK_COMBO_09                 = 15,
	AI_BEHAVIOR_ATK_COMBO_10                 = 16,
	AI_BEHAVIOR_ATK_COMBO_11                 = 17,
	AI_BEHAVIOR_ATK_COMBO_12                 = 18,
	AI_BEHAVIOR_ATK_RUSH_START               = 19,
	AI_BEHAVIOR_ATK_RUSH_05                  = 20,
	AI_BEHAVIOR_ATK_RUSH_10                  = 21,
	AI_BEHAVIOR_ATK_RUSH_15                  = 22,
	AI_BEHAVIOR_ATK_SHOT                     = 23,
	AI_BEHAVIOR_ATK_SHOT_CHARGE              = 24,
	AI_BEHAVIOR_ATK_SHOT_KYOU                = 25,
	AI_BEHAVIOR_ATK_SHOT_KYOU_CHARGE         = 26,
	AI_BEHAVIOR_ATK_SP                       = 27,
	AI_BEHAVIOR_ATK_SP_02                    = 28,
	AI_BEHAVIOR_GUARD_START                  = 29,
	AI_BEHAVIOR_GUARD_END                    = 30,
	AI_BEHAVIOR_COUNTER                      = 31,
	AI_BEHAVIOR_BURST                        = 32,
	AI_BEHAVIOR_SAIYAJIN                     = 33,
	AI_BEHAVIOR_APURU_H_SKILL                = 34,
	AI_BEHAVIOR_APURU_COMMON_SKILL           = 35,
	AI_BEHAVIOR_MOVE_HEIGHT                  = 36,
	AI_BEHAVIOR_MOVE_APPROACH                = 37,
	AI_BEHAVIOR_MOVE_APPROACH_BOOST          = 38,
	AI_BEHAVIOR_MOVE_APPROACH_DIRECT         = 39,
	AI_BEHAVIOR_MOVE_RECEDE                  = 40,
	AI_BEHAVIOR_MOVE_CENTER                  = 41,
	AI_BEHAVIOR_MOVE_WAIT                    = 42,
	AI_BEHAVIOR_MOVE_HOMING                  = 43,
	AI_BEHAVIOR_MOVE_BOOST_LIMIT             = 44,
	AI_BEHAVIOR_MOVE_BACK_STEP               = 45,
	AI_BEHAVIOR_MOVE_BACK_STEP_REKKOUBULLET  = 46,
	AI_BEHAVIOR_GUARD                        = 47,
	AI_BEHAVIOR_BACK_STEP_GUARD              = 48,
	AI_BEHAVIOR_MOVE_APPROACH_BOOST_LEFT     = 49,
	AI_BEHAVIOR_MOVE_APPROACH_BOOST_LIGHT    = 50,
	AI_BEHAVIOR_MOVE_APPROACH_BOOST_UPPER    = 51,
	AI_BEHAVIOR_MOVE_APPROACH_BOOST_BELOW    = 52,
	AI_BEHAVIOR_MOVE_APPROACH_PLAYER_TARGET  = 53,
	AI_BEHAVIOR_MOVE_PARALLEL_LEFT           = 54,
	AI_BEHAVIOR_MOVE_PARALLEL_RIGHT          = 55,
	AI_BEHAVIOR_MOVE_PARALLEL_BACK           = 56,
	AI_BEHAVIOR_REINFORCEMENT_SAIBAIMAN      = 57,
	AI_BEHAVIOR_SEARCH_01                    = 58,
	AI_BEHAVIOR_SEARCH_02                    = 59,
	AI_BEHAVIOR_ENERGYCHARGE_100             = 60,
	AI_BEHAVIOR_ENERGYCHARGE_090_OVER        = 61,
	AI_BEHAVIOR_ENERGYCHARGE_080_OVER        = 62,
	AI_BEHAVIOR_ENERGYCHARGE_070_OVER        = 63,
	AI_BEHAVIOR_ENERGYCHARGE_060_OVER        = 64,
	AI_BEHAVIOR_ENERGYCHARGE_050_OVER        = 65,
	AI_BEHAVIOR_ENERGYCHARGE_040_OVER        = 66,
	AI_BEHAVIOR_ENERGYCHARGE_030_OVER        = 67,
	AI_BEHAVIOR_ENERGYCHARGE_020_OVER        = 68,
	AI_BEHAVIOR_ENERGYCHARGE_010_OVER        = 69,
	AI_BEHAVIOR_ENERGYCHARGE_050_100         = 70,
	AI_BEHAVIOR_ENERGYCHARGE_040_090         = 71,
	AI_BEHAVIOR_ENERGYCHARGE_030_080         = 72,
	AI_BEHAVIOR_MOVE_TARGET_AROUNDBACK       = 73,
	AI_BEHAVIOR_SPATK_LINE_LEAVE             = 74,
	AI_BEHAVIOR_SPATK_STEP_LEAVE             = 75,
	AI_BEHAVIOR_SPATK_GUARD                  = 76,
	AI_BEHAVIOR_SPATK_WAIT                   = 77,
	AI_BEHAVIOR_WARP                         = 78,
	AI_BEHAVIOR_PASSIVE                      = 79,
	AI_BEHAVIOR_CHAINASSIST                  = 80,
	AI_BEHAVIOR_CHAINASSIST_WAIT             = 81,
	AI_BEHAVIOR_PLAYERMOVE                   = 82,
	AI_BEHAVIOR_SEARCH_WARNING               = 83,
	AI_BEHAVIOR_SEARCH_RETURN                = 84,
	AI_BEHAVIOR_SKYRISING                    = 85,
	AI_BEHAVIOR_AREAEND_ESCAPE               = 86,
	AI_BEHAVIOR_PLAYER_FROM_ESCAPE           = 87,
	AI_BEHAVIOR_PLAYER_TRACKING              = 88,
	AI_BEHAVIOR_BATTLEAREA_CENTER            = 89,
	AI_BEHAVIOR_SKILL_RR                     = 90,
	AI_BEHAVIOR_SKILL_RU                     = 91,
	AI_BEHAVIOR_SKILL_RL                     = 92,
	AI_BEHAVIOR_SKILL_RD                     = 93,
	AI_BEHAVIOR_SKILL_LR                     = 94,
	AI_BEHAVIOR_SKILL_LU                     = 95,
	AI_BEHAVIOR_SKILL_LL                     = 96,
	AI_BEHAVIOR_SKILL_LD                     = 97,
	AI_BEHAVIOR_SKILL_SPARKING               = 98,
	AI_BEHAVIOR_NAPPA_SHOCK_WAVE             = 99,
	AI_BEHAVIOR_NAPPA_OVERHEADKICK           = 100,
	AI_BEHAVIOR_NAPPA_SUPERPUNCH             = 101,
	AI_BEHAVIOR_NAPPA_DELUXEBOMBER           = 102,
	AI_BEHAVIOR_NAPPA_BUREIJINGUSTORM        = 103,
	AI_BEHAVIOR_MOVE_BACK_STEP_PARALLEL      = 104,
	AI_BEHAVIOR_PICCOLO_MAKANKOUSAPPO        = 105,
	AI_BEHAVIOR_SAIBAIMAN_NAIL_ATTACK_01     = 106,
	AI_BEHAVIOR_SAIBAIMAN_NAIL_ATTACK_02     = 107,
	AI_BEHAVIOR_SAIBAIMAN_NAIL_ATTACK_03     = 108,
	AI_BEHAVIOR_SAIBAIMAN_NAIL_ATTACK_04     = 109,
	AI_BEHAVIOR_SAIBAIMAN_NAIL_ATTACK_05     = 110,
	AI_BEHAVIOR_SAIBAIMAN_SELFDESTRUCT       = 111,
	AI_BEHAVIOR_SAIBAIMAN_SELFDESTRUCT_ASSAULT = 112,
	AI_BEHAVIOR_SAIBAIMAN_ENERGY_BULLET_01   = 113,
	AI_BEHAVIOR_SAIBAIMAN_ENERGY_BULLET_02   = 114,
	AI_BEHAVIOR_SAIBAIMAN_ENERGY_BULLET_03   = 115,
	AI_BEHAVIOR_SAIBAIMAN_ENERGY_BULLET_04   = 116,
	AI_BEHAVIOR_SAIBAIMAN_ENERGY_BULLET_05   = 117,
	AI_BEHAVIOR_SAIBAIMAN_HELP               = 118,
	AI_BEHAVIOR_RADITZ_DAYSBREAK             = 119,
	AI_BEHAVIOR_RADITZ_SATURDAYCRASH         = 120,
	AI_BEHAVIOR_RADITZ_SONICDAYS             = 121,
	AI_BEHAVIOR_RADITZ_DOUBLESUNDAY          = 122,
	AI_BEHAVIOR_EVERYDIRECTION_MOVE          = 123,
	AI_BEHAVIOR_LEFT_AND_RIGHT_STEP          = 124,
	AI_BEHAVIOR_EVERYDIRECTION_CURVE         = 125,
	AI_BEHAVIOR_MOVEWAIT_ZENPOU              = 126,
	AI_BEHAVIOR_MOVEWAIT_KOUHOU              = 127,
	AI_BEHAVIOR_MOVEWAIT_RIGHT               = 128,
	AI_BEHAVIOR_MOVEWAIT_LEFT                = 129,
	AI_BEHAVIOR_PLAYER_LOCKMOVE              = 130,
	AI_BEHAVIOR_PLAYER_LOCKSTEP              = 131,
	AI_BEHAVIOR_SHORT_RANGE_1COMBO           = 132,
	AI_BEHAVIOR_SHORT_RANGE_2COMBO           = 133,
	AI_BEHAVIOR_SHORT_RANGE_3COMBO           = 134,
	AI_BEHAVIOR_SHORT_RANGE_4COMBO           = 135,
	AI_BEHAVIOR_SHORT_RANGE_5COMBO           = 136,
	AI_BEHAVIOR_SHORT_RANGE_MAXCOMBO         = 137,
	AI_BEHAVIOR_LONG_RANGE_1COMBO            = 138,
	AI_BEHAVIOR_LONG_RANGE_2COMBO            = 139,
	AI_BEHAVIOR_LONG_RANGE_3COMBO            = 140,
	AI_BEHAVIOR_LONG_RANGE_4COMBO            = 141,
	AI_BEHAVIOR_LONG_RANGE_5COMBO            = 142,
	AI_BEHAVIOR_LONG_RANGE_MAXCOMBO          = 143,
	AI_BEHAVIOR_LEFTMOVE_LONG_RANGE_3COMBO   = 144,
	AI_BEHAVIOR_RIGHTMOVE_LONG_RANGE_3COMBO  = 145,
	AI_BEHAVIOR_BACKMOVE_LONG_RANGE_3COMBO   = 146,
	AI_BEHAVIOR_BACKMOVE_LONG_RANGE_MAXCOMBO = 147,
	AI_BEHAVIOR_FASTMOVING_COMBO             = 148,
	AI_BEHAVIOR_LEFT_STEP                    = 149,
	AI_BEHAVIOR_RIGHT_STEP                   = 150,
	AI_BEHAVIOR_CAMERA_MOVE                  = 151,
	AI_BEHAVIOR_SEARCH_WARNING_MOVE          = 152,
	AI_BEHAVIOR_SEARCH_LOITERING_MOVE        = 153,
	AI_BEHAVIOR_SEARCH_PLAYER_MOVE           = 154,
	AI_BEHAVIOR_SEARCH_PLAYER_HIGHMOVE       = 155,
	AI_BEHAVIOR_SEARCH_WAIT                  = 156,
	AI_BEHAVIOR_SEARCH_WARP                  = 157,
	AI_BEHAVIOR_TEST_MOVE                    = 158,
	AI_BEHAVIOR_NONE                         = 159,
	AI_BEHAVIOR_RUSH_EVACUATE                = 160,
	AI_BEHAVIOR_POINT_MOVE_FAST              = 161,
	AI_BEHAVIOR_POINT_MOVE_NORMAL            = 162,
	AI_BEHAVIOR_LANDING_POINT_WAIT           = 163,
	AI_BEHAVIOR_HUGE_TURN_ANGLE              = 164,
	AI_BEHAVIOR_HUGE_TURN_TARGET             = 165,
	AI_BEHAVIOR_HUGE_WALK_TARGET             = 166,
	AI_BEHAVIOR_HUGE_F_STEP_TARGET           = 167,
	AI_BEHAVIOR_HUGE_B_STEP_TARGET           = 168,
	AI_BEHAVIOR_MAX                          = 169,
};

// Enum AT.E_AI_ACTION
// NumValues: 0x0005
enum class E_AI_ACTION : uint8
{
	AI_ACTION_WAIT                           = 0,
	AI_ACTION_ATK                            = 1,
	AI_ACTION_MOV                            = 2,
	AI_ACTION_DEF                            = 3,
	AI_ACTION_MAX                            = 4,
};

// Enum AT.EAirCarMoveState
// NumValues: 0x000D
enum class EAirCarMoveState : uint8
{
	Land                                     = 0,
	LandMoveST                               = 1,
	LandMoveLP                               = 2,
	LandMoveED                               = 3,
	LandGoBackST                             = 4,
	LandGoBackLP                             = 5,
	LandGoBackED                             = 6,
	LandLanding                              = 7,
	LandBoost                                = 8,
	LandAccident                             = 9,
	Stop                                     = 10,
	Nothing                                  = 11,
	EAirCarMoveState_MAX                     = 12,
};

// Enum AT.EAirCarMoveCategory
// NumValues: 0x0004
enum class EAirCarMoveCategory : uint8
{
	Land                                     = 0,
	Fly                                      = 1,
	Nothing                                  = 2,
	EAirCarMoveCategory_MAX                  = 3,
};

// Enum AT.EAndroidAssaultDroneMove
// NumValues: 0x0009
enum class EAndroidAssaultDroneMove : uint8
{
	None                                     = 0,
	Horizon                                  = 1,
	Horizon_C                                = 2,
	Vertical_U                               = 3,
	Vertical_D                               = 4,
	Vertical_C                               = 5,
	Circle                                   = 6,
	Chase                                    = 7,
	Max                                      = 8,
};

// Enum AT.EAndroidAssaultDrone
// NumValues: 0x0005
enum class EAndroidAssaultDrone : uint8
{
	None                                     = 0,
	Searcher                                 = 1,
	Supporter                                = 2,
	Commander                                = 3,
	Max                                      = 4,
};

// Enum AT.EAnimalAccessPointNotifyNowState
// NumValues: 0x0004
enum class EAnimalAccessPointNotifyNowState : uint8
{
	NotifyAnimal_NowState_Wait               = 0,
	NotifyAnimal_NowState_Free               = 1,
	NotifyAnimal_NowState_End                = 2,
	NotifyAnimal_NowState_MAX                = 3,
};

// Enum AT.EAnimalPointState
// NumValues: 0x0006
enum class EAnimalPointState : uint8
{
	StateAnimalWait                          = 0,
	StateAnimalUIWait                        = 1,
	StateAnimalPlayerMoveWait                = 2,
	StateAnimalEffectWait                    = 3,
	StateAnimalTaken                         = 4,
	EAnimalPointState_MAX                    = 5,
};

// Enum AT.EAnimalEventCategory
// NumValues: 0x0006
enum class EAnimalEventCategory : uint8
{
	Capture                                  = 0,
	Chicken                                  = 1,
	AutoGet                                  = 2,
	AuraSearch                               = 3,
	None                                     = 4,
	EAnimalEventCategory_MAX                 = 5,
};

// Enum AT.ECaptureMoveResult
// NumValues: 0x0004
enum class ECaptureMoveResult : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Failure                                  = 2,
	ECaptureMoveResult_MAX                   = 3,
};

// Enum AT.ESymbol
// NumValues: 0x0004
enum class ESymbol : uint8
{
	Single                                   = 0,
	Group                                    = 1,
	Group_Child                              = 2,
	ESymbol_MAX                              = 3,
};

// Enum AT.EAnimalSpawnerTargetPointState
// NumValues: 0x0004
enum class EAnimalSpawnerTargetPointState : uint8
{
	Idle                                     = 0,
	Spawning                                 = 1,
	SpawnEnd                                 = 2,
	EAnimalSpawnerTargetPointState_MAX       = 3,
};

// Enum AT.EAnimalSpawnerVolumeKind
// NumValues: 0x0004
enum class EAnimalSpawnerVolumeKind : uint8
{
	AutoSpawn                                = 0,
	SpawnStart                               = 1,
	SpawnTargetPos                           = 2,
	EAnimalSpawnerVolumeKind_MAX             = 3,
};

// Enum AT.EBaseballGameNotifyType
// NumValues: 0x0005
enum class EBaseballGameNotifyType : uint32
{
	None                                     = 0,
	ReleaseBall                              = 1,
	HitBall                                  = 2,
	PrepareSwing                             = 3,
	EBaseballGameNotifyType_MAX              = 4,
};

// Enum AT.E_SHINKUGEKI_DAMAGE_VECTOR
// NumValues: 0x000A
enum class E_SHINKUGEKI_DAMAGE_VECTOR : uint8
{
	SHINKUGEKI_DAMAGE_VECTOR_RANDOM          = 0,
	SHINKUGEKI_DAMAGE_VECTOR_F2B             = 1,
	SHINKUGEKI_DAMAGE_VECTOR_B2F             = 2,
	SHINKUGEKI_DAMAGE_VECTOR_L2R             = 3,
	SHINKUGEKI_DAMAGE_VECTOR_R2L             = 4,
	SHINKUGEKI_DAMAGE_VECTOR_U2D             = 5,
	SHINKUGEKI_DAMAGE_VECTOR_D2U             = 6,
	SHINKUGEKI_DAMAGE_VECTOR_BU2D            = 7,
	SHINKUGEKI_DAMAGE_VECTOR_BD2U            = 8,
	SHINKUGEKI_DAMAGE_VECTOR_MAX             = 9,
};

// Enum AT.EEffectCondition
// NumValues: 0x0013
enum class EEffectCondition : uint8
{
	ALL                                      = 0,
	GEAR1ST                                  = 1,
	GEAR2ND                                  = 2,
	GEAR3RD                                  = 3,
	NORMAL                                   = 4,
	SUPERSAIYAN                              = 5,
	INWATER                                  = 6,
	NOINWATER                                = 7,
	NEARLYONWATER                            = 8,
	BREAK                                    = 9,
	ATTEMPTSAIYA                             = 10,
	NOTATTEMPTSAIYA                          = 11,
	FRIEND                                   = 12,
	NOT_FRIEND                               = 13,
	NEARLYGROUND                             = 14,
	NOT_NEARLYGROUND                         = 15,
	FREEZER_FIRSTHALF                        = 16,
	FREEZER_LATTERHALF                       = 17,
	EEffectCondition_MAX                     = 18,
};

// Enum AT.EButtonType
// NumValues: 0x000F
enum class EButtonType : uint8
{
	Buttom_R_Right                           = 0,
	Buttom_R_Down                            = 1,
	Buttom_R_Left                            = 2,
	Buttom_R_Top                             = 3,
	Buttom_L_Right                           = 4,
	Buttom_L_Down                            = 5,
	Buttom_L_Left                            = 6,
	Buttom_L_Top                             = 7,
	Buttom_R1                                = 8,
	Buttom_R2                                = 9,
	Buttom_R3                                = 10,
	Buttom_L1                                = 11,
	Buttom_L2                                = 12,
	Buttom_L3                                = 13,
	Buttom_MAX                               = 14,
};

// Enum AT.EAppearType
// NumValues: 0x0009
enum class EAppearType : uint8
{
	None                                     = 0,
	Front                                    = 1,
	Back                                     = 2,
	Left                                     = 3,
	Right                                    = 4,
	Top                                      = 5,
	Bottom                                   = 6,
	Debug                                    = 7,
	Max                                      = 8,
};

// Enum AT.EGameState
// NumValues: 0x0007
enum class EGameState : uint8
{
	None                                     = 0,
	LoadingArea                              = 1,
	LoadingDoor                              = 2,
	LoadCompleted                            = 3,
	Field                                    = 4,
	Battle                                   = 5,
	Max                                      = 6,
};

// Enum AT.ESuperTrainingType
// NumValues: 0x0006
enum class ESuperTrainingType : uint8
{
	SuperTraining                            = 0,
	BreakthroughTraining                     = 1,
	ChallengeToGodOfDestruction              = 2,
	ChallengeFreezerF                        = 3,
	CrowdTraining                            = 4,
	ESuperTrainingType_MAX                   = 5,
};

// Enum AT.EBlurType
// NumValues: 0x0003
enum class EBlurType : uint8
{
	RADIAL_BLUR_TYPE                         = 0,
	BLUR_TYPE_MAX                            = 1,
	EBlurType_MAX                            = 2,
};

// Enum AT.EUnderWaterState
// NumValues: 0x0004
enum class EUnderWaterState : uint8
{
	None                                     = 0,
	ShallowUnderWater                        = 1,
	DeepUnderWater                           = 2,
	EUnderWaterState_MAX                     = 3,
};

// Enum AT.EInvincibleEnableFlag
// NumValues: 0x0005
enum class EInvincibleEnableFlag : uint8
{
	Action                                   = 0,
	AnimNotify                               = 1,
	Timer                                    = 2,
	Demo                                     = 3,
	Max                                      = 4,
};

// Enum AT.ESuperArmorEnableFlag
// NumValues: 0x0006
enum class ESuperArmorEnableFlag : uint8
{
	Action                                   = 0,
	AnimNotify                               = 1,
	BlowNoneAction                           = 2,
	BlowNoneAnimNotify                       = 3,
	Timer                                    = 4,
	Max                                      = 5,
};

// Enum AT.EPlayerEnableFlag
// NumValues: 0x0007
enum class EPlayerEnableFlag : uint8
{
	Teleport                                 = 0,
	Notify                                   = 1,
	Quest                                    = 2,
	Skill                                    = 3,
	Fusion                                   = 4,
	Event                                    = 5,
	Max                                      = 6,
};

// Enum AT.RUN_GEAR_STATE
// NumValues: 0x0003
enum class ERUN_GEAR_STATE : uint8
{
	FIRST                                    = 0,
	SECOND                                   = 1,
	RUN_GEAR_MAX                             = 2,
};

// Enum AT.FLY_GEAR_STATE
// NumValues: 0x0005
enum class EFLY_GEAR_STATE : uint8
{
	NEUTRAL                                  = 0,
	FIRST                                    = 1,
	SECOND                                   = 2,
	THIRD                                    = 3,
	FLY_GEAR_MAX                             = 4,
};

// Enum AT.ESupportActionRecast
// NumValues: 0x000A
enum class ESupportActionRecast : uint8
{
	ComboAssistShort                         = 0,
	ComboAssistLong                          = 1,
	SkillAssist                              = 2,
	Pursue                                   = 3,
	ComboCut                                 = 4,
	BulletGuard                              = 5,
	Provocation                              = 6,
	RecoveryHp                               = 7,
	RecoveryMp                               = 8,
	Max                                      = 9,
};

// Enum AT.ESupportActionCategory
// NumValues: 0x000A
enum class ESupportActionCategory : uint8
{
	None                                     = 0,
	ComboAssist                              = 1,
	SkillAssist                              = 2,
	Pursue                                   = 3,
	ComboCut                                 = 4,
	BulletGuard                              = 5,
	Provocation                              = 6,
	RecoveryHp                               = 7,
	RecoveryMp                               = 8,
	Max                                      = 9,
};

// Enum AT.ESupportStyle
// NumValues: 0x0005
enum class ESupportStyle : uint8
{
	None                                     = 0,
	OffenseStyle                             = 1,
	DefenseStyle                             = 2,
	SpecialStyle                             = 3,
	Max                                      = 4,
};

// Enum AT.EATRegions
// NumValues: 0x0005
enum class EATRegions : uint8
{
	English                                  = 0,
	EFIGS                                    = 1,
	EFIGSCJK                                 = 2,
	CJK                                      = 3,
	EATRegions_MAX                           = 4,
};

// Enum AT.E_CHARACTER_NAME
// NumValues: 0x0079
enum class E_CHARACTER_NAME : uint32
{
	CHARA_GOKU                               = 0,
	CHARA_GOKU_GINYU                         = 1,
	CHARA_GOHAN                              = 2,
	CHARA_GREATE_SAIYA                       = 3,
	CHARA_GOTEN                              = 4,
	CHARA_GOTENKS                            = 5,
	CHARA_VEGETA                             = 6,
	CHARA_SUPER_VEGET                        = 7,
	CHARA_TRUNKS                             = 8,
	CHARA_PICCOLO                            = 9,
	CHARA_KURIRIN                            = 10,
	CHARA_TIEN_SHINHAN                       = 11,
	CHARA_CHIAOTZU                           = 12,
	CHARA_YAMCHA                             = 13,
	CHARA_ANDROID_06                         = 14,
	CHARA_ANDROID_16                         = 15,
	CHARA_ANDROID_17                         = 16,
	CHARA_ANDROID_18                         = 17,
	CHARA_ANDROID_20                         = 18,
	CHARA_GINYU                              = 19,
	CHARA_CELL                               = 20,
	CHARA_DABURA                             = 21,
	CHARA_NAPPA                              = 22,
	CHARA_FRIEZA                             = 23,
	CHARA_MECHA_FRIEZA                       = 24,
	CHARA_RADITZ                             = 25,
	CHARA_BUU                                = 26,
	CHARA_SAIBA_MEN                          = 27,
	CHARA_KAIWARE_MEN                        = 28,
	CHARA_KYUKON_MEN                         = 29,
	CHARA_TENEN_MEN                          = 30,
	CHARA_JINKO_MEN                          = 31,
	CHARA_APPULE                             = 32,
	CHARA_RAMON                              = 33,
	CHARA_ORLEN                              = 34,
	CHARA_APPULE2                            = 35,
	CHARA_CUI                                = 36,
	CHARA_PIYER                              = 37,
	CHARA_GORIN                              = 38,
	CHARA_STOROBU                            = 39,
	CHARA_DODORIA                            = 40,
	CHARA_KURBOS                             = 41,
	CHARA_GORMAN                             = 42,
	CHARA_ZARBON                             = 43,
	CHARA_USE                                = 44,
	CHARA_MANDARIN                           = 45,
	CHARA_RECCOME                            = 46,
	CHARA_EARTH                              = 47,
	CHARA_ZOFT                               = 48,
	CHARA_BURTER                             = 49,
	CHARA_MARRIGAN                           = 50,
	CHARA_JAN                                = 51,
	CHARA_JEICE                              = 52,
	CHARA_BANIERA                            = 53,
	CHARA_MOOSE                              = 54,
	CHARA_GULDO                              = 55,
	CHARA_ZERA                               = 56,
	CHARA_POOLEN                             = 57,
	CHARA_ANDROID_19                         = 58,
	CHARA_ANDROID_19_PLOT                    = 59,
	CHARA_CELL_JR                            = 60,
	CHARA_CELL_JR_SUB                        = 61,
	CHARA_BIT_ROBOT_BEAM                     = 62,
	CHARA_BIT_ROBOT_HEAL                     = 63,
	CHARA_BIT_ROBOT_BARRIER                  = 64,
	CHARA_YACCON                             = 65,
	CHARA_YACCON_SUB                         = 66,
	CHARA_PUI_PUI                            = 67,
	CHARA_PUI_PUI_SUB                        = 68,
	CHARA_YAJIROBE                           = 69,
	CHARA_MR_SATAN                           = 70,
	CHARA_BURUMA                             = 71,
	CHARA_CHICHI                             = 72,
	CHARA_MASTER_ROSHI                       = 73,
	CHARA_SEA_TURTLE                         = 74,
	CHARA_GOD                                = 75,
	CHARA_KARIN                              = 76,
	CHARA_Dr_BRIEF                           = 77,
	CHARA_OOLONG                             = 78,
	CHARA_PUAR                               = 79,
	CHARA_OX_KING                            = 80,
	CHARA_MR_POPO                            = 81,
	CHARA_FORTUNETELLER_BABA                 = 82,
	CHARA_KAI_KING_KAI                       = 83,
	CHARA_BUBBLES                            = 84,
	CHARA_DENDE                              = 85,
	CHARA_NAIL                               = 86,
	CHARA_GRAND_ELDER_GURU                   = 87,
	CHARA_MARRON                             = 88,
	CHARA_VIDEL                              = 89,
	CHARA_WORLD_TOURNAMENT_ANNOUNCER         = 90,
	CHARA_KIBITO                             = 91,
	CHARA_KAIOSHIN                           = 92,
	CHARA_OLD_KAIOSHIN                       = 93,
	CHARA_PILAF                              = 94,
	CHARA_SHU                                = 95,
	CHARA_MAI                                = 96,
	CHARA_LAUNCH                             = 97,
	CHARA_NAM                                = 98,
	CHARA_SUNO                               = 99,
	CHARA_SUPOPOVICH                         = 100,
	CHARA_YAMU                               = 101,
	CHARA_ARALE                              = 102,
	CHARA_SENBEI_NORIMAKI                    = 103,
	CHARA_GATCHAN                            = 104,
	CHARA_BORA                               = 105,
	CHARA_UPA                                = 106,
	CHARA_MERCENARY_TAO                      = 107,
	CHARA_BEE                                = 108,
	CHARA_SHENRON                            = 109,
	CHARA_PORUNGA                            = 110,
	CHARA_MASTER_SHEN                        = 111,
	CHARA_KING_YEMMA                         = 112,
	CHARA_KING_COLD                          = 113,
	CHARA_BABIDI                             = 114,
	CHARA_PIRATEROBOT                        = 115,
	CHARA_RRROBOT                            = 116,
	CHARA_BOBBIDISOLDIER                     = 117,
	CHARACTER_NAME_TOTAL                     = 118,
	CHARA_DUMMY                              = 119,
	E_CHARACTER_MAX                          = 120,
};

// Enum AT.E_WINDOW_TYPE
// NumValues: 0x0003
enum class E_WINDOW_TYPE : uint8
{
	SINGLE                                   = 0,
	CHOICES                                  = 1,
	E_WINDOW_TYPE_MAX                        = 2,
};

// Enum AT.E_WINDOW_SELECT
// NumValues: 0x0004
enum class E_WINDOW_SELECT : uint8
{
	SELECT                                   = 0,
	YES                                      = 1,
	NO                                       = 2,
	E_WINDOW_SELECT_MAX                      = 3,
};

// Enum AT.E_MSG_FACE_ICON
// NumValues: 0x000A
enum class E_MSG_FACE_ICON : uint8
{
	E_MSG_FACE_ICON_BRF1                     = 0,
	E_MSG_FACE_ICON_BRM1                     = 1,
	E_MSG_FACE_ICON_GHN1                     = 2,
	E_MSG_FACE_ICON_GOK1                     = 3,
	E_MSG_FACE_ICON_GRD1                     = 4,
	E_MSG_FACE_ICON_KRN1                     = 5,
	E_MSG_FACE_ICON_PCL1                     = 6,
	E_MSG_FACE_ICON_RKM1                     = 7,
	E_MSG_FACE_ICON_VGT1                     = 8,
	E_MSG_FACE_ICON_MAX                      = 9,
};

// Enum AT.PARAM_ID
// NumValues: 0x000D
enum class EPARAM_ID : uint8
{
	None                                     = 0,
	Vegeta                                   = 1,
	Vegeta2                                  = 2,
	Vegeta3                                  = 3,
	Apuru1                                   = 4,
	Apuru2                                   = 5,
	Apuru3                                   = 6,
	Apuru4                                   = 7,
	Freezer                                  = 8,
	Recoom                                   = 9,
	Guldo                                    = 10,
	Nappa                                    = 11,
	PARAM_MAX                                = 12,
};

// Enum AT.EATSkeletonType
// NumValues: 0x0008
enum class EATSkeletonType : uint8
{
	None                                     = 0,
	Human                                    = 1,
	Robot1                                   = 2,
	Robot2                                   = 3,
	Bit                                      = 4,
	Yakon                                    = 5,
	Ohzaru                                   = 6,
	EATSkeletonType_MAX                      = 7,
};

// Enum AT.CHARACTER_TYPE
// NumValues: 0x00D1
enum class ECHARACTER_TYPE : uint8
{
	None                                     = 0,
	Goku                                     = 1,
	Goku_N                                   = 2,
	Gohan_A                                  = 3,
	Gohan                                    = 4,
	Gohan_C                                  = 5,
	Gohan_D                                  = 6,
	Gohan_Z                                  = 7,
	Vegeta                                   = 8,
	Vegeta_Z                                 = 9,
	Vegeta_B                                 = 10,
	Apuru                                    = 11,
	Apuru_C02                                = 12,
	Apuru_C03                                = 13,
	Apuru_C04                                = 14,
	Freezer_A                                = 15,
	Freezer_B                                = 16,
	Freezer_C                                = 17,
	Freezer                                  = 18,
	Freezer_E                                = 19,
	Freezer_MECHA                            = 20,
	Kuririn                                  = 21,
	Yamcha                                   = 22,
	Tien                                     = 23,
	Chiaotzu                                 = 24,
	Piccolo                                  = 25,
	Raditz                                   = 26,
	Nappa                                    = 27,
	Saibamen                                 = 28,
	Saibamen_C02                             = 29,
	Saibamen_C03                             = 30,
	Saibamen_C04                             = 31,
	Saibamen_C05                             = 32,
	Cui_C01                                  = 33,
	Dodoria_C01                              = 34,
	Zarbon_A_C01                             = 35,
	Zarbon_B_C01                             = 36,
	Recoom                                   = 37,
	Burter_C01                               = 38,
	Jeice_C01                                = 39,
	Guldo                                    = 40,
	Ginyu                                    = 41,
	Trunks                                   = 42,
	Trunks_B                                 = 43,
	Android19_C01                            = 44,
	Android20                                = 45,
	Android17                                = 46,
	Android18                                = 47,
	Cell_A                                   = 48,
	Cell_B                                   = 49,
	Cell_C                                   = 50,
	CellJr_C01                               = 51,
	Goten                                    = 52,
	Dabura                                   = 53,
	PuiPui_C01                               = 54,
	Yakon_C01                                = 55,
	Buu_A                                    = 56,
	Buu_B                                    = 57,
	Buu_C                                    = 58,
	Buu_E                                    = 59,
	Gotenks                                  = 60,
	Vegito                                   = 61,
	RRArmyRobot_C01                          = 62,
	RRArmyRobot_C02                          = 63,
	RRArmyRobot_C03                          = 64,
	PirateRobot_C01                          = 65,
	PirateRobot_C02                          = 66,
	PirateRobot_C03                          = 67,
	BobbidiSoldier                           = 68,
	BobbidiSoldier_B                         = 69,
	BobbidiSoldier_A                         = 70,
	BobbidiSoldier_C                         = 71,
	RRBit_C01                                = 72,
	RRBit_C02                                = 73,
	RRBit_C03                                = 74,
	FZBit_C01                                = 75,
	FZBit_C02                                = 76,
	FZBit_C03                                = 77,
	AlienA_C01                               = 78,
	AlienA_C02                               = 79,
	AlienA_C03                               = 80,
	AlienB_C01                               = 81,
	AlienB_C02                               = 82,
	AlienB_C03                               = 83,
	AlienC_C01                               = 84,
	Mira                                     = 85,
	Bonyu                                    = 86,
	BnBit_C01                                = 87,
	BnBit_C02                                = 88,
	BnBarrier                                = 89,
	PirateBit_C01                            = 90,
	PirateBit_C02                            = 91,
	PirateBit_C03                            = 92,
	Beerus                                   = 93,
	Whis                                     = 94,
	Freezer_F                                = 95,
	Apuru_L                                  = 96,
	Apuru_C02_L                              = 97,
	Apuru_C03_L                              = 98,
	Apuru_C04_L                              = 99,
	AlienA_C01_L                             = 100,
	AlienA_C02_L                             = 101,
	AlienA_C03_L                             = 102,
	AlienB_C01_L                             = 103,
	AlienB_C02_L                             = 104,
	AlienB_C03_L                             = 105,
	Gotenks_B                                = 106,
	Vegito_B                                 = 107,
	Gohan_E                                  = 108,
	Gohan_F                                  = 109,
	Gohan_G                                  = 110,
	Trunks_C                                 = 111,
	Trunks_D                                 = 112,
	Trunks_E                                 = 113,
	Android17_B                              = 114,
	Android18_B                              = 115,
	Cell_F                                   = 116,
	Babidi_A                                 = 117,
	Dabura_B                                 = 118,
	Shin                                     = 119,
	Cpl027                                   = 120,
	Cpl027_B                                 = 121,
	Cpl078                                   = 122,
	Cpl079                                   = 123,
	Cpl003_C                                 = 124,
	Cpl003_D                                 = 125,
	Cpl005_G                                 = 126,
	Cpl084                                   = 127,
	Cpl085                                   = 128,
	Cpl004_C05                               = 129,
	Cpl086                                   = 130,
	Cpl018_B                                 = 131,
	Cpl017_B                                 = 132,
	Cpl082                                   = 133,
	Cpl082_C02                               = 134,
	Cpl082_C03                               = 135,
	Cpl083                                   = 136,
	Cpl083_C02                               = 137,
	Cpl083_C03                               = 138,
	Cpl094                                   = 139,
	Cpl094_C02                               = 140,
	Cpl094_C03                               = 141,
	Cpl093                                   = 142,
	Cpl093_C02                               = 143,
	Cpl093_C03                               = 144,
	Cpl091                                   = 145,
	Cpl092                                   = 146,
	Cpl082_C04                               = 147,
	Cpl086_C02                               = 148,
	Cpl095                                   = 149,
	Cpl096                                   = 150,
	Cpl096_C02                               = 151,
	Cpl096_C03                               = 152,
	Cpl097                                   = 153,
	Cpl097_C02                               = 154,
	Cpl082_L                                 = 155,
	Cpl082_C02_L                             = 156,
	Cpl082_C03_L                             = 157,
	Cpl093_L                                 = 158,
	Cpl093_C02_L                             = 159,
	Cpl093_C03_L                             = 160,
	Cpl001C                                  = 161,
	Cpl001C_02                               = 162,
	Cpl001D                                  = 163,
	Cpl008B                                  = 164,
	Cpl011B                                  = 165,
	Cpl011C                                  = 166,
	Cpl098A                                  = 167,
	Cpl099A                                  = 168,
	Cpl100A                                  = 169,
	Cpl100B                                  = 170,
	Cpl100C                                  = 171,
	Cpl101A                                  = 172,
	Cpl101B                                  = 173,
	Cpl102A                                  = 174,
	Cpl102B                                  = 175,
	Cpl102C                                  = 176,
	Cpl102D                                  = 177,
	Cpl102E                                  = 178,
	Cpl103A                                  = 179,
	Cpl103B                                  = 180,
	Cpl103C                                  = 181,
	Cpl103D                                  = 182,
	Cpl103E                                  = 183,
	Cpl104A                                  = 184,
	Cpl104B                                  = 185,
	Cpl075D                                  = 186,
	Cpl075E                                  = 187,
	Cpl075F                                  = 188,
	Cpl059D                                  = 189,
	Cpl059E                                  = 190,
	Cpl059F                                  = 191,
	Cpl056D                                  = 192,
	Cpl056E                                  = 193,
	Cpl056F                                  = 194,
	Cpl058D                                  = 195,
	Cpl058E                                  = 196,
	Cpl058F                                  = 197,
	Cpl001E                                  = 198,
	Cpl001F                                  = 199,
	Cpl036B                                  = 200,
	Cpl003E                                  = 201,
	Cpl105A                                  = 202,
	Cpl106A                                  = 203,
	Cpl106B                                  = 204,
	Cpl107A                                  = 205,
	Cpl028F                                  = 206,
	Cpl034G                                  = 207,
	CHARACTER_MAX                            = 208,
};

// Enum AT.E_EMOTION_TYPE
// NumValues: 0x0004
enum class E_EMOTION_TYPE : uint8
{
	NORMAL                                   = 0,
	ANGER                                    = 1,
	PROSTRATION                              = 2,
	MAX                                      = 3,
};

// Enum AT.ESummonIndex
// NumValues: 0x000A
enum class ESummonIndex : uint8
{
	None                                     = 0,
	Summon01                                 = 1,
	Summon02                                 = 2,
	Summon03                                 = 3,
	Summon04                                 = 4,
	Summon05                                 = 5,
	Summon06                                 = 6,
	Summon07                                 = 7,
	Summon08                                 = 8,
	ESummonIndex_MAX                         = 9,
};

// Enum AT.E_ENEMYSPAWN_TYPE
// NumValues: 0x0005
enum class E_ENEMYSPAWN_TYPE : uint8
{
	ENEMYSPAWN_TYPE_NONE                     = 0,
	ENEMYSPAWN_TYPE_ENCOUNT                  = 1,
	ENEMYSPAWN_TYPE_QUEST                    = 2,
	ENEMYSPAWN_TYPE_BOSS                     = 3,
	ENEMYSPAWN_TYPE_MAX                      = 4,
};

// Enum AT.ATTACK_TYPE
// NumValues: 0x0007
enum class EATTACK_TYPE : uint8
{
	NONE                                     = 0,
	WEAK                                     = 1,
	STRONG                                   = 2,
	THROW                                    = 3,
	BURST                                    = 4,
	SPECIAL                                  = 5,
	ATTACK_MAX                               = 6,
};

// Enum AT.VEHICLE_TYPE_EVENT
// NumValues: 0x0006
enum class EVEHICLE_TYPE_EVENT : uint8
{
	VEHICLE_TYPE_EVENT_NONE                  = 0,
	VEHICLE_TYPE_EVENT_KINTOUN               = 1,
	VEHICLE_TYPE_EVENT_AIRCAR                = 2,
	VEHICLE_TYPE_EVENT_TWINFOOT              = 3,
	VEHICLE_TYPE_EVENT_PILLAR                = 4,
	VEHICLE_TYPE_EVENT_MAX                   = 5,
};

// Enum AT.EMiniGameType
// NumValues: 0x0006
enum class EMiniGameType : uint8
{
	MINIGAME_TYPE_NONE                       = 0,
	MINIGAME_TYPE_FISHING                    = 1,
	MINIGAME_TYPE_RACE                       = 2,
	MINIGAME_TYPE_BASEBALL                   = 3,
	MINIGAME_TYPE_TRAININGROOM               = 4,
	MINIGAME_TYPE_MAX                        = 5,
};

// Enum AT.StringID
// NumValues: 0x0005
enum class EStringID : uint8
{
	MSG_Z_BLAST_Level00                      = 0,
	MSG_Z_BLAST_Level01                      = 1,
	MSG_Z_BLAST_Level02                      = 2,
	MSG_Z_BLAST_Level03                      = 3,
	MSG_Z_BLAST_MAX                          = 4,
};

// Enum AT.CrowdResultRank
// NumValues: 0x0004
enum class ECrowdResultRank : uint8
{
	RANK_S                                   = 0,
	RANK_A                                   = 1,
	RANK_B                                   = 2,
	RANK_MAX                                 = 3,
};

// Enum AT.CrowdResultType
// NumValues: 0x0003
enum class ECrowdResultType : uint8
{
	ENDLESS_BATTLE                           = 0,
	TIMEUP_BATTLE                            = 1,
	CrowdResultType_MAX                      = 2,
};

// Enum AT.SUPPORT_TARGET_TYPE
// NumValues: 0x0003
enum class ESUPPORT_TARGET_TYPE : uint8
{
	SUPPORT_LEFT                             = 0,
	SUPPORT_RIGHT                            = 1,
	SUPPORT_MAX                              = 2,
};

// Enum AT.EAT_UIBatteleState
// NumValues: 0x0007
enum class EAT_UIBatteleState : uint8
{
	NONE                                     = 0,
	BATTLE                                   = 1,
	EVENT_BATTLE                             = 2,
	FINISH                                   = 3,
	BACK_ATTACK                              = 4,
	ESCAPE                                   = 5,
	MAX                                      = 6,
};

// Enum AT.RankAnimType
// NumValues: 0x0005
enum class ERankAnimType : uint8
{
	S_RANK_ANIM                              = 0,
	A_RANK_ANIM                              = 1,
	B_RANK_ANIM                              = 2,
	RANK_ANIM_TYPE_NUM                       = 3,
	RankAnimType_MAX                         = 4,
};

// Enum AT.ECountType
// NumValues: 0x0004
enum class ECountType : uint8
{
	None                                     = 0,
	CountUp                                  = 1,
	CountDown                                = 2,
	ECountType_MAX                           = 3,
};

// Enum AT.ETrainingRewardType
// NumValues: 0x0008
enum class ETrainingRewardType : uint8
{
	None                                     = 0,
	SuperTraining                            = 1,
	CrowdTraining                            = 2,
	DLC4ClearTraining                        = 3,
	DLC5ClearTraining                        = 4,
	DLC6ClearTraining                        = 5,
	MainStoryExClearTraining                 = 6,
	Max                                      = 7,
};

// Enum AT.ELogoType
// NumValues: 0x0008
enum class ELogoType : uint8
{
	Cesa                                     = 0,
	Causion                                  = 1,
	Bng                                      = 2,
	CC2                                      = 3,
	CRI                                      = 4,
	Dolby                                    = 5,
	UE4                                      = 6,
	ELogoType_MAX                            = 7,
};

// Enum AT.EUMG_FADE_PAUSE_TYPE
// NumValues: 0x0004
enum class EUMG_FADE_PAUSE_TYPE : uint8
{
	NONE                                     = 0,
	PAUSE                                    = 1,
	READY                                    = 2,
	EUMG_FADE_PAUSE_MAX                      = 3,
};

// Enum AT.EUMG_FADE_COLOR
// NumValues: 0x0003
enum class EUMG_FADE_COLOR : uint8
{
	FADE_COLOR_BLACK                         = 0,
	FADE_COLOR_WHITE                         = 1,
	FADE_COLOR_MAX                           = 2,
};

// Enum AT.EUMG_FADE_TYPE
// NumValues: 0x0004
enum class EUMG_FADE_TYPE : uint8
{
	FADE_NONE                                = 0,
	FADE_IN                                  = 1,
	FADE_OUT                                 = 2,
	FADE_MAX                                 = 3,
};

// Enum AT.StoryDataTableLoadType
// NumValues: 0x0005
enum class EStoryDataTableLoadType : uint8
{
	Nothing                                  = 0,
	DLC4                                     = 1,
	DLC5                                     = 2,
	DLC6                                     = 4,
	StoryDataTableLoadType_MAX               = 5,
};

// Enum AT.ECommunityBoardState
// NumValues: 0x000A
enum class ECommunityBoardState : uint8
{
	NONE                                     = 0,
	MAIN                                     = 1,
	MAIN_EMB_SEL                             = 2,
	MAIN_EMB_SEL_LEADER                      = 3,
	EDITING                                  = 4,
	EDITING_NON_HOLD                         = 5,
	TIPS_TO_LIST                             = 6,
	TIPS_ON_EMB                              = 7,
	END                                      = 8,
	MAX                                      = 9,
};

// Enum AT.ECommunityStart_PageChangeType
// NumValues: 0x0004
enum class ECommunityStart_PageChangeType : uint8
{
	None                                     = 0,
	Right                                    = 1,
	Left                                     = 2,
	ECommunityStart_MAX                      = 3,
};

// Enum AT.ECompZPageBaseNotify
// NumValues: 0x0013
enum class ECompZPageBaseNotify : uint8
{
	None                                     = 0,
	Refresh_Pair                             = 1,
	Request_In                               = 2,
	Request_Out                              = 3,
	PageMove_Back                            = 4,
	PageMove_Next                            = 5,
	PageJump_Back                            = 6,
	PageJump_Next                            = 7,
	Memo_In                                  = 8,
	Memo_Inner                               = 9,
	Memo_Out                                 = 10,
	Index_In                                 = 11,
	Index_Jump                               = 12,
	Index_Out                                = 13,
	Reward_In                                = 14,
	Bgm_Play                                 = 15,
	Bgm_Stop                                 = 16,
	Demo_Play                                = 17,
	ECompZPageBaseNotify_MAX                 = 18,
};

// Enum AT.CookingMenuShopListBaseColorType
// NumValues: 0x0005
enum class ECookingMenuShopListBaseColorType : uint8
{
	POSSIBLE                                 = 0,
	POSSIBLE_SELECTED                        = 1,
	IMPOSSIBLE                               = 2,
	IMPOSSIBLE_SELECTED                      = 3,
	CookingMenuShopListBaseColorType_MAX     = 4,
};

// Enum AT.EKeyGuideCondition
// NumValues: 0x0009
enum class EKeyGuideCondition : uint8
{
	None                                     = 0,
	ZCompleteUnlock                          = 1,
	FieldShot                                = 2,
	Jump                                     = 3,
	Dush                                     = 4,
	BoostJump                                = 5,
	Map                                      = 6,
	NinbusGetOff                             = 7,
	EKeyGuideCondition_MAX                   = 8,
};

// Enum AT.EKeyGuideCtrlMode
// NumValues: 0x0005
enum class EKeyGuideCtrlMode : uint8
{
	None                                     = 0,
	AutoIn                                   = 1,
	Fixed                                    = 2,
	OnOff                                    = 3,
	EKeyGuideCtrlMode_MAX                    = 4,
};

// Enum AT.EKeyGuideType
// NumValues: 0x000D
enum class EKeyGuideType : uint8
{
	None                                     = 0,
	BattleTutorial                           = 1,
	Tutorial                                 = 2,
	Field_G                                  = 3,
	Field_F                                  = 4,
	Nimbus                                   = 5,
	AirCar                                   = 6,
	TwinFoot                                 = 7,
	Battle                                   = 8,
	PillarThrow                              = 9,
	Field_G_DLC5                             = 10,
	Field_F_DLC5                             = 11,
	Max                                      = 12,
};

// Enum AT.EFilteredCharacterType
// NumValues: 0x000E
enum class EFilteredCharacterType : uint8
{
	Goku                                     = 0,
	Gohan                                    = 1,
	Vegeta                                   = 2,
	Piccolo                                  = 3,
	Trunks                                   = 4,
	Kuririn                                  = 5,
	Yamcha                                   = 6,
	Tien                                     = 7,
	Chiaotzu                                 = 8,
	Android18                                = 9,
	Goten                                    = 10,
	Trunks_B                                 = 11,
	Trunks_D                                 = 12,
	EFilteredCharacterType_MAX               = 13,
};

// Enum AT.ETrainingDataConditionType
// NumValues: 0x0006
enum class ETrainingDataConditionType : uint8
{
	EVENT_BATTLE                             = 0,
	LEARNED_SKILL                            = 1,
	CLEARED_SCENARIO                         = 2,
	DMEDAL                                   = 3,
	COMMUNITY                                = 4,
	ETrainingDataConditionType_MAX           = 5,
};

// Enum AT.EShopInfoType
// NumValues: 0x0007
enum class EShopInfoType : uint8
{
	FISHING_SPOT                             = 0,
	HUNTING_SPOT                             = 1,
	COLLEECTION_SPOT                         = 2,
	MINING_SPOT                              = 3,
	CARRACE_INFO                             = 4,
	SHOP_INFO_NUM                            = 5,
	EShopInfoType_MAX                        = 6,
};

// Enum AT.MiniGameBaseballClearType
// NumValues: 0x0006
enum class EMiniGameBaseballClearType : uint8
{
	RANK                                     = 0,
	FLYING_DISTANCE                          = 1,
	CUTIN_LOOK_COUNT                         = 2,
	JUST_MEET_COUNT                          = 3,
	CONTINUOUS_HOMERUNS_COUNT                = 4,
	MiniGameBaseballClearType_MAX            = 5,
};

// Enum AT.MiniGameRaceClearType
// NumValues: 0x0005
enum class EMiniGameRaceClearType : uint8
{
	RANK                                     = 0,
	CLEAR_TIME                               = 1,
	CHECKPOINT_TIME                          = 2,
	PLAY_TIMES                               = 3,
	MiniGameRaceClearType_MAX                = 4,
};

// Enum AT.MiniGameRaceMode
// NumValues: 0x0004
enum class EMiniGameRaceMode : uint8
{
	BIPEDWALKINGROBOT                        = 0,
	AIRCAR                                   = 1,
	LEVITATION_TECHNIQUE                     = 2,
	MiniGameRaceMode_MAX                     = 3,
};

// Enum AT.EOptionItemType
// NumValues: 0x0009
enum class EOptionItemType : uint8
{
	Normal                                   = 0,
	PopUp                                    = 1,
	Volume                                   = 2,
	Display                                  = 3,
	Number                                   = 4,
	KeyBind                                  = 5,
	Append                                   = 6,
	BgmSel                                   = 7,
	EOptionItemType_MAX                      = 8,
};

// Enum AT.E_UI_MAP_TYPE
// NumValues: 0x0005
enum class E_UI_MAP_TYPE : uint8
{
	None                                     = 0,
	Field                                    = 1,
	Town                                     = 2,
	Landmark                                 = 3,
	E_UI_MAP_MAX                             = 4,
};

// Enum AT.EEncounterDirectionType
// NumValues: 0x0007
enum class EEncounterDirectionType : uint8
{
	NORMAL                                   = 0,
	SUB_QUEST                                = 1,
	MAIN_QUEST                               = 2,
	ENEMY                                    = 3,
	DB                                       = 4,
	CHECKPOINT                               = 5,
	MAX                                      = 6,
};

// Enum AT.RIDE_ICON_TYPE
// NumValues: 0x0006
enum class ERIDE_ICON_TYPE : uint8
{
	CLOUD                                    = 0,
	CAR                                      = 1,
	ROBOT                                    = 2,
	FLY                                      = 3,
	PILLAR                                   = 4,
	MAX                                      = 5,
};

// Enum AT.EMobAgeType
// NumValues: 0x0007
enum class EMobAgeType : uint8
{
	MaleAdult                                = 0,
	MaleAged                                 = 1,
	MaleChildren                             = 2,
	FemaleAdult                              = 3,
	FemaleAged                               = 4,
	FemaleChildren                           = 5,
	Max                                      = 6,
};

// Enum AT.EMobSectorType
// NumValues: 0x000F
enum class EMobSectorType : uint8
{
	Sector071                                = 0,
	Sector072                                = 1,
	Sector041                                = 2,
	Sector021                                = 3,
	Sector031                                = 4,
	Sector032                                = 5,
	Sector011                                = 6,
	Sector012                                = 7,
	Sector051                                = 8,
	Sector052                                = 9,
	Sector061                                = 10,
	Sector101                                = 11,
	Sector111                                = 12,
	Sector112                                = 13,
	Max                                      = 14,
};

// Enum AT.DAMAGE_TYPE
// NumValues: 0x0004
enum class EDAMAGE_TYPE : uint8
{
	DAMAGE_TYPE_NORMAL                       = 0,
	DAMAGE_TYPE_CRITICAL                     = 1,
	DAMAGE_TYPE_LANDFORM                     = 2,
	DAMAGE_TYPE_MAX                          = 3,
};

// Enum AT.DESTINATION_TYPE
// NumValues: 0x0006
enum class EDESTINATION_TYPE : uint8
{
	DESTINATION_QUEST_02                     = 0,
	DESTINATION_QUEST_01                     = 1,
	DESTINATION_EVENT_02                     = 2,
	DESTINATION_EVENT_01                     = 3,
	DESTINATION_MAIN                         = 4,
	DESTINATION_MAX                          = 5,
};

// Enum AT.COMMON_ANIM_PARAM_ID
// NumValues: 0x0002
enum class ECOMMON_ANIM_PARAM_ID : uint8
{
	COMMON_ANIM_PARAM_QUESTION_RANGE         = 0,
	COMMON_ANIM_PARAM_QUESTION_MAX           = 1,
};

// Enum AT.ENEMY_CONDITION_TYPE
// NumValues: 0x0005
enum class ENEMY_CONDITION_TYPE : uint8
{
	ENEMY_CONDITION_NONE                     = 0,
	ENEMY_CONDITION_SAIYAN                   = 1,
	ENEMY_CONDITION_BURST                    = 2,
	ENEMY_CONDITION_TYPE_MAX                 = 3,
	ENEMY_CONDITION_MAX                      = 4,
};

// Enum AT.EInfoLogIconCategoryType
// NumValues: 0x0004
enum class EInfoLogIconCategoryType : uint8
{
	ITEM                                     = 0,
	GROUP                                    = 1,
	INFO                                     = 2,
	EInfoLogIconCategoryType_MAX             = 3,
};

// Enum AT.EKeyHelpGroup
// NumValues: 0x0004
enum class EKeyHelpGroup : uint8
{
	MenuControl                              = 0,
	FieldControl                             = 1,
	Nothing                                  = 2,
	EKeyHelpGroup_MAX                        = 3,
};

// Enum AT.EKeyHelpId
// NumValues: 0x0035
enum class EKeyHelpId : uint8
{
	Decide                                   = 0,
	Cancel                                   = 1,
	Btn00                                    = 2,
	Btn01                                    = 3,
	Btn02                                    = 4,
	Btn03                                    = 5,
	BtnR1                                    = 6,
	BtnR2                                    = 7,
	BtnR3                                    = 8,
	BtnL1                                    = 9,
	BtnL2                                    = 10,
	BtnL3                                    = 11,
	DpadNeutral                              = 12,
	DpadLeft                                 = 13,
	DpadUp                                   = 14,
	DpadRight                                = 15,
	DpadDown                                 = 16,
	DpadHorizontal                           = 17,
	DpadVertical                             = 18,
	StickRightNeutral                        = 19,
	StickLeftNeutral                         = 20,
	BtnOptions                               = 21,
	BtnTouchPad                              = 22,
	KeyConfirm                               = 23,
	KeyCancel                                = 24,
	KeyFastForward                           = 25,
	KeyAutoFeed                              = 26,
	BaseballSwing                            = 27,
	KeysConfirmAndCancel                     = 28,
	KeysTouchPadAndCancel                    = 29,
	KeysOptionsAndCancel                     = 30,
	KeysBtnR1AndConfirm                      = 31,
	KeysPagePrev                             = 32,
	KeysPageNext                             = 33,
	W                                        = 34,
	A                                        = 35,
	S                                        = 36,
	D                                        = 37,
	GCG_Up                                   = 38,
	GCG_Left                                 = 39,
	GCG_Down                                 = 40,
	GCG_Right                                = 41,
	GCG_TurnEnd_Save                         = 42,
	GCG_Tab_Left                             = 43,
	GCG_Tab_Right                            = 44,
	GCG_Deck_Switch                          = 45,
	GCG_Detail                               = 46,
	GCG_Log_Receipt                          = 47,
	GCG_Card_Delete                          = 48,
	GCG_Card_Generat                         = 49,
	GCG_TestBattle                           = 50,
	KeyNothing                               = 51,
	EKeyHelpId_MAX                           = 52,
};

// Enum AT.LockonCursorAnimType
// NumValues: 0x0004
enum class ELockonCursorAnimType : uint8
{
	LockOnCursor_InAnim                      = 0,
	LockOnCursor_OutAnim                     = 1,
	LockOnCursor_Anim_Num                    = 2,
	LockOnCursor_MAX                         = 3,
};

// Enum AT.EMapNaviIcon
// NumValues: 0x0005
enum class EMapNaviIcon : uint8
{
	PLAYER_NAVI                              = 0,
	MAIN_QUEST                               = 1,
	SUB_QUEST                                = 2,
	DLC6_QUEST                               = 3,
	EMapNaviIcon_MAX                         = 4,
};

// Enum AT.EMapIcon
// NumValues: 0x0044
enum class EMapIcon : uint8
{
	NONE                                     = 0,
	FOOD_SHOP                                = 1,
	COOKING_SHOP                             = 2,
	MATERIAL_SHOP                            = 3,
	SEARCH_COMMUNITY                         = 4,
	FISHING                                  = 5,
	COLLECTING                               = 6,
	HUNTING                                  = 7,
	ORE                                      = 8,
	COMMON                                   = 9,
	INFORMATION_STORE                        = 10,
	MINI_GAME_RESCUE                         = 11,
	MINI_GAME_BASEBALL                       = 12,
	MINI_GAME_RACE                           = 13,
	MINI_GAME_PUNCH                          = 14,
	PRACTICE                                 = 15,
	PRACTICE_BATTLE                          = 16,
	DEVELOPMENT                              = 17,
	FOODSTUFF_COMM                           = 18,
	TIME_MACHINE                             = 19,
	PLAYER_NAVI                              = 20,
	PLAYER                                   = 21,
	MINI_GAME_CHECK_POINT                    = 22,
	MINI_GAME_GOAL                           = 23,
	MAINQUEST_NO_BATTLE                      = 24,
	TRAININGROOM                             = 25,
	SUBQUEST_NO_BATTLE                       = 26,
	TURTLESCHOOL                             = 27,
	DRAGON_BALL                              = 28,
	PLAYER_MARKER                            = 29,
	EVIL_ENEMY                               = 30,
	EVIL_ENEMY_BOSS                          = 31,
	ENEMIES_BASE                             = 32,
	FIELD_MEMORY                             = 33,
	EVIL_ENEMY_2                             = 34,
	EVIL_ENEMY_BOSS_2                        = 35,
	ENEMIES_AIRSHIP                          = 36,
	TCG                                      = 37,
	GroupBattle                              = 38,
	GroupBattlePractice                      = 39,
	SubQuestFreezer                          = 40,
	DRONE_COMMANDER                          = 41,
	Researcher                               = 42,
	Submarine                                = 43,
	SaiyanHangout                            = 44,
	MedicalRoom                              = 45,
	StoryReplay                              = 46,
	DlcStory04SubQuest                       = 47,
	ClearedPractice                          = 48,
	GRD_Enemy                                = 49,
	GRD_SuperEnemyGroup                      = 50,
	ICE_STALL_SHOP                           = 51,
	GRD_EnemyGroup                           = 52,
	DlcStory05SubQuest                       = 53,
	TAKOYAKI_STALL_SHOP                      = 54,
	HOTDOG_STALL_SHOP                        = 55,
	Police                                   = 56,
	ReturnToMain                             = 57,
	Restaurant                               = 58,
	DlcStory06SubQuest                       = 59,
	Field_Memory_Battle                      = 60,
	Fortuneteller_BABA                       = 61,
	HAVING_TEXTURE_MAX                       = 62,
	MAINQUEST_RANGE_ONLY                     = 63,
	SUBQUEST_RANGE_ONLY                      = 64,
	DANGER_ZONE_RANGE_ONLY                   = 65,
	COMMON_RANGE_ONLY                        = 66,
	MAX                                      = 67,
};

// Enum AT.AreaMapState
// NumValues: 0x0005
enum class EAreaMapState : uint8
{
	Closed                                   = 0,
	Open                                     = 1,
	Select                                   = 2,
	Close                                    = 3,
	AreaMapState_MAX                         = 4,
};

// Enum AT.ELandmarkIconType
// NumValues: 0x0015
enum class ELandmarkIconType : uint8
{
	None                                     = 0,
	Area01_00_00                             = 1,
	Area01_00_01                             = 2,
	Area03_00_04                             = 3,
	Area03_00_05                             = 4,
	Area03_02_00                             = 5,
	Area03_02_01                             = 6,
	Area04_00_00                             = 7,
	Area06_00_00                             = 8,
	Area07_00_01                             = 9,
	Area07_02_01                             = 10,
	Area09_00_00                             = 11,
	Area09_00_01                             = 12,
	Area11_00_03                             = 13,
	Area16_00_00                             = 14,
	Area16_00_01                             = 15,
	Area11_00_00                             = 16,
	Area11_00_01                             = 17,
	Area11_00_02                             = 18,
	Area11_00_04                             = 19,
	Max                                      = 20,
};

// Enum AT.EWMapAreaId
// NumValues: 0x0011
enum class EWMapAreaId : uint8
{
	AreaId01                                 = 0,
	AreaId02                                 = 1,
	AreaId03                                 = 2,
	AreaId04                                 = 3,
	AreaId05                                 = 4,
	AreaId06                                 = 5,
	AreaId07                                 = 6,
	AreaId08                                 = 7,
	AreaId09                                 = 8,
	AreaId10                                 = 9,
	AreaId11                                 = 10,
	AreaId12                                 = 11,
	AreaId13                                 = 12,
	AreaId14                                 = 13,
	AreaIdNum                                = 14,
	AreaIdNone                               = 15,
	EWMapAreaId_MAX                          = 16,
};

// Enum AT.UI_MINIGAME_TOP_ESELECT_ID
// NumValues: 0x0023
enum class EUI_MINIGAME_TOP_ESELECT_ID : uint8
{
	SELECT_ID_MACHINE                        = 0,
	SELECT_ID_CUSTOMIZE                      = 1,
	SELECT_ID_POWER_UP                       = 2,
	SELECT_ID_BENTO                          = 3,
	SELECT_ID_COURCE                         = 4,
	SELECT_ID_BUY                            = 5,
	SELECT_ID_SELL                           = 6,
	SELECT_ID_AIRCAR                         = 7,
	SELECT_ID_BIPEDWALKINGROBOT              = 8,
	SELECT_ID_AIRCAR_CHALLENGE               = 9,
	SELECT_ID_AIRCAR_LOG                     = 10,
	SELECT_ID_AIRCAR_REWARD                  = 11,
	SELECT_ID_BIPEDWALKINGROBOT_CHALLENGE    = 12,
	SELECT_ID_BIPEDWALKINGROBOT_LOG          = 13,
	SELECT_ID_BIPEDWALKINGROBOT_REWARD       = 14,
	SELECT_ID_BASEBALL_ELEMENTARY_LEVEL      = 15,
	SELECT_ID_BASEBALL_INTERMEDIATE_LEVEL    = 16,
	SELECT_ID_BASEBALL_ADVANCED_LEVEL        = 17,
	SELECT_ID_BASEBALL_SUPERLATIVE           = 18,
	SELECT_ID_BASEBALL_ELEMENTARY_LEVEL_CHALLENGE = 19,
	SELECT_ID_BASEBALL_ELEMENTARY_LEVEL_LOG  = 20,
	SELECT_ID_BASEBALL_ELEMENTARY_LEVEL_REWARD = 21,
	SELECT_ID_BASEBALL_INTERMEDIATE_LEVEL_CHALLENGE = 22,
	SELECT_ID_BASEBALL_INTERMEDIATE_LEVEL_LOG = 23,
	SELECT_ID_BASEBALL_INTERMEDIATE_LEVEL_REWARD = 24,
	SELECT_ID_BASEBALL_ADVANCED_LEVEL_CHALLENGE = 25,
	SELECT_ID_BASEBALL_ADVANCED_LEVEL_LOG    = 26,
	SELECT_ID_BASEBALL_ADVANCED_LEVEL_REWARD = 27,
	SELECT_ID_BASEBALL_SUPERLATIVE_CHALLENGE = 28,
	SELECT_ID_BASEBALL_SUPERLATIVE_LOG       = 29,
	SELECT_ID_BASEBALL_SUPERLATIVE_REWARD    = 30,
	SELECT_ID_CANCEL                         = 31,
	SELECT_ID_NUM                            = 32,
	SELECT_ID_NONE                           = 33,
	SELECT_ID_MAX                            = 34,
};

// Enum AT.EMINIGAMETOPTYPE_ID
// NumValues: 0x000F
enum class EMINIGAMETOPTYPE_ID : uint8
{
	TYPE_NONE                                = 0,
	TYPE_DEVELOPMENT                         = 1,
	TYPE_BENTO_SHOP                          = 2,
	TYPE_COOKING_CHICHI                      = 3,
	TYPE_MATERIAL_SHOP                       = 4,
	TYPE_FOODSTUFF_SHOP                      = 5,
	TYPE_INFORMATION_SHOP                    = 6,
	TYPE_REPAIR_SHOP                         = 7,
	TYPE_RACE                                = 8,
	TYPE_BASEBALL                            = 9,
	TYPE_RESCUE                              = 10,
	TYPE_PUNCH                               = 11,
	TYPE_QUIZ                                = 12,
	TYPE_NUM                                 = 13,
	TYPE_MAX                                 = 14,
};

// Enum AT.PointIconIndex
// NumValues: 0x000B
enum class EPointIconIndex : uint8
{
	FISH                                     = 0,
	WIND                                     = 1,
	DINOSAUR                                 = 2,
	QUEST                                    = 3,
	RACE                                     = 4,
	BASEBALL                                 = 5,
	RESQUE                                   = 6,
	PUNCH                                    = 7,
	TRAINING                                 = 8,
	TRAININGROOM                             = 9,
	PointIconIndex_MAX                       = 10,
};

// Enum AT.UIMiniGameWin00_Mode
// NumValues: 0x0005
enum class EUIMiniGameWin00_Mode : uint8
{
	Ranking                                  = 0,
	QuestRetry                               = 1,
	ResultRanking                            = 2,
	RewardList                               = 3,
	UIMiniGameWin00_MAX                      = 4,
};

// Enum AT.EQuestImageAnimationType
// NumValues: 0x0006
enum class EQuestImageAnimationType : uint8
{
	None                                     = 0,
	PanUp                                    = 1,
	PanDown                                  = 2,
	PanRight                                 = 3,
	PanLeft                                  = 4,
	EQuestImageAnimationType_MAX             = 5,
};

// Enum AT.ShopCommonShowMode
// NumValues: 0x0003
enum class EShopCommonShowMode : uint8
{
	BUY                                      = 0,
	SELL                                     = 1,
	ShopCommonShowMode_MAX                   = 2,
};

// Enum AT.ESHOPTOP_SELECT_ID
// NumValues: 0x0019
enum class ESHOPTOP_SELECT_ID : uint8
{
	SELECT_ID_MACHINE                        = 0,
	SELECT_ID_CUSTOMIZE                      = 1,
	SELECT_ID_POWER_UP                       = 2,
	SELECT_ID_BENTO                          = 3,
	SELECT_ID_COURCE                         = 4,
	SELECT_ID_CHAPTER_SAIYAZIN               = 5,
	SELECT_ID_CHAPTER_FREEZER                = 6,
	SELECT_ID_CHAPTER_CELL                   = 7,
	SELECT_ID_CHAPTER_BUU                    = 8,
	SELECT_ID_CHAPTER_XXX                    = 9,
	SELECT_ID_BUY                            = 10,
	SELECT_ID_SELL                           = 11,
	SELECT_ID_TRADE                          = 12,
	SELECT_ID_TRAINING_ACTIVESKILL           = 13,
	SELECT_ID_TRAINING_PASSIVE               = 14,
	SELECT_ID_TRAININGROOM_IN                = 15,
	SELECT_ID_TRAININGROOM_REMODEL           = 16,
	SELECT_ID_TRAININGROOM_SIMULATOR         = 17,
	SELECT_ID_SUPER_TRAINING                 = 18,
	SELECT_ID_BREAKTHROUGH                   = 19,
	SELECT_ID_TICKET_TRADE                   = 20,
	SELECT_ID_CANCEL                         = 21,
	SELECT_ID_NUM                            = 22,
	SELECT_ID_NONE                           = 23,
	SELECT_ID_MAX                            = 24,
};

// Enum AT.SHOPTOP_DEBUG_ID
// NumValues: 0x000C
enum class ESHOPTOP_DEBUG_ID : uint8
{
	INPUT_CANCEL                             = 0,
	TYPE_DEVELOPMENT                         = 1,
	TYPE_BENTO_SHOP                          = 2,
	TYPE_COOKING_CHICHI                      = 3,
	TYPE_SHOP                                = 4,
	TYPE_PARTS_TRADE                         = 5,
	TYPE_TRAINING                            = 6,
	TYPE_TRAINING_ROOM                       = 7,
	INPUT_UP                                 = 8,
	INPUT_DOWN                               = 9,
	INPUT_DECIDE                             = 10,
	SHOPTOP_DEBUG_MAX                        = 11,
};

// Enum AT.ESHOPTYPE_ID
// NumValues: 0x0012
enum class ESHOPTYPE_ID : uint8
{
	TYPE_NONE                                = 0,
	TYPE_DEVELOPMENT                         = 1,
	TYPE_BENTO_SHOP                          = 2,
	TYPE_COOKING_CHICHI                      = 3,
	TYPE_QUEST_RETRY                         = 4,
	TYPE_MATERIAL_SHOP                       = 5,
	TYPE_FOODSTUFF_SHOP                      = 6,
	TYPE_INFORMATION_SHOP                    = 7,
	TYPE_REPAIR_SHOP                         = 8,
	TYPE_TRAINING                            = 9,
	TYPE_TRAINING_ROOM                       = 10,
	TYPE_SUPER_TRAINING                      = 11,
	TYPE_FOODSTUFF_YOGENGYO                  = 12,
	TYPE_DLC3_TRAINING_ROOM                  = 13,
	TYPE_DLC3_PARTS_TRADE                    = 14,
	TYPE_COOKING_RESTAURANT                  = 15,
	TYPE_NUM                                 = 16,
	TYPE_MAX                                 = 17,
};

// Enum AT.EGroupBattleSwitch
// NumValues: 0x0003
enum class EGroupBattleSwitch : uint8
{
	Normal                                   = 0,
	BestScore                                = 1,
	EGroupBattleSwitch_MAX                   = 2,
};

// Enum AT.EShopTraining03MenuType
// NumValues: 0x0008
enum class EShopTraining03MenuType : uint8
{
	None                                     = 0,
	SuperTraining                            = 1,
	CrowdTraining                            = 2,
	AreaChangeTraining                       = 3,
	DLC5Training                             = 4,
	DLC6Training                             = 5,
	MainStoryExTraining                      = 6,
	Max                                      = 7,
};

// Enum AT.EShopTraining04MenuType
// NumValues: 0x0005
enum class EShopTraining04MenuType : uint8
{
	None                                     = 0,
	BreakThrough                             = 1,
	ChallengeBeerus                          = 2,
	ChallengeFreezerF                        = 3,
	Max                                      = 4,
};

// Enum AT.ESkillEnemyIconType
// NumValues: 0x0006
enum class ESkillEnemyIconType : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Boss                                     = 2,
	BossPowerful                             = 3,
	Num                                      = 4,
	ESkillEnemyIconType_MAX                  = 5,
};

// Enum AT.EUnselectableFilterText
// NumValues: 0x0005
enum class EUnselectableFilterText : uint8
{
	None                                     = 0,
	CanNotSelect                             = 1,
	CanNotSelectSupporterOnly                = 2,
	CanNotSelectLocked                       = 3,
	EUnselectableFilterText_MAX              = 4,
};

// Enum AT.EDragonBallBtnWishState
// NumValues: 0x0005
enum class EDragonBallBtnWishState : uint32
{
	None                                     = 0,
	Select                                   = 1,
	NotSelect                                = 2,
	CanSelect                                = 3,
	EDragonBallBtnWishState_MAX              = 4,
};

// Enum AT.EWishSelectState
// NumValues: 0x0004
enum class EWishSelectState : uint32
{
	None                                     = 0,
	WishFrameSelect                          = 1,
	WishSelect                               = 2,
	EWishSelectState_MAX                     = 3,
};

// Enum AT.EWishBarSelectState
// NumValues: 0x0006
enum class EWishBarSelectState : uint32
{
	None                                     = 0,
	SetSelect                                = 1,
	NotSet                                   = 2,
	Set                                      = 3,
	ChangeText                               = 4,
	EWishBarSelectState_MAX                  = 5,
};

// Enum AT.StartPartyBarType
// NumValues: 0x0005
enum class EStartPartyBarType : uint32
{
	Player                                   = 0,
	Support1                                 = 1,
	Support2                                 = 2,
	Reserve                                  = 3,
	StartPartyBarType_MAX                    = 4,
};

// Enum AT.StartPartyBarEditMode
// NumValues: 0x0008
enum class EStartPartyBarEditMode : uint32
{
	Configured                               = 0,
	Empty                                    = 1,
	UnConfigurable                           = 2,
	UseItem                                  = 3,
	CannotUseItem                            = 4,
	ExpGive                                  = 5,
	ExpGiveCannotUseItem                     = 6,
	StartPartyBarEditMode_MAX                = 7,
};

// Enum AT.EViewStatusIconType
// NumValues: 0x0008
enum class EViewStatusIconType : uint8
{
	NearAtk                                  = 0,
	FarAtk                                   = 1,
	NearDef                                  = 2,
	FarDef                                   = 3,
	Critical                                 = 4,
	HP                                       = 5,
	SP                                       = 6,
	EViewStatusIconType_MAX                  = 7,
};

// Enum AT.EViewStatusBuffType
// NumValues: 0x0005
enum class EViewStatusBuffType : uint8
{
	None                                     = 0,
	PassiveSkill                             = 1,
	StatusGrant                              = 2,
	Cooking                                  = 3,
	EViewStatusBuffType_MAX                  = 4,
};

// Enum AT.GaugeColor
// NumValues: 0x0003
enum class EGaugeColor : uint8
{
	SP                                       = 0,
	HP                                       = 1,
	GaugeColor_MAX                           = 2,
};

// Enum AT.SkillIcon
// NumValues: 0x0006
enum class ESkillIcon : uint8
{
	SHORT_DISTANCE                           = 0,
	LONG_DISTANCE                            = 1,
	HIGH_SPEED                               = 2,
	SPY_KING                                 = 3,
	SPECIAL                                  = 4,
	SkillIcon_MAX                            = 5,
};

// Enum AT.START_TOP_LIST_ID
// NumValues: 0x0010
enum class ESTART_TOP_LIST_ID : uint8
{
	COMMUNITY                                = 0,
	DRAGONBALL                               = 1,
	ITEM                                     = 2,
	PARTY                                    = 3,
	QUEST                                    = 4,
	CHARACTER                                = 5,
	SYSTEM                                   = 6,
	COMMUNITY_BOARD                          = 7,
	COMMUNITY_EMBLEM                         = 8,
	SYSTEM_SAVE                              = 9,
	SYSTEM_LOAD                              = 10,
	SYSTEM_OPTION                            = 11,
	SYSTEM_TUTORIAL                          = 12,
	SYSTEM_TITLE                             = 13,
	DLC                                      = 14,
	MAX                                      = 15,
};

// Enum AT.EAnimType
// NumValues: 0x000D
enum class EAnimType : uint8
{
	None                                     = 0,
	In                                       = 1,
	Out                                      = 2,
	Sign                                     = 3,
	FadeIn                                   = 4,
	FadeOut                                  = 5,
	Slide_L                                  = 6,
	Slide_R                                  = 7,
	SlideUpLine_L                            = 8,
	SlideDownLine_L                          = 9,
	SlideUpLine_R                            = 10,
	SlideDownLine_R                          = 11,
	Max                                      = 12,
};

// Enum AT.E_STATE_ICON_TYPE
// NumValues: 0x0013
enum class E_STATE_ICON_TYPE : uint8
{
	NONE                                     = 0,
	BUFF_SHORT_RANGE_ATK_UP                  = 1,
	BUFF_LONG_RANGE_ATK_UP                   = 2,
	BUFF_SHORT_RANGE_DEF_UP                  = 3,
	BUFF_LONG_RANGE_DEF_UP                   = 4,
	BUFF_CRITICAL_RATE_UP                    = 5,
	BUFF_HP_UP                               = 6,
	BUFF_HP_AUTO_REFRESH                     = 7,
	BUFF_ENERGY_UP                           = 8,
	BUFF_ENERGY_RECOVERY_UP                  = 9,
	DEBUFF_STOP                              = 10,
	DEBUFF_BLIND                             = 11,
	DEBUFF_SHACKLES                          = 12,
	DEBUFF_CANDY                             = 13,
	BUFF_EXPERIENCE_UP                       = 14,
	BUFF_ZORB_AVAILABILITY_UP                = 15,
	BUFF_ITME_DROP_NUM_UP                    = 16,
	BUFF_ITME_DROP_RATE_UP                   = 17,
	MAX                                      = 18,
};

// Enum AT.SystemWindowAnimType
// NumValues: 0x0004
enum class ESystemWindowAnimType : uint8
{
	SystemWindow_InAnim                      = 0,
	SystemWindow_OutAnim                     = 1,
	SystemWindow_Anim_Num                    = 2,
	SystemWindow_MAX                         = 3,
};

// Enum AT.ETelopViewType
// NumValues: 0x0005
enum class ETelopViewType : uint8
{
	LTop                                     = 0,
	RTop                                     = 1,
	LBottom                                  = 2,
	RBottom                                  = 3,
	ETelopViewType_MAX                       = 4,
};

// Enum AT.EPlayerBattleHUDAppearance
// NumValues: 0x0004
enum class EPlayerBattleHUDAppearance : uint8
{
	STANDARD_APPEARANCE                      = 0,
	BROKEN_APPEARANCE                        = 1,
	NO_SP_NUMBER_APPEARANCE                  = 2,
	MAX                                      = 3,
};

// Enum AT.ESpGaugeOverlayAppearance
// NumValues: 0x0003
enum class ESpGaugeOverlayAppearance : uint8
{
	STANDARD_APPEARANCE                      = 0,
	BROKEN_APPEARANCE                        = 1,
	MAX                                      = 2,
};

// Enum AT.EEpisodeId
// NumValues: 0x000C
enum class EEpisodeId : uint8
{
	EpisodeNone                              = 0,
	EpisodeSaiyajin                          = 1,
	EpisodeFreezer                           = 2,
	EpisodeCell                              = 3,
	EpisodeBuu                               = 4,
	EpisodeFinish                            = 5,
	EpisodeDLC3                              = 6,
	EpisodeDLC4                              = 7,
	EpisodeDLC5                              = 8,
	EpisodeDLC6                              = 9,
	EpisodeNum                               = 10,
	EEpisodeId_MAX                           = 11,
};

// Enum AT.EEMB_ICON_TYPE
// NumValues: 0x0008
enum class EEMB_ICON_TYPE : uint8
{
	None                                     = 0,
	Question                                 = 1,
	Lock                                     = 2,
	Normal                                   = 3,
	Silver                                   = 4,
	Gold                                     = 5,
	Cap                                      = 6,
	Max                                      = 7,
};

// Enum AT.EXCmnHeaderIconType
// NumValues: 0x0009
enum class EXCmnHeaderIconType : uint8
{
	Cooking                                  = 0,
	Development                              = 1,
	Training                                 = 2,
	Gods                                     = 3,
	Adult                                    = 4,
	Adventure                                = 5,
	ZFighters                                = 6,
	MAX                                      = 7,
	None                                     = 8,
};

// Enum AT.EXCmnHeaderFontType
// NumValues: 0x003A
enum class EXCmnHeaderFontType : uint8
{
	CommuTop                                 = 0,
	CommuBoard                               = 1,
	Item                                     = 2,
	Option                                   = 3,
	Save                                     = 4,
	SoulEmblem                               = 5,
	StoryResult                              = 6,
	MainMenu                                 = 7,
	World                                    = 8,
	Character                                = 9,
	Customize                                = 10,
	Development                              = 11,
	Powerup                                  = 12,
	Cooking                                  = 13,
	SkillTree                                = 14,
	SkillCustomize                           = 15,
	Quest                                    = 16,
	Tutorial                                 = 17,
	Load                                     = 18,
	Db                                       = 19,
	Shop                                     = 20,
	Areamap                                  = 21,
	Race                                     = 22,
	Baseball                                 = 23,
	Party                                    = 24,
	CommuQuest                               = 25,
	System                                   = 26,
	InfoShop                                 = 27,
	PastQuest                                = 28,
	MealTime                                 = 29,
	ShopFood                                 = 30,
	ShopMaterial                             = 31,
	ShopPartsTrade                           = 32,
	Learning                                 = 33,
	Training                                 = 34,
	Dlc                                      = 35,
	PastQuestDLC4                            = 36,
	TcgTop                                   = 37,
	TcgHome                                  = 37,
	TcgProfile                               = 38,
	TcgDeckSelect                            = 39,
	TcgDeckEdit                              = 40,
	TcgBdokai                                = 41,
	TcgMissionList                           = 42,
	TcgGiftBox                               = 43,
	TcgRanking                               = 44,
	TcgHelp                                  = 45,
	TcgTraining                              = 46,
	TcgOption                                = 47,
	TcgShopSelect                            = 48,
	TcgSystem                                = 49,
	TcgBattleSelect                          = 50,
	TcgCardGallery                           = 51,
	TcgBattleLobby                           = 52,
	TcgStageSelect                           = 53,
	TcgRandomBattle                          = 54,
	FontTypeNum                              = 55,
	EXCmnHeaderFontType_MAX                  = 56,
};

// Enum AT.EMiniHeaderType
// NumValues: 0x0004
enum class EMiniHeaderType : uint8
{
	BaseBall                                 = 0,
	Fishing                                  = 1,
	Race                                     = 2,
	EMiniHeaderType_MAX                      = 3,
};

// Enum AT.EATPlatBtnId
// NumValues: 0x0099
enum class EATPlatBtnId : uint8
{
	Btn00                                    = 0,
	Btn01                                    = 1,
	Btn02                                    = 2,
	Btn03                                    = 3,
	BtnR1                                    = 4,
	BtnR2                                    = 5,
	BtnR3                                    = 6,
	BtnL1                                    = 7,
	BtnL2                                    = 8,
	BtnL3                                    = 9,
	DpadNeutral                              = 10,
	DpadLeft                                 = 11,
	DpadUp                                   = 12,
	DpadRight                                = 13,
	DpadDown                                 = 14,
	DpadHorizontal                           = 15,
	DpadVertical                             = 16,
	StickRightNeutral                        = 17,
	StickLeftNeutral                         = 18,
	BtnOptions                               = 19,
	BtnTouchPad                              = 20,
	MouseX                                   = 21,
	MouseY                                   = 22,
	MouseScrollUp                            = 23,
	MouseScrollDown                          = 24,
	MouseWheelAxis                           = 25,
	LeftMouseButton                          = 26,
	RightMouseButton                         = 27,
	MiddleMouseButton                        = 28,
	ThumbMouseButton                         = 29,
	ThumbMouseButton2                        = 30,
	BackSpace                                = 31,
	Tab                                      = 32,
	Enter                                    = 33,
	Pause                                    = 34,
	CapsLock                                 = 35,
	Escape                                   = 36,
	SpaceBar                                 = 37,
	PageUp                                   = 38,
	PageDown                                 = 39,
	End                                      = 40,
	Home                                     = 41,
	Left                                     = 42,
	Up                                       = 43,
	Right                                    = 44,
	Down                                     = 45,
	UpDown                                   = 46,
	LeftRight                                = 47,
	AllArrow                                 = 48,
	Insert                                   = 49,
	Delete                                   = 50,
	Zero                                     = 51,
	One                                      = 52,
	Two                                      = 53,
	Three                                    = 54,
	Four                                     = 55,
	Five                                     = 56,
	Six                                      = 57,
	Seven                                    = 58,
	Eight                                    = 59,
	Nine                                     = 60,
	A                                        = 61,
	B                                        = 62,
	C                                        = 63,
	D                                        = 64,
	E                                        = 65,
	F                                        = 66,
	G                                        = 67,
	H                                        = 68,
	I                                        = 69,
	J                                        = 70,
	K                                        = 71,
	L                                        = 72,
	M                                        = 73,
	N                                        = 74,
	O                                        = 75,
	P                                        = 76,
	Q                                        = 77,
	R                                        = 78,
	S                                        = 79,
	T                                        = 80,
	U                                        = 81,
	V                                        = 82,
	W                                        = 83,
	X                                        = 84,
	Y                                        = 85,
	Z                                        = 86,
	NumPadZero                               = 87,
	NumPadOne                                = 88,
	NumPadTwo                                = 89,
	NumPadThree                              = 90,
	NumPadFour                               = 91,
	NumPadFive                               = 92,
	NumPadSix                                = 93,
	NumPadSeven                              = 94,
	NumPadEight                              = 95,
	NumPadNine                               = 96,
	Multiply                                 = 97,
	Add                                      = 98,
	Subtract                                 = 99,
	Decimal                                  = 100,
	Divide                                   = 101,
	F1                                       = 102,
	F2                                       = 103,
	F3                                       = 104,
	F4                                       = 105,
	F5                                       = 106,
	F6                                       = 107,
	F7                                       = 108,
	F8                                       = 109,
	F9                                       = 110,
	F10                                      = 111,
	F11                                      = 112,
	F12                                      = 113,
	NumLock                                  = 114,
	ScrollLock                               = 115,
	LeftShift                                = 116,
	RightShift                               = 117,
	LeftControl                              = 118,
	RightControl                             = 119,
	LeftAlt                                  = 120,
	RightAlt                                 = 121,
	LeftCommand                              = 122,
	RightCommand                             = 123,
	Semicolon                                = 124,
	Equals                                   = 125,
	Comma                                    = 126,
	Underscore                               = 127,
	Hyphen                                   = 128,
	Period                                   = 129,
	Slash                                    = 130,
	Tilde                                    = 131,
	LeftBracket                              = 132,
	LeftParantheses                          = 133,
	Backslash                                = 134,
	RightBracket                             = 135,
	RightParantheses                         = 136,
	Apostrophe                               = 137,
	Quote                                    = 138,
	Asterix                                  = 139,
	Ampersand                                = 140,
	Caret                                    = 141,
	Dollar                                   = 142,
	Exclamation                              = 143,
	Colon                                    = 144,
	A_AccentGrave                            = 145,
	E_AccentGrave                            = 146,
	E_AccentAigu                             = 147,
	C_Cedille                                = 148,
	Section                                  = 149,
	AT_Section_Plus                          = 150,
	None                                     = 151,
	EATPlatBtnId_MAX                         = 152,
};

// Enum AT.UIXLISTBAR01_STATE_ID
// NumValues: 0x000F
enum class EUIXLISTBAR01_STATE_ID : uint8
{
	STATE_UNSELECTED                         = 0,
	STATE_SELECT                             = 1,
	STATE_ENTER                              = 2,
	STATE_SUBIN                              = 3,
	STATE_SUBIN_RESET                        = 4,
	STATE_SUBOUT                             = 5,
	STATE_SUBIN_SELECT                       = 6,
	STATE_SUBOUT_SELECT                      = 7,
	STATE_SUBENTER                           = 8,
	STATE_UNSELECTED_NO_ENTER                = 9,
	STATE_SELECT_NO_ENTER                    = 10,
	STATE_DISABLE                            = 11,
	STATE_END_ENTER                          = 12,
	STATE_ID_NUM                             = 13,
	STATE_MAX                                = 14,
};

// Enum AT.ShopMode
// NumValues: 0x0003
enum class EShopMode : uint8
{
	BUY                                      = 0,
	SELL                                     = 1,
	ShopMode_MAX                             = 2,
};

// Enum AT.XlistBar04InfoMode
// NumValues: 0x0004
enum class EXlistBar04InfoMode : uint8
{
	TRADABLE                                 = 0,
	UNTRADABLE                               = 1,
	SOLDOUT                                  = 2,
	XlistBar04InfoMode_MAX                   = 3,
};

// Enum AT.ESkillCutinActorPauseType
// NumValues: 0x0005
enum class ESkillCutinActorPauseType : uint8
{
	None                                     = 0,
	ExcludeOwner                             = 1,
	ExcludeOwnerAndTarget                    = 2,
	ExcludePlayerPartyAndTarget              = 3,
	ESkillCutinActorPauseType_MAX            = 4,
};

// Enum AT.ESkillCutinProjectileDestroyType
// NumValues: 0x0004
enum class ESkillCutinProjectileDestroyType : uint8
{
	None                                     = 0,
	All                                      = 1,
	Other                                    = 2,
	ESkillCutinProjectileDestroyType_MAX     = 3,
};

// Enum AT.SHOT_DIRECT
// NumValues: 0x0006
enum class ESHOT_DIRECT : uint8
{
	Horizontal                               = 0,
	Vertical                                 = 1,
	DiagonallyRight                          = 2,
	ObliqueLeft                              = 3,
	None                                     = 4,
	SHOT_MAX                                 = 5,
};

// Enum AT.ESkillFizzle_GR
// NumValues: 0x0006
enum class ESkillFizzle_GR : uint8
{
	SuperArmor                               = 0,
	Invincible                               = 1,
	ActionLock                               = 2,
	Guard                                    = 3,
	Attach                                   = 4,
	ESkillFizzle_MAX                         = 5,
};

// Enum AT.ESkillGoldenSlicerMvType
// NumValues: 0x0003
enum class ESkillGoldenSlicerMvType : uint32
{
	Right_Move                               = 0,
	Left_Move                                = 1,
	ESkillGoldenSlicerMvType_MAX             = 2,
};

// Enum AT.EDoubleSundayBeamEaseSet
// NumValues: 0x0004
enum class EDoubleSundayBeamEaseSet : uint8
{
	EDoubleSundayBeamEaseSet_None            = 0,
	EDoubleSundayBeamEaseSet_In              = 1,
	EDoubleSundayBeamEaseSet_Out             = 2,
	EDoubleSundayBeamEaseSet_Max             = 3,
};

// Enum AT.EATActCpl034SkillPunishStormRotType
// NumValues: 0x0003
enum class EATActCpl034SkillPunishStormRotType : uint8
{
	EROT_TYPE_A                              = 0,
	EROT_TYPE_B                              = 1,
	EROT_TYPE_MAX                            = 2,
};

// Enum AT.EFlamethrowerAngle
// NumValues: 0x0005
enum class EFlamethrowerAngle : uint8
{
	RIGHT_LEFT                               = 0,
	LEFT_RIGHT                               = 1,
	UP_DOWN                                  = 2,
	DOWN_UP                                  = 3,
	EFlamethrowerAngle_MAX                   = 4,
};

// Enum AT.EATCharacterFieldShotState
// NumValues: 0x0005
enum class EATCharacterFieldShotState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Wait                                     = 2,
	Loop                                     = 3,
	Max                                      = 4,
};

// Enum AT.EATCharacterImmediateUnderWaterState
// NumValues: 0x0004
enum class EATCharacterImmediateUnderWaterState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Immediate                                = 2,
	Max                                      = 3,
};

// Enum AT.EATCharacterImmediateUpperWaterState
// NumValues: 0x0005
enum class EATCharacterImmediateUpperWaterState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Wait                                     = 2,
	Loop                                     = 3,
	Max                                      = 4,
};

// Enum AT.EATCharacterNoOxygenUnderWaterState
// NumValues: 0x0005
enum class EATCharacterNoOxygenUnderWaterState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Wait                                     = 2,
	Loop                                     = 3,
	Max                                      = 4,
};

// Enum AT.EATCharacterNoOxygenUpperWaterState
// NumValues: 0x0005
enum class EATCharacterNoOxygenUpperWaterState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Wait                                     = 2,
	Loop                                     = 3,
	Max                                      = 4,
};

// Enum AT.EATCharacterSearchState
// NumValues: 0x0005
enum class EATCharacterSearchState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Wait                                     = 2,
	Loop                                     = 3,
	Max                                      = 4,
};

// Enum AT.ESkillMoveType
// NumValues: 0x0006
enum class ESkillMoveType : uint8
{
	None                                     = 0,
	Dash                                     = 1,
	QuickDash                                = 2,
	Teleport                                 = 3,
	ExtAround                                = 4,
	ESkillMoveType_MAX                       = 5,
};

// Enum AT.ESkillFizzle
// NumValues: 0x0006
enum class ESkillFizzle : uint8
{
	SuperArmor                               = 0,
	Invincible                               = 1,
	ActionLock                               = 2,
	Guard                                    = 3,
	Attach                                   = 4,
	ESkillFizzle_MAX                         = 5,
};

// Enum AT.EFusionPostion
// NumValues: 0x0004
enum class EFusionPostion : uint8
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	Max                                      = 3,
};

// Enum AT.EReplicateBodyAttackTargetType
// NumValues: 0x0005
enum class EReplicateBodyAttackTargetType : uint8
{
	None                                     = 0,
	Range                                    = 1,
	Prediction                               = 2,
	PredictionRev                            = 3,
	EReplicateBodyAttackTargetType_MAX       = 4,
};

// Enum AT.EATCharacterUseRadarState
// NumValues: 0x0005
enum class EATCharacterUseRadarState : uint8
{
	None                                     = 0,
	PreStart                                 = 1,
	Start                                    = 2,
	End                                      = 3,
	Max                                      = 4,
};

// Enum AT.EVibrationForce
// NumValues: 0x0005
enum class EVibrationForce : uint8
{
	None                                     = 0,
	Weak                                     = 1,
	Middle                                   = 2,
	Strong                                   = 3,
	Max                                      = 4,
};

// Enum AT.ESkillCameraSide
// NumValues: 0x0005
enum class ESkillCameraSide : uint32
{
	All                                      = 0,
	Player                                   = 1,
	Friend                                   = 2,
	Enemy                                    = 3,
	ESkillCameraSide_MAX                     = 4,
};

// Enum AT.EATCharacterFoot
// NumValues: 0x0004
enum class EATCharacterFoot : uint32
{
	None                                     = 0,
	Left                                     = 1,
	Right                                    = 2,
	EATCharacterFoot_MAX                     = 3,
};

// Enum AT.EPlayParticleEffectEndAction
// NumValues: 0x0005
enum class EPlayParticleEffectEndAction : uint8
{
	None                                     = 0,
	Detach                                   = 1,
	Destroy                                  = 2,
	Deactive                                 = 3,
	EPlayParticleEffectEndAction_MAX         = 4,
};

// Enum AT.EPlayParticleEffectCameraEndAction
// NumValues: 0x0004
enum class EPlayParticleEffectCameraEndAction : uint8
{
	None                                     = 0,
	Detach                                   = 1,
	Destroy                                  = 2,
	EPlayParticleEffectCameraEndAction_MAX   = 3,
};

// Enum AT.EATAtrociousSaveState
// NumValues: 0x0004
enum class EATAtrociousSaveState : uint32
{
	None                                     = 0,
	Complete_BeginDirection                  = 1,
	Complete_All                             = 2,
	Max                                      = 3,
};

// Enum AT.EATAtrociousPhase
// NumValues: 0x0005
enum class EATAtrociousPhase : uint32
{
	None                                     = 18446744073709551615,
	Phase1                                   = 0,
	Phase2                                   = 1,
	Phase3                                   = 2,
	Max                                      = 3,
};

// Enum AT.EBattleAIFollowAction
// NumValues: 0x0004
enum class EBattleAIFollowAction : uint8
{
	None                                     = 0,
	Execute                                  = 1,
	PreExecute                               = 2,
	Max                                      = 3,
};

// Enum AT.EBattleAITargetSituation
// NumValues: 0x0005
enum class EBattleAITargetSituation : uint8
{
	None                                     = 0,
	MutualLeader                             = 1,
	MutualTarget                             = 2,
	Other                                    = 3,
	Max                                      = 4,
};

// Enum AT.EBattleAIPhaseCondition
// NumValues: 0x0005
enum class EBattleAIPhaseCondition : uint8
{
	None                                     = 0,
	Equal                                    = 1,
	Over                                     = 2,
	Under                                    = 3,
	Max                                      = 4,
};

// Enum AT.EBattleAICondition
// NumValues: 0x0088
enum class EBattleAICondition : uint8
{
	None                                     = 0,
	OwnerHpOver                              = 1,
	OwnerHpUnder                             = 2,
	OwnerMpOver                              = 3,
	OwnerMpUnder                             = 4,
	OwnerMpOverShot                          = 5,
	OwnerMpOverBurst                         = 6,
	OwnerLevelOver                           = 7,
	OwnerLevelUnder                          = 8,
	TargetDistanceOver                       = 9,
	TargetDistanceUnder                      = 10,
	TargetDistance2DOver                     = 11,
	TargetDistance2DUnder                    = 12,
	TargetDistanceVOver                      = 13,
	TargetDistanceVUnder                     = 14,
	TargetHeightOver                         = 15,
	TargetHeightUnder                        = 16,
	TargetAngleVOver                         = 17,
	TargetAngleVUnder                        = 18,
	TargetAngleHOver                         = 19,
	TargetAngleHUnder                        = 20,
	TargetAngleSubVOver                      = 21,
	TargetAngleSubVUnder                     = 22,
	TargetAngleSubHOver                      = 23,
	TargetAngleSubHUnder                     = 24,
	LeaderDistanceOver                       = 25,
	LeaderDistanceUnder                      = 26,
	FloorDistanceOver                        = 27,
	FloorDistanceUnder                       = 28,
	RoofDistanceOver                         = 29,
	RoofDistanceUnder                        = 30,
	OwnerStatusDamage                        = 31,
	OwnerStatusDamageNot                     = 32,
	OwnerStatusBlowoff                       = 33,
	OwnerStatusBlowoffNot                    = 34,
	OwnerStatusSparking                      = 35,
	OwnerStatusSparkingNot                   = 36,
	OwnerStatusRage                          = 37,
	OwnerStatusRageNot                       = 38,
	TargetStatusGuard                        = 39,
	TargetStatusGuardNot                     = 40,
	TargetStatusDamage                       = 41,
	TargetStatusDamageNot                    = 42,
	TargetStatusInvincible                   = 43,
	TargetStatusInvincibleNot                = 44,
	TargetStatusSparking                     = 45,
	TargetStatusSparkingNot                  = 46,
	OverlapVolumeShortRange                  = 47,
	OverlapVolumeLongRange                   = 48,
	OverlapVolumeFastMove                    = 49,
	SensingAttackBeamTarget                  = 50,
	SensingAttackLongRangeTarget             = 51,
	OwnerCameraOutOver                       = 52,
	OwnerCameraOutUnder                      = 53,
	OwnerDamageTimeOver                      = 54,
	OwnerDamageTimeUnder                     = 55,
	PartyMemberOver                          = 56,
	PartyMemberUnder                         = 57,
	PartyMemberOmitBitOver                   = 58,
	PartyMemberOmitBitUnder                  = 59,
	PartyMemberHPOver                        = 60,
	PartyMemberHPUnder                       = 61,
	BattleElapseTimeOver                     = 62,
	BattleElapseTimeUnder                    = 63,
	ExecuteCountOver                         = 64,
	ExecuteCountUnder                        = 65,
	ExecuteTimeOver                          = 66,
	OwnerAbsorbMode                          = 67,
	SensingSkill_C001A_S_SKL004              = 68,
	HaveFollower                             = 69,
	HaveFollowerNot                          = 70,
	PowerUpBuff                              = 71,
	PowerUpBuffNot                           = 72,
	BabidiPowerUpBuff                        = 73,
	BabidiPowerUpBuffNot                     = 74,
	SensingSkill_C001A_S_SKL016              = 75,
	SensingSkill_C001A_S_SKL016_Support      = 76,
	SensingSkill_C028C_S_SKL007              = 77,
	GroupBattleDefeatRateOver                = 78,
	GroupBattleDefeatRateUnder               = 79,
	TargetStatusLocked                       = 80,
	PlayingVisionNot                         = 81,
	C005G_SKL003Not                          = 82,
	GroundCenterDistOver                     = 83,
	GroundCenterDistUnder                    = 84,
	GroundTargetDistOver                     = 85,
	GroundTargetDistUnder                    = 86,
	GroundOwnerDamage                        = 87,
	GroundOwnerDamageNot                     = 88,
	GroundOwnerBlowoff                       = 89,
	GroundOwnerBlowoffNot                    = 90,
	GroundOwnerRage                          = 91,
	GroundOwnerRageNot                       = 92,
	GroundTargetAir                          = 93,
	GroundTargetLand                         = 94,
	GroundTargetJump                         = 95,
	GroundTargetGuard                        = 96,
	GroundTargetGuardNot                     = 97,
	GroundTargetDamage                       = 98,
	GroundTargetDamageNot                    = 99,
	GroundTargetBlowoff                      = 100,
	GroundTargetBlowoffNot                   = 101,
	GroundTargetSparking                     = 102,
	GroundTargetSparkingNot                  = 103,
	GroundDownCountOver                      = 104,
	GroundVolumeShortRange                   = 105,
	GroundVolumeLongRange                    = 106,
	GroundSensingBeam                        = 107,
	GroundSensingLongRange                   = 108,
	GroundOwnerCameraOutOver                 = 109,
	GroundOwnerCameraOutUnder                = 110,
	GroundOwnerDamageTimeOver                = 111,
	GroundOwnerDamageTimeUnder               = 112,
	GroundTargetCenterNear                   = 113,
	GroundTargetCenterNearNot                = 114,
	GroundTargetCenterLine                   = 115,
	GroundTargetCenterLineNot                = 116,
	GroundUsableGuardAround                  = 117,
	SensingSkill_Flash                       = 118,
	PlayingSpecialDown                       = 119,
	NotPlayingSpecialDown                    = 120,
	EquipMeleeWeapon                         = 121,
	NotEquipMeleeWeapon                      = 122,
	GroundBattleOwnerAir                     = 123,
	GroundBattleOwnerGround                  = 124,
	SensingSkill_C001D_G_SKL005              = 125,
	DeadCountOver                            = 126,
	DeadCountUnder                           = 127,
	GroundFieldEndOver                       = 128,
	GroundFieldEndUnder                      = 129,
	TargetStatusStun                         = 130,
	RequestBattleTalkEnd                     = 131,
	FlashBackTalk1End                        = 132,
	FlashBackTalk2End                        = 133,
	SpecificCurrentPhase                     = 134,
	Max                                      = 135,
};

// Enum AT.EBattleAIBehavior
// NumValues: 0x008F
enum class EBattleAIBehavior : uint8
{
	None                                     = 0,
	Wait                                     = 1,
	Attack                                   = 2,
	Shot                                     = 3,
	ShotMoveL                                = 4,
	ShotMoveR                                = 5,
	ShotMoveB                                = 6,
	SkillReady                               = 7,
	Skill                                    = 8,
	Skill_RR                                 = 9,
	Skill_RU                                 = 10,
	Skill_RL                                 = 11,
	Skill_RD                                 = 12,
	Skill_LR                                 = 13,
	Skill_LU                                 = 14,
	Skill_LL                                 = 15,
	Skill_LD                                 = 16,
	SkillSlot_01                             = 17,
	SkillSlot_02                             = 18,
	SkillSlot_03                             = 19,
	SkillSlot_04                             = 20,
	SkillSlot_05                             = 21,
	SkillSlot_06                             = 22,
	SkillSlot_07                             = 23,
	SkillSlot_08                             = 24,
	SkillSlot_09                             = 25,
	SkillSlot_10                             = 26,
	SkillSlot_11                             = 27,
	SkillSlot_12                             = 28,
	SkillSlot_13                             = 29,
	SkillSlot_14                             = 30,
	SkillSlot_15                             = 31,
	SkillSlot_16                             = 32,
	SkillSlot_17                             = 33,
	SkillSlot_18                             = 34,
	SkillSlot_19                             = 35,
	SkillSlot_20                             = 36,
	CounterSkill                             = 37,
	Sparking                                 = 38,
	Guard                                    = 39,
	Burst                                    = 40,
	Charge                                   = 41,
	HighBoost                                = 42,
	Reversal                                 = 43,
	Rampage                                  = 44,
	Rage                                     = 45,
	MiniRage                                 = 46,
	Weakness                                 = 47,
	BlowoffBrake                             = 48,
	Vanish                                   = 49,
	Assault                                  = 50,
	MoveF                                    = 51,
	MoveB                                    = 52,
	MoveL                                    = 53,
	MoveR                                    = 54,
	MoveApproach                             = 55,
	MoveApproachBoost                        = 56,
	MoveApproachBoostL                       = 57,
	MoveApproachBoostR                       = 58,
	MoveLeave                                = 59,
	MoveLeaveBoost                           = 60,
	MoveStepF                                = 61,
	MoveStepB                                = 62,
	MoveStepL                                = 63,
	MoveStepR                                = 64,
	MoveBoostU                               = 65,
	MoveBoostD                               = 66,
	MoveAdjustHeight                         = 67,
	SpecialMoveTeleportF                     = 68,
	SpecialMoveTeleportB                     = 69,
	SpecialMoveTeleportL                     = 70,
	SpecialMoveTeleportR                     = 71,
	SpecialMoveTeleportU                     = 72,
	SpecialMoveTeleportD                     = 73,
	SpecialMoveTeleportTargetF               = 74,
	SpecialMoveTeleportTargetB               = 75,
	SpecialMoveTeleportTargetL               = 76,
	SpecialMoveTeleportTargetR               = 77,
	SpecialMoveTeleportView                  = 78,
	SpecialMoveZigzag                        = 79,
	SpecialMoveZigzagBack                    = 80,
	SpecialMoveZigzagTeleport                = 81,
	HugeTurnAngle                            = 82,
	HugeTurnTarget                           = 83,
	HugeWalkTarget                           = 84,
	HugeStepF                                = 85,
	HugeStepB                                = 86,
	HugeWeakness                             = 87,
	Formation                                = 88,
	FollowMove                               = 89,
	FollowEntry                              = 90,
	FollowRemove                             = 91,
	FollowBreak                              = 92,
	SuspendOtherGroupAI                      = 93,
	ForceStopAI                              = 94,
	RecoveryLongBlowoff                      = 95,
	TeleportCenter                           = 96,
	TeleportPoint                            = 97,
	CutinReversal                            = 98,
	CutinRampage                             = 99,
	GroundAttack                             = 100,
	GroundShot                               = 101,
	GroundJump                               = 102,
	GroundMoveStepF                          = 103,
	GroundMoveStepB                          = 104,
	GroundMoveStepL                          = 105,
	GroundMoveStepR                          = 106,
	GroundMoveStepC                          = 107,
	GroundMoveF                              = 108,
	GroundMoveB                              = 109,
	GroundMoveL                              = 110,
	GroundMoveR                              = 111,
	GroundMoveC                              = 112,
	GroundGuard                              = 113,
	GrdHighBoost                             = 114,
	GroundBurst                              = 115,
	GroundCharge                             = 116,
	GroundSkillReady                         = 117,
	GroundCounterSkill                       = 118,
	GroundReversal                           = 119,
	GroundRage                               = 120,
	GrdWeakness                              = 121,
	GroundTeleportCenterF                    = 122,
	GroundTeleportCenterB                    = 123,
	GroundTeleportCenterL                    = 124,
	GroundTeleportCenterR                    = 125,
	GroundTeleportTargetF                    = 126,
	GroundTeleportTargetB                    = 127,
	GroundTeleportTargetL                    = 128,
	GroundTeleportTargetR                    = 129,
	GroundTurn                               = 130,
	GroundGuardAround                        = 131,
	GroundMoveT                              = 132,
	GroundTeleportOutView                    = 133,
	GroundGroupTeleportToView                = 134,
	GroundTeleportOutOfAttackRange           = 135,
	SpecialMoveGroundZigzag                  = 136,
	SpecialMoveGroundZigzagBack              = 137,
	SpecialMoveGroundZigzagTeleport          = 138,
	RampageS                                 = 139,
	RequestBattleTalk                        = 140,
	ExtendGroupAIBehavior                    = 141,
	Max                                      = 142,
};

// Enum AT.EBattleCheerCondition
// NumValues: 0x001B
enum class EBattleCheerCondition : uint8
{
	AttackHit                                = 0,
	ShotHit                                  = 1,
	Guard                                    = 2,
	GuardBreak                               = 3,
	ComboNum                                 = 4,
	FirstDamage                              = 5,
	Stalemate                                = 6,
	Dodge                                    = 7,
	BlowOff                                  = 8,
	BlowOffField                             = 9,
	ReturnField                              = 10,
	PlaySkill                                = 11,
	SkillHit                                 = 12,
	StartBattle                              = 13,
	Down                                     = 14,
	DownReturn                               = 15,
	DownVictory                              = 16,
	CountDown                                = 17,
	EndBattleHP_GE                           = 18,
	EndBattleHP_LT                           = 19,
	CheckHP_GE                               = 20,
	CheckHP_LT                               = 21,
	CheckMutualHP_GE                         = 22,
	CheckMutualHP_LT                         = 23,
	TimeLapse                                = 24,
	BreakStage                               = 25,
	EBattleCheerCondition_MAX                = 26,
};

// Enum AT.EATBattleDemoBranch
// NumValues: 0x0004
enum class EATBattleDemoBranch : uint8
{
	None                                     = 0,
	Success                                  = 1,
	Failure                                  = 2,
	EATBattleDemoBranch_MAX                  = 3,
};

// Enum AT.EBattleGroupAIFormation
// NumValues: 0x0004
enum class EBattleGroupAIFormation : uint8
{
	None                                     = 0,
	Surround                                 = 1,
	Gather                                   = 2,
	Max                                      = 3,
};

// Enum AT.EBattleGroupAIMemberCondition
// NumValues: 0x0006
enum class EBattleGroupAIMemberCondition : uint8
{
	None                                     = 0,
	TypeNormal                               = 1,
	TypeSmall                                = 2,
	LevelOver                                = 3,
	LevelUnder                               = 4,
	Max                                      = 5,
};

// Enum AT.EBattleGroupAICondition
// NumValues: 0x0028
enum class EBattleGroupAICondition : uint8
{
	None                                     = 0,
	MemberNumOver                            = 1,
	MemberNumUnder                           = 2,
	BattleElapseTimeOver                     = 3,
	BattleElapseTimeUnder                    = 4,
	EntryGroupCountOver                      = 5,
	EntryGroupCountUnder                     = 6,
	EntryGroupElapseTimeOver                 = 7,
	EntryGroupElapseTimeUnder                = 8,
	BreakGroupElapseTimeOver                 = 9,
	BreakGroupElapseTimeUnder                = 10,
	ExecuteCountOver                         = 11,
	ExecuteCountUnder                        = 12,
	EntryGroupBehaviorCountOver              = 13,
	EntryGroupBehaviorCountUnder             = 14,
	AllMemberHpOver                          = 15,
	AllMemberHpUnder                         = 16,
	AnyMemberHpOver                          = 17,
	AnyMemberHpUnder                         = 18,
	AllMemberMpOver                          = 19,
	AllMemberMpUnder                         = 20,
	AnyMemberMpOver                          = 21,
	AnyMemberMpUnder                         = 22,
	AnyMemberDamageTimeOver                  = 23,
	AnyMemberStatusDamage                    = 24,
	AnyMemberStatusDamageNot                 = 25,
	AnyMemberStatusRage                      = 26,
	AnyMemberStatusRageNot                   = 27,
	AnyAllMemberStatusRage                   = 28,
	AnyAllMemberStatusRageNot                = 29,
	AnyMemberStatusSkill                     = 30,
	AnyMemberStatusSkillNot                  = 31,
	Cpl071Breaktime                          = 32,
	Cpl071BreaktimeNot                       = 33,
	DeadCountOver                            = 34,
	DeadCountUnder                           = 35,
	ExtendedGroupAIBehaivior                 = 36,
	AnyMemberStatusAttack                    = 37,
	AnyMemberStatusAttackNot                 = 38,
	Max                                      = 39,
};

// Enum AT.EBonfireActivate
// NumValues: 0x0004
enum class EBonfireActivate : uint8
{
	Default                                  = 0,
	Activate                                 = 1,
	Deactivate                               = 2,
	EBonfireActivate_MAX                     = 3,
};

// Enum AT.EBuffEffectAddType
// NumValues: 0x0004
enum class EBuffEffectAddType : uint8
{
	None                                     = 0,
	Rate                                     = 1,
	Fixed                                    = 2,
	EBuffEffectAddType_MAX                   = 3,
};

// Enum AT.EHealEffectType
// NumValues: 0x0004
enum class EHealEffectType : uint8
{
	None                                     = 0,
	Rate                                     = 1,
	Fixed                                    = 2,
	EHealEffectType_MAX                      = 3,
};

// Enum AT.ERidingAnimState
// NumValues: 0x0009
enum class ERidingAnimState : uint8
{
	None                                     = 0,
	Default                                  = 1,
	Back_ST                                  = 2,
	Back_LP                                  = 3,
	Back_ED                                  = 4,
	Break_ST                                 = 5,
	Break_LP                                 = 6,
	Break_ED                                 = 7,
	Max                                      = 8,
};

// Enum AT.ECharacterActionEndState
// NumValues: 0x0005
enum class ECharacterActionEndState : uint8
{
	Default                                  = 0,
	WaitLand                                 = 1,
	WaitAir                                  = 2,
	Fall                                     = 3,
	Max                                      = 4,
};

// Enum AT.ECharacterActionCategory
// NumValues: 0x000F
enum class ECharacterActionCategory : uint8
{
	None                                     = 0,
	Wait                                     = 1,
	Attack                                   = 2,
	Charge                                   = 3,
	Guard                                    = 4,
	Skill                                    = 5,
	LandMove                                 = 6,
	FlyMove                                  = 7,
	Jump                                     = 8,
	Recovery                                 = 9,
	Step                                     = 10,
	Damage                                   = 11,
	Burst                                    = 12,
	Other                                    = 13,
	Max                                      = 14,
};

// Enum AT.ECharacterAction
// NumValues: 0x012F
enum class ECharacterAction : uint16
{
	None                                     = 0,
	Wait                                     = 1,
	Move                                     = 2,
	Guard                                    = 3,
	GuardAround                              = 4,
	Step                                     = 5,
	Avoid                                    = 6,
	Charge                                   = 7,
	Burst                                    = 8,
	HighBoost                                = 9,
	Reversal                                 = 10,
	Rampage                                  = 11,
	SearchS                                  = 12,
	SearchL                                  = 13,
	SearchE                                  = 14,
	BehindS                                  = 15,
	BehindL                                  = 16,
	BehindE                                  = 17,
	Weakness                                 = 18,
	OffsetBoost                              = 19,
	AssaultReady                             = 20,
	AssaultBoost                             = 21,
	AssaultAttack                            = 22,
	SkillMove                                = 23,
	SkillMoveDash                            = 24,
	SkillMoveQuickDash                       = 25,
	SkillMoveTeleport                        = 26,
	SkillMoveChase                           = 27,
	SkillAssistTeleport                      = 28,
	SpecialMoveTeleport                      = 29,
	SpecialMoveTeleportTarget                = 30,
	SpecialMoveTeleportView                  = 31,
	SpecialMoveZigzag                        = 32,
	SpecialMoveZigzagBack                    = 33,
	SpecialMoveZigzagTeleport                = 34,
	TeleportCenter                           = 35,
	TeleportPoint                            = 36,
	Attack                                   = 37,
	Shot                                     = 38,
	LongBlowoffChase                         = 39,
	DamageNormalLow                          = 40,
	DamageNormalMedium                       = 41,
	DamageNormalHigh                         = 42,
	DamageGuard                              = 43,
	DamageBlowoff                            = 44,
	DamageBlowoffRoll                        = 45,
	DamageBlowoffEnd                         = 46,
	DamageBlowoffBrake                       = 47,
	DamageBlowoffRecovery                    = 48,
	DamageBlowSpin                           = 49,
	DamageBlowSpin_C034A_S_SKL002            = 50,
	DamageBlowSpin2                          = 51,
	DamageBlowSpinEnd                        = 52,
	DamageBlowSpin2End                       = 53,
	DamageBlowSpinRecovery                   = 54,
	DamageLongBlowoff                        = 55,
	DamageLongBlowoffVertical                = 56,
	DamageLongBlowoffEnd                     = 57,
	DamageLongBlowoffDirection               = 58,
	DamageCrashLand                          = 59,
	DamageCrashWall                          = 60,
	DamageCrashWallLP                        = 61,
	DamageCrashWallED                        = 62,
	DamageDownLP                             = 63,
	DamageDownED                             = 64,
	DamageWinceST                            = 65,
	DamageWinceLP                            = 66,
	DamageWinceED                            = 67,
	DamageStunST                             = 68,
	DamageStunLP                             = 69,
	DamageStunED                             = 70,
	DamageBlindST                            = 71,
	DamageBlindLP                            = 72,
	DamageBlindED                            = 73,
	DamagePukeST                             = 74,
	DamagePukeLP                             = 75,
	DamagePukeED                             = 76,
	DamageBreakST                            = 77,
	DamageBreakLP                            = 78,
	DamageBreakED                            = 79,
	DamageGuardBreakST                       = 80,
	DamageGuardBreakLP                       = 81,
	DamageGuardBreakED                       = 82,
	DamageLock                               = 83,
	DamageDyingST                            = 84,
	DamageDyingLP                            = 85,
	DamageDyingED                            = 86,
	DamageDeathST                            = 87,
	DamageDeathLP                            = 88,
	DamageDeathFall                          = 89,
	DamageDeathBlowoff                       = 90,
	DamageOutrageBlowoff                     = 91,
	DamageDeathCompositionAction             = 92,
	DamageHoldNormal                         = 93,
	DamageHoldGrasp                          = 94,
	DamageHoldCpl024                         = 95,
	DamageHoldNumb                           = 96,
	DamageHoldHealth                         = 97,
	DamageJostleBeam                         = 98,
	DamageFaceTrigger                        = 99,
	DamageDeathBreak                         = 100,
	DamageReturnField                        = 101,
	DamageShinKuGeki                         = 102,
	DamageHoldCpl070                         = 103,
	DamageHoldCpl031                         = 104,
	DamageHoldCpl037                         = 105,
	DamageDeathStunToCorner                  = 106,
	DamageStunAtCornerST                     = 107,
	DamageStunAtCornerLP                     = 108,
	DamageStunAtCornerED                     = 109,
	StunCornerRecovery                       = 110,
	DamageNormalHeavy                        = 111,
	DamageBlowoffLP                          = 112,
	DamageVanish                             = 113,
	Skill_RR_00                              = 114,
	Skill_RU_00                              = 115,
	Skill_RL_00                              = 116,
	Skill_RD_00                              = 117,
	Skill_LR_00                              = 118,
	Skill_LU_00                              = 119,
	Skill_LL_00                              = 120,
	Skill_LD_00                              = 121,
	SkillSlot_01                             = 122,
	SkillSlot_02                             = 123,
	SkillSlot_03                             = 124,
	SkillSlot_04                             = 125,
	SkillSlot_05                             = 126,
	SkillSlot_06                             = 127,
	SkillSlot_07                             = 128,
	SkillSlot_08                             = 129,
	SkillSlot_09                             = 130,
	SkillSlot_10                             = 131,
	SkillSlot_11                             = 132,
	SkillSlot_12                             = 133,
	SkillSlot_13                             = 134,
	SkillSlot_14                             = 135,
	SkillSlot_15                             = 136,
	SkillSlot_16                             = 137,
	SkillSlot_17                             = 138,
	SkillSlot_18                             = 139,
	SkillSlot_19                             = 140,
	SkillSlot_20                             = 141,
	Skill_RR_00_Air                          = 142,
	Skill_RU_00_Air                          = 143,
	Skill_RL_00_Air                          = 144,
	Skill_RD_00_Air                          = 145,
	Skill_Sparking0                          = 146,
	Skill_Sparking1                          = 147,
	Skill_Sparking2                          = 148,
	Skill_Sparking3                          = 149,
	Skill_SparkingA                          = 150,
	Skill_SupportReady                       = 151,
	Skill_Support01                          = 152,
	Skill_Support02                          = 153,
	Skill_Cooperation                        = 154,
	SupportComboAssistShortReady             = 155,
	SupportComboAssistShort                  = 156,
	SupportComboAssistLongReady              = 157,
	SupportComboAssistLong                   = 158,
	SupportSkillAssistReady                  = 159,
	SupportSkillAssist                       = 160,
	SupportPursue                            = 161,
	SupportPursueSkill                       = 162,
	SupportPursueDamage                      = 163,
	SupportComboCutReady                     = 164,
	SupportComboCut                          = 165,
	SupportComboCutSkill                     = 166,
	SupportBulletGuardReady                  = 167,
	SupportBulletGuard                       = 168,
	SupportProvocation                       = 169,
	SupportRecoveryHp                        = 170,
	SupportRecoveryMp                        = 171,
	FishingWait                              = 172,
	FishingST                                = 173,
	FishingLP                                = 174,
	FishingED                                = 175,
	Fishing                                  = 176,
	FishingBait                              = 177,
	BaseballBatter                           = 178,
	AnimalCapture                            = 179,
	ActionPoint                              = 180,
	ActionPointMineral                       = 181,
	ActionPointGet                           = 182,
	EncountLook                              = 183,
	EncountDushL                             = 184,
	EncountDushR                             = 185,
	EncountBackAtkDushST                     = 186,
	EncountBackAtkDush                       = 187,
	EncountBackAtk                           = 188,
	EncountBackAtkDmg                        = 189,
	EncountSummon                            = 190,
	SkillAuraWait_ST                         = 191,
	SkillAuraWait_LP                         = 192,
	Special00                                = 193,
	Special01                                = 194,
	Special02                                = 195,
	Special03                                = 196,
	Special04                                = 197,
	Riding                                   = 198,
	RideInCar                                = 199,
	RideOutCar                               = 200,
	RideInMachine                            = 201,
	RideOutMachine                           = 202,
	RideInFriend                             = 203,
	RideOutFriend                            = 204,
	PillarThrow                              = 205,
	IngameDemo                               = 206,
	CookingDemo                              = 207,
	Search                                   = 208,
	WorldMapDemo                             = 209,
	UseRadar                                 = 210,
	FieldShot                                = 211,
	GetFieldShot                             = 212,
	NoOxygen_UnderWater                      = 213,
	NoOxygen_UpperWater                      = 214,
	FieldShotCharge                          = 215,
	HeatupCut                                = 216,
	MiniRage                                 = 217,
	GroupBattleResult                        = 218,
	Fusion                                   = 219,
	FusionEnd                                = 220,
	ChangePlayer                             = 221,
	AndroidAssaultAttack1                    = 222,
	AndroidAssaultAttack2                    = 223,
	ShakeOff                                 = 224,
	DamageBlowoffDisableBrake                = 225,
	Immediate_UnderWater                     = 226,
	Immediate_UpperWater                     = 227,
	GroundBattleJump                         = 228,
	GroundBattleStep                         = 229,
	GroundBattleGuard                        = 230,
	GroundBattleCharge                       = 231,
	GroundBattleBurst                        = 232,
	GroundBattleHighBoost                    = 233,
	GroundBattleGuardAround                  = 234,
	GroundBattleWeakness                     = 235,
	GroundBattleOffsetBoost                  = 236,
	GroundBattleAttack                       = 237,
	GroundBattleAttackAir                    = 238,
	GroundBattleShot                         = 239,
	GroundBattleShotAir                      = 240,
	GroundBattleAvoid                        = 241,
	GroundBattleLongBlowoffChase             = 242,
	GroundBattleGroupTeleportToViewWait      = 243,
	GroundBattleGroupTeleportToView          = 244,
	GroundBattleGroupTeleportToViewDone      = 245,
	GroundBattleDeathGroupTeleportToView     = 246,
	GroundBattleDamageGuard                  = 247,
	GroundBattleDamageGuardAir               = 248,
	GroundBattleDamageNormal                 = 249,
	GroundBattleDamageNormalAir              = 250,
	GroundBattleDamageNormalHeavy            = 251,
	GroundBattleDamageNormalAirHeavy         = 252,
	GroundBattleDamageBlowoff                = 253,
	GroundBattleDamageSlide                  = 254,
	GroundBattleDamageCrashLand              = 255,
	GroundBattleDamageCrashWall              = 256,
	GroundBattleDamageCrashWallLP            = 257,
	GroundBattleDamageCrashWallED            = 258,
	GroundBattleDamageBound                  = 259,
	GroundBattleDamageUpper                  = 260,
	GroundBattleDamageDownLP                 = 261,
	GroundBattleDamageDownED                 = 262,
	GroundBattleDamageDownRecovery           = 263,
	GroundBattleDamagePukeST                 = 264,
	GroundBattleDamagePukeLP                 = 265,
	GroundBattleDamagePukeED                 = 266,
	GroundBattleDamageBlindST                = 267,
	GroundBattleDamageBlindLP                = 268,
	GroundBattleDamageBlindED                = 269,
	GroundBattleDamageBreakST                = 270,
	GroundBattleDamageBreakLP                = 271,
	GroundBattleDamageBreakED                = 272,
	GroundBattleDamageGuardBreakST           = 273,
	GroundBattleDamageGuardBreakLP           = 274,
	GroundBattleDamageGuardBreakED           = 275,
	GroundBattleDamageRingoutDown            = 276,
	GroundBattleDamageRingoutRecovery        = 277,
	GroundBattleDamageRingoutEndure          = 278,
	GroundBattleDamageCountQTE               = 279,
	GroundBattleDamageForceKnockBack         = 280,
	GroundBossBattleDamageDownST             = 281,
	GroundBossBattleDamageDownLP             = 282,
	GroundBossBattleDamageDownED             = 283,
	GroundBattleHeatupCut                    = 284,
	CutinReversal                            = 285,
	CutinRampage                             = 286,
	GroundBattleEnemyFieldAttack             = 287,
	GetFieldEnemyShot                        = 288,
	Cpl107Skill002DamageBlowoff              = 289,
	DamageSlanderTrigger                     = 290,
	HighBoostFlashBack                       = 291,
	SpecialMoveGroundZigzag                  = 292,
	SpecialMoveGroundZigzagBack              = 293,
	SpecialMoveGroundZigzagTeleport          = 294,
	RampageS                                 = 295,
	WaitFlashBack                            = 296,
	FinishRushQte                            = 297,
	GroundBattleDamageBoundC001F_SKL003      = 298,
	DamageRushQteFaceTrigger                 = 299,
	GroundBattleStraightBoost                = 300,
	HighBoostRushQte                         = 301,
	Max                                      = 302,
};

// Enum AT.E_CHAR_STATE
// NumValues: 0x0003
enum class E_CHAR_STATE : uint8
{
	CHAR_STATE_NONE                          = 0,
	CHAR_STATE_WAIT                          = 1,
	CHAR_STATE_MAX                           = 2,
};

// Enum AT.E_CHARA_ACT
// NumValues: 0x0027
enum class E_CHARA_ACT : uint8
{
	VE_CHARA_ACT_NONE                        = 0,
	VE_CHARA_ACT_Wait_F                      = 1,
	VE_CHARA_ACT_FLY_UP                      = 2,
	VE_CHARA_ACT_FLY_DOWN                    = 3,
	VE_CHARA_ACT_FLY_S                       = 4,
	VE_CHARA_ACT_FLY_L                       = 5,
	VE_CHARA_ACT_FLY_E                       = 6,
	VE_CHARA_ACT_JUMP_FLY_L                  = 7,
	VE_CHARA_ACT_JUMP_CANCEL_FLY_S           = 8,
	VE_CHARA_ACT_FALLING                     = 9,
	VE_CHARA_ACT_LOCKONMOVE_F                = 10,
	VE_CHARA_ACT_LOCKONMOVE_B                = 11,
	VE_CHARA_ACT_LOCKONMOVE_R                = 12,
	VE_CHARA_ACT_LOCKONMOVE_L                = 13,
	VE_CHARA_ACT_LOCKONMOVE_U                = 14,
	VE_CHARA_ACT_LOCKONMOVE_D                = 15,
	VE_CHARA_TARGETMOVE                      = 16,
	VE_CHARA_TARGETMOVEHARD                  = 17,
	VE_CHARA_TARGETMOVETHROW                 = 18,
	VE_CHARA_DASH_START                      = 19,
	VE_CHARA_DASH_END                        = 20,
	VE_CHARA_ACT_FLY_BOOST_S                 = 21,
	VE_CHARA_ACT_FLY_BOOST_L                 = 22,
	VE_CHARA_ACT_FLY_BOOST_E                 = 23,
	VE_CHARA_ACT_FLY_NUT                     = 24,
	VE_CHARA_ACT_LAND_NUT                    = 25,
	VE_CHARA_ACT_WALK_S                      = 26,
	VE_CHARA_ACT_WALK_L                      = 27,
	VE_CHARA_ACT_WALK_E                      = 28,
	VE_CHARA_ACT_RUN_S                       = 29,
	VE_CHARA_ACT_RUN_L                       = 30,
	VE_CHARA_ACT_RUN_E                       = 31,
	VE_CHARA_ACT_RUSHSTEP_BACK_S             = 32,
	VE_CHARA_ACT_RUSHSTEP_BACK               = 33,
	VE_CHARA_ACT_RUSHSTEP_BACK_E             = 34,
	VE_CHARA_ACT_BOOST_POS                   = 35,
	VE_CHARA_ACT_GETITEM_AUTO_PILOT_LOOP     = 36,
	VE_CHARA_ACT_MAX                         = 37,
	VE_CHARA_MAX                             = 38,
};

// Enum AT.EATCharacterBattleFloatVariation
// NumValues: 0x0004
enum class EATCharacterBattleFloatVariation : uint8
{
	None                                     = 0,
	Special01                                = 1,
	Special02                                = 2,
	EATCharacterBattleFloatVariation_MAX     = 3,
};

// Enum AT.EATCharacterStandWaitVariation
// NumValues: 0x0004
enum class EATCharacterStandWaitVariation : uint8
{
	None                                     = 0,
	Motion4                                  = 1,
	Motion3                                  = 2,
	EATCharacterStandWaitVariation_MAX       = 3,
};

// Enum AT.EATCharacterStandWaitVariationState
// NumValues: 0x0006
enum class EATCharacterStandWaitVariationState : uint8
{
	None                                     = 0,
	ST                                       = 1,
	Loop01                                   = 2,
	Loop02                                   = 3,
	ED                                       = 4,
	EATCharacterStandWaitVariationState_MAX  = 5,
};

// Enum AT.EATCharacterMontageBase
// NumValues: 0x0006
enum class EATCharacterMontageBase : uint8
{
	Stand                                    = 0,
	Float                                    = 1,
	BattleFloat                              = 2,
	GroundBattleStand                        = 3,
	GroundBattleFall                         = 4,
	EATCharacterMontageBase_MAX              = 5,
};

// Enum AT.ECharacterDeBuffType
// NumValues: 0x0003
enum class ECharacterDeBuffType : uint32
{
	None                                     = 0,
	Fire                                     = 1,
	Max                                      = 2,
};

// Enum AT.ECharacterBuffEffect
// NumValues: 0x0039
enum class ECharacterBuffEffect : uint32
{
	None                                     = 0,
	MpInfinity                               = 1,
	OnlyActionSkill                          = 2,
	SealItem                                 = 3,
	SuperArmor                               = 4,
	OnlyDamageBreak                          = 5,
	DamageUp                                 = 6,
	DamageUpHeat                             = 7,
	DamageUpAssist                           = 8,
	DamageUpBreak                            = 9,
	HateDown                                 = 10,
	DamageUpStrongTarget                     = 11,
	BreakDamageUp                            = 12,
	GuardBreakDamageUp                       = 13,
	BattleItemHealUp                         = 14,
	SupportGaugeUp                           = 15,
	DamageUpLowLife                          = 16,
	DamageUpHighCombo                        = 17,
	UseMagicDown                             = 18,
	DamageUpHighMagic                        = 19,
	DamageUpDamageOverTime                   = 20,
	SupportGaugeUpBattleStart                = 21,
	DamageUpWeakTarget                       = 22,
	SuperArmorHeatUp                         = 23,
	RegenHeatUp                              = 24,
	DamageUpZCombination                     = 25,
	ZOrbDropUpAtrocious                      = 26,
	AutoFormChangeBattleStart                = 27,
	SupportSkillDamageUp                     = 28,
	SupportSkillCoolTimeReduction            = 29,
	SupportDamageUp                          = 30,
	SupportSkillEffectTimeUp                 = 31,
	SupportActionHealUp                      = 32,
	SupportDamageUpToPlayerTarget            = 33,
	ZOrbDropUpEnemy                          = 34,
	MeleeBoost_DLC                           = 35,
	KiBoost_DLC                              = 36,
	DamageUpHeat_DLC                         = 37,
	HeatUpExtend_DLC                         = 38,
	ComboExtend_DLC                          = 39,
	ComboBoost_DLC                           = 40,
	StunBoost_DLC                            = 41,
	ChaseBoost_DLC                           = 42,
	StunAdditionalDamage_DLC                 = 43,
	ArtsMPSave_DLC                           = 44,
	ArtsBoost_DLC                            = 45,
	DamageUpAssist_DLC                       = 46,
	DodgeAccumPower_DLC                      = 47,
	HighTension_DLC                          = 48,
	OnlyDamageBreak_DLC                      = 49,
	GroundHitBoost_DLC                       = 50,
	LifeDotDamage_DLC                        = 51,
	AirEnemyDamageUp_DLC                     = 52,
	AirEnemyStunDamageUp_DLC                 = 53,
	DamageUpComboFinishSkill                 = 54,
	AddExp                                   = 55,
	ECharacterBuffEffect_MAX                 = 56,
};

// Enum AT.ECharacterBuffCondition
// NumValues: 0x0004
enum class ECharacterBuffCondition : uint32
{
	None                                     = 0,
	HeatUp                                   = 1,
	Battle                                   = 2,
	Max                                      = 3,
};

// Enum AT.ECharacterBuffCalcuration
// NumValues: 0x0003
enum class ECharacterBuffCalcuration : uint32
{
	Add                                      = 0,
	Multi                                    = 1,
	Max                                      = 2,
};

// Enum AT.ECharacterCancelFlag
// NumValues: 0x000C
enum class ECharacterCancelFlag : uint8
{
	Move                                     = 0,
	Jump                                     = 1,
	Boost                                    = 2,
	Burst                                    = 3,
	Attack                                   = 4,
	Charge                                   = 5,
	Guard                                    = 6,
	Skill                                    = 7,
	Recovery                                 = 8,
	Sparking                                 = 9,
	IgnorePriorty                            = 10,
	ECharacterCancelFlag_MAX                 = 11,
};

// Enum AT.ESummonCondition
// NumValues: 0x0003
enum class ESummonCondition : uint32
{
	None                                     = 0,
	Atrocious                                = 1,
	Max                                      = 2,
};

// Enum AT.ERacialType
// NumValues: 0x0006
enum class ERacialType : uint32
{
	Human                                    = 0,
	Saiyan                                   = 1,
	Namekian                                 = 2,
	Android                                  = 3,
	Other                                    = 4,
	Max                                      = 5,
};

// Enum AT.CREATE_ICON_TYPE
// NumValues: 0x0006
enum class ECREATE_ICON_TYPE : uint64
{
	ICON_NONE                                = 18446744073709551615,
	ICON_PLAYER_TYPE                         = 0,
	ICON_PLAYER_SUPPORT_L_TYPE               = 1,
	ICON_PLAYER_SUPPORT_R_TYPE               = 2,
	ICON_ENEMY_TYPE                          = 3,
	ICON_MAX                                 = 4,
};

// Enum AT.CREATE_CHARACTER_TYPE
// NumValues: 0x0008
enum class ECREATE_CHARACTER_TYPE : uint32
{
	CREATE_PLAYER_TYPE                       = 0,
	CREATE_PLAYER_SUPPORT_TYPE               = 1,
	CREATE_ENEMY_TYPE                        = 2,
	CREATE_EVENTENEMY_TYPE                   = 3,
	CREATE_ATROCIOUS_TYPE                    = 4,
	CREATE_EVENTATROCIOUS_TYPE               = 5,
	CREATE_ACCOMPANY_TYPE                    = 6,
	CREATE_MAX                               = 7,
};

// Enum AT.EATGaugeBreakState
// NumValues: 0x0004
enum class EATGaugeBreakState : uint8
{
	Wait                                     = 0,
	Heal                                     = 1,
	Break                                    = 2,
	EATGaugeBreakState_MAX                   = 3,
};

// Enum AT.EATGaugeGuardBreakState
// NumValues: 0x0003
enum class EATGaugeGuardBreakState : uint8
{
	Wait                                     = 0,
	Break                                    = 1,
	EATGaugeGuardBreakState_MAX              = 2,
};

// Enum AT.EATCharacterReset
// NumValues: 0x000A
enum class EATCharacterReset : uint8
{
	Stand                                    = 0,
	Float                                    = 1,
	Fall                                     = 2,
	FloatSecond                              = 3,
	NimbusWait                               = 4,
	NimbusSecond                             = 5,
	BattleStand                              = 6,
	Pillar                                   = 7,
	GroundBattleStand                        = 8,
	EATCharacterReset_MAX                    = 9,
};

// Enum AT.EATCharacterFloatBoostMotionState
// NumValues: 0x0004
enum class EATCharacterFloatBoostMotionState : uint8
{
	FloatBoostLp                             = 0,
	FloatBoostEd                             = 1,
	FloatSecondLp                            = 2,
	EATCharacterFloatBoostMotionState_MAX    = 3,
};

// Enum AT.EATCharacterFloatMove
// NumValues: 0x0003
enum class EATCharacterFloatMove : uint8
{
	Normal                                   = 0,
	WindRoad                                 = 1,
	EATCharacterFloatMove_MAX                = 2,
};

// Enum AT.EATCharacterNimbusRide
// NumValues: 0x0003
enum class EATCharacterNimbusRide : uint8
{
	Float                                    = 0,
	FloatSecond                              = 1,
	EATCharacterNimbusRide_MAX               = 2,
};

// Enum AT.EATCharacterActingBoostEndState
// NumValues: 0x0003
enum class EATCharacterActingBoostEndState : uint8
{
	Float                                    = 0,
	Fall                                     = 1,
	EATCharacterActingBoostEndState_MAX      = 2,
};

// Enum AT.EATCharacterAutoMoveBP
// NumValues: 0x0008
enum class EATCharacterAutoMoveBP : uint8
{
	StandFirst                               = 0,
	StandSecond                              = 1,
	FloatFirst                               = 2,
	FloatSecond                              = 3,
	NimbusSecond                             = 4,
	StandDash                                = 5,
	FloatBoost                               = 6,
	EATCharacterAutoMoveBP_MAX               = 7,
};

// Enum AT.EATCharacterAutoMove
// NumValues: 0x0009
enum class EATCharacterAutoMove : uint8
{
	StandFirst                               = 0,
	StandSecond                              = 1,
	FloatFirst                               = 2,
	FloatSecond                              = 3,
	NimbusSecond                             = 4,
	BattleRecoveryMove                       = 5,
	StandDash                                = 6,
	FloatBoost                               = 7,
	EATCharacterAutoMove_MAX                 = 8,
};

// Enum AT.EATCharacterFloatRoll
// NumValues: 0x0005
enum class EATCharacterFloatRoll : uint8
{
	None                                     = 0,
	First                                    = 1,
	Second                                   = 2,
	Third                                    = 3,
	EATCharacterFloatRoll_MAX                = 4,
};

// Enum AT.EATCharacterJump
// NumValues: 0x0007
enum class EATCharacterJump : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Second                                   = 2,
	Third                                    = 3,
	HighJump                                 = 4,
	ToNimbus                                 = 5,
	EATCharacterJump_MAX                     = 6,
};

// Enum AT.EATCharacterBoost
// NumValues: 0x0007
enum class EATCharacterBoost : uint8
{
	None                                     = 0,
	Stand                                    = 1,
	Float                                    = 2,
	TargetFloat                              = 3,
	Acting                                   = 4,
	Nimbus                                   = 5,
	EATCharacterBoost_MAX                    = 6,
};

// Enum AT.EATCharacterMoveGear
// NumValues: 0x0004
enum class EATCharacterMoveGear : uint8
{
	Zero                                     = 0,
	First                                    = 1,
	Second                                   = 2,
	EATCharacterMoveGear_MAX                 = 3,
};

// Enum AT.EATCharacterMoveState
// NumValues: 0x004A
enum class EATCharacterMoveState : uint8
{
	Stand                                    = 0,
	StandTurn                                = 1,
	StandMoveST                              = 2,
	StandMoveLP                              = 3,
	StandMoveED                              = 4,
	StandLanding                             = 5,
	StandLandingToRun                        = 6,
	Float                                    = 7,
	FloatMoveST                              = 8,
	FloatMoveLP                              = 9,
	FloatMoveED                              = 10,
	FloatMoveLookForwardST                   = 11,
	FloatMoveLookForwardLP                   = 12,
	FloatMoveLookForwardED                   = 13,
	FloatSwitchGear                          = 14,
	FloatRoll                                = 15,
	FloatFromJump                            = 16,
	FloatBoostCharge                         = 17,
	FloatBoostST                             = 18,
	FloatBoostLP                             = 19,
	FloatBoostED                             = 20,
	FloatBoostLookForwardST                  = 21,
	FloatBoostLookForwardLP                  = 22,
	FloatBoostLookForwardED                  = 23,
	FloatBoostSlideTurn                      = 24,
	FloatBoostSlide                          = 25,
	FloatBoostBraking                        = 26,
	FloatVertical                            = 27,
	FloatBoostRoll                           = 28,
	JumpAntc                                 = 29,
	Jumping                                  = 30,
	Falling                                  = 31,
	BattleFloat                              = 32,
	BattleMove                               = 33,
	BattleStepST                             = 34,
	BattleStepLP                             = 35,
	BattleStepED                             = 36,
	BattleStand                              = 37,
	BattleStandTurn                          = 38,
	BattleStandMoveST                        = 39,
	BattleStandMoveLP                        = 40,
	BattleStandMoveED                        = 41,
	BattleStandStepST                        = 42,
	BattleStandStepLP                        = 43,
	BattleStandStepED                        = 44,
	NimbusWait                               = 45,
	NimbusMoveST                             = 46,
	NimbusMoveLP                             = 47,
	NimbusMoveED                             = 48,
	NimbusRide                               = 49,
	NimbusVertical                           = 50,
	NimbusRoll                               = 51,
	NimbusDash                               = 52,
	NimbusBoostCharge                        = 53,
	NimbusBoostST                            = 54,
	NimbusBoostLP                            = 55,
	NimbusBoostED                            = 56,
	PillarReady                              = 57,
	PillarMove                               = 58,
	GroundBattleStand                        = 59,
	GroundBattleTurn                         = 60,
	GroundBattleMoveST                       = 61,
	GroundBattleMoveLP                       = 62,
	GroundBattleMoveED                       = 63,
	GroundBattleLanding                      = 64,
	GroundBattleLandingToRun                 = 65,
	GroundBattleStandTurn                    = 66,
	GroundBattleJumpAntc                     = 67,
	GroundBattleJumping                      = 68,
	GroundBattleFalling                      = 69,
	GroundBattleFloat                        = 70,
	GroundBattleFloatMove                    = 71,
	Nothing                                  = 72,
	EATCharacterMoveState_MAX                = 73,
};

// Enum AT.EATCharacterMoveCategory
// NumValues: 0x000E
enum class EATCharacterMoveCategory : uint8
{
	Stand                                    = 0,
	Float                                    = 1,
	Jump                                     = 2,
	Fall                                     = 3,
	Battle                                   = 4,
	BattleStand                              = 5,
	Nimbus                                   = 6,
	Pillar                                   = 7,
	GroundBattleStand                        = 8,
	GroundBattleJump                         = 9,
	GroundBattleFall                         = 10,
	GroundBattleFloat                        = 11,
	Nothing                                  = 12,
	EATCharacterMoveCategory_MAX             = 13,
};

// Enum AT.EAddExpReason
// NumValues: 0x0006
enum class EAddExpReason : uint8
{
	None                                     = 0,
	Battle                                   = 1,
	Quest                                    = 2,
	Mission                                  = 3,
	Item                                     = 4,
	EAddExpReason_MAX                        = 5,
};

// Enum AT.ETeleportTargetPosType
// NumValues: 0x000B
enum class ETeleportTargetPosType : uint8
{
	Front                                    = 0,
	Left                                     = 1,
	Right                                    = 2,
	Back                                     = 3,
	Up                                       = 4,
	Down                                     = 5,
	FrontEx                                  = 6,
	BackEx                                   = 7,
	Num                                      = 8,
	Random                                   = 9,
	ETeleportTargetPosType_MAX               = 10,
};

// Enum AT.ECmnParticleType
// NumValues: 0x0002
enum class ECmnParticleType : uint8
{
	Smoke                                    = 0,
	Max                                      = 1,
};

// Enum AT.EATCookingBuffType
// NumValues: 0x000D
enum class EATCookingBuffType : uint32
{
	ShortOffensePower                        = 0,
	LongOffensePower                         = 1,
	ShortDefensePower                        = 2,
	LongDefensePower                         = 3,
	CriticalPower                            = 4,
	MaxHitPoint                              = 5,
	MaxMagicPoint                            = 6,
	RegenHitPoint                            = 7,
	RegenMagicPoint                          = 8,
	Exp                                      = 9,
	ZOrb                                     = 10,
	ItemDrop                                 = 11,
	Max                                      = 12,
};

// Enum AT.ETeleportDirectionType
// NumValues: 0x0006
enum class ETeleportDirectionType : uint8
{
	Front                                    = 0,
	Right                                    = 1,
	Left                                     = 2,
	Back                                     = 3,
	Num                                      = 4,
	ETeleportDirectionType_MAX               = 5,
};

// Enum AT.ETeleportPosType
// NumValues: 0x0004
enum class ETeleportPosType : uint8
{
	OneThird                                 = 0,
	OneHalf                                  = 1,
	Num                                      = 2,
	ETeleportPosType_MAX                     = 3,
};

// Enum AT.EDamageCollisionResult
// NumValues: 0x0009
enum class EDamageCollisionResult : uint8
{
	None                                     = 0,
	Lose                                     = 1,
	Draw                                     = 2,
	Applied                                  = 3,
	Reflect                                  = 4,
	Absorb                                   = 5,
	AbsorbApplied                            = 6,
	Through                                  = 7,
	EDamageCollisionResult_MAX               = 8,
};

// Enum AT.EOffsetType
// NumValues: 0x0005
enum class EOffsetType : uint8
{
	Off                                      = 0,
	OffDestroy                               = 1,
	On                                       = 2,
	OnDestroy                                = 3,
	EOffsetType_MAX                          = 4,
};

// Enum AT.E_REACTION_TYPE
// NumValues: 0x0025
enum class E_REACTION_TYPE : uint8
{
	REACTION_NONE                            = 0,
	REACTION_NORMAL                          = 1,
	REACTION_BLOWOFF                         = 2,
	REACTION_BLOWOFF_KEEP                    = 3,
	REACTION_BLOWSPIN                        = 4,
	REACTION_SUPERLONGBLOWOFF                = 5,
	REACTION_BACK_ATTACK                     = 6,
	REACTION_BOOST_ATTACK                    = 7,
	REACTION_FORWARD_BENDING                 = 8,
	REACTION_HOLD_NORMAL                     = 9,
	REACTION_HOLD_GRASP                      = 10,
	REACTION_HOLD_CPL024                     = 11,
	REACTION_HOLD_NUMB                       = 12,
	REACTION_BLIND                           = 13,
	REACTION_PUKE                            = 14,
	REACTION_PUKE_LOOP                       = 15,
	REACTION_GET_FIELD_SHOT                  = 16,
	REACTION_BLOWOFF_LP                      = 17,
	REACTION_BLOWSPIN_2                      = 18,
	REACTION_SHINKUGEKI                      = 19,
	REACTION_HOLD_CPL070                     = 20,
	REACTION_HOLD_CPL031                     = 21,
	REACTION_HOLD_CPL037                     = 22,
	REACTION_BLOWOFF_DISABLEBRAKE            = 23,
	REACTION_GRD_NORMAL                      = 24,
	REACTION_GRD_NORMAL_AIR                  = 25,
	REACTION_GRD_BLOWOFF                     = 26,
	REACTION_GRD_BLOWOFF_SLIDE               = 27,
	REACTION_GRD_BOUND                       = 28,
	REACTION_GRD_UPPER                       = 29,
	REACTION_GRD_PUKE                        = 30,
	REACTION_GRD_BLIND                       = 31,
	REACTION_GRD_KNOCKBACK                   = 32,
	REACTION_GET_FIELD_ENEMY_SHOT            = 33,
	REACTION_GRD_BOUNDC001F_SKL003           = 34,
	REACTION_TYPE_MAX                        = 35,
	REACTION_MAX                             = 36,
};

// Enum AT.EDamageStrength
// NumValues: 0x0005
enum class EDamageStrength : uint8
{
	Low                                      = 0,
	Medium                                   = 1,
	High                                     = 2,
	Heavy                                    = 3,
	Max                                      = 4,
};

// Enum AT.E_BLOWVECTOR
// NumValues: 0x0006
enum class E_BLOWVECTOR : uint8
{
	BLOWVECTOR_NONE                          = 0,
	BLOWVECTOR_UP                            = 1,
	BLOWVECTOR_DOWN                          = 2,
	BLOWVECTOR_RIGHT                         = 3,
	BLOWVECTOR_LEFT                          = 4,
	BLOWVECTOR_MAX                           = 5,
};

// Enum AT.EDamageDirectionType
// NumValues: 0x0004
enum class EDamageDirectionType : uint8
{
	None                                     = 0,
	Forward                                  = 1,
	Radial                                   = 2,
	EDamageDirectionType_MAX                 = 3,
};

// Enum AT.E_DAMAGE_ATTR
// NumValues: 0x0015
enum class E_DAMAGE_ATTR : uint8
{
	PROJECTILE                               = 0,
	SKILL                                    = 1,
	DISABLE_RECOVERY                         = 2,
	NO_DEAD                                  = 3,
	NO_BREAK                                 = 4,
	CHANCE_ATTACK                            = 5,
	START_LOCK                               = 6,
	FORCE_HIT                                = 7,
	SA_PENETRATION                           = 8,
	SUPERLONG_BLOWOFF                        = 9,
	ATTACK_KI                                = 10,
	DIRECT                                   = 11,
	SUPERLONG_BLOWOFF_SPARKING               = 12,
	SUPERLONG_BLOWOFF_NOADJUST               = 13,
	NO_DESTRUCT                              = 14,
	ABSORB_ENERGY                            = 15,
	REACTION_NOOVERWRITE                     = 16,
	DAMAGE_CALCULATED                        = 17,
	INV_PENETRATION                          = 18,
	COMBO_FINISH_DAMAGE                      = 19,
	MAX                                      = 20,
};

// Enum AT.EATDataAssetKind
// NumValues: 0x000C
enum class EATDataAssetKind : uint8
{
	None                                     = 0,
	Character                                = 1,
	CharacterAction                          = 2,
	Enemy                                    = 3,
	Item                                     = 4,
	Ui                                       = 5,
	Sound                                    = 6,
	Particle                                 = 7,
	Quest                                    = 8,
	MechaDev                                 = 9,
	EventBattle                              = 10,
	EATDataAssetKind_MAX                     = 11,
};

// Enum AT.EDemoBGMSeamlessType
// NumValues: 0x0004
enum class EDemoBGMSeamlessType : uint8
{
	None                                     = 0,
	SeamlessIn                               = 1,
	SeamlessInOut                            = 2,
	EDemoBGMSeamlessType_MAX                 = 3,
};

// Enum AT.EINGAME_DEMO_BLEND_CAMERA_MODE
// NumValues: 0x0005
enum class EINGAME_DEMO_BLEND_CAMERA_MODE : uint8
{
	NONE                                     = 0,
	NORMAL                                   = 1,
	FLY                                      = 2,
	BATTLE                                   = 3,
	EINGAME_DEMO_BLEND_CAMERA_MAX            = 4,
};

// Enum AT.EINGAME_DEMO_LATER_MODE
// NumValues: 0x0007
enum class EINGAME_DEMO_LATER_MODE : uint8
{
	NONE                                     = 0,
	LAND_WAIT                                = 1,
	FLY_WAIT                                 = 2,
	FLY                                      = 3,
	NIMBUS_WAIT                              = 4,
	NIMBUS                                   = 5,
	EINGAME_DEMO_LATER_MAX                   = 6,
};

// Enum AT.EDEMO_KEYHELP_TYPE
// NumValues: 0x0004
enum class EDEMO_KEYHELP_TYPE : uint8
{
	NONE                                     = 0,
	PLAY                                     = 1,
	PAUSE                                    = 2,
	MAX                                      = 3,
};

// Enum AT.EDEMO_INTERRUPT_TYPE
// NumValues: 0x0004
enum class EDEMO_INTERRUPT_TYPE : uint8
{
	NONE                                     = 0,
	BEGIN_DIRECTION                          = 1,
	END_DIRECTION                            = 2,
	MAX                                      = 3,
};

// Enum AT.EDlcElementType
// NumValues: 0x0006
enum class EDlcElementType : uint32
{
	None                                     = 0,
	Item                                     = 1,
	Quest                                    = 2,
	Carddass                                 = 3,
	Other                                    = 4,
	EDlcElementType_MAX                      = 5,
};

// Enum AT.EATEnemyBaseType
// NumValues: 0x0004
enum class EATEnemyBaseType : uint8
{
	None                                     = 0,
	RR_BASE                                  = 1,
	FR_POD                                   = 2,
	EATEnemyBaseType_MAX                     = 3,
};

// Enum AT.DirectionRequestType
// NumValues: 0x0005
enum class EDirectionRequestType : uint8
{
	BeginDirection                           = 0,
	EndDirection                             = 1,
	BeginLocationMovement                    = 2,
	EndLocationMovement                      = 3,
	DirectionRequestType_MAX                 = 4,
};

// Enum AT.EEventBattleMobPlaceType
// NumValues: 0x0003
enum class EEventBattleMobPlaceType : uint8
{
	Ground                                   = 0,
	Air                                      = 1,
	Max                                      = 2,
};

// Enum AT.EAndroidAssaultEndConditionType
// NumValues: 0x0003
enum class EAndroidAssaultEndConditionType : uint8
{
	CONDITION_TYPE_FIXED                     = 0,
	CONDITION_TYPE_RANDOM                    = 1,
	MAX                                      = 2,
};

// Enum AT.EEventBattleFinishBlow
// NumValues: 0x0004
enum class EEventBattleFinishBlow : uint8
{
	None                                     = 0,
	Face                                     = 1,
	NoFace                                   = 2,
	Max                                      = 3,
};

// Enum AT.EEventBattleMode
// NumValues: 0x0009
enum class EEventBattleMode : uint8
{
	None                                     = 0,
	Failed                                   = 1,
	Survival                                 = 2,
	TimeAttack                               = 3,
	ScoreAttack                              = 4,
	Tournament                               = 5,
	VillainGroup                             = 6,
	SuperVillainGroup                        = 7,
	Max                                      = 8,
};

// Enum AT.ETarget
// NumValues: 0x0007
enum class ETarget : uint8
{
	NONE                                     = 0,
	PLAYER                                   = 1,
	PLAYER_PARTY                             = 2,
	ENEMY                                    = 3,
	ENEMY_PARTY                              = 4,
	ALL                                      = 5,
	ETarget_MAX                              = 6,
};

// Enum AT.EExMission
// NumValues: 0x001D
enum class EExMission : uint8
{
	NONE                                     = 0,
	SHORT_ATTACK_HIT_CNT                     = 1,
	SHORT_SKILL_HIT_CNT                      = 2,
	ADD_ATTACK_CNT                           = 3,
	LONG_SKILL_HIT_CNT                       = 4,
	JOSTLE_BEAM_CNT                          = 5,
	HEATUP_CNT                               = 6,
	HEATUP_DMG                               = 7,
	COMBO_OVER                               = 8,
	STUN_DMG                                 = 9,
	STUN_CNT                                 = 10,
	SKILL_HIT_CNT                            = 11,
	Z_COMBINAITION_CNT                       = 12,
	JUST_DODGE_CNT                           = 13,
	DAMAGE_LIMIT                             = 14,
	SKILL_DMG_FINISH                         = 15,
	SUPPORT_SKILL_DMG_FINISH                 = 16,
	PARTY_NUM                                = 17,
	GARD_BREAK                               = 18,
	TIME_LIMIT                               = 19,
	TERRAIN_DMG                              = 20,
	DEFEAT_CNT                               = 21,
	EXTERMINATION_DESTROY_BASTION            = 22,
	TB_NO_DOWN                               = 23,
	TB_ENEMY_DEATH                           = 24,
	TB_NO_ITEM                               = 25,
	TB_NO_GARD_BREAK                         = 26,
	TB_COMBO_DAMAGE_OVER                     = 27,
	MAX                                      = 28,
};

// Enum AT.EExCondition
// NumValues: 0x0024
enum class EExCondition : uint8
{
	NONE                                     = 0,
	HP_INCREASE                              = 1,
	HP_DECREASE                              = 2,
	MP_INCREASE                              = 3,
	MP_DECREASE                              = 4,
	MP_INFINITY                              = 5,
	ONLY_ACTION_SKILL                        = 6,
	SEAL_ITEM                                = 7,
	ONLY_DAMAGE_BREAK                        = 8,
	DAMAGE_UP_HEAT                           = 9,
	DAMAGE_UP_ASSIST                         = 10,
	ADD_BUFF                                 = 11,
	ADD_SUPER_ARMOR                          = 12,
	SET_HP                                   = 13,
	SET_HP_MORE                              = 14,
	NO_DEAD                                  = 15,
	DAMAGE_UP_SHORT_ATK                      = 16,
	DAMAGE_UP_LONG_ATK                       = 17,
	DAMAGE_UP_HEAT2                          = 18,
	HEAT_TIME_ADD                            = 19,
	COMBO_TIME_ADD                           = 20,
	DAMAGE_UP_COMBO                          = 21,
	STUN_DAMAGE_UP                           = 22,
	DAMAGE_UP_ADD_ATTACK                     = 23,
	DAMAGE_UP_STUN                           = 24,
	SUB_SKILL_MP                             = 25,
	DAMAGE_UP_SKILL                          = 26,
	DAMAGE_UP_SUPPORT                        = 27,
	DAMAGE_UP_DODGE                          = 28,
	ADD_HEAT_GAUGE                           = 29,
	ONLY_DAMAGE_STUN                         = 30,
	DAMAGE_UP_TERRAIN                        = 31,
	SET_SUPPORT_GAUGE_L                      = 32,
	SET_SUPPORT_GAUGE_R                      = 33,
	SET_RAGE_BUFF                            = 34,
	MAX                                      = 35,
};

// Enum AT.EEVENTBATTLE_DEATH_REACTION
// NumValues: 0x000A
enum class EEVENTBATTLE_DEATH_REACTION : uint8
{
	NONE                                     = 0,
	RECOVERY                                 = 1,
	NORECOVERY                               = 2,
	BLOW                                     = 3,
	STAND                                    = 4,
	RECOVERY_BREAK                           = 5,
	STUN_TO_CORNER                           = 6,
	TELEPORT_PLAYER                          = 7,
	RECOVERY_BACK_STEP                       = 8,
	EEVENTBATTLE_DEATH_MAX                   = 9,
};

// Enum AT.EEVENTBATTLE_DEFEAT_CONDITIONS
// NumValues: 0x0008
enum class EEVENTBATTLE_DEFEAT_CONDITIONS : uint8
{
	LEADER_DEATH                             = 0,
	TIME_ATTACK                              = 1,
	GB_PARTY_DEATH                           = 2,
	GB_SURVIVAL                              = 3,
	GB_TIME_ATTACK                           = 4,
	GB_SCORE_ATTACK                          = 5,
	TB_RINGOUT                               = 6,
	MAX                                      = 7,
};

// Enum AT.EEVENTBATTLE_VICTORY_CONDITIONS
// NumValues: 0x0018
enum class EEVENTBATTLE_VICTORY_CONDITIONS : uint8
{
	LEADER_DEATH                             = 0,
	LEADER_LIMIT_DAMAGE                      = 1,
	PARTY_DEATH                              = 2,
	PARTY_LIMIT_DAMAGE                       = 3,
	TIME_ATTACK                              = 4,
	GB_PARTY_DEATH                           = 5,
	GB_SURVIVAL                              = 6,
	GB_TIME_ATTACK                           = 7,
	GB_SCORE_ATTACK                          = 8,
	AA_DMGCOUNT_HEATUP                       = 9,
	AA_DMGCOUNT_SKILL                        = 10,
	AA_COMBO_COUNT                           = 11,
	AA_STUN_COUNT                            = 12,
	AA_ZCOMBO_COUNT                          = 13,
	AA_DMGCOUNT_SHTATK                       = 14,
	AA_DMGCOUNT_LNGATK                       = 15,
	AA_DMGCOUNT_SHTSKL                       = 16,
	AA_DMGCOUNT_LNGSKL                       = 17,
	AA_DMGCOUNT_STUN                         = 18,
	AA_DMGCOUNT_CHASE                        = 19,
	AA_JDODGE_COUNT                          = 20,
	TB_RINGOUT                               = 21,
	TB_PARTY_STUN_COUNT                      = 22,
	MAX                                      = 23,
};

// Enum AT.EEVENTBATTLE_PERFORMANCE
// NumValues: 0x0007
enum class EEVENTBATTLE_PERFORMANCE : uint8
{
	EACH_WAIT                                = 0,
	INGAME                                   = 1,
	EACH_BLOWN_OFF                           = 2,
	PLAYER_BLOWN_OFF                         = 3,
	ENEMY_BLOWN_OFF                          = 4,
	EACH_HIGH_BOOST                          = 5,
	EEVENTBATTLE_MAX                         = 6,
};

// Enum AT.EATEventBattleVisionCondition
// NumValues: 0x0003
enum class EATEventBattleVisionCondition : uint8
{
	None                                     = 0,
	EnemyLife                                = 1,
	Max                                      = 2,
};

// Enum AT.EEventTimingType
// NumValues: 0x0004
enum class EEventTimingType : uint8
{
	NONE                                     = 0,
	BEGIN                                    = 1,
	END                                      = 2,
	MAX                                      = 3,
};

// Enum AT.EFacialType
// NumValues: 0x000A
enum class EFacialType : uint8
{
	None                                     = 0,
	Neutral                                  = 1,
	Battle                                   = 2,
	Damage01                                 = 3,
	Damage02                                 = 4,
	Damage03                                 = 5,
	Dying                                    = 6,
	Surprise                                 = 7,
	UI                                       = 8,
	Max                                      = 9,
};

// Enum AT.EFeverKind
// NumValues: 0x000C
enum class EFeverKind : uint8
{
	None                                     = 0,
	FEVER_KIND_ALL_SPOT                      = 1,
	FEVER_KIND_RARE_ACTOR_WEIGHT             = 2,
	FEVER_KIND_ACTOR_WEIGHT                  = 3,
	FEVER_KIND_RARE_ITEM_WEIGHT              = 4,
	FEVER_KIND_NORMAL_ITEM_LOTTERY_COUNT     = 5,
	FEVER_KIND_FIXED_ITEM_LOTTERY_COUNT      = 6,
	FEVER_KIND_ITEM_NUM                      = 7,
	FEVER_KIND_SHOP_DISCOUNT                 = 8,
	FEVER_KIND_SHOP_RARE_ITEM_WEIGHT         = 9,
	FEVER_KIND_MAX                           = 10,
	EFeverKind_MAX                           = 11,
};

// Enum AT.EFeverCategory
// NumValues: 0x000A
enum class EFeverCategory : uint8
{
	FEVER_CATEGORY_FISHING                   = 0,
	FEVER_CATEGORY_DINOSAUR                  = 1,
	FEVER_CATEGORY_ANIMAL                    = 2,
	FEVER_CATEGORY_MINERAL                   = 3,
	FEVER_CATEGORY_FRUIT                     = 4,
	FEVER_CATEGORY_DROP                      = 5,
	FEVER_CATEGORY_SMALLFISH                 = 6,
	FEVER_CATEGORY_SHOP                      = 7,
	FEVER_CATEGORY_PEOPLE_SAVING             = 8,
	FEVER_CATEGORY_MAX                       = 9,
};

// Enum AT.EKpiBNIDStatus
// NumValues: 0x0005
enum class EKpiBNIDStatus : uint8
{
	Incompatible                             = 0,
	Maintenance                              = 1,
	Disable                                  = 2,
	Enable                                   = 3,
	EKpiBNIDStatus_MAX                       = 4,
};

// Enum AT.EAreaDirection
// NumValues: 0x0006
enum class EAreaDirection : uint8
{
	East                                     = 0,
	West                                     = 1,
	South                                    = 2,
	North                                    = 3,
	Num                                      = 4,
	EAreaDirection_MAX                       = 5,
};

// Enum AT.EArea
// NumValues: 0x0005
enum class EArea : uint8
{
	GM940                                    = 0,
	Test00                                   = 1,
	Test01                                   = 2,
	Num                                      = 3,
	EArea_MAX                                = 4,
};

// Enum AT.EVisibleTiming
// NumValues: 0x000E
enum class EVisibleTiming : uint8
{
	None                                     = 0,
	Wished                                   = 1,
	SpawnedAtrociousMobEnemies               = 2,
	KilledAtrociousMobEnemies                = 3,
	KilledAtrociousNamedEnemies              = 4,
	PlayerCharacerChanged                    = 5,
	QuestTriggerEnabled                      = 6,
	QuestCompleted                           = 7,
	QuestSymbolDefined                       = 8,
	DLC4MainStory                            = 9,
	DLC4AdditionalStory                      = 10,
	DLC6Cleared                              = 11,
	EvenOnceBNID                             = 12,
	EVisibleTiming_MAX                       = 13,
};

// Enum AT.ELevelLoadType
// NumValues: 0x0003
enum class ELevelLoadType : uint8
{
	None                                     = 0,
	AlwaysLoaded                             = 1,
	ELevelLoadType_MAX                       = 2,
};

// Enum AT.ELongBlowoffObjectType
// NumValues: 0x000D
enum class ELongBlowoffObjectType : uint8
{
	Grass                                    = 0,
	Sand                                     = 1,
	Rock                                     = 2,
	Asphalt                                  = 3,
	WaterSurface                             = 4,
	Wood                                     = 5,
	Ice                                      = 6,
	Metal                                    = 7,
	WaterBottom                              = 8,
	Snow                                     = 9,
	Dirt                                     = 10,
	Building                                 = 11,
	ELongBlowoffObjectType_MAX               = 12,
};

// Enum AT.MECHA_DEV_STATE
// NumValues: 0x0004
enum class EMECHA_DEV_STATE : uint8
{
	NONE                                     = 0,
	DEV_MENU                                 = 1,
	DIRECTION                                = 2,
	MAX                                      = 3,
};

// Enum AT.EMissionOwnerType
// NumValues: 0x0003
enum class EMissionOwnerType : uint8
{
	TurtleSchool                             = 0,
	Subjugation                              = 1,
	EMissionOwnerType_MAX                    = 2,
};

// Enum AT.EMissionPhaseProgressType
// NumValues: 0x0005
enum class EMissionPhaseProgressType : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Unreported                               = 2,
	Accomplished                             = 3,
	EMissionPhaseProgressType_MAX            = 4,
};

// Enum AT.EMissionUpdateType
// NumValues: 0x0004
enum class EMissionUpdateType : uint8
{
	None                                     = 0,
	Total                                    = 1,
	Update                                   = 2,
	EMissionUpdateType_MAX                   = 3,
};

// Enum AT.EMissionType
// NumValues: 0x001B
enum class EMissionType : uint8
{
	NONE                                     = 0,
	ZorbBlueCount                            = 1,
	ZorbGreenCount                           = 2,
	ZorbRedCount                             = 3,
	ZorbRainbowCount                         = 4,
	GetRecipe                                = 5,
	GetDragonBall                            = 6,
	CollectMoney                             = 7,
	BattleComboCount                         = 8,
	UseSupportCharacterSkillEnemyKillCount   = 9,
	RareFishCaptureCount                     = 10,
	FirstPlaceRaceAreaCount                  = 11,
	BaseBallJustHitHomeRunCount              = 12,
	LinkBonusCount                           = 13,
	CommunityRank                            = 14,
	MovingDistance                           = 15,
	Mileage                                  = 16,
	IncreaseLevel                            = 17,
	GamePlayedTime                           = 18,
	DefeatEnemy                              = 19,
	NPCTalk                                  = 20,
	DefeatVillainGroup                       = 21,
	DefeatSuperVillainGroup                  = 22,
	DefeatVillain                            = 23,
	DefeatRobot                              = 24,
	DefeatDrone                              = 25,
	MAX                                      = 26,
};

// Enum AT.EModelFadeMode
// NumValues: 0x0003
enum class EModelFadeMode : uint8
{
	FADE_IN                                  = 0,
	FADE_OUT                                 = 1,
	FADE_MAX                                 = 2,
};

// Enum AT.EPlaceObjectType
// NumValues: 0x0014
enum class EPlaceObjectType : uint8
{
	None                                     = 0,
	ZOrb_Red_S                               = 1,
	ZOrb_Red_M                               = 2,
	ZOrb_Red_L                               = 3,
	ZOrb_Blue_S                              = 4,
	ZOrb_Blue_M                              = 5,
	ZOrb_Blue_L                              = 6,
	ZOrb_Green_S                             = 7,
	ZOrb_Green_M                             = 8,
	ZOrb_Green_L                             = 9,
	ZOrb_Rainbow                             = 10,
	ZOrb_White                               = 11,
	ZOrb_PureWhite                           = 12,
	Item_Normal                              = 13,
	Item_Rare                                = 14,
	Item_Epic                                = 15,
	Item_Exp_Normal                          = 16,
	Item_Exp_Rare                            = 17,
	Item_Exp_Epic                            = 18,
	EPlaceObjectType_MAX                     = 19,
};

// Enum AT.EPlaceObjectArrangement
// NumValues: 0x0005
enum class EPlaceObjectArrangement : uint8
{
	Point                                    = 0,
	Circle                                   = 1,
	Spiral_Right                             = 2,
	Spiral_Left                              = 3,
	EPlaceObjectArrangement_MAX              = 4,
};

// Enum AT.EOverrideAnimationTiming
// NumValues: 0x0007
enum class EOverrideAnimationTiming : uint8
{
	Spawned                                  = 0,
	DoorClosing                              = 1,
	Command                                  = 2,
	CookFinished                             = 3,
	DevelopFinished                          = 4,
	MissionFinished                          = 5,
	EOverrideAnimationTiming_MAX             = 6,
};

// Enum AT.EParticleSpawnLocation
// NumValues: 0x0006
enum class EParticleSpawnLocation : uint8
{
	AttachedSocket                           = 0,
	WorldSocket                              = 1,
	WorldSocketLocOnly                       = 2,
	World                                    = 3,
	WorldLocOnly                             = 4,
	EParticleSpawnLocation_MAX               = 5,
};

// Enum AT.EParticleAttachLocation
// NumValues: 0x0004
enum class EParticleAttachLocation : uint8
{
	Attached                                 = 0,
	World                                    = 1,
	AttachedBody                             = 2,
	MAX                                      = 3,
};

// Enum AT.ECommonParticleData
// NumValues: 0x0002
enum class ECommonParticleData : uint8
{
	None                                     = 0,
	MAX                                      = 1,
};

// Enum AT.EATPauseFlags
// NumValues: 0x000D
enum class EATPauseFlags : uint16
{
	PF_None                                  = 0,
	PF_DebugMenu                             = 1,
	PF_MainMenu                              = 4,
	PF_HitStop                               = 8,
	PF_SubQuestDirection                     = 16,
	PF_DemoPause                             = 32,
	PF_DemoDirection                         = 64,
	PF_AreaMap                               = 128,
	PF_Tips                                  = 256,
	PF_Tutorial                              = 512,
	PF_WorldMap                              = 1024,
	PF_SaveLoad                              = 2048,
	PF_MAX_0                                 = 2049,
};

// Enum AT.AutoMoveSpeed
// NumValues: 0x0003
enum class EAutoMoveSpeed : uint8
{
	First                                    = 0,
	Second                                   = 1,
	AutoMoveSpeed_MAX                        = 2,
};

// Enum AT.AutoControlState
// NumValues: 0x0009
enum class EAutoControlState : uint8
{
	None                                     = 0,
	Talk                                     = 1,
	TalkRelease                              = 2,
	Turn                                     = 3,
	MoveLocation                             = 4,
	MoveForwardLocation                      = 5,
	MoveBackwardLocation                     = 6,
	MoveActor                                = 7,
	AutoControlState_MAX                     = 8,
};

// Enum AT.ECameraShake
// NumValues: 0x0029
enum class ECameraShake : uint8
{
	ECameraShake_None                        = 0,
	ECameraShake_01                          = 1,
	ECameraShake_02                          = 2,
	ECameraShake_03                          = 3,
	ECameraShake_04                          = 4,
	ECameraShake_05                          = 5,
	ECameraShake_SuperSaiyan                 = 6,
	ECameraShake_GuldoSkillBlow              = 7,
	ECameraShake_NpaShockWave                = 8,
	ECameraShake_Normal                      = 9,
	ECameraShake_BackAttackMulti             = 10,
	ECameraShake_SKILLBREAK                  = 11,
	ECameraShake_TPS                         = 12,
	ECameraShake_SuperLongBlowOff_HitObject  = 13,
	ECameraShake_Rush01                      = 14,
	ECameraShake_Rush02                      = 15,
	ECameraShake_Rush03                      = 16,
	ECameraShake_Rush04                      = 17,
	ECameraShake_AuraRush01                  = 18,
	ECameraShake_AuraRush02                  = 19,
	ECameraShake_AuraRush03                  = 20,
	ECameraShake_AuraRush04                  = 21,
	ECameraShake_RaceGameBoost               = 22,
	ECameraShake_RaceGameBoost_FpView        = 23,
	ECameraShake_BaseballGameHit_Normal      = 24,
	ECameraShake_BaseballGameHit_JustMeet    = 25,
	ECameraShake_AirCarHit_Weak              = 26,
	ECameraShake_AirCarHit_Strong            = 27,
	ECameraShake_AirCarHit_WallRubbing       = 28,
	ECameraShake_FloatBoostLanding           = 29,
	ECameraShake_QuestParam                  = 30,
	ECameraShake_JostleBeam                  = 31,
	ECameraShake_HeatPhysics                 = 32,
	ECameraShake_HeatPhysicsEnemy            = 33,
	ECameraShake_GRD_HeatPhysics             = 34,
	ECameraShake_GRD_HeatPhysicsEnemy        = 35,
	ECameraShake_LandPillar                  = 36,
	ECameraShake_AssaultClash                = 37,
	ECameraShake_AssaultAttack               = 38,
	ECameraShake_Zero                        = 39,
	ECameraShake_Max                         = 40,
};

// Enum AT.ECameraMode
// NumValues: 0x0049
enum class ECameraMode : uint8
{
	ECameraMode_None                         = 0,
	ECameraMode_Normal                       = 1,
	ECameraMode_Fly                          = 2,
	ECameraMode_Encounter                    = 3,
	ECameraMode_Appearance                   = 4,
	ECameraMode_IngameDemo                   = 5,
	ECameraMode_FPS                          = 6,
	ECameraMode_Direction                    = 7,
	ECameraMode_TargetActor                  = 8,
	ECameraMode_LandTarget                   = 9,
	ECameraMode_StartingNimbus               = 10,
	ECameraMode_HuntingDino                  = 11,
	ECameraMode_GetItemAutoPilot             = 12,
	ECameraMode_SubQuest                     = 13,
	ECameraMode_Battle                       = 14,
	ECameraMode_BattleBossSkill              = 15,
	ECameraMode_Skill                        = 16,
	ECameraMode_BattleEnd                    = 17,
	ECameraMode_TPSSkill                     = 18,
	ECameraMode_COOKDEMO                     = 19,
	ECameraMode_AIRCAR_FLY                   = 20,
	ECameraMode_AIRCAR_FpView                = 21,
	ECameraMode_TWINFOOT                     = 22,
	ECameraMode_ShortCombo                   = 23,
	ECameraMode_OffsetHighBoost              = 24,
	ECameraMode_Weakness                     = 25,
	ECameraMode_ComboCut                     = 26,
	ECameraMode_SupportPursue                = 27,
	ECameraMode_TalkFocus                    = 28,
	ECameraMode_NappaGiantStorm              = 29,
	ECameraMode_NappaBlazingStorm            = 30,
	ECameraMode_SkillDoubleSunday            = 31,
	ECameraMode_SkillDoubleSundayAttack      = 32,
	ECameraMode_LongBlowoff                  = 33,
	ECameraMode_LongBlowoffHit               = 34,
	ECameraMode_LongBlowoffChaseAttack       = 35,
	ECameraMode_Cpl018SkillSpecial           = 36,
	ECameraMode_Anim                         = 37,
	ECameraMode_WindRoad                     = 38,
	ECameraMode_BaseballGame                 = 39,
	ECameraMode_TargetFloat                  = 40,
	ECameraMode_FloatBoostSlide              = 41,
	ECameraMode_SkillWildQuake_Rise          = 42,
	ECameraMode_SkillWildQuake_Fall          = 43,
	ECameraMode_OnSphereGround               = 44,
	ECameraMode_SkillDeathSlicer             = 45,
	ECameraMode_NimbusRoll                   = 46,
	ECameraMode_PlayableCharacterBustUp      = 47,
	ECameraMode_PillarThrow                  = 48,
	ECameraMode_PillarToFly                  = 49,
	ECameraMode_ReturnField                  = 50,
	ECameraMode_Assault                      = 51,
	ECameraMode_Reinforce                    = 52,
	ECameraMode_Fusion                       = 53,
	ECameraMode_AndroidAssaultEscape         = 54,
	ECameraMode_Cpl005GSkill003              = 55,
	ECameraMode_GroundShortCombo             = 56,
	ECameraMode_GroundBattle                 = 57,
	ECameraMode_GroundRingout                = 58,
	ECameraMode_GroundCountQTE               = 59,
	ECameraMode_GroudBossBattle              = 60,
	ECameraMode_Cpl008BSkill005              = 61,
	ECameraMode_Cpl008BSkill002              = 62,
	ECameraMode_Cpl011BSkill004              = 63,
	ECameraMode_Cpl011CSkill006              = 64,
	ECameraMode_StunCornerRecovery           = 65,
	ECameraMode_CutinReversal                = 66,
	ECameraMode_Cpl011CSkill007              = 67,
	ECameraMode_GroundOffsetHighBoost        = 68,
	ECameraMode_Cpl003ESkill007              = 69,
	ECameraMode_SpecialMoveGroundZigzag      = 70,
	ECameraMode_Fix                          = 71,
	ECameraMode_Max                          = 72,
};

// Enum AT.EAT_CONTROL_INPUT_ACTION
// NumValues: 0x0022
enum class EAT_CONTROL_INPUT_ACTION : uint8
{
	FACE_TOP                                 = 0,
	FACE_BOTTOM                              = 1,
	FACE_RIGHT                               = 2,
	FACE_LEFT                                = 3,
	ARROW_UP                                 = 4,
	ARROW_DOWN                               = 5,
	ARROW_RIGHT                              = 6,
	ARROW_LEFT                               = 7,
	RIGHTSTICK_UP                            = 8,
	RIGHTSTICK_DOWN                          = 9,
	RIGHTSTICK_RIGHT                         = 10,
	RIGHTSTICK_LEFT                          = 11,
	LEFTSTICK_UP                             = 12,
	LEFTSTICK_DOWN                           = 13,
	LEFTSTICK_RIGHT                          = 14,
	LEFTSTICK_LEFT                           = 15,
	CENTER_RIGHT                             = 16,
	CENTER_LEFT                              = 17,
	RIGHTSHOULDER                            = 18,
	LEFTSHOULDER                             = 19,
	RIGHTTRIGGER                             = 20,
	LEFTTRIGGER                              = 21,
	RIGHTSTICK                               = 22,
	LEFTSTICK                                = 23,
	RightMouseButton                         = 24,
	LeftMouseButton                          = 25,
	KB_DecideKey                             = 26,
	KB_CancelKey                             = 27,
	KB_FACE_TOP                              = 28,
	KB_FACE_BOTTOM                           = 29,
	KB_FACE_RIGHT                            = 30,
	KB_FACE_LEFT                             = 31,
	AT_CONTROL_INPUT_ACTION_MAX              = 32,
	EAT_CONTROL_INPUT_ACTION_MAX             = 33,
};

// Enum AT.EAT_CONTROL_INPUT_AXIS
// NumValues: 0x0008
enum class EAT_CONTROL_INPUT_AXIS : uint8
{
	RIGHTSTICK_X                             = 0,
	RIGHTSTICK_Y                             = 1,
	LEFTSTICK_X                              = 2,
	LEFTSTICK_Y                              = 3,
	RIGHTTRIGGER_AXIS                        = 4,
	LEFTTRIGGER_AXIS                         = 5,
	AT_CONTROL_INPUT_AXIS_MAX                = 6,
	EAT_CONTROL_INPUT_AXIS_MAX               = 7,
};

// Enum AT.E_PLAYER_CONTROL_TYPE
// NumValues: 0x001B
enum class E_PLAYER_CONTROL_TYPE : uint8
{
	NONE                                     = 0,
	ACTION                                   = 1,
	MOVE                                     = 2,
	FIELD                                    = 3,
	DEMO                                     = 4,
	COOKING_DEMO                             = 5,
	COOKING_SELECT_MENU                      = 6,
	FISHING                                  = 7,
	BASEBALL_GAME                            = 8,
	TUTORIAL                                 = 9,
	TALK                                     = 10,
	MENU                                     = 11,
	ANYBUTTON                                = 12,
	SUBQUEST                                 = 13,
	HUNTING_DINO_QTE                         = 14,
	FIELD_RIDE_SELECT                        = 15,
	FISHING_QTE                              = 16,
	WORLD_MAP                                = 17,
	UI_COMMON                                = 18,
	CAMERA                                   = 19,
	EVENT_BATTLE_FINISH                      = 20,
	TALK_EVENT                               = 21,
	NOW_LOADING                              = 22,
	PILLAR_THROW                             = 23,
	DEBUG                                    = 24,
	DEBUGMENU                                = 25,
	MAX                                      = 26,
};

// Enum AT.EPlayerControlMode
// NumValues: 0x0016
enum class EPlayerControlMode : uint8
{
	None                                     = 0,
	NowLoading                               = 1,
	Default                                  = 2,
	Talk                                     = 3,
	Tutorial                                 = 4,
	Fishing                                  = 5,
	BaseballGame                             = 6,
	Demo                                     = 7,
	Menu                                     = 8,
	CookingDemo                              = 9,
	CookingSelectMenu                        = 10,
	HuntingDino                              = 11,
	PressStart                               = 12,
	SubQuest                                 = 13,
	FishingQte                               = 14,
	WorldMap                                 = 15,
	UiCommon                                 = 16,
	EventBattleFinish                        = 17,
	TalkEvent                                = 18,
	Treasure                                 = 19,
	PillarThrow                              = 20,
	EPlayerControlMode_MAX                   = 21,
};

// Enum AT.EPlayerStartCategory
// NumValues: 0x0004
enum class EPlayerStartCategory : uint8
{
	Default                                  = 0,
	Timemachine                              = 1,
	DLC_Trunks                               = 2,
	EPlayerStartCategory_MAX                 = 3,
};

// Enum AT.EBeamSize
// NumValues: 0x0004
enum class EBeamSize : uint8
{
	SmallBeam                                = 0,
	MediumBeam                               = 1,
	LargeBeam                                = 2,
	EBeamSize_MAX                            = 3,
};

// Enum AT.EQuestCharacterBehaveState
// NumValues: 0x0006
enum class EQuestCharacterBehaveState : uint8
{
	Stand                                    = 0,
	Crying                                   = 1,
	StandPending                             = 2,
	CryBegan                                 = 3,
	CryIdling                                = 4,
	EQuestCharacterBehaveState_MAX           = 5,
};

// Enum AT.EStateType
// NumValues: 0x000D
enum class EStateType : uint8
{
	None                                     = 0,
	OpenTutorialWindow                       = 1,
	CloseTutorialWindow                      = 2,
	OpenLeaderSoulEmblemWindow               = 3,
	CloseLeaderSoulEmblemWindow              = 4,
	OpenCommunityBoard                       = 5,
	CloseCommunityBoard                      = 6,
	OpenUnlockWindow                         = 7,
	CloseUnlockWindow                        = 8,
	OpenCommunityBoardUnlockWindow           = 9,
	CloseCommunityBoardUnlockWindow          = 10,
	Finished                                 = 11,
	Max                                      = 12,
};

// Enum AT.EConditionType
// NumValues: 0x0003
enum class EConditionType : uint8
{
	IsInside                                 = 0,
	IsToggle                                 = 1,
	EConditionType_MAX                       = 2,
};

// Enum AT.QuestFieldConditionType
// NumValues: 0x0003
enum class EQuestFieldConditionType : uint8
{
	Default                                  = 0,
	Raining                                  = 1,
	QuestFieldConditionType_MAX              = 2,
};

// Enum AT.EQUEST_GENERAL_TALK_TIMING
// NumValues: 0x0003
enum class EQUEST_GENERAL_TALK_TIMING : uint8
{
	START                                    = 0,
	END                                      = 1,
	EQUEST_GENERAL_TALK_MAX                  = 2,
};

// Enum AT.EQuestImageState
// NumValues: 0x0008
enum class EQuestImageState : uint8
{
	None                                     = 0,
	Loading                                  = 1,
	FadeOut                                  = 2,
	FadeIn                                   = 3,
	Enable                                   = 4,
	Disable                                  = 5,
	Waiting                                  = 6,
	EQuestImageState_MAX                     = 7,
};

// Enum AT.ENotyfyConditionCategory
// NumValues: 0x0002
enum class ENotyfyConditionCategory : uint8
{
	Disabled                                 = 0,
	ENotyfyConditionCategory_MAX             = 1,
};

// Enum AT.NotyfyTiming
// NumValues: 0x0009
enum class ENotyfyTiming : uint8
{
	Hunting                                  = 0,
	Fishing                                  = 1,
	CollectingItems                          = 2,
	CollectingFruits                         = 3,
	CollectingOre                            = 4,
	CollectingZOrbs                          = 5,
	Minigame                                 = 6,
	Atrocious                                = 7,
	Max                                      = 8,
};

// Enum AT.EATRestrictMoveControlPreset
// NumValues: 0x0014
enum class EATRestrictMoveControlPreset : uint8
{
	None                                     = 0,
	House                                    = 1,
	CaveSmall                                = 2,
	CaveBig                                  = 3,
	LevitationMode                           = 4,
	NimbusMode                               = 5,
	DisableLevitation                        = 6,
	DepressedMode                            = 7,
	GroundOnly                               = 8,
	Carrying                                 = 9,
	Running                                  = 10,
	IgnoreLevitationMode                     = 11,
	RestrictJumping                          = 12,
	DisableBoost                             = 13,
	GroundOnlyDisableRide                    = 14,
	RestrictJumpingAndFieldShot              = 15,
	StandFirstAndSecondOnly                  = 16,
	MedicalCenter_DLC4                       = 17,
	SaiyanHangout_DLC4                       = 18,
	Max                                      = 19,
};

// Enum AT.EATRestrictMoveControlB
// NumValues: 0x0008
enum class EATRestrictMoveControlB : uint8
{
	None                                     = 0,
	Disable                                  = 1,
	FirstOnlyCanCancel                       = 2,
	SecondOnlyCanCancel                      = 3,
	ForceFirst                               = 4,
	ForceSecond                              = 5,
	ForceEnableCanSwitchGear                 = 6,
	EATRestrictMoveControlB_MAX              = 7,
};

// Enum AT.EATRestrictMoveControlA
// NumValues: 0x0003
enum class EATRestrictMoveControlA : uint8
{
	None                                     = 0,
	Disable                                  = 1,
	EATRestrictMoveControlA_MAX              = 2,
};

// Enum AT.ESHOP_MONEY_CURRENCY_TYPE
// NumValues: 0x0003
enum class ESHOP_MONEY_CURRENCY_TYPE : uint8
{
	CURRENCY_TYPE_DEFAULT                    = 0,
	CURRENCY_TYPE_PARTS                      = 1,
	CURRENCY_TYPE_MAX                        = 2,
};

// Enum AT.EBgmCode
// NumValues: 0x0076
enum class EBgmCode : uint8
{
	BGM_title                                = 0,
	BGM_menu                                 = 1,
	BGM_worldMap                             = 2,
	BGM_driving                              = 3,
	BGM_mg_baseball                          = 4,
	BGM_mg_fishing                           = 5,
	BGM_mg_race                              = 6,
	BGM_house                                = 7,
	BGM_capsule                              = 8,
	BGM_town                                 = 9,
	BGM_village                              = 10,
	BGM_SatanCity                            = 11,
	BGM_shrine                               = 12,
	BGM_kaiosei                              = 13,
	BGM_kaioshinkai                          = 14,
	BGM_battle01                             = 15,
	BGM_battle02                             = 16,
	BGM_battle03                             = 17,
	BGM_battle04                             = 18,
	BGM_Vegeta                               = 19,
	BGM_Freezer                              = 20,
	BGM_Cell                                 = 21,
	BGM_Buu                                  = 22,
	BGM_Buu_Final                            = 23,
	BGM_boss01                               = 24,
	BGM_boss02                               = 25,
	BGM_boss03                               = 26,
	BGM_boss04                               = 27,
	BGM_endChapter                           = 28,
	BGM_anxiety                              = 29,
	BGM_assault                              = 30,
	BGM_sorrow                               = 31,
	BGM_search                               = 32,
	BGM_everyday01                           = 33,
	BGM_everyday02                           = 34,
	BGM_upbeat                               = 35,
	BGM_hurry                                = 36,
	BGM_sneaking                             = 37,
	BGM_Z_dictionary                         = 38,
	BGM_bonfire                              = 39,
	BGM_CHC                                  = 40,
	BGM_WGP                                  = 41,
	BGM_M0710                                = 42,
	BGM_M1711                                = 43,
	BGM_M0708A                               = 44,
	BGM_M1706A                               = 45,
	BGM_M0814                                = 46,
	BGM_M1119                                = 47,
	BGM_M1522                                = 48,
	BGM_M0703                                = 49,
	BGM_M1606                                = 50,
	BGM_M0723                                = 51,
	BGM_M0732                                = 52,
	BGM_CHARA_oche                           = 53,
	BGM_M0710oneshot                         = 54,
	BGM_M1711oneshot                         = 55,
	BGM_WGPoneshot                           = 56,
	BGM_exploration                          = 57,
	BGM_hidden                               = 58,
	BGM_Atrocious                            = 59,
	BGM_CHARA_oche_loop                      = 60,
	BGM_shenlong                             = 61,
	BGM_CHC_VO_Loop                          = 62,
	BGM_Cell_Final                           = 63,
	J_get_dragonball                         = 64,
	J_quest                                  = 65,
	J_result                                 = 66,
	BGM_Anison_Makafusigi                    = 67,
	BGM_Anison_Romantic                      = 68,
	BGM_Anison_WEGOTTAPOWER                  = 69,
	BGM_Anison_DetekoitobikiriZENKAI         = 70,
	BGM_Anison_bokutachihatensi              = 71,
	BGM_Anison_yapparisaikyou                = 72,
	BGM_Anison_Solidstate                    = 73,
	BGM_Anison_DragonSoul                    = 74,
	BGM_Anison_Unmeinohi                     = 75,
	BGM_Anison_DRAGONBALLZ                   = 76,
	BGM_Anison_FreezerVSsupersaiyans         = 77,
	BGM_DLC1_Beerus_Planet                   = 78,
	BGM_DLC1_Beerus_Battle                   = 79,
	BGM_DLC1_Whis_Battle                     = 80,
	BGM_DLC1_Beerus_Final                    = 81,
	BGM_TCG_title                            = 82,
	BGM_TCG_mainmenu                         = 83,
	BGM_TCG_battle01                         = 84,
	BGM_TCG_battle_hurryup                   = 85,
	BGM_DLC2_crowd_battle                    = 86,
	BGM_DLC2_Golden_Frieza_battle            = 87,
	BGM_DLC2_Golden_Frieza_Final             = 88,
	BGM_DLC3_Androids_Battle                 = 89,
	BGM_DLC3_Androids_Battle_Final           = 90,
	BGM_DLC3_Town_Broken                     = 91,
	BGM_DLC3_Dabura_Battle_Final             = 92,
	BGM_DLC3_Androids_Battle_Gohan           = 93,
	BGM_DLC4_battle                          = 94,
	BGM_DLC4_Vegeta_Planet1                  = 95,
	BGM_DLC4_Freezer                         = 96,
	BGM_DLC4_Collapse                        = 97,
	BGM_DLC4_Future                          = 98,
	BGM_DLC4_Destroy                         = 99,
	BGM_DLC4_Vegeta_Planet2                  = 100,
	BGM_DLC4_Solidstate_Orche                = 101,
	BGM_DLC5_battle_01_adventure             = 102,
	BGM_DLC5_battle_02_tournament            = 103,
	BGM_DLC5_battle_03_tenshinhan            = 104,
	BGM_DLC5_battle_04_boss                  = 105,
	BGM_DLC5_battle_05_boss2                 = 106,
	BGM_DLC5_stadium_01                      = 107,
	BGM_DLC5_pressure                        = 108,
	BGM_DLC5_title                           = 109,
	BGM_DLC6_battle_01_stronger              = 110,
	BGM_DLC6_battle_02_pan                   = 111,
	BGM_DLC6_battle_03_fury                  = 112,
	BGM_DLC6_battle_04_power                 = 113,
	BGM_DLC6_festival                        = 114,
	BGM_TOTAL                                = 115,
	BGM_none                                 = 116,
	EBgmCode_MAX                             = 117,
};

// Enum AT.EPlBattleVoice_ID
// NumValues: 0x0069
enum class EPlBattleVoice_ID : uint8
{
	V_PL_DASH                                = 0,
	V_PL_ATK_CMN_S                           = 1,
	V_PL_ATK_CMN_L                           = 2,
	V_PL_ATK_SHOT                            = 3,
	V_PL_ATK_RASH_SHORT_ST                   = 4,
	V_PL_ATK_RASH_SHORT_ED                   = 5,
	V_PL_ATK_RASH_LONG_ST                    = 6,
	V_PL_ATK_RASH_LONG_ED                    = 7,
	V_PL_ATK_RASH_HIGHSPEED_ST               = 8,
	V_PL_ATK_RASH_HIGHSPEED_ED               = 9,
	V_PL_DMG_CMN_S                           = 10,
	V_PL_DMG_CMN_L                           = 11,
	V_PL_ATK_CMN_CHARGE                      = 12,
	V_PL_DEBUFF_01                           = 13,
	V_PL_DEBUFF_02                           = 14,
	V_PL_DEBUFF_03                           = 15,
	V_PL_DMG_BREAK                           = 16,
	V_PL_DMG_FLY                             = 17,
	V_PL_BURST                               = 18,
	V_PL_JUST_AVOIDANCE                      = 19,
	V_PL_ITEM_SEND                           = 20,
	V_PL_ITEM_RECEIVE                        = 21,
	V_PL_ITEM_USE                            = 22,
	V_PL_RESCUE                              = 23,
	V_PL_SKL_OMEN_S                          = 24,
	V_PL_SKL_OMEN_L                          = 25,
	V_PL_SKL_01                              = 26,
	V_PL_SKL_02                              = 27,
	V_PL_SKL_03                              = 28,
	V_PL_SKL_04                              = 29,
	V_PL_SKL_05                              = 30,
	V_PL_SKL_06                              = 31,
	V_PL_SKL_07                              = 32,
	V_PL_SKL_08                              = 33,
	V_PL_SKL_09                              = 34,
	V_PL_SKL_10                              = 35,
	V_PL_SKL_11                              = 36,
	V_PL_SKL_12                              = 37,
	V_PL_SKL_13                              = 38,
	V_PL_SKL_14                              = 39,
	V_PL_SKL_15                              = 40,
	V_PL_SKL_16                              = 41,
	V_PL_SKL_17                              = 42,
	V_PL_SKL_18                              = 43,
	V_PL_SKL_19                              = 44,
	V_PL_SKL_20                              = 45,
	V_PL_SKL_21                              = 46,
	V_PL_SKL_22                              = 47,
	V_PL_SKL_23                              = 48,
	V_PL_SKL_24                              = 49,
	V_PL_SKL_25                              = 50,
	V_PL_SKL_26                              = 51,
	V_PL_SKL_27                              = 52,
	V_PL_SKL_28                              = 53,
	V_PL_SKL_29                              = 54,
	V_PL_SKL_30                              = 55,
	V_PL_ETC_01                              = 56,
	V_PL_ETC_02                              = 57,
	V_PL_ETC_03                              = 58,
	V_PL_ETC_04                              = 59,
	V_PL_ETC_05                              = 60,
	V_PL_ETC_06                              = 61,
	V_PL_ETC_07                              = 62,
	V_PL_ETC_08                              = 63,
	V_PL_ETC_09                              = 64,
	V_PL_ETC_10                              = 65,
	V_PL_ETC_11                              = 66,
	V_PL_ETC_12                              = 67,
	V_PL_ETC_13                              = 68,
	V_PL_ETC_14                              = 69,
	V_PL_ETC_15                              = 70,
	V_PL_ETC_16                              = 71,
	V_PL_ETC_17                              = 72,
	V_PL_ETC_18                              = 73,
	V_PL_ETC_19                              = 74,
	V_PL_ETC_20                              = 75,
	V_PL_IDLING_01                           = 76,
	V_PL_IDLING_02                           = 77,
	V_PL_JUMP_01                             = 78,
	V_PL_JUMP_02                             = 79,
	V_PL_HIJUMP_01                           = 80,
	V_PL_HIJUMP_02                           = 81,
	V_PL_BOOST_01                            = 82,
	V_PL_BOOST_02                            = 83,
	V_PL_JUMP_03                             = 84,
	V_PL_JUMP_TO_FLY                         = 85,
	V_PL_HIJUMP_TO_FLY                       = 86,
	V_PL_ROLLING_01                          = 87,
	V_PL_ROLLING_02                          = 88,
	V_PL_WALLKICK                            = 89,
	V_PL_BOOST_03                            = 90,
	V_PL_SHORTBOOST                          = 91,
	V_PL_BRAKE                               = 92,
	V_PL_VBOOST_UP                           = 93,
	V_PL_VBOOST_DOWN                         = 94,
	V_PL_TARGET_FLY                          = 95,
	V_PL_VEHICLE_RIDE                        = 96,
	V_PL_VEHICLE_GETOUT                      = 97,
	V_PL_DMG_DEAD                            = 98,
	V_PL_SYS_BTLSTART                        = 99,
	V_PL_VICTORY                             = 100,
	V_PL_ESCAPE                              = 101,
	SE_TOTAL_PL_VOICE                        = 102,
	PL_VOICE_none                            = 103,
	EPlBattleVoice_MAX                       = 104,
};

// Enum AT.ESndCodeTcg
// NumValues: 0x0075
enum class ESndCodeTcg : uint8
{
	S_tcg_ui_card_disassembly                = 0,
	S_tcg_ui_card_flip_multi                 = 1,
	S_tcg_ui_cardpack_get                    = 2,
	S_tcg_ui_cardpack_release                = 3,
	S_tcg_ui_defeat                          = 4,
	S_tcg_ui_gameover                        = 5,
	S_tcg_ui_login_bonus                     = 6,
	S_tcg_ui_matching_LP                     = 7,
	S_tcg_ui_select                          = 8,
	S_tcg_ui_timecount                       = 9,
	S_tcg_ui_timecount_start                 = 10,
	S_tcg_ui_titlemenu_in                    = 11,
	S_tcg_ui_turn_select                     = 12,
	S_tcg_ui_turnend                         = 13,
	S_tcg_ui_turnend_hold                    = 14,
	S_tcg_ui_turnover                        = 15,
	S_tcg_ui_turnstart                       = 16,
	S_tcg_ui_versus                          = 17,
	S_tcg_ui_victory                         = 18,
	S_tcg_bank_charge                        = 19,
	S_tcg_bank_release                       = 20,
	S_tcg_bank_repair                        = 21,
	S_tcg_bank_symbol_charge                 = 22,
	S_tcg_bank_symbol_release                = 23,
	S_tcg_card_attack                        = 24,
	S_tcg_card_attack_hit                    = 25,
	S_tcg_card_buff                          = 26,
	S_tcg_card_condition_normal              = 27,
	S_tcg_card_dead                          = 28,
	S_tcg_card_debuff                        = 29,
	S_tcg_card_flip                          = 30,
	S_tcg_card_guard                         = 31,
	S_tcg_card_heal                          = 32,
	S_tcg_card_Instant_death                 = 33,
	S_tcg_card_invincible                    = 34,
	S_tcg_card_sphere                        = 35,
	S_tcg_card_sphere_hit                    = 36,
	S_tcg_card_sword                         = 37,
	S_tcg_card_sword_hit                     = 38,
	S_tcg_demo_card_eject                    = 39,
	S_tcg_demo_card_generate                 = 40,
	S_tcg_demo_opening                       = 41,
	S_tcg_demo_start_animation               = 42,
	S_tcg_leader_damage                      = 43,
	S_tcg_leader_dead                        = 44,
	S_tcg_shop_rarecard_get_s                = 45,
	S_tcg_shop_rarecard_get_ss               = 46,
	S_tcg_skill_attack_rush                  = 47,
	S_tcg_skill_big_explosion                = 48,
	S_tcg_skill_bigbangattack                = 49,
	S_tcg_skill_burningattack                = 50,
	S_tcg_skill_crusher_ball                 = 51,
	S_tcg_skill_death_ball                   = 52,
	S_tcg_skill_death_beam                   = 53,
	S_tcg_skill_dx_bomber                    = 54,
	S_tcg_skill_esp                          = 55,
	S_tcg_skill_evil_buster                  = 56,
	S_tcg_skill_finalflash                   = 57,
	S_tcg_skill_galacticdonuts               = 58,
	S_tcg_skill_gekiretsu                    = 59,
	S_tcg_skill_genkidama                    = 60,
	S_tcg_skill_great_ape_beam               = 61,
	S_tcg_skill_kamehame                     = 62,
	S_tcg_skill_kienzan                      = 63,
	S_tcg_skill_kikouhou                     = 64,
	S_tcg_skill_makan                        = 65,
	S_tcg_skill_masenko                      = 66,
	S_tcg_skill_mouthcannon                  = 67,
	S_tcg_skill_okashi                       = 68,
	S_tcg_skill_piccolo_sphere               = 69,
	S_tcg_skill_recoome_eraser_gun           = 70,
	S_tcg_skill_renzoku_kidan                = 71,
	S_tcg_skill_self_destruction             = 72,
	S_tcg_skill_sphere_rush                  = 73,
	S_tcg_skill_sword_rush                   = 74,
	S_tcg_skill_vanishing_ball               = 75,
	S_tcg_sp_summon                          = 76,
	S_tcg_rare_summon                        = 77,
	S_tcg_ui_titlemenu_decide                = 78,
	S_tcg_skill_taiyoken                     = 79,
	S_tcg_demo_opening_logo                  = 80,
	S_tcg_demo_card_generate_result          = 81,
	S_shop_rarecard_get_ss                   = 82,
	S_shop_rarecard_get_s                    = 83,
	S_tcg_ui_skill_omen                      = 84,
	S_tcg_ui_turnstart_enemy                 = 85,
	S_tcg_ui_levelup                         = 86,
	S_tcg_ui_rankdown                        = 87,
	S_tcg_ui_rankup                          = 88,
	S_tcg_demo_singlecard_eject              = 89,
	S_tcg_ui_singlecard_release              = 90,
	S_tcg_card_costdown                      = 91,
	S_tcg_card_disappear                     = 92,
	S_tcg_card_ginyuforce_pause              = 93,
	S_tcg_card_instant_appearance            = 94,
	S_tcg_card_jump                          = 95,
	S_tcg_card_regene                        = 96,
	S_tcg_card_trriger_effect                = 97,
	S_tcg_skill_punishmentstorm              = 98,
	S_tcg_skill_rain_pours                   = 99,
	S_tcg_skill_dirtyfireworks               = 100,
	S_tcg_skill_hellsflash                   = 101,
	S_tcg_skill_vanishing_ball_wide          = 102,
	S_tcg_skill_galickgun                    = 103,
	S_tcg_skill_kiss                         = 104,
	S_tcg_skill_statue                       = 105,
	S_tcg_skill_doublesunday                 = 106,
	S_tcg_skill_deathslicer_single           = 107,
	S_tcg_skill_deathslicer_twin             = 108,
	S_tcg_skill_heatup                       = 109,
	S_tcg_skill_kyushu                       = 110,
	S_tcg_skill_potara                       = 111,
	S_tcg_skill_satan                        = 112,
	S_tcg_skill_chotokudai_genkidama         = 113,
	SE_TOTAL_TCG                             = 114,
	TCG_none                                 = 115,
	ESndCodeTcg_MAX                          = 116,
};

// Enum AT.ESndCodeAmbient
// NumValues: 0x0029
enum class ESndCodeAmbient : uint8
{
	S_amb_windroads_LP                       = 0,
	S_amb_underwater_LP                      = 1,
	S_amb_waterfall_LP                       = 2,
	S_amb_waterfall_splash_LP                = 3,
	S_amb_cave_LP                            = 4,
	S_amb_river_LP                           = 5,
	S_amb_beach_LP                           = 6,
	S_amb_cob                                = 7,
	S_amb_bird_tweet_LP                      = 8,
	S_amb_shortwind                          = 9,
	S_amb_springwater                        = 10,
	S_amb_wind_soft_LP                       = 11,
	S_amb_ice_impact_LP                      = 12,
	S_amb_wind_hard_LP                       = 13,
	S_amb_fountain_LP                        = 14,
	S_amb_swaying_trees                      = 15,
	S_amb_thunder1                           = 16,
	S_amb_thunder2                           = 17,
	S_amb_bonfire_LP                         = 18,
	S_amb_dragonball_LP                      = 19,
	S_amb_lightning                          = 20,
	S_amb_thundercloud_01_LP                 = 21,
	S_amb_thundercloud_02_LP                 = 22,
	S_amb_sky_LP                             = 23,
	S_amb_tree                               = 24,
	S_amb_wasteland_LP                       = 25,
	S_amb_freezabattle                       = 26,
	S_amb_spaceship_LP                       = 27,
	S_amb_rain_LP                            = 28,
	S_amb_submarine                          = 29,
	S_amb_conveyor_LP                        = 30,
	S_amb_medical_machine_LP                 = 31,
	S_amb_windmill_LP                        = 32,
	S_amb_bar_LP                             = 33,
	S_amb_audienceLP                         = 34,
	S_amb_foodwagonLP                        = 35,
	S_amb_restaurantLP                       = 36,
	S_amb_restaurant2LP                      = 37,
	SE_TOTAL_AMBIENT                         = 38,
	AMBIENT_none                             = 39,
	ESndCodeAmbient_MAX                      = 40,
};

// Enum AT.ESndCodeTalkdemo
// NumValues: 0x0089
enum class ESndCodeTalkdemo : uint8
{
	S_talkdemo_scouter_operation             = 0,
	S_talkdemo_scouter_notice                = 1,
	S_talkdemo_scouter_search                = 2,
	S_talkdemo_fightingpose                  = 3,
	S_talkdemo_cloth_turn                    = 4,
	S_talkdemo_impact01                      = 5,
	S_talkdemo_valleywind_LP                 = 6,
	S_talkdemo_cloth_friction                = 7,
	S_talkdemo_cloth_friction2               = 8,
	S_talkdemo_impact03                      = 9,
	S_talkdemo_cloth_hit                     = 10,
	S_talkdemo_androidboot_Sub_Cpl033_01_02  = 11,
	S_talkdemo_ball_throw                    = 12,
	S_talkdemo_dig_Sub_NPC007_01_S060_evt    = 13,
	S_talkdemo_door_open_gravityroom         = 14,
	S_talkdemo_door_open_guru                = 15,
	S_talkdemo_dragonball_Sub_Npc016_01_01   = 16,
	S_talkdemo_drumming                      = 17,
	S_talkdemo_flashback                     = 18,
	S_talkdemo_flashback2                    = 19,
	S_talkdemo_landing_C01_010_S110_evt      = 20,
	S_talkdemo_mobilephoneput                = 21,
	S_talkdemo_phonecall                     = 22,
	S_talkdemo_phoneput                      = 23,
	S_talkdemo_phonetake                     = 24,
	S_talkdemo_piccolo_fusion                = 25,
	S_talkdemo_plane_C01_020_S050_evt        = 26,
	S_talkdemo_plane_C03_070_S010_evt        = 27,
	S_talkdemo_powerup                       = 28,
	S_talkdemo_quiz                          = 29,
	S_talkdemo_scouter_broken                = 30,
	S_talkdemo_scouter_remove                = 31,
	S_talkdemo_ship_C02_040_S090_evt         = 32,
	S_talkdemo_spaceship_broken              = 33,
	S_talkdemo_traingroom_off                = 34,
	S_talkdemo_traingroom_on                 = 35,
	S_talkdemo_work_Sub_Cpl033_01_02         = 36,
	S_talkdemo_zarbon_fall                   = 37,
	S_talkdemo_zarbon_wake                   = 38,
	S_talkdemo_dragonrader_search            = 39,
	S_talkdemo_vegita_fly_C03_050_S050_evt_LP = 40,
	S_talkdemo_exolosion_C03_030_S015_evt    = 41,
	S_talkdemo_ship_C03_050_S075_evt         = 42,
	S_talkdemo_fall_contraller_C03_070_S040_evt = 43,
	S_talkdemo_saiyaman_transform_on         = 44,
	S_talkdemo_incident_C04_010_S035_evt     = 45,
	S_talkdemo_chime_school                  = 46,
	S_talkdemo_saiyaman_transform_off        = 47,
	S_talkdemo_saiyan1_aura_LP               = 48,
	S_talkdemo_saiyan2_aura_LP               = 49,
	S_talkdemo_pistol_shot                   = 50,
	S_talkdemo_impact02                      = 51,
	S_talkdemo_robo_voice                    = 52,
	S_talkdemo_saiyaman_transform            = 53,
	S_talkdemo_clothing_beam_C04_060_S010_evt = 54,
	S_talkdemo_gaya_LP                       = 55,
	S_talkdemo_applause                      = 56,
	S_talkdemo_zsword_C04_040_S070_evt       = 57,
	S_talkdemo_heal_C04_050_S040_evt         = 58,
	S_talkdemo_buu_parts_C04_060_S055_evt    = 59,
	S_talkdemo_imagesearch_C02_030_S070_evt  = 60,
	S_talkdemo_spaceship_door                = 61,
	S_talkdemo_voiceplay_subquest64          = 62,
	S_talkdemo_full_throttle_C03_020_S085_evt = 63,
	S_talkdemo_car_start_C03_020_S085_evt    = 64,
	S_talkdemo_training_C01_040_S090_evt     = 65,
	S_talkdemo_vegita_aura_C02_030_S150_evt  = 66,
	S_talkdemo_dash_start                    = 67,
	S_talkdemo_dash_loop                     = 68,
	S_talkdemo_dash_end                      = 69,
	S_talkdemo_yamcha_explosion              = 70,
	S_talkdemo_comical_smoke                 = 71,
	S_talkdemo_android_landing               = 72,
	S_talkdemo_porunga_leaving               = 73,
	S_talkdemo_chiaotzu_skilloffset_subquest01 = 74,
	S_talkdemo_handgrip                      = 75,
	S_talkdemo_chichi_attack_subquest13      = 76,
	S_talkdemo_heartbeat                     = 77,
	S_talkdemo_earthquake_LP                 = 78,
	S_talkdemo_zsword_pullout_C04_040_S070_evt = 79,
	S_talkdemo_town_explosion_C04_040_S120_evt = 80,
	S_talkdemo_fallbook_subquest76           = 81,
	S_talkdemo_flashback3                    = 82,
	S_talkdemo_robo_creaking                 = 83,
	S_talkdemo_puar_move                     = 84,
	S_talkdemo_robo_stun                     = 85,
	S_talkdemo_robo_subquest28               = 86,
	S_talkdemo_baba_power                    = 87,
	S_talkdemo_police_arrival                = 88,
	S_talkdemo_chiaotzu_skill_subquest01     = 89,
	S_talkdemo_baba_float                    = 90,
	S_talkdemo_baba_landing                  = 91,
	S_talkdemo_baba_flyaway                  = 92,
	S_talkdemo_flash_subquest22              = 93,
	S_talkdemo_puar_trance_subquest75        = 94,
	S_talkdemo_ship_idle_C04_010_S065_evt    = 95,
	S_talkdemo_ship_start_C04_010_S065_evt   = 96,
	S_talkdemo_car_Sub_Npc026_05             = 97,
	S_talkdemo_crystal_C04_030_S027_evt      = 98,
	S_talkdemo_jump                          = 99,
	S_talkdemo_high_jump                     = 100,
	S_talkdemo_halo_off                      = 101,
	S_talkdemo_hungry                        = 102,
	S_talkdemo_saiyan1_aura_LP_fadein        = 103,
	S_talkdemo_saiyan2_aura_LP_fadein        = 104,
	S_talkdemo_ssgss_aura                    = 105,
	S_talkdemo_door_knock                    = 106,
	S_talkdemo_drone_siren                   = 107,
	S_talkdemo_radio_noise                   = 108,
	S_talkdemo_autodoor                      = 109,
	S_talkdemo_bar_door                      = 110,
	S_talkdemo_hitglass                      = 111,
	S_talkdemo_incubator_LP                  = 112,
	S_talkdemo_kanassa_wind_LP               = 113,
	S_talkdemo_bar_LP                        = 114,
	S_talkdemo_battle_guard                  = 115,
	S_talkdemo_field_fishing_09              = 116,
	S_talkdemo_tournament_audience1LP        = 117,
	S_talkdemo_tournament_audience2LP        = 118,
	S_talkdemo_tournament_audience3LP        = 119,
	S_talkdemo_tournament_gong               = 120,
	S_talkdemo_ChiChi                        = 121,
	S_talkdemo_cloak_takeoff                 = 122,
	S_talkdemo_fist                          = 123,
	S_talkdemo_rocket_fire                   = 124,
	S_talkdemo_rocket_move                   = 125,
	S_talkdemo_robot_stop                    = 126,
	S_talkdemo_robot_restart                 = 127,
	S_talkdemo_swallow                       = 128,
	S_talkdemo_meditation_out                = 129,
	S_talkdemo_meditation_in                 = 130,
	S_talkdemo_fireplace                     = 131,
	S_talkdemo_buu_eat                       = 132,
	S_talkdemo_fly_sp                        = 133,
	SE_TOTAL_TALKDEMO                        = 134,
	TALKDEMO_none                            = 135,
	ESndCodeTalkdemo_MAX                     = 136,
};

// Enum AT.ESndCodeMinigame
// NumValues: 0x0028
enum class ESndCodeMinigame : uint8
{
	S_minigame_cmn_applause                  = 0,
	S_minigame_cmn_correct                   = 1,
	S_minigame_cmn_incorrect                 = 2,
	S_minigame_cmn_count3                    = 3,
	S_minigame_cmn_count2                    = 4,
	S_minigame_cmn_count1                    = 5,
	S_minigame_cmn_start                     = 6,
	S_minigame_cmn_result1                   = 7,
	S_minigame_cmn_result2                   = 8,
	S_minigame_bb_batswing                   = 9,
	S_minigame_bb_hit_s                      = 10,
	S_minigame_bb_hit_m                      = 11,
	S_minigame_bb_hit_l                      = 12,
	S_minigame_bb_throw_easy                 = 13,
	S_minigame_bb_throw_normal               = 14,
	S_minigame_bb_throw_hard                 = 15,
	S_minigame_bb_throw_expert               = 16,
	S_minigame_bb_throw_sp1                  = 17,
	S_minigame_bb_throw_sp2                  = 18,
	S_minigame_bb_throw_sp3                  = 19,
	S_minigame_bb_ballcatch                  = 20,
	S_minigame_bb_energy_fx                  = 21,
	S_minigame_bb_countup                    = 22,
	S_minigame_bb_gameset                    = 23,
	S_minigame_bb_cut1                       = 24,
	S_minigame_bb_cut2                       = 25,
	S_minigame_bb_cut3                       = 26,
	S_minigame_bb_rank_in                    = 27,
	S_minigame_bb_throw_fx                   = 28,
	S_minigame_bb_bat_fx                     = 29,
	S_minigame_race_hurry                    = 30,
	S_minigame_race_timeup                   = 31,
	S_minigame_race_finish                   = 32,
	S_minigame_race_boost                    = 33,
	S_minigame_race_checkpoint               = 34,
	S_minigame_bb_throw_motion               = 35,
	S_minigame_race_boost_2                  = 36,
	SE_TOTAL_MINIGAME                        = 37,
	MINIGAME_none                            = 38,
	ESndCodeMinigame_MAX                     = 39,
};

// Enum AT.ESndCodeBattle
// NumValues: 0x00E1
enum class ESndCodeBattle : uint8
{
	S_battle_aura_super                      = 0,
	S_battle_blow_off                        = 1,
	S_battle_blow_off_02                     = 2,
	S_battle_bodyblow_hit                    = 3,
	S_battle_bodyblow_sw                     = 4,
	S_battle_goku_genkidama_exp              = 5,
	S_battle_vegita_bigbangattack_exp        = 6,
	S_battle_dash_end                        = 7,
	S_battle_dash_start                      = 8,
	S_battle_vegita_superbigbangattack_exp   = 9,
	S_battle_trunks_burningattack_exp        = 10,
	S_battle_trunks_kakusan_burningattack_exp = 11,
	S_battle_dblow_start                     = 12,
	S_battle_drive_back                      = 13,
	S_battle_trunks_genkai_burningattack_exp = 14,
	S_battle_piccolo_gekiretukoudan_exp      = 15,
	S_battle_piccolo_choyudou_gekiretukoudan_exp = 16,
	S_battle_mine_LP                         = 17,
	S_battle_piccolo_makuuhouidan_exp        = 18,
	S_battle_gotenks_galacticdonuts_float_LP = 19,
	S_battle_gotenks_galacticdonuts_exp      = 20,
	S_battle_gotenks_galacticdonuts_hold     = 21,
	S_battle_gotenks_galacticdonuts_unhold   = 22,
	S_battle_guard                           = 23,
	S_battle_guardbreak                      = 24,
	S_battle_guard_spheres                   = 25,
	S_battle_hit_critical                    = 26,
	S_battle_hit_ground                      = 27,
	S_battle_hit_ground_slide                = 28,
	S_battle_hit_normal                      = 29,
	S_battle_guldo_psycho_shoot              = 30,
	S_battle_guldo_psycho_appear             = 31,
	S_battle_frieza_deathstorm_exp           = 32,
	S_battle_cell_punishmentstorm_exp        = 33,
	S_battle_cell_shisin_disappear           = 34,
	S_battle_guard_beam                      = 35,
	S_battle_buu_candybeam_change            = 36,
	S_battle_buu_candybeam_release           = 37,
	S_battle_hit_sklspheres                  = 38,
	S_battle_hit_spheres                     = 39,
	S_battle_hit_super                       = 40,
	S_battle_mira_genkidama_exp              = 41,
	S_battle_buu_steam                       = 42,
	S_battle_buu_druminng                    = 43,
	S_battle_kaioken_auraoff                 = 44,
	S_battle_douka_auraoff                   = 45,
	S_battle_kyuukyokukaihou_auraoff         = 46,
	S_battle_kick_sw_a                       = 47,
	S_battle_kick_sw_b                       = 48,
	S_battle_kick_sw_c                       = 49,
	S_battle_nap_beam_bom01                  = 50,
	S_battle_nap_beam_bom02                  = 51,
	S_battle_nap_beam_chg                    = 52,
	S_battle_nap_beam_fire                   = 53,
	S_battle_notice                          = 54,
	S_battle_pic_makan_fire                  = 55,
	S_battle_powercharge                     = 56,
	S_battle_punch_sw                        = 57,
	S_battle_punch_sw_a                      = 58,
	S_battle_punch_sw_b                      = 59,
	S_battle_punch_sw_c                      = 60,
	S_battle_punch_sw_d                      = 61,
	S_battle_punch_sw_e                      = 62,
	S_battle_rcm_beam                        = 63,
	S_battle_rcm_kick                        = 64,
	S_battle_recover                         = 65,
	S_battle_rekkoudan_tame                  = 66,
	S_battle_rush_auto                       = 67,
	S_battle_rush_avoidance                  = 68,
	S_battle_shoot                           = 69,
	S_battle_skillbreak_loop                 = 70,
	S_battle_sklbrk_ed                       = 71,
	S_battle_sklbrk_st                       = 72,
	S_battle_sklchain_01                     = 73,
	S_battle_sklchain_02                     = 74,
	S_battle_sklchain_03                     = 75,
	S_battle_sklchain_ed                     = 76,
	S_battle_sklchain_lvup                   = 77,
	S_battle_slow_finish                     = 78,
	S_battle_slow_start                      = 79,
	S_battle_tame_shoot                      = 80,
	S_battle_tps_finish                      = 81,
	S_battle_tps_start                       = 82,
	S_battle_veg_beam_chg                    = 83,
	S_battle_warp                            = 84,
	S_battle_water_splash                    = 85,
	S_bsbattle_beam_afterimage               = 86,
	S_bsbattle_beam_avoid                    = 87,
	S_bsbattle_beam_chgloop                  = 88,
	S_bsbattle_beam_fire                     = 89,
	S_bsbattle_beam_hit                      = 90,
	S_bsbattle_beam_warp                     = 91,
	S_bsbattle_bigkamehame                   = 92,
	S_bsbattle_crash                         = 93,
	S_bsbattle_crash_bt                      = 94,
	S_bsbattle_kamehame_ed                   = 95,
	S_bsbattle_kamehame_loop                 = 96,
	S_bsbattle_supernova                     = 97,
	S_battle_giantstorm_wide                 = 98,
	S_battle_dash_loop                       = 99,
	S_battle_dash_fall                       = 100,
	S_battle_dash_up                         = 101,
	S_battle_target                          = 102,
	S_battle_dash_pre                        = 103,
	S_battle_robo_atk_shoot                  = 104,
	S_battle_robo_charge                     = 105,
	S_battle_robo_dash                       = 106,
	S_battle_robo_dmg_break                  = 107,
	S_battle_robo_dmg_cmn_l                  = 108,
	S_battle_robo_dmg_cmn_s                  = 109,
	S_battle_kick_sw                         = 110,
	S_battle_robo_dmg_dead                   = 111,
	S_battle_robo_skl_01                     = 112,
	S_battle_robo_skl_02                     = 113,
	S_battle_robo_skl_05                     = 114,
	S_battle_robo_skl_03                     = 115,
	S_battle_robo_skl_04                     = 116,
	S_battle_bit_dmg_cmn_s                   = 117,
	S_battle_bit_dmg_cmn_l                   = 118,
	S_battle_bit_dmg_fly                     = 119,
	S_battle_bit_return                      = 120,
	S_battle_bit_wakeup                      = 121,
	S_battle_bit_atk_shoot                   = 122,
	S_battle_bit_charge                      = 123,
	S_battle_bit_omen                        = 124,
	S_battle_bit_skl_01                      = 125,
	S_battle_bit_skl_02                      = 126,
	S_battle_bit_skl_03                      = 127,
	S_battle_bit_dmg_dead                    = 128,
	S_battle_shoot_charge                    = 129,
	S_battle_bit_dmg_break                   = 130,
	S_battle_radits_doublesunday_shoot       = 131,
	S_battle_robo_beam_charge                = 132,
	S_battle_rampage                         = 133,
	S_battle_weakness                        = 134,
	S_battle_heatup_auraoff                  = 135,
	S_battle_offsetboost                     = 136,
	S_battle_offset_beam                     = 137,
	S_battle_offset_lose                     = 138,
	S_battle_offset_win                      = 139,
	S_battle_trunks_finishbuster_exp         = 140,
	S_battle_burst                           = 141,
	S_battle_bodyfall                        = 142,
	S_battle_nappa_bomberdx_exp              = 143,
	S_battle_supersaiyan_auraoff             = 144,
	S_battle_frieza_deathslicer_LP           = 145,
	S_battle_superfinish_genkidama           = 146,
	S_battle_superfinish_kamehameha          = 147,
	S_battle_robo_skl_06                     = 148,
	S_battle_robo_skl_07                     = 149,
	S_battle_robo_skl_08                     = 150,
	S_battle_robo_skl_09                     = 151,
	S_battle_robo_skl_10                     = 152,
	S_battle_robo_skl_11                     = 153,
	S_battle_robo_skl_12                     = 154,
	S_battle_absorb_beam                     = 155,
	S_battle_absorb_energy                   = 156,
	S_battle_absorb_shoot                    = 157,
	S_battle_bonyu_barrier_break             = 158,
	S_battle_bonyu_barrier_LP                = 159,
	S_battle_bonyu_blastball_appear          = 160,
	S_battle_bonyu_blaststorm_hold_LP        = 161,
	S_battle_bonyu_blaststorm_unhold         = 162,
	S_battle_bonyu_barrier_crack_01          = 163,
	S_battle_bonyu_barrier_crack_02          = 164,
	S_battle_bonyu_blastball_disappear       = 165,
	S_battle_wiss_guardLP                    = 166,
	S_battle_wiss_symphonic_LP               = 167,
	S_battle_wiss_suite_bomb                 = 168,
	S_battle_wiss_suite_LP                   = 169,
	S_battle_wiss_waltz_bomb                 = 170,
	S_battle_wiss_waltz_s_bomb               = 171,
	S_battle_beerusball_bomb                 = 172,
	S_battle_beerusball_LP                   = 173,
	S_battle_beerus_sphere_sppear            = 174,
	S_battle_beerus_sphere_flash             = 175,
	S_battle_beerus_sphere_LP                = 176,
	S_battle_beerus_sphere_shot              = 177,
	S_battle_mira_honkidama_exp              = 178,
	S_battle_mira_powerup_LP                 = 179,
	S_battle_zcomb_exp                       = 180,
	S_battle_frieza_goldendeathslicer_LP     = 181,
	S_battle_frieza_goldenedge_exp           = 182,
	S_battle_supersaiyan_aura_LP             = 183,
	S_battle_ssgss_auraoff                   = 184,
	S_battle_gokudai_kamehameha_exp          = 185,
	S_battle_frieza_goldendeathball_exp      = 186,
	S_battle_frieza_goldendeathball_LP       = 187,
	S_battle_wiss_duet_disp                  = 188,
	S_battle_wiss_sonata_disp                = 189,
	S_battle_variable_catcher_hold           = 190,
	S_battle_variable_catcher_unhold         = 191,
	S_battle_dabra_enhancement_LP            = 192,
	S_battle_godblaster_bomb                 = 193,
	S_battle_foresee_fade                    = 194,
	S_battle_foresee_omen                    = 195,
	S_battle_C027A_S_SKL001_Bomb             = 196,
	S_battle_C078A_S_SKL001_ExpFall          = 197,
	S_battle_C005G_S_SKL001_B_SE_02BallFly   = 198,
	S_battle_C079A_S_SKL001_B_SE_00_teleport = 199,
	S_battle_C079A_S_SKL001_B_SE_01_move     = 200,
	S_battle_C086A_S_SKL001_B_SE_02_Ball_Loop = 201,
	S_battle_C086A_S_SKL001_B_SE_03_Bomb     = 202,
	S_battle_C005G_S_SKL002_B_SE_03_Hit      = 203,
	S_battle_C005G_S_SKL003_B_SE_01_BallDown = 204,
	S_battle_C001C_G_SKL004_B_SE_03LastHit   = 205,
	S_battle_C001D_G_SKL003_B_SE_03ApperHit  = 206,
	S_battle_C001D_G_SKL004_A_SE_02Hit       = 207,
	S_battle_C001D_G_SKL004_B_SE_02Hit       = 208,
	S_battle_C001D_G_SKL103_B_SE_04Hit       = 209,
	S_battle_C098A_G_SKL001_E_B_SE_02Hit     = 210,
	S_battle_C098A_G_SKL004_E_B_SE_03Expro   = 211,
	S_battle_C101B_G_SKL006_B_SE_02Hit       = 212,
	S_battle_C102A_G_SKL002_B_SE_03Hit       = 213,
	S_battle_C011C_G_SKL005_B_SE_01_Shot     = 214,
	S_battle_C011C_G_SKL105_B_SE_01Shot      = 215,
	S_battle_C102A_G_SKL103_B_SE_02Flying    = 216,
	S_battle_C036B_G_SKL005_B_SE_01_Loop     = 217,
	S_battle_C036B_G_SKL005_B_SE_02_Break    = 218,
	S_battle_C106A_GBTL_GigzagBoost_B_SE_02_Punch = 219,
	S_battle_C003E_S_SKL007_A_SE_02_1Shot    = 220,
	S_battle_C003E_S_SKL007_A_SE_03_Bomb     = 221,
	SE_TOTAL_BATTLE                          = 222,
	BATTLE_none                              = 223,
	ESndCodeBattle_MAX                       = 224,
};

// Enum AT.ESndCodeField
// NumValues: 0x00E5
enum class ESndCodeField : uint8
{
	S_field_footstep_grass                   = 0,
	S_field_footstep_sand                    = 1,
	S_field_footstep_rock                    = 2,
	S_field_footstep_asphalt                 = 3,
	S_field_footstep_watersurface            = 4,
	S_field_footstep_wood                    = 5,
	S_field_footstep_ice                     = 6,
	S_field_footstep_metal                   = 7,
	S_field_footstep_waterbottom             = 8,
	S_field_footstep_cliff                   = 9,
	S_field_cook_eat                         = 10,
	S_field_cook_eat2                        = 11,
	S_field_car_horn                         = 12,
	S_field_plane_LP                         = 13,
	S_field_vehicle_crash                    = 14,
	S_field_vehicle1_idle_LP                 = 15,
	S_field_vehicle1_start                   = 16,
	S_field_vehicle1_brake                   = 17,
	S_field_vehicle1_back_LP                 = 18,
	S_field_vehicle2_idle_LP                 = 19,
	S_field_vehicle2_step                    = 20,
	S_field_vehicle2_start                   = 21,
	S_field_vehicle2_jump                    = 22,
	S_field_vehicle2_land                    = 23,
	S_field_search_circle_open               = 24,
	S_field_search_circle_close              = 25,
	S_field_cry_birds                        = 26,
	S_field_cry_chicken1                     = 27,
	S_field_cry_chicken2                     = 28,
	S_field_cry_dog1                         = 29,
	S_field_cry_dog2                         = 30,
	S_field_cry_wolf                         = 31,
	S_field_cry_deer                         = 32,
	S_field_cry_pterosaur                    = 33,
	S_field_cry_dinosaur                     = 34,
	S_field_cry_littlebird                   = 35,
	S_field_cry_eagle                        = 36,
	S_field_cry_dolphin                      = 37,
	S_field_footsteps_animals_s              = 38,
	S_field_footsteps_animals_l              = 39,
	S_field_dino_footstep                    = 40,
	S_field_windroads_LP                     = 41,
	S_field_vehicle_call                     = 42,
	S_field_thicket                          = 43,
	S_field_flapping_pterosaur               = 44,
	S_field_waterdive                        = 45,
	S_field_swaying_trees                    = 46,
	S_field_shortwind                        = 47,
	S_field_thunder1                         = 48,
	S_field_thunder2                         = 49,
	S_field_waterfall_LP                     = 50,
	S_field_river_LP                         = 51,
	S_field_sea_LP                           = 52,
	S_field_spawn_friends                    = 53,
	S_field_error                            = 54,
	S_field_break_ore                        = 55,
	S_field_break_rock_s                     = 56,
	S_field_break_rock_l                     = 57,
	S_field_push_grass                       = 58,
	S_field_rummaging                        = 59,
	S_minigame_fishing_bounce_fish           = 60,
	S_minigame_fishing_tailswing             = 61,
	S_minigame_fishing_groundbait            = 62,
	S_minigame_fishing_splash                = 63,
	S_field_smoke_comical                    = 64,
	S_field_break_rock                       = 65,
	S_field_bigbird_flap                     = 66,
	S_field_bird_flap_b                      = 67,
	S_field_bird_flap_c                      = 68,
	S_field_bird_flap_d                      = 69,
	S_field_bird_flap_e                      = 70,
	S_field_bird_tweet_a                     = 71,
	S_field_bird_tweet_b                     = 72,
	S_field_bird_tweet_c                     = 73,
	S_field_bird_tweet_d                     = 74,
	S_field_bird_tweet_e                     = 75,
	S_field_break_building                   = 76,
	S_field_break_tree                       = 77,
	S_field_car                              = 78,
	S_field_chicken_a                        = 79,
	S_field_chicken_b                        = 80,
	S_field_chicken_c                        = 81,
	S_field_chicken_d                        = 82,
	S_field_chicken_e                        = 83,
	S_field_common_get                       = 84,
	S_field_dino_fall                        = 85,
	S_field_dino_notice                      = 86,
	S_field_dino_roar                        = 87,
	S_field_dino_wait                        = 88,
	S_field_dragonball                       = 89,
	S_field_fishing_01                       = 90,
	S_field_fishing_02                       = 91,
	S_field_fishing_03                       = 92,
	S_field_fishing_04                       = 93,
	S_field_fishing_05                       = 94,
	S_field_fishing_06                       = 95,
	S_field_fishing_07                       = 96,
	S_field_fishing_08                       = 97,
	S_field_fishing_09                       = 98,
	S_field_fishing_11                       = 99,
	S_field_fishing_12                       = 100,
	S_field_fishing_13                       = 101,
	S_field_fishing_14                       = 102,
	S_field_fishing_15                       = 103,
	S_field_fishing_gauge                    = 104,
	S_field_fishing_rare                     = 105,
	S_field_fishing_splash                   = 106,
	S_field_fishing_start                    = 107,
	S_field_fly                              = 108,
	S_field_fly_dive                         = 109,
	S_field_fly_jump                         = 110,
	S_field_fly_landing                      = 111,
	S_field_fly_rise                         = 112,
	S_field_fly_sp                           = 113,
	S_field_fly_splash                       = 114,
	S_field_fly_stop                         = 115,
	S_field_fly_tree                         = 116,
	S_field_fly_turn                         = 117,
	S_field_fly_water                        = 118,
	S_field_fly_water_small                  = 119,
	S_field_footstep_a                       = 120,
	S_field_footstep_b                       = 121,
	S_field_footstep_mob_a                   = 122,
	S_field_footstep_mob_b                   = 123,
	S_field_footstep_mob_c                   = 124,
	S_field_footstep_mob_d                   = 125,
	S_field_foot_landing                     = 126,
	S_field_force_end                        = 127,
	S_field_force_start                      = 128,
	S_field_fruit_appear                     = 129,
	S_field_get_orb                          = 130,
	S_field_high_jump                        = 131,
	S_field_hit_wall                         = 132,
	S_field_jump                             = 133,
	S_field_ore_appear                       = 134,
	S_field_plane                            = 135,
	S_field_flying_dino                      = 136,
	S_field_cry_wolf_dagame                  = 137,
	S_field_cry_deer_damage                  = 138,
	S_field_cry_pterosaur_damage             = 139,
	S_field_cry_dinosaur_2                   = 140,
	S_field_break_ice_s                      = 141,
	S_field_break_ice_l                      = 142,
	S_field_break_pots                       = 143,
	S_field_break_metals                     = 144,
	S_field_fishing_rod_01                   = 145,
	S_field_fishing_rod_02                   = 146,
	S_field_fishing_rod_03                   = 147,
	S_field_fly_turn_3                       = 148,
	S_field_fly_ground                       = 149,
	S_field_door_open_gokuhouse              = 150,
	S_field_door_open_capsulecorp            = 151,
	S_field_door_open_babidiship             = 152,
	S_field_bonfire                          = 153,
	S_field_get_timeorb                      = 154,
	S_field_zorb_appear                      = 155,
	S_field_zorb_timecount                   = 156,
	S_field_zorb_disappear                   = 157,
	S_field_zorb_comp                        = 158,
	S_field_worldmap                         = 159,
	S_field_beach                            = 160,
	S_field_fountain                         = 161,
	S_field_falling                          = 162,
	S_field_dino_sleep                       = 163,
	S_field_dino_bite                        = 164,
	S_field_dino_damage_a                    = 165,
	S_field_dino_damage_b                    = 166,
	S_field_dino_damage_c                    = 167,
	S_field_dino_kicking                     = 168,
	S_field_flyningdino_damage               = 169,
	S_field_hit_level_limit                  = 170,
	S_field_tresurebox                       = 171,
	S_field_worldmap_fly                     = 172,
	S_field_worldmap_decide                  = 173,
	S_field_worldmap_new                     = 174,
	S_field_kintoun_getout                   = 175,
	S_field_kintoun_fly                      = 176,
	S_field_kintoun_call                     = 177,
	S_field_hit_spheres_water                = 178,
	S_field_hit_spheres_ground               = 179,
	S_field_drown                            = 180,
	S_field_jump_3                           = 181,
	S_field_jump_2                           = 182,
	S_field_cry_birds_fishpoint              = 183,
	S_field_bonfire_meal                     = 184,
	S_field_footstep_carpet                  = 185,
	S_field_footstep_snow                    = 186,
	S_field_footstep_woodboard               = 187,
	S_field_kintoun_ride                     = 188,
	S_field_kintoun_idle                     = 189,
	S_field_kintoun_start                    = 190,
	S_field_kintoun_roll                     = 191,
	S_field_fly_slow                         = 192,
	S_field_fly_fall                         = 193,
	S_field_fly_turn_2                       = 194,
	S_field_vehicle_ride                     = 195,
	S_field_vehicle_getout                   = 196,
	S_field_runspin_LP                       = 197,
	S_field_runspin_start                    = 198,
	S_field_runspin_end                      = 199,
	S_field_fishing_fall                     = 200,
	S_field_get_orb_touch                    = 201,
	S_field_cave_LP                          = 202,
	S_field_Wind_LP                          = 203,
	S_field_zorb_timecount_hurry             = 204,
	S_field_footstep_desert                  = 205,
	S_field_bird_flap                        = 206,
	S_field_footstep_mob_01                  = 207,
	S_field_base_ship_LP                     = 208,
	S_field_base_explosion                   = 209,
	S_field_base_tower_break                 = 210,
	S_field_base_tower_radar_LP              = 211,
	S_field_vehicle1_run_LP                  = 212,
	S_field_bubbles_LP                       = 213,
	S_field_planet_warp                      = 214,
	S_field_pillar_on_windroads              = 215,
	S_field_drone_move_LP                    = 216,
	S_field_drone_siren_LP                   = 217,
	S_field_footstep_rain                    = 218,
	S_field_drone_warningarea_LP             = 219,
	S_field_pod_carrier_LP                   = 220,
	S_field_pod_move_LP                      = 221,
	S_field_pod_takeoff                      = 222,
	S_field_pod_takeoff2                     = 223,
	S_field_medical_bubble                   = 224,
	S_field_footstep_bare                    = 225,
	SE_TOTAL_FIELD                           = 226,
	FIELD_none                               = 227,
	ESndCodeField_MAX                        = 228,
};

// Enum AT.ESndCodeCmn
// NumValues: 0x00A8
enum class ESndCodeCmn : uint8
{
	S_ui_select                              = 0,
	S_ui_decide                              = 1,
	S_ui_cancel                              = 2,
	S_ui_ng                                  = 3,
	S_ui_pageswitch                          = 4,
	S_ui_change                              = 5,
	S_ui_panel_open                          = 6,
	S_ui_panel_connect                       = 7,
	S_ui_linkbonus                           = 8,
	S_ui_community_rankup                    = 9,
	S_ui_skill_learn                         = 10,
	S_ui_result_rank                         = 11,
	S_cmn_cooking                            = 12,
	S_cmn_mecha_making                       = 13,
	S_ui_radio_call                          = 14,
	S_ui_cook_comp                           = 15,
	S_ui_cook_comp_s                         = 16,
	S_ui_result_window                       = 17,
	S_ui_cook_state_up                       = 18,
	S_ui_cook_state_up2                      = 19,
	S_ui_cook_state_up3                      = 20,
	S_ui_getitem                             = 21,
	S_ui_getitem_rare                        = 22,
	S_ui_get_dragonball_                     = 23,
	S_ui_get_treasure_get                    = 24,
	S_ui_window                              = 25,
	S_ui_update                              = 26,
	S_ui_lockon                              = 27,
	S_ui_quest_achievement                   = 28,
	S_ui_menutitle_in                        = 29,
	S_ui_quiz_correct                        = 30,
	S_ui_quiz_incorrect                      = 31,
	S_cmn_cook_fx                            = 32,
	S_cmn_cook_dishnoise                     = 33,
	S_cmn_eat_don_cdm_C001Aaa0               = 34,
	S_ui_gaugeup_LP                          = 35,
	S_ui_shop_pay                            = 36,
	S_ui_item_message                        = 37,
	S_ui_item_remove                         = 38,
	S_ui_chara_select                        = 39,
	S_ui_dragonball_comp                     = 40,
	S_ui_dodged                              = 41,
	S_ui_mainmenu_open                       = 42,
	S_ui_itemuse                             = 43,
	S_ui_dragon_radar_wake                   = 44,
	S_ui_dragon_radar_search                 = 45,
	S_ui_dragon_radar_set                    = 46,
	S_ui_dragon_radar_close                  = 47,
	S_ui_community_levelup                   = 48,
	S_ui_dragonball_shine                    = 49,
	S_ui_community_popular                   = 50,
	S_ui_enemy_caution1                      = 51,
	S_ui_enemy_caution2                      = 52,
	S_ui_battle_start                        = 53,
	S_cmn_cook_eat_dishnoise_LP              = 54,
	S_ui_battle_escape                       = 55,
	S_ui_battle_event_in                     = 56,
	S_ui_skillpalette_change                 = 57,
	S_ui_skillpalette_decide                 = 58,
	S_ui_skillpalette_empty                  = 59,
	S_ui_skillpalette_target                 = 60,
	S_ui_skillpalette_item_use               = 61,
	S_ui_skilltelop_player                   = 62,
	S_ui_skilltelop_enemy                    = 63,
	S_ui_skillchain_count                    = 64,
	S_ui_chaingauge                          = 65,
	S_ui_skillchain_result                   = 66,
	S_ui_skillchain_totaldamage              = 67,
	S_ui_rush_command                        = 68,
	S_ui_rush_start                          = 69,
	S_ui_rush_button                         = 70,
	S_ui_skillbreak_start                    = 71,
	S_ui_sparkinggauge_empty                 = 72,
	S_ui_battle_finish                       = 73,
	S_ui_show_result                         = 74,
	S_ui_story_result_rank                   = 75,
	S_ui_story_result_open                   = 76,
	S_ui_story_result_close                  = 77,
	S_ui_story_result_end                    = 78,
	S_ui_gameover                            = 79,
	S_ui_gameover_decide                     = 80,
	S_cmn_notice                             = 81,
	S_ui_assist_cutin                        = 82,
	S_ui_aula                                = 83,
	S_ui_bossresult_point                    = 84,
	S_ui_bossresult_rank                     = 85,
	S_ui_chance                              = 86,
	S_ui_decide_a                            = 87,
	S_ui_decide_b                            = 88,
	S_ui_decide_c                            = 89,
	S_ui_dragonball_skill                    = 90,
	S_ui_dragon_radar                        = 91,
	S_ui_encount                             = 92,
	S_ui_fishing_gauge                       = 93,
	S_ui_fishing_gauge_b                     = 94,
	S_ui_fishing_get_jingle                  = 95,
	S_ui_fishing_get_se                      = 96,
	S_ui_fishing_get_se_02                   = 97,
	S_ui_fishing_hit                         = 98,
	S_ui_levelup                             = 99,
	S_ui_message                             = 100,
	S_ui_orb_use_count                       = 101,
	S_ui_qte_mistake                         = 102,
	S_ui_qte_success                         = 103,
	S_ui_quest_instr_window                  = 104,
	S_ui_quest_log_update                    = 105,
	S_ui_quest_log_window                    = 106,
	S_ui_quest_received                      = 107,
	S_ui_quest_remuneration                  = 108,
	S_ui_screen_crack_01                     = 109,
	S_ui_screen_crack_02                     = 110,
	S_ui_screen_crack_03                     = 111,
	S_ui_screen_crack_fin                    = 112,
	S_ui_skillpalette_cls                    = 113,
	S_ui_skillpalette_op                     = 114,
	S_ui_skill_pal_rot                       = 115,
	S_ui_skill_right                         = 116,
	S_ui_skill_unlock                        = 117,
	S_ui_sub_quest                           = 118,
	S_ui_superfinish                         = 119,
	S_ui_rankgauge                           = 120,
	S_ui_dragonball_get                      = 121,
	S_ui_heatup_gauge                        = 122,
	S_ui_heatup_max                          = 123,
	S_ui_timemachine                         = 124,
	S_ui_call_shenlong                       = 125,
	S_zdic_bookclose                         = 126,
	S_zdic_bookopen                          = 127,
	S_zdic_decide                            = 128,
	S_zdic_turn_multipage                    = 129,
	S_zdic_turn_singlepage                   = 130,
	S_ui_heatup_on                           = 131,
	S_ui_support_gauge_max                   = 132,
	S_ui_chapter_result_deside               = 133,
	S_ui_dragon_radar_off                    = 134,
	S_ui_get_dmedal                          = 135,
	S_ui_title_decide                        = 136,
	S_ui_sp_max                              = 137,
	S_ui_result_rank_a                       = 138,
	S_ui_result_rank_b                       = 139,
	S_ui_result_rank_s                       = 140,
	S_ui_breath_caution                      = 141,
	S_ui_bonfire_eating                      = 142,
	S_ui_fadein_blur                         = 143,
	S_ui_emblem_get                          = 144,
	S_ui_emblem_levelup                      = 145,
	S_ui_story_result_vs                     = 146,
	S_ui_dino_chase                          = 147,
	S_ui_system_unlock                       = 148,
	S_ui_memories                            = 149,
	V_cmn_voicetest_goku_jp                  = 150,
	V_cmn_voicetest_goku_en                  = 151,
	S_cmn_pillar_throw_gauge_LP              = 152,
	S_ui_drone_caution_max                   = 153,
	S_ui_drone_escape                        = 154,
	S_ui_drone_caution                       = 155,
	S_ui_countup                             = 156,
	S_ui_subjugation                         = 157,
	S_ui_revival_fix                         = 158,
	S_ui_revival_up                          = 159,
	S_ui_qte_charge                          = 160,
	S_ui_qte_success2                        = 161,
	S_ui_qte_mistake2                        = 162,
	S_ui_qte_success2_2                      = 163,
	S_ui_qte_success2_3                      = 164,
	SE_TOTAL_CMN                             = 165,
	CMN_none                                 = 166,
	ESndCodeCmn_MAX                          = 167,
};

// Enum AT.ESndAcbId
// NumValues: 0x001D
enum class ESndAcbId : uint8
{
	ACB_BGM                                  = 0,
	ACB_CMN                                  = 1,
	ACB_BATTLE                               = 2,
	ACB_FIELD                                = 3,
	ACB_MINIGAME                             = 4,
	ACB_V_MAIN_C01                           = 5,
	ACB_V_MAIN_C02                           = 6,
	ACB_V_MAIN_C03                           = 7,
	ACB_V_MAIN_C04                           = 8,
	ACB_V_DLC01                              = 9,
	ACB_V_MAIN_SUB                           = 10,
	ACB_V_COMMUNITYLINK                      = 11,
	ACB_V_REACTION                           = 12,
	ACB_V_MINIGAME                           = 13,
	ACB_V_TITLEMESSAGE                       = 14,
	ACB_V_CROSSTALK                          = 15,
	ACB_V_TELEPATHY                          = 16,
	ACB_SKILL                                = 17,
	ACB_TALKDEMO                             = 18,
	ACB_AMBIENT                              = 19,
	ACB_TCG                                  = 20,
	ACB_V_TCG                                = 21,
	ACB_V_DLC02                              = 22,
	ACB_V_DLC03                              = 23,
	ACB_V_DLC04                              = 24,
	ACB_V_DLC05                              = 25,
	ACB_V_DLC06                              = 26,
	ACB_TOTAL                                = 27,
	ACB_MAX                                  = 28,
};

// Enum AT.TWEEN_TYPE
// NumValues: 0x0004
enum class ETWEEN_TYPE : uint8
{
	TWEEN_NOTUSE                             = 0,
	TWEEN_FADE_LOAD                          = 1,
	TWEEN_FADE_DEMO                          = 2,
	TWEEN_MAX                                = 3,
};

// Enum AT.ESndLoadReq
// NumValues: 0x000A
enum class ESndLoadReq : uint8
{
	BGM                                      = 0,
	CMN                                      = 1,
	PLVOICE                                  = 2,
	DEMO                                     = 3,
	MINIGAME                                 = 4,
	FIELD                                    = 5,
	VOICE                                    = 6,
	TCG                                      = 7,
	TOTAL                                    = 8,
	ESndLoadReq_MAX                          = 9,
};

// Enum AT.ESound3dType
// NumValues: 0x0004
enum class ESound3dType : uint8
{
	USE_FIELD_SE                             = 0,
	USE_AMBIENT_SE                           = 1,
	NOT_USE_SE                               = 2,
	ESound3dType_MAX                         = 3,
};

// Enum AT.ESoundDebugInputState
// NumValues: 0x0005
enum class ESoundDebugInputState : uint8
{
	Press                                    = 0,
	Down                                     = 1,
	Release                                  = 2,
	No                                       = 3,
	ESoundDebugInputState_MAX                = 4,
};

// Enum AT.ESoundTestMode
// NumValues: 0x0008
enum class ESoundTestMode : uint8
{
	TEST_NONE                                = 0,
	TEST_BGM                                 = 1,
	TEST_SE                                  = 2,
	TEST_VOICE                               = 3,
	TEST_BATTLE_VOICE                        = 4,
	TEST_MOVIE                               = 5,
	TEST_BACKTITLE                           = 6,
	TEST_MAX                                 = 7,
};

// Enum AT.EATSurfaceType
// NumValues: 0x0012
enum class EATSurfaceType : uint8
{
	Default                                  = 0,
	Grass                                    = 1,
	Sand                                     = 2,
	Rock                                     = 3,
	Asphalt                                  = 4,
	WaterSurface                             = 5,
	Wood                                     = 6,
	Ice                                      = 7,
	Metal                                    = 8,
	WaterBottom                              = 9,
	Snow                                     = 10,
	Dirt                                     = 11,
	Building                                 = 12,
	NoEffect                                 = 13,
	Cloth                                    = 14,
	Tree                                     = 15,
	MaxSurfaceType                           = 16,
	EATSurfaceType_MAX                       = 17,
};

// Enum AT.ESelectionEnableType
// NumValues: 0x0006
enum class ESelectionEnableType : uint8
{
	NONE                                     = 0,
	MAIN_QUEST_TARGET                        = 1,
	SUB_QUEST_TARGET                         = 2,
	HAS_MAIN_QUEST                           = 3,
	HAS_SUB_QUEST                            = 4,
	ESelectionEnableType_MAX                 = 5,
};

// Enum AT.ETalkWindowType
// NumValues: 0x0005
enum class ETalkWindowType : uint8
{
	Default                                  = 0,
	NaviWindow                               = 1,
	SystemWindow                             = 2,
	FrontWindow                              = 3,
	ETalkWindowType_MAX                      = 4,
};

// Enum AT.ETalkEventType
// NumValues: 0x000B
enum class ETalkEventType : uint8
{
	NONE                                     = 0,
	DEVELOPMENT                              = 1,
	COOKING                                  = 2,
	MINIGAME_BASEBALL                        = 3,
	MINIGAME_RACE                            = 4,
	QUEST_REPLAY                             = 5,
	QUEST_TURTLESCHOOL                       = 6,
	QUEST_SUBJUGATION                        = 7,
	ITEM_LIST                                = 8,
	TIPS                                     = 9,
	MAX                                      = 10,
};

// Enum AT.TALK_CONDITION_TYPE
// NumValues: 0x0008
enum class ETALK_CONDITION_TYPE : uint8
{
	NONE                                     = 0,
	BASEBALL                                 = 1,
	AIRCAR                                   = 2,
	ITEM                                     = 3,
	CHARA                                    = 4,
	SUBQUEST                                 = 5,
	CONDITION                                = 6,
	MAX                                      = 7,
};

// Enum AT.TALK_MINIGAME_LEVEL
// NumValues: 0x0005
enum class ETALK_MINIGAME_LEVEL : uint8
{
	EASY                                     = 0,
	NORMAL                                   = 1,
	HARD                                     = 2,
	VERY_HARD                                = 3,
	TALK_MINIGAME_MAX                        = 4,
};

// Enum AT.TALK_MINIGAME_TYPE
// NumValues: 0x0003
enum class ETALK_MINIGAME_TYPE : uint8
{
	BASEBALL                                 = 0,
	AIRCAR                                   = 1,
	TALK_MINIGAME_MAX                        = 2,
};

// Enum AT.TALK_TIMES_CONFIG
// NumValues: 0x0005
enum class ETALK_TIMES_CONFIG : uint8
{
	NONE                                     = 0,
	ONLY                                     = 1,
	LATER                                    = 2,
	LATER_RANDOM                             = 3,
	TALK_TIMES_MAX                           = 4,
};

// Enum AT.TALK_REACTION
// NumValues: 0x0003
enum class ETALK_REACTION : uint8
{
	NONE                                     = 0,
	STARE                                    = 1,
	TALK_MAX                                 = 2,
};

// Enum AT.EQuestTutorialType
// NumValues: 0x0004
enum class EQuestTutorialType : uint8
{
	None                                     = 0,
	UsedItem                                 = 1,
	PlacedPallet                             = 2,
	EQuestTutorialType_MAX                   = 3,
};

// Enum AT.EQuestTutorialPendingType
// NumValues: 0x0003
enum class EQuestTutorialPendingType : uint8
{
	Resolved                                 = 0,
	Pending                                  = 1,
	EQuestTutorialPendingType_MAX            = 2,
};

// Enum AT.EATTrailState
// NumValues: 0x0005
enum class EATTrailState : uint8
{
	None                                     = 0,
	Bgn                                      = 1,
	Loop                                     = 2,
	End                                      = 3,
	EATTrailState_MAX                        = 4,
};

// Enum AT.EATAuraState
// NumValues: 0x0006
enum class EATAuraState : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	StepBgn                                  = 2,
	StepLoop                                 = 3,
	StepEnd                                  = 4,
	EATAuraState_MAX                         = 5,
};

// Enum AT.EATWindRoadRarity
// NumValues: 0x0003
enum class EATWindRoadRarity : uint8
{
	Normal                                   = 0,
	Rare                                     = 1,
	EATWindRoadRarity_MAX                    = 2,
};

// Enum AT.EATWindRoadCamera
// NumValues: 0x0004
enum class EATWindRoadCamera : uint8
{
	Normal                                   = 0,
	Chase                                    = 1,
	Point                                    = 2,
	EATWindRoadCamera_MAX                    = 3,
};

// Enum AT.EATWindRoadEnter
// NumValues: 0x0004
enum class EATWindRoadEnter : uint8
{
	Start                                    = 0,
	Middle                                   = 1,
	End                                      = 2,
	EATWindRoadEnter_MAX                     = 3,
};

// Enum AT.EATWorldBlockingVolumeType
// NumValues: 0x000C
enum class EATWorldBlockingVolumeType : uint32
{
	Wall                                     = 0,
	WorldMap                                 = 1,
	Border                                   = 2,
	BlockingRayCast                          = 3,
	TownBlockingWall                         = 4,
	PlayerBlock                              = 5,
	Caution                                  = 6,
	PlayGoProgress                           = 7,
	BattleField                              = 8,
	IgnoreOnlyCamera                         = 9,
	AudienceShield                           = 10,
	Max                                      = 11,
};

// Enum AT.EATAreaMoveState
// NumValues: 0x0004
enum class EATAreaMoveState : uint8
{
	Close                                    = 0,
	Prohibit                                 = 1,
	Open                                     = 2,
	EATAreaMoveState_MAX                     = 3,
};

// Enum AT.EWorldStageId
// NumValues: 0x0023
enum class EWorldStageId : uint8
{
	STAGE_ID_NONE                            = 0,
	STAGE_ID_EastVillage                     = 1,
	STAGE_ID_EastWasteland                   = 2,
	STAGE_ID_KameHouse                       = 3,
	STAGE_ID_SolitaryIsland                  = 4,
	STAGE_ID_GokuHouse                       = 5,
	STAGE_ID_OrangeCity                      = 6,
	STAGE_ID_SatanCity                       = 7,
	STAGE_ID_YamchaHouse                     = 8,
	STAGE_ID_Swamp                           = 9,
	STAGE_ID_Wasteland                       = 10,
	STAGE_ID_ResortTown                      = 11,
	STAGE_ID_WorldTournament                 = 12,
	STAGE_ID_Desert                          = 13,
	STAGE_ID_NumVillage                      = 14,
	STAGE_ID_GingerTown                      = 15,
	STAGE_ID_WestCity                        = 16,
	STAGE_ID_HolyLandKorin                   = 17,
	STAGE_ID_KamiLookout                     = 18,
	STAGE_ID_Plain                           = 19,
	STAGE_ID_NorthFrozenSea                  = 20,
	STAGE_ID_PlanetNamek                     = 21,
	STAGE_ID_PlanetKai                       = 22,
	STAGE_ID_SupremeKai                      = 23,
	STAGE_ID_CAPSULE_CORPORATION             = 24,
	STAGE_ID_KARIN                           = 25,
	STAGE_ID_WestCity_Destruction            = 26,
	STAGE_ID_WestCity_Recovery               = 27,
	STAGE_ID_GingerTown_Destruction          = 28,
	STAGE_ID_GingerTown_Recovery             = 29,
	STAGE_ID_OrangeCity_Destruction          = 30,
	STAGE_ID_OrangeCity_Recovery             = 31,
	STAGE_ID_WorldTournament_Destruction     = 32,
	STAGE_ID_NUM                             = 33,
	STAGE_ID_MAX                             = 34,
};

// Enum AT.EPitcherMontageState
// NumValues: 0x0007
enum class EPitcherMontageState : uint8
{
	None                                     = 0,
	Wait                                     = 1,
	Throw                                    = 2,
	Hit_L                                    = 3,
	Hit_R                                    = 4,
	ChangeAuraDuringWait                     = 5,
	EPitcherMontageState_MAX                 = 6,
};

// Enum AT.EMobGender
// NumValues: 0x0005
enum class EMobGender : uint32
{
	None                                     = 0,
	Mob_Man                                  = 1,
	Mob_Woman                                = 2,
	Mob_Kid                                  = 3,
	Max                                      = 4,
};

// Enum AT.EBASEBALLGAME_STATE
// NumValues: 0x0010
enum class EBASEBALLGAME_STATE : uint8
{
	NONE                                     = 0,
	STATE_START_FADE                         = 1,
	STATE_BASEBALL_TALK                      = 2,
	STATE_BASEBALL_TUTORIAL                  = 3,
	STATE_BASEBALL_BEGIN                     = 4,
	STATE_BASEBALL_PLAYING                   = 5,
	STATE_BASEBALL_STRIKE                    = 6,
	STATE_BASEBALL_HOMERUN                   = 7,
	STATE_BASEBALL_PAUSE                     = 8,
	STATE_BASEBALL_END                       = 9,
	STATE_RESULT_OPEN                        = 10,
	STATE_RESULT_BASEBALL                    = 11,
	STATE_RESULT_RANKING                     = 12,
	STATE_RESULT_REWARD                      = 13,
	STATE_END_FADE                           = 14,
	MAX                                      = 15,
};

// Enum AT.EBaseballGameCutinType
// NumValues: 0x0005
enum class EBaseballGameCutinType : uint32
{
	None                                     = 0,
	Earth                                    = 1,
	Moon                                     = 2,
	Sun                                      = 3,
	Max                                      = 4,
};

// Enum AT.EBaseballGameHomerunType
// NumValues: 0x0005
enum class EBaseballGameHomerunType : uint8
{
	None                                     = 0,
	Center                                   = 1,
	Left                                     = 2,
	Right                                    = 3,
	Max                                      = 4,
};

// Enum AT.EBaseballGameHitTiming
// NumValues: 0x000B
enum class EBaseballGameHitTiming : uint8
{
	None                                     = 0,
	NormalFrontOuter                         = 1,
	NormalFrontInner                         = 2,
	HeavyFrontOuter                          = 3,
	HeavyFrontInner                          = 4,
	JustMeet                                 = 5,
	HeavyBackInner                           = 6,
	HeavyBackOuter                           = 7,
	NormalBackInner                          = 8,
	NormalBackOuter                          = 9,
	Max                                      = 10,
};

// Enum AT.EBaseballGameEvaluation
// NumValues: 0x0005
enum class EBaseballGameEvaluation : uint8
{
	None                                     = 0,
	Strike                                   = 1,
	Good                                     = 2,
	Great                                    = 3,
	Max                                      = 4,
};

// Enum AT.EBaseballGameDifficulty
// NumValues: 0x0006
enum class EBaseballGameDifficulty : uint8
{
	None                                     = 0,
	Easy                                     = 1,
	Normal                                   = 2,
	Hard                                     = 3,
	VeryHard                                 = 4,
	Max                                      = 5,
};

// Enum AT.EBbaseballGamePointType
// NumValues: 0x0007
enum class EBbaseballGamePointType : uint8
{
	None                                     = 0,
	Pitcher                                  = 1,
	Batter                                   = 2,
	Homebase                                 = 3,
	Mob                                      = 4,
	Result                                   = 5,
	Max                                      = 6,
};

// Enum AT.EBaseballGameEffectType
// NumValues: 0x0006
enum class EBaseballGameEffectType : uint8
{
	None                                     = 0,
	NormalSmall                              = 1,
	NormalLarge                              = 2,
	SpecialSmall                             = 3,
	SpecialLarge                             = 4,
	Max                                      = 5,
};

// Enum AT.EBaseballGameBallType
// NumValues: 0x0008
enum class EBaseballGameBallType : uint8
{
	None                                     = 0,
	Straight                                 = 1,
	Curve                                    = 2,
	Fork                                     = 3,
	Knuckle                                  = 4,
	Spiral                                   = 5,
	Wave                                     = 6,
	Max                                      = 7,
};

// Enum AT.EBATTLE_EVALUATION
// NumValues: 0x0005
enum class EBATTLE_EVALUATION : uint8
{
	NONE                                     = 0,
	RANK_S                                   = 1,
	RANK_A                                   = 2,
	RANK_B                                   = 3,
	EBATTLE_MAX                              = 4,
};

// Enum AT.E_BATTLE_GROUP
// NumValues: 0x0004
enum class E_BATTLE_GROUP : uint8
{
	PLAYER                                   = 0,
	ENEMY                                    = 1,
	THIRD                                    = 2,
	E_BATTLE_MAX                             = 3,
};

// Enum AT.E_BATTLE_BGM
// NumValues: 0x0008
enum class E_BATTLE_BGM : uint8
{
	NONE                                     = 0,
	NOMAL                                    = 1,
	VEGETA                                   = 2,
	RESULT                                   = 3,
	FREEZA                                   = 4,
	RECOOM                                   = 5,
	GULDO                                    = 6,
	E_BATTLE_MAX                             = 7,
};

// Enum AT.E_FIELD_BGM
// NumValues: 0x0006
enum class E_FIELD_BGM : uint8
{
	NONE                                     = 0,
	WASTELAMD                                = 1,
	WATER                                    = 2,
	SKY                                      = 3,
	FREEZA                                   = 4,
	E_FIELD_MAX                              = 5,
};

// Enum AT.EBattleState
// NumValues: 0x000B
enum class EBattleState : uint8
{
	None                                     = 0,
	Encount                                  = 1,
	InBattle                                 = 2,
	Demo                                     = 3,
	Escape                                   = 4,
	End                                      = 5,
	BossFormChange                           = 6,
	Boss                                     = 7,
	GameOver                                 = 8,
	Outrage                                  = 9,
	Max                                      = 10,
};

// Enum AT.EBGMCategory
// NumValues: 0x000D
enum class EBGMCategory : uint8
{
	None                                     = 0,
	Field                                    = 1,
	Quest                                    = 2,
	SubQuest                                 = 3,
	Town                                     = 4,
	Quest_HighPriority                       = 5,
	SubQuest_HighPriority                    = 6,
	Battle                                   = 7,
	CarBGM                                   = 8,
	MiniGame                                 = 9,
	Demo                                     = 10,
	UI                                       = 11,
	MAX                                      = 12,
};

// Enum AT.EBuffType
// NumValues: 0x0007
enum class EBuffType : uint8
{
	None                                     = 0,
	Break                                    = 1,
	DownMovable                              = 2,
	DownImmovable                            = 3,
	Up                                       = 4,
	Cooking                                  = 5,
	EBuffType_MAX                            = 6,
};

// Enum AT.ENpcFightingPowerType
// NumValues: 0x0005
enum class ENpcFightingPowerType : uint8
{
	Type_NPC                                 = 0,
	Type_NomalEnemy                          = 1,
	Type_BossEnemy                           = 2,
	Type_Support                             = 3,
	Type_MAX                                 = 4,
};

// Enum AT.ECollectionNaviType
// NumValues: 0x0004
enum class ECollectionNaviType : uint8
{
	None                                     = 0,
	Area                                     = 1,
	Page                                     = 2,
	ECollectionNaviType_MAX                  = 3,
};

// Enum AT.ECollectionText
// NumValues: 0x0007
enum class ECollectionText : uint8
{
	TITLE                                    = 0,
	TEXT1                                    = 1,
	TEXT2                                    = 2,
	TEXT3                                    = 3,
	APX1                                     = 4,
	CATEGORY                                 = 5,
	ECollectionText_MAX                      = 6,
};

// Enum AT.ECollectionOpenFlag
// NumValues: 0x000A
enum class ECollectionOpenFlag : uint8
{
	Navigation1                              = 0,
	Navigation2                              = 1,
	Navigation3                              = 2,
	Notice1                                  = 3,
	Notice2                                  = 4,
	Notice3                                  = 5,
	New1                                     = 6,
	New2                                     = 7,
	New3                                     = 8,
	Max                                      = 9,
};

// Enum AT.ECollectionMiniGame
// NumValues: 0x0008
enum class ECollectionMiniGame : uint8
{
	BASEBALL_BEGINER                         = 0,
	BASEBALL_MEDIUM                          = 1,
	BASEBALL_HIGHER                          = 2,
	BASEBALL_SPECIAL                         = 3,
	RACE_AIRCAR                              = 4,
	RACE_TWOFOOT                             = 5,
	FISHING                                  = 6,
	Max                                      = 7,
};

// Enum AT.AI_MOVE_RIDE
// NumValues: 0x0004
enum class EAI_MOVE_RIDE : uint8
{
	NONE                                     = 0,
	WAIT                                     = 1,
	END                                      = 2,
	AI_MOVE_MAX                              = 3,
};

// Enum AT.AI_MOVE_ACTION
// NumValues: 0x0009
enum class EAI_MOVE_ACTION : uint8
{
	NONE                                     = 0,
	WAIT                                     = 1,
	JUMP                                     = 2,
	FALL                                     = 3,
	JUMP_FLOAT                               = 4,
	FLOAT                                    = 5,
	STANDBOOST                               = 6,
	WARP                                     = 7,
	AI_MOVE_MAX                              = 8,
};

// Enum AT.MOVE_SEQ_LAND
// NumValues: 0x0007
enum class EMOVE_SEQ_LAND : uint8
{
	Wait                                     = 0,
	Move                                     = 1,
	Jump                                     = 2,
	Fall                                     = 3,
	FLOATMOVE                                = 4,
	WARP                                     = 5,
	MOVE_SEQ_LAND_MAX                        = 6,
};

// Enum AT.MOVE_SEQ
// NumValues: 0x000A
enum class EMOVE_SEQ : uint8
{
	ESEQ_WAIT                                = 0,
	ESEQ_MOVE                                = 1,
	ESEQ_AUTO                                = 2,
	ESEQ_PREBRAKE                            = 3,
	ESEQ_BRAKE                               = 4,
	ESEQ_STOP                                = 5,
	ESEQ_ONGROUND                            = 6,
	ESEQ_UPDOWN                              = 7,
	ESEQ_FALING                              = 8,
	ESEQ_MAX                                 = 9,
};

// Enum AT.EMealType
// NumValues: 0x0007
enum class EMealType : uint8
{
	None                                     = 0,
	SEIZE                                    = 1,
	STICK1                                   = 2,
	STICK2                                   = 3,
	STICK3                                   = 4,
	GRASP                                    = 5,
	EMealType_MAX                            = 6,
};

// Enum AT.EAttachmentType
// NumValues: 0x0006
enum class EAttachmentType : uint8
{
	None                                     = 0,
	STICK                                    = 1,
	RENGE                                    = 2,
	BONE                                     = 3,
	FORK                                     = 4,
	EAttachmentType_MAX                      = 5,
};

// Enum AT.EFoodList
// NumValues: 0x0018
enum class EFoodList : uint8
{
	None                                     = 0,
	DinosaurSpareRibs                        = 1,
	BeastOfSteak                             = 2,
	BrownedGrilledFish                       = 3,
	BrownedGrilledFish_B                     = 4,
	BigFishBoiled                            = 5,
	MeetInRiceBall                           = 6,
	FishInRiceBall                           = 7,
	MeetBowlofRice                           = 8,
	SeafoodBowlOfRice                        = 9,
	FriedRice                                = 10,
	SpicyMabotofu                            = 11,
	MeetBasedNoodles                         = 12,
	MeetBasedNoodles_B                       = 13,
	MeetPasta                                = 14,
	SeafoodPasta                             = 15,
	FishSoup                                 = 16,
	FishSoup_B                               = 17,
	GomaDango                                = 18,
	Cake                                     = 19,
	Cake_B                                   = 20,
	FruitJelly                               = 21,
	JuicyChineseBuns                         = 22,
	EFoodList_MAX                            = 23,
};

// Enum AT.EFoodType
// NumValues: 0x0007
enum class EFoodType : uint8
{
	None                                     = 0,
	MEET                                     = 1,
	FISH                                     = 2,
	RICE                                     = 3,
	NOODLE                                   = 4,
	DESSERT                                  = 5,
	EFoodType_MAX                            = 6,
};

// Enum AT.ECookingEffectValueType
// NumValues: 0x0003
enum class ECookingEffectValueType : uint8
{
	NUM                                      = 0,
	TEXT                                     = 1,
	MAX                                      = 2,
};

// Enum AT.EEFFECT_APPLY_TYPE
// NumValues: 0x0004
enum class EEFFECT_APPLY_TYPE : uint8
{
	NONE                                     = 0,
	PLUS                                     = 1,
	PCNT                                     = 2,
	MAX                                      = 3,
};

// Enum AT.EEFFECT_TYPE
// NumValues: 0x0018
enum class EEFFECT_TYPE : uint8
{
	NONE                                     = 0,
	ATK_UP                                   = 1,
	DEF_UP                                   = 2,
	SPEED_UP                                 = 3,
	BREAK_RESIST_UP                          = 4,
	SHORT_RANGE_ATK_UP                       = 5,
	LONG_RANGE_ATK_UP                        = 6,
	BOOST_ATK_UP                             = 7,
	CRITICAL_RATE_UP                         = 8,
	ALL_ATK_UP                               = 9,
	SHORT_RANGE_DEF_UP                       = 10,
	LONG_RANGE_DEF_UP                        = 11,
	BOOST_DEF_UP                             = 12,
	ALL_DEF_UP                               = 13,
	HP_UP                                    = 14,
	HP_RECOVERY_UP                           = 15,
	ENERGY_UP                                = 16,
	ENERGY_RECOVERY_UP                       = 17,
	ITME_DROP_RATE_UP                        = 18,
	ITME_DROP_COUNT_UP                       = 19,
	EXPERIENCE_UP                            = 20,
	ZORB_AVAILABILITY_UP                     = 21,
	ALL_BOUNUS_UP                            = 22,
	MAX                                      = 23,
};

// Enum AT.ECOOKING_CONDITION
// NumValues: 0x0004
enum class ECOOKING_CONDITION : uint8
{
	NONE                                     = 0,
	BY_RECIPE                                = 1,
	BY_COMU                                  = 2,
	MAX                                      = 3,
};

// Enum AT.ECOOKING_FORMAT
// NumValues: 0x0004
enum class ECOOKING_FORMAT : uint8
{
	NONE                                     = 0,
	ONE                                      = 1,
	COURCE                                   = 2,
	MAX                                      = 3,
};

// Enum AT.ECOOKING_GENRE
// NumValues: 0x0008
enum class ECOOKING_GENRE : uint8
{
	NONE                                     = 0,
	MEAT                                     = 1,
	FISH                                     = 2,
	RICE                                     = 3,
	NOODLE                                   = 4,
	DESSERT                                  = 5,
	BONFIRE                                  = 6,
	MAX                                      = 7,
};

// Enum AT.ECOOKING_ACCESSER
// NumValues: 0x0008
enum class ECOOKING_ACCESSER : uint8
{
	NONE                                     = 0,
	COOKING_MACHINE                          = 1,
	NPC_CHICHI                               = 2,
	NPC_BENTO_SHOP                           = 3,
	NPC_CHICHI_TUTORIAL                      = 4,
	BONFIRE                                  = 5,
	NPC_RESTAURANT                           = 6,
	MAX                                      = 7,
};

// Enum AT.ECrossTalkInequalitySign
// NumValues: 0x0005
enum class ECrossTalkInequalitySign : uint8
{
	None                                     = 0,
	LessThanOrEqualTo                        = 1,
	GreaterThanOrEqualTo                     = 2,
	Equal                                    = 3,
	ECrossTalkInequalitySign_MAX             = 4,
};

// Enum AT.ECrossTalkPlayerState
// NumValues: 0x0005
enum class ECrossTalkPlayerState : uint8
{
	None                                     = 0,
	Stand                                    = 1,
	Float                                    = 2,
	AirCar                                   = 3,
	ECrossTalkPlayerState_MAX                = 4,
};

// Enum AT.ECrossTalkBattleType
// NumValues: 0x0009
enum class ECrossTalkBattleType : uint8
{
	Always                                   = 0,
	NotBattle                                = 1,
	General                                  = 2,
	Event                                    = 3,
	Unknown                                  = 4,
	Enhance                                  = 5,
	NotGeneral                               = 6,
	NotEvent                                 = 7,
	ECrossTalkBattleType_MAX                 = 8,
};

// Enum AT.ECrossTalkCondition
// NumValues: 0x0065
enum class ECrossTalkCondition : uint8
{
	None                                     = 0,
	AlwaysTrue                               = 1,
	ElapseFree                               = 2,
	ElapseMove                               = 3,
	ElapseMoveAcc                            = 4,
	ElapseStay                               = 5,
	TouchVolume                              = 6,
	TouchLandmark                            = 7,
	TouchNoEntryVolume                       = 8,
	DiscoverEnemy                            = 9,
	DiscoverStrongEnemy                      = 10,
	StartBattleGeneral                       = 11,
	StartBattleEvent                         = 12,
	StartBattleUnknown                       = 13,
	StartBattleEnhance                       = 14,
	StartBattleContinuous                    = 15,
	ReduceHP                                 = 16,
	HitSkill                                 = 17,
	InvokeSkill                              = 18,
	LongBlowOff                              = 19,
	JustDodge                                = 20,
	EndBattleHP_GE                           = 21,
	EndBattleHP_LT                           = 22,
	Dead                                     = 23,
	LockOn                                   = 24,
	Critical                                 = 25,
	RaceCheckPoint1                          = 26,
	RaceCheckPoint2                          = 27,
	RaceCheckPoint3                          = 28,
	RaceStart                                = 29,
	RaceCrash1                               = 30,
	RaceCrash2                               = 31,
	RaceBoost                                = 32,
	RaceTimeUP                               = 33,
	RaceGoal                                 = 34,
	ReceiveRequestPlayer                     = 35,
	ReceiveRequestSupport                    = 36,
	ReceiveRequestEnemy                      = 37,
	HaraheriStart                            = 38,
	HaraheriContinuation                     = 39,
	GetItem                                  = 40,
	EndBattleGeneral                         = 41,
	EndBattleEvent                           = 42,
	EndBattleEnhance                         = 43,
	FishingPoint                             = 44,
	FishingCool                              = 45,
	FishingAmazing                           = 46,
	SubStoryCancel                           = 47,
	DestroyEnemiesBase                       = 48,
	FormChange                               = 49,
	DefeatEnemies                            = 50,
	DestroyedDrones                          = 51,
	ComingAndroid                            = 52,
	EnteredAndroidWarningArea                = 53,
	FinishedAssaultDirection                 = 54,
	FoundPlayerByDrones                      = 55,
	IncreasedSearchGauge                     = 56,
	GroupBattleBossDead                      = 57,
	SuccessiveGenerationsBossDead            = 58,
	AnnounserAttackHit                       = 59,
	AnnounserShotHit                         = 60,
	AnnounserGuard                           = 61,
	AnnounserGuardBreak                      = 62,
	AnnounserComboNum                        = 63,
	AnnounserFirstDamage                     = 64,
	AnnounserStalemate                       = 65,
	AnnounserDodge                           = 66,
	AnnounserBlowOff                         = 67,
	AnnounserPlaySkill                       = 68,
	AnnounserSkillHit                        = 69,
	AnnounserGuardTime                       = 70,
	AnnounserDodgeNum                        = 71,
	AnnounserReversal                        = 72,
	AnnounserGuardBreakNum                   = 73,
	AnnounserGuardAroundNum                  = 74,
	AnnounserBattleStart                     = 75,
	AnnounserBattleStartNoDamage             = 76,
	AnnounserWinMatch                        = 77,
	AnnounserRage                            = 78,
	AnnounserHeatUp                          = 79,
	AnnounserDown                            = 80,
	AnnounserDownCount                       = 81,
	AnnounserJostleStart                     = 82,
	AnnounserJostleWin                       = 83,
	AnnounserJostleLoss                      = 84,
	AnnounserRingoutRecovery                 = 85,
	AnnounserRingout                         = 86,
	AnnounserUseSpecificSkill                = 87,
	AnnounserTenCountGameOver                = 88,
	AnnounserReceiveRequest                  = 89,
	FlashBackStart                           = 90,
	FlashBackEnd                             = 91,
	GeneralBattleRage                        = 92,
	ReceiveAiRequest                         = 93,
	ReceiveRequestAiExternal                 = 94,
	SlanderQTE_Failed                        = 95,
	EachOtherReduceHP                        = 96,
	AnnounserDownRecovery                    = 97,
	Cpl003Skill007Finish                     = 98,
	Cpl003FormOff                            = 99,
	ECrossTalkCondition_MAX                  = 100,
};

// Enum AT.ECrossTalkPriority
// NumValues: 0x000F
enum class ECrossTalkPriority : uint8
{
	Level1                                   = 0,
	Level2                                   = 1,
	Level3                                   = 2,
	Level4                                   = 3,
	Level5                                   = 4,
	Level2_DLC6                              = 5,
	Level3_DLC6                              = 6,
	Level4_DLC6                              = 7,
	Level5_DLC6                              = 8,
	Announser                                = 9,
	Staging                                  = 10,
	NUM                                      = 11,
	Normal                                   = 4,
	Scenario                                 = 0,
	ECrossTalkPriority_MAX                   = 12,
};

// Enum AT.ECrossTalkSideCategory
// NumValues: 0x0004
enum class ECrossTalkSideCategory : uint8
{
	None                                     = 0,
	AllySide                                 = 1,
	EnemySide                                = 2,
	ECrossTalkSideCategory_MAX               = 3,
};

// Enum AT.E_HEALTH_ID
// NumValues: 0x0004
enum class E_HEALTH_ID : uint8
{
	NONE                                     = 0,
	WINCE                                    = 1,
	BIND_C067                                = 2,
	MAX                                      = 3,
};

// Enum AT.ETYPE_OF_TOGGLE
// NumValues: 0x0007
enum class ETYPE_OF_TOGGLE : uint8
{
	TYPE_ToggleTick                          = 0,
	TYPE_ToggleRender                        = 1,
	TYPE_TogglePhysics                       = 2,
	TYPE_ToggleCollision                     = 3,
	TYPE_ToggleAnimation                     = 4,
	TYPE_ToggleDamaged                       = 5,
	TYPE_MAX                                 = 6,
};

// Enum AT.ETYPE_OF_DEBUGACTOR
// NumValues: 0x0026
enum class ETYPE_OF_DEBUGACTOR : uint8
{
	TYPE_None                                = 0,
	TYPE_System_UE4                          = 1,
	TYPE_System_AT                           = 2,
	TYPE_Sound                               = 3,
	TYPE_Character_Player                    = 4,
	TYPE_Character_Friends                   = 5,
	TYPE_Character_Enemies                   = 6,
	TYPE_Character_Enemy_Boss                = 7,
	TYPE_BackGround_LandScape                = 8,
	TYPE_BackGround_Road                     = 9,
	TYPE_BackGround_House                    = 10,
	TYPE_BackGround_Building                 = 11,
	TYPE_BackGround_Sea                      = 12,
	TYPE_BackGround_Cloud                    = 13,
	TYPE_Object_NPC                          = 14,
	TYPE_Object_Mob                          = 15,
	TYPE_Object_Car                          = 16,
	TYPE_Object_Plane                        = 17,
	TYPE_Object_Animal                       = 18,
	TYPE_Object_ZOrb                         = 19,
	TYPE_Object_MiningPoint                  = 20,
	TYPE_Procedural_Plant                    = 21,
	TYPE_Procedural_Tree                     = 22,
	TYPE_Procedural_Rock                     = 23,
	TYPE_DestructiveObject_Before            = 24,
	TYPE_DestructiveObject_After             = 25,
	TYPE_Effect_Aura                         = 26,
	TYPE_Effect_Kidan                        = 27,
	TYPE_Effect_Kamehameha                   = 28,
	TYPE_Effect_Debris                       = 29,
	TYPE_Effect_Smoke                        = 30,
	TYPE_Display_Quest                       = 31,
	TYPE_Display_Message                     = 32,
	TYPE_Display_Balloon                     = 33,
	TYPE_Display_Icon                        = 34,
	TYPE_UI                                  = 35,
	TYPE_PostEffect                          = 36,
	TYPE_MAX                                 = 37,
};

// Enum AT.E_DISPUSEDMEMORY_TARGET
// NumValues: 0x0012
enum class E_DISPUSEDMEMORY_TARGET : uint8
{
	EDUM_TARGET_NONE                         = 0,
	EDUM_TARGET_PLAYER                       = 1,
	EDUM_TARGET_ENEMY                        = 2,
	EDUM_TARGET_BOSS                         = 3,
	EDUM_TARGET_NPC                          = 4,
	EDUM_TARGET_ANIMALS                      = 5,
	EDUM_TARGET_PROCEDURAL_TREE              = 6,
	EDUM_TARGET_PROCEDURAL_PLANT             = 7,
	EDUM_TARGET_PROCEDURAL_ROCK              = 8,
	EDUM_TARGET_DISTOBJECT_BEFORE            = 9,
	EDUM_TARGET_BUILDING                     = 10,
	EDUM_TARGET_LANDSCAPE                    = 11,
	EDUM_TARGET_BG                           = 12,
	EDUM_TARGET_EFFECT                       = 13,
	EDUM_TARGET_UI                           = 14,
	EDUM_TARGET_POSTEFFECT                   = 15,
	EDUM_TARGET_NUM                          = 16,
	EDUM_TARGET_MAX                          = 17,
};

// Enum AT.EDebugType
// NumValues: 0x0008
enum class EDebugType : uint8
{
	TYPE_NONE                                = 0,
	TYPE_ROOT                                = 1,
	TYPE_INT                                 = 2,
	TYPE_FLOAT                               = 3,
	TYPE_BOOL                                = 4,
	TYPE_STRING                              = 5,
	TYPE_EXECUTE                             = 6,
	TYPE_MAX                                 = 7,
};

// Enum AT.ELanguage
// NumValues: 0x0003
enum class ELanguage : uint32
{
	LANG_JP                                  = 0,
	LANG_EN                                  = 1,
	LANG_MAX                                 = 2,
};

// Enum AT.EDebugID
// NumValues: 0x03FB
enum class EDebugID : uint16
{
	ID_QUICK_OFTEN_USE                       = 0,
	ID_QUICK_COOKING_BENTO                   = 1,
	ID_QUICK_PL_MP_INFINITY                  = 2,
	ID_QUICK_PL_MP_INFINITY_PLAYER           = 3,
	ID_QUICK_PL_PLAYABLECHARA                = 4,
	ID_QUICK_PL_CHANGE_CONTROL               = 5,
	ID_QUICK_PL_ONE_HIT_DEATH                = 6,
	ID_QUICK_DAMAGE_LOG                      = 7,
	ID_QUICK_PL_DAMAGE_PLAYER_HEALTH_RATE    = 8,
	ID_QUICK_PL_DAMAGE_PLAYER_BREAK_RATE     = 9,
	ID_QUICK_PL_DAMAGE_FRIEND_HEALTH_RATE    = 10,
	ID_QUICK_PL_DAMAGE_FRIEND_BREAK_RATE     = 11,
	ID_QUICK_PL_DAMAGE_ENEMY_HEALTH_RATE     = 12,
	ID_QUICK_PL_DAMAGE_ENEMY_BREAK_RATE      = 13,
	ID_QUICK_AI_ACTIVE                       = 14,
	ID_QUICK_AI_SPAWN                        = 15,
	ID_QUICK_AI_NODEAD                       = 16,
	ID_QUICK_AI_ONE_HIT_DEATH                = 17,
	ID_QUICK_AI_SPAWN_FRIEND                 = 18,
	ID_QUICK_AI_FRIEND_DELETE                = 19,
	ID_QUICK_AI_FRIEND_NODEAD                = 20,
	ID_QUICK_SUPERLONGBLOWOFF_PURSUE         = 21,
	ID_QUICK_SUPERLONGBLOWOFF_DAMAGE         = 22,
	ID_QUICK_ADD_MONEY                       = 23,
	ID_QUICK_ADD_ORB                         = 24,
	ID_QUICK_ADD_MEDAL                       = 25,
	ID_QUICK_AUTO_SAVE_OFF                   = 26,
	ID_QUICK_QUESTDEMO_SUBSCRIBE_AUTOMATICALLY = 27,
	ID_QUICK_QUESTDEMO_SUBSCRIBE_AUTOMATICALLY_DELAY = 28,
	ID_QUICK_DEMO_DIRECTION_SKIP             = 29,
	ID_QUICK_UI_INVISIBLE                    = 30,
	ID_SYSTEM                                = 31,
	ID_SAVE_PRM                              = 32,
	ID_DEFAULTPRM                            = 33,
	ID_BACKTITLE                             = 34,
	ID_RESTARTLEVEL                          = 35,
	ID_RESTARTPLAYER                         = 36,
	ID_DRAW_PRINT                            = 37,
	ID_DRAW_DECAL                            = 38,
	ID_STAT_LOADING_STATUS                   = 39,
	ID_CHANGE_ELAPSED_SPEED_OF_GAME_PLAY_TIME = 40,
	ID_TOGGLE_SHOWDEBUG                      = 41,
	ID_TOGGLE_AUTODEBUG                      = 42,
	ID_DRAW_TICK_INFO                        = 43,
	ID_USE_TICK_CONTROL                      = 44,
	ID_DRAW_SOUND_INFO                       = 45,
	ID_OUTPUTLOG_SOUND_SE                    = 46,
	ID_PLAYER1                               = 47,
	ID_DEBUGPLAYER                           = 48,
	ID_DRAWANIMATION                         = 49,
	ID_DRAWANIMATION_MEMBER                  = 50,
	ID_PL_DRAW_ACTION                        = 51,
	ID_PL_DRAW_ACTION_TARGET                 = 52,
	ID_PL_DRAW_SKILL                         = 53,
	ID_PL_DRAW_BOOST                         = 54,
	ID_PL_DRAW_BUFF                          = 55,
	ID_PL_DRAW_BUFF_TARGET                   = 56,
	ID_PL_DRAW_BUFF_SUPPORT                  = 57,
	ID_PL_DRAW_PARAMETER                     = 58,
	ID_PL_DRAW_INPUT                         = 59,
	ID_RESTRICT_MOVE                         = 60,
	ID_PL_DRAW_SPAWNDATA                     = 61,
	ID_PL_TRANSFORM_OFF                      = 62,
	ID_PL_MP_INFINITY_PLAYER                 = 63,
	ID_PL_MP_REGENERATE_OFF                  = 64,
	ID_PL_BREAK_REGENERATE_OFF               = 65,
	ID_PL_BREAKTIME_INFINITY                 = 66,
	ID_PL_LEADER_LEVEL                       = 67,
	ID_PL_SUPPORTLEFT_LEVEL                  = 68,
	ID_PL_SUPPORTRIGHT_LEVEL                 = 69,
	ID_PL_PLAYABLECHARA                      = 70,
	ID_PL_BATTLE_MOVE_MODE                   = 71,
	ID_PL_SKILLASSIST_LEFT                   = 72,
	ID_PL_SKILLASSIST_RIGHT                  = 73,
	ID_PL_SKILLASSIST_COOLTIME_OFF           = 74,
	ID_PL_SHOW_CHARACTER_EXP                 = 75,
	ID_PLAYER2                               = 76,
	ID_PL_SET_HEALTH_TARGET                  = 77,
	ID_PL_SET_HEALTH                         = 78,
	ID_PL_ONE_HIT_DEATH                      = 79,
	ID_PL_ENABLE_PASSIVESKILL                = 80,
	ID_PL_SKILLTREE_DRAW                     = 81,
	ID_PL_SKILLTREE_DRAW_FILTER              = 82,
	ID_PL_SET_SKILL_LEVEL_1                  = 83,
	ID_PL_SET_SKILL_LEVEL_2                  = 84,
	ID_PL_SET_SKILL_LEVEL_3                  = 85,
	ID_PL_DISABLE_LOOKAT                     = 86,
	ID_PL_DISABLE_FOOTIK                     = 87,
	ID_ZOVERTHROW_ACTION_GAUGE_MAX           = 88,
	ID_ZOVERTHROW_ACTION_SET_GAUGE_0         = 89,
	ID_ZOVERTHROW_ACTION_SET_GAUGE_100       = 90,
	ID_ZOVERTHROW_ACTION_SET_GAUGE_LEVELFIXED = 91,
	ID_PL_BREAK_STATECHANGE                  = 92,
	ID_PL_BREAK_ADD_TIME                     = 93,
	ID_DAMAGE                                = 94,
	ID_DAMAGE_LOG                            = 95,
	ID_DAMAGE_DRAW_COLLISION                 = 96,
	ID_PL_DAMAGE_PLAYER_HEALTH_RATE          = 97,
	ID_PL_DAMAGE_PLAYER_BREAK_RATE           = 98,
	ID_PL_DAMAGE_FRIEND_HEALTH_RATE          = 99,
	ID_PL_DAMAGE_FRIEND_BREAK_RATE           = 100,
	ID_PL_DAMAGE_ENEMY_HEALTH_RATE           = 101,
	ID_PL_DAMAGE_ENEMY_BREAK_RATE            = 102,
	ID_PL_DAMAGE_CITICAL_OFF                 = 103,
	ID_HUD                                   = 104,
	ID_HUD_MAP                               = 105,
	ID_HUD_VISIBLE_FLY_CTRL                  = 106,
	ID_HUD_VISIBLE_BOSS_HUD                  = 107,
	ID_HUD_CHANGE_3DI                        = 108,
	ID_HUD_BOSSRESULT                        = 109,
	ID_DESTRUCTION                           = 110,
	ID_DESTRUCTION_DEBUGDRAW                 = 111,
	ID_DESTRUCTION_BLOWOFF_EFFECT_ON_GROUND  = 112,
	ID_DESTRUCTION_BLOWOFF_DECAL_HIT_NEW     = 113,
	ID_DESTRUCTION_FIX_DEBRIS_PROCESSING     = 114,
	ID_TERRAIN_DECORATE                      = 115,
	ID_TERRAIN_DECORATE_DEBUGDRAW            = 116,
	ID_TERRAIN_DECORATE_SETENV               = 117,
	ID_TERRAIN_DECORATE_ENEMY_AI_ACTIVE      = 118,
	ID_TERRAIN_DECORATE_DUMMY3               = 119,
	ID_TERRAIN_DECORATE_DECAL_TYPE           = 120,
	ID_TERRAIN_DECORATE_EFECT_MPOOL_TYPE     = 121,
	ID_TERRAIN_DECORATE_DECAL_MPOOL_TYPE     = 122,
	ID_TERRAIN_DECORATE_EFECT_TEST           = 123,
	ID_TERRAIN_DECORATE_DECAL_TEST           = 124,
	ID_TERRAIN_DECORATE_DECAL_DESTROY_ALL    = 125,
	ID_TERRAIN_DECORATE_HIT_PHOTON_TYPE      = 126,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_GENERATE = 127,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_DRAWHIT = 128,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_TRACE_CHANNEL = 129,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_RADIUS = 130,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_FLAG0 = 131,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_FLAG1 = 132,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_VALUE0 = 133,
	ID_TERRAIN_DECORATE_HIT_PRIM_SPHERE_VALUE1 = 134,
	ID_TERRAIN_DECORATE_DECAL_FLAG3          = 135,
	ID_TERRAIN_DECORATE_DECAL_FLAG4          = 136,
	ID_TERRAIN_DECORATE_DECAL_FLAG5          = 137,
	ID_TERRAIN_DECORATE_DECAL_VALUE0         = 138,
	ID_TERRAIN_DECORATE_DECAL_VALUE1         = 139,
	ID_TERRAIN_DECORATE_DECAL_VALUE2         = 140,
	ID_CAMERA                                = 141,
	ID_CAMERA_FREECAMERA                     = 142,
	ID_CAMERA_FREECAMERA_SPEED               = 143,
	ID_CAMERA_DEBUGDRAW                      = 144,
	ID_CAMERA_SHAKE                          = 145,
	ID_CAMERA_FPS                            = 146,
	ID_VALID_GROUND_CAMERA                   = 147,
	ID_GROUND_BOSS_BATTLE_ADJUST_DEPTH_VALUE = 148,
	ID_GROUND_BOSS_BATTLE_ADJUST_PITCH_VALUE = 149,
	ID_GROUND_BOSS_BATTLE_ORDINATE_VALUE     = 150,
	ID_GROUND_BOSS_BATTLE_FIXED_DISTANCE_VALUE = 151,
	ID_GROUND_CAMERA_ZIGZAG_DISABLE          = 152,
	ID_AI                                    = 153,
	ID_AI_ONLY_ACTION                        = 154,
	ID_AI_ACTIVE                             = 155,
	ID_AI_ACTIVE_FRIEND                      = 156,
	ID_AI_SPAWN                              = 157,
	ID_AI_SPAWN_LEVEL                        = 158,
	ID_AI_SPAWNDIST                          = 159,
	ID_AI_ENCOUNT_TYPE                       = 160,
	ID_AI_ENCOUNT_AREA                       = 161,
	ID_AI_ENCOUNT_ROT                        = 162,
	ID_AI_ENCOUNT_SEARCH                     = 163,
	ID_AI_EVENT_BATTLE                       = 164,
	ID_AI_SPAWN_SUPPORTCHARA01               = 165,
	ID_AI_SPAWN_SUPPORTCHARA02               = 166,
	ID_AI_SPAWN_ENCOUNT_PARTY                = 167,
	ID_AI_DEBUGDRAW                          = 168,
	ID_AI_NODEAD                             = 169,
	ID_AI_ONE_HIT_DEATH                      = 170,
	ID_AI_SPAWN_FRIEND                       = 171,
	ID_AI_FRIEND_DELETE                      = 172,
	ID_AI_FRIEND_NODEAD                      = 173,
	ID_AI_MP_0                               = 174,
	ID_AI_HATE_OFF                           = 175,
	ID_AI_CAMERA_AREA                        = 176,
	ID_AI_SUPPORT                            = 177,
	ID_AI_NEW_FOLLOWUP_ROUTINE               = 178,
	ID_AI_DEBUG_DRAW                         = 179,
	ID_AI_FIXED_FOLLOWING_POINT              = 180,
	ID_AI_SPEED_OFFSET                       = 181,
	ID_AI_PERSONAL_SPACE_RADIUS              = 182,
	ID_AI_PERSONAL_SPACE_POWER               = 183,
	ID_BTL_AI                                = 184,
	ID_BTL_AI_STOP                           = 185,
	ID_BTL_AI_STOP_ENEMY                     = 186,
	ID_BTL_AI_STOP_SUPPORT                   = 187,
	ID_BTL_AI_DEBUG_DRAW                     = 188,
	ID_BTL_AI_EXECUTE_BEHAVIOR               = 189,
	ID_BTL_AI_EXECUTE_BEHAVIOR_PARAM         = 190,
	ID_BTL_AI_EXECUTE_BEHAVIOR_WAIT          = 191,
	ID_BTL_AI_FIXED_SITUATION                = 192,
	ID_BTL_AI_RESET                          = 193,
	ID_BTL_AI_DRAW_HATE                      = 194,
	ID_BTL_AI_DRAW_LOAD                      = 195,
	ID_BTL_AI_DRAW_BEHAVIOR                  = 196,
	ID_BTL_AI_LOG_FORCE_STOP_AI              = 197,
	ID_BATTLE                                = 198,
	ID_BATTLE_DEBUGDRAW                      = 199,
	ID_BATTLE_DRAW_CAMERA_DISTANCE           = 200,
	ID_BATTLE_NO_ENCOUNTER                   = 201,
	ID_BATTLE_ATTACK_ALL_HIT                 = 202,
	ID_BATTLE_FINISH_LOCKOFF_DELAY           = 203,
	ID_BATTLE_ENCOUNTER_DEMO                 = 204,
	ID_BATTLE_RUSH_ATKPUSH_ENABLE            = 205,
	ID_BATTLE_RUSH_CAMERAROLL_ENABLE         = 206,
	ID_BATTLE_NEW_DEFAULT_ENCOUNT_FLAG       = 207,
	ID_BATTLE_ENCOUNTER_DEMO_BACKATK_ANNOUNCE_STARTTIME = 208,
	ID_BATTLE_NEW_MOVE                       = 209,
	ID_BATTLE_OUTRAGE_FORCE                  = 210,
	ID_BATTLE_OUTRAGE_HITSTOP_DURATION       = 211,
	ID_BATTLE_OUTRAGE_HITSTOP_POWER          = 212,
	ID_BATTLE_REINFORCE_OFF                  = 213,
	ID_BATTLE_DRAW_ATROCIOUS_INFO            = 214,
	ID_BATTLE_DRAW_ATROCIOUS_ALLPHASE        = 215,
	ID_BATTLE_COMPLETE_ATROCIOUS_CURRENTPHASE = 216,
	ID_BATTLE_NEXT_ATROCIOUS_CURRENTPHASE    = 217,
	ID_BATTLE_SPECIAL_PROGRESS               = 218,
	ID_BATTLE_FINISH_GROUPBATTLE             = 219,
	ID_BATTLE_DRAW_LOCKON_ENEMY_STATUS       = 220,
	ID_BATTLE_LOAD_CHARA_LIST                = 221,
	ID_BATTLE_ENCOUNT_ENEMY_POOL             = 222,
	ID_BATTLE_ENCOUNT_ENEMY_POOL_DRAW        = 223,
	ID_BATTLE_ENCOUNT_ENEMY_POOL_LOG         = 224,
	ID_FUSION_CHARACTRT_RELEASE_TIME         = 225,
	ID_BATTLE_DEBUGDRAW_BATTLEMANUALSAFETYPOINT = 226,
	ID_BATTLE_DEBUGDRAW_BATTLEMANUALSAFETYPOINT_DRAW = 227,
	ID_BATTLE_DEBUGDRAW_BATTLEMANUALSAFETYPOINT_DRAW_DESTINATION = 228,
	ID_EVENT_BATTLE                          = 229,
	ID_EVENT_BATTLE_START                    = 230,
	ID_EVENT_BATTLE_REPLACE                  = 231,
	ID_EVENT_BATTLE_LEVEL_SYNC               = 232,
	ID_EVENT_BATTLE_LEVEL_SYNC_VALUE         = 233,
	ID_EVENT_BATTLE_ADD_BIT                  = 234,
	ID_EVENT_BATTLE_DRAW                     = 235,
	ID_EVENT_BATTLE_DEMO_STOPOFF             = 236,
	ID_EVENT_BATTLE_SET_TIME                 = 237,
	ID_EVENT_BATTLE_SET_TIME_REMAINING       = 238,
	ID_EVENT_BATTLE_GROUPBATTLE_DRAW         = 239,
	ID_EVENT_BATTLE_GROUPBATTLE_TEST_ENEMY   = 240,
	ID_EVENT_BATTLE_GROUPBATTLE_SPAWNED      = 241,
	ID_EVENT_BATTLE_GROUPBATTLE_RANK         = 242,
	ID_EVENT_BATTLE_FINISH_BLOW_SKIP         = 243,
	ID_EVENT_BATTLE_VISION_SKIP              = 244,
	ID_EVENT_BATTLE_E0500030B_DRAW           = 245,
	ID_EVENT_BATTLE_ENTRY_RINGOUT_CHARACTER  = 246,
	ID_EVENT_BATTLE_CLEAR_RINGOUT_CHARACTER  = 247,
	ID_EVENT_BATTLE_DLC6_FLASHBACK_SKIP      = 248,
	ID_EVENT_BATTLE_DLC6_FACEACTION_DIRECTION_SKIP = 249,
	ID_EVENT_BATTLE_DLC6_FORMCHANGE_FORCEEND_SKIP = 250,
	ID_EVENT_BATTLE_DLC6_FLASHBACK01_LIFELIMITSET = 251,
	ID_EVENT_BATTLE_DLC6_FLASHBACK02_LIFELIMITSET = 252,
	ID_EVENT_BATTLE_DLC6_FACEACTION_DIRECTION_LIFELIMITSET = 253,
	ID_EVENT_BATTLE_DLC6_LIMIT_RESET         = 254,
	ID_SUPPORT_ACTION                        = 255,
	ID_SUPPORT_ACTION_DRAW                   = 256,
	ID_SUPPORT_ACTION_GAUGE_MAX              = 257,
	ID_SUPPORT_ACTION_RECAST_OFF             = 258,
	ID_SUPPORT_ACTION_PURSUE_SKILL           = 259,
	ID_SUPPORT_ACTION_COMBOCUT_SKILL         = 260,
	ID_SUPPORT_ACTION_SET_GAUGE_0            = 261,
	ID_SUPPORT_ACTION_SET_GAUGE_50           = 262,
	ID_SUPPORT_ACTION_SET_GAUGE_100          = 263,
	ID_ANDROID_ASSAULT                       = 264,
	ID_ANDROID_ASSAULT_DRAW                  = 265,
	ID_ANDROID_ASSAULT_DRAW_DRONE            = 266,
	ID_ANDROID_ASSAULT_ALERT_OFF             = 267,
	ID_ANDROID_ASSAULT_SEARCH_OFF            = 268,
	ID_ANDROID_ASSAULT_CHASE_OFF             = 269,
	ID_ANDROID_ASSAULT_BATTLE_COND           = 270,
	ID_ANDROID_ASSAULT_ACTIVATE_ALL_HEALTH_GAUGES = 271,
	ID_HUD_DEBUG                             = 272,
	ID_HUD_DEBUG_BATTLEPOWER                 = 273,
	ID_HUD_DEBUG_CRITICAL                    = 274,
	ID_EFFECT_DEBUG                          = 275,
	ID_EFFECT_DEBUG_ALWAYS_CHAIN             = 276,
	ID_NPC                                   = 277,
	ID_NPC_DEBUG_WINDOW                      = 278,
	ID_NPC_GENERAL_INFO_DRAW                 = 279,
	ID_NPC_MOVMENT_INFO_DRAW                 = 280,
	ID_NPC_MOB_VISIBILITY                    = 281,
	ID_NPC_ANIMAL_INIT                       = 282,
	ID_NPC_ANIMAL_DRAW_SE_RANGE              = 283,
	ID_NPC_POINT_DRAW                        = 284,
	ID_NPC_STOP_TALK_COMPONENT               = 285,
	ID_NPC_INVALID_OBJECT                    = 286,
	ID_NPC_GREETING_INFO                     = 287,
	ID_NPC_ALL_CAR_VISIBILITY                = 288,
	ID_NPC_DISPLAY_CAR_SUMMARY               = 289,
	ID_NPC_DISPLAY_CAR_SPLINE                = 290,
	ID_NPC_DISPLAY_TRAFFIC_LIGHT             = 291,
	ID_NPC_DISPLAY_LOGIC_CAR                 = 292,
	ID_NPC_DISPLAY_CAR_OPTIMIZE_INFO         = 293,
	ID_NPC_DISPLAY_CAR_SHOT_INFO             = 294,
	ID_NPC_DISPLAY_CAR_SOUND_INFO            = 295,
	ID_MENU                                  = 296,
	ID_MENU_DEBUGDRAW                        = 297,
	ID_MENU_COLLECT_ALL_DB                   = 298,
	ID_MENU_OPEN_MENU_TYPE                   = 299,
	ID_MENU_FORCE_PROCEED_EVENT              = 300,
	ID_MENU_CAN_START_THE_TRAINING_BATTLE_UNCONDITIONALLY = 301,
	ID_MENU_FORCE_JAPAN_CREDIT               = 302,
	ID_MENU_UNLOCK_SUPER_LEVEL_UP_TRAINING   = 303,
	ID_MENU_UNLOCK_GROUP_BATTLE_TRAINING     = 304,
	ID_MENU_UNLOCK_AREA_CHANGE_BATTLE_TRAINING = 305,
	ID_ITEM                                  = 306,
	ID_ADD_ITEM_IMPRTANT                     = 307,
	ID_ADD_ITEM_CONSUMPTION                  = 308,
	ID_ADD_ITEM_DRONEPARTS                   = 309,
	ID_ITEM_DEVELOPPER_TOOL                  = 310,
	ID_COOKING                               = 311,
	ID_COOKING_ADD_ALL_RECIPE                = 312,
	ID_COOKING_ADD_ALL_FOOD                  = 313,
	ID_COOKING_ADD_ALL_BENTO                 = 314,
	ID_COOKING_FORCE_RARITY                  = 315,
	ID_COOKING_FORCE_COMP                    = 316,
	ID_COOKING_FORCE_SUPER_COMP              = 317,
	ID_COOKING_CAPTURE_MODE                  = 318,
	ID_LONGBLOWOFF                           = 319,
	ID_LONGBLOWOFF_CHECK_MODE                = 320,
	ID_LONGBLOWOFF_DISABLE_DIRECTION         = 321,
	ID_LONGBLOWOFF_TYPE                      = 322,
	ID_LONGBLOWOFF_DRAW_HITCHECK             = 323,
	ID_LONGBLOWOFF_DRAW_HITCHECK_TIME        = 324,
	ID_LONGBLOWOFF_PRINT_LOG                 = 325,
	ID_LONGBLOWOFF_WARP                      = 326,
	ID_WORLDMAP                              = 327,
	ID_WORLDMAP_OPEN_LEVEL                   = 328,
	ID_WORLDMAP_ALL_OPEN                     = 329,
	ID_DEBUG_DISP_MEM_USED                   = 330,
	ID_DEBUG_DISP_MEM_USED_SHOWTARGET        = 331,
	ID_DEBUG_PRINT                           = 332,
	ID_DEBUG_PRINT_CATEGORY                  = 333,
	ID_DEBUG_PRINT_MOBILITY                  = 334,
	ID_DEBUG_FORCE_BATTLE                    = 335,
	ID_DEBUG_SKIP_HITCH                      = 336,
	ID_DEBUG_FORCE_NPC                       = 337,
	ID_DEBUG_FORCE_ACTSEARCH                 = 338,
	ID_DEBUG_FORCE_LIGHTTOWER                = 339,
	ID_DEBUG_FORCE_TREASURE                  = 340,
	ID_DEBUG_FORCE_ANIMALCAPTURE             = 341,
	ID_DEBUG_FORCE_MININGPOINT               = 342,
	ID_DEBUG_FORCE_MISSIONSTORE              = 343,
	ID_DEBUG_FORCE_WINDROAD                  = 344,
	ID_DEBUG_FORCE_FEVER                     = 345,
	ID_DEBUG_FORCE_PLACEMENT                 = 346,
	ID_DEBUG_FORCE_PARTY                     = 347,
	ID_DEBUG_FORCE_QUEST                     = 348,
	ID_DEBUG_FORCE_BATTLERESCUE              = 349,
	ID_DEBUG_FORCE_BLOCKINGVOLUME            = 350,
	ID_DEBUG_FORCE_CPL058SKILLBARRIER        = 351,
	ID_DEBUG_FORCE_CPL058SKILLFLOAT          = 352,
	ID_DEBUG_FORCE_GAMEMODE                  = 353,
	ID_DEBUG_TICK                            = 354,
	ID_DEBUG_TICK_SYSTEM_UE4                 = 355,
	ID_DEBUG_TICK_SYSTEM_AT                  = 356,
	ID_DEBUG_TICK_SOUND                      = 357,
	ID_DEBUG_TICK_CHARACTER_PLAYER           = 358,
	ID_DEBUG_TICK_CHARACTER_FRIENDS          = 359,
	ID_DEBUG_TICK_CHARACTER_ENEMIES          = 360,
	ID_DEBUG_TICK_CHARACTER_ENEMY_BOSS       = 361,
	ID_DEBUG_TICK_BACKGROUND_LANDSCAPE       = 362,
	ID_DEBUG_TICK_BACKGROUND_ROAD            = 363,
	ID_DEBUG_TICK_BACKGROUND_HOUSE           = 364,
	ID_DEBUG_TICK_BACKGROUND_BUILDING        = 365,
	ID_DEBUG_TICK_BACKGROUND_SEA             = 366,
	ID_DEBUG_TICK_BACKGROUND_CLOUD           = 367,
	ID_DEBUG_TICK_OBJECT_NPC                 = 368,
	ID_DEBUG_TICK_OBJECT_MOB                 = 369,
	ID_DEBUG_TICK_OBJECT_CAR                 = 370,
	ID_DEBUG_TICK_OBJECT_PLANE               = 371,
	ID_DEBUG_TICK_OBJECT_ANIMAL              = 372,
	ID_DEBUG_TICK_OBJECT_ZORB                = 373,
	ID_DEBUG_TICK_OBJECT_MININGPOINT         = 374,
	ID_DEBUG_TICK_PROCEDURAL_PLANT           = 375,
	ID_DEBUG_TICK_PROCEDURAL_TREE            = 376,
	ID_DEBUG_TICK_PROCEDURAL_ROCK            = 377,
	ID_DEBUG_TICK_DESTRUCTIVEOBJECT_BEFORE   = 378,
	ID_DEBUG_TICK_DESTRUCTIVEOBJECT_AFTER    = 379,
	ID_DEBUG_TICK_EFFECT_AURA                = 380,
	ID_DEBUG_TICK_EFFECT_KIDAN               = 381,
	ID_DEBUG_TICK_EFFECT_KAMEHAMEHA          = 382,
	ID_DEBUG_TICK_EFFECT_DEBRIS              = 383,
	ID_DEBUG_TICK_EFFECT_SMOKE               = 384,
	ID_DEBUG_TICK_DISPLAY_QUEST              = 385,
	ID_DEBUG_TICK_DISPLAY_MESSAGE            = 386,
	ID_DEBUG_TICK_DISPLAY_BALLOON            = 387,
	ID_DEBUG_TICK_DISPLAY_ICON               = 388,
	ID_DEBUG_TICK_UI                         = 389,
	ID_DEBUG_TICK_POSTEFFECT                 = 390,
	ID_DEBUG_RENDER                          = 391,
	ID_DEBUG_RENDER_SYSTEM_UE4               = 392,
	ID_DEBUG_RENDER_SYSTEM_AT                = 393,
	ID_DEBUG_RENDER_SOUND                    = 394,
	ID_DEBUG_RENDER_CHARACTER_PLAYER         = 395,
	ID_DEBUG_RENDER_CHARACTER_FRIENDS        = 396,
	ID_DEBUG_RENDER_CHARACTER_ENEMIES        = 397,
	ID_DEBUG_RENDER_CHARACTER_ENEMY_BOSS     = 398,
	ID_DEBUG_RENDER_BACKGROUND_LANDSCAPE     = 399,
	ID_DEBUG_RENDER_BACKGROUND_ROAD          = 400,
	ID_DEBUG_RENDER_BACKGROUND_HOUSE         = 401,
	ID_DEBUG_RENDER_BACKGROUND_BUILDING      = 402,
	ID_DEBUG_RENDER_BACKGROUND_SEA           = 403,
	ID_DEBUG_RENDER_BACKGROUND_CLOUD         = 404,
	ID_DEBUG_RENDER_OBJECT_NPC               = 405,
	ID_DEBUG_RENDER_OBJECT_MOB               = 406,
	ID_DEBUG_RENDER_OBJECT_CAR               = 407,
	ID_DEBUG_RENDER_OBJECT_PLANE             = 408,
	ID_DEBUG_RENDER_OBJECT_ANIMAL            = 409,
	ID_DEBUG_RENDER_OBJECT_ZORB              = 410,
	ID_DEBUG_RENDER_OBJECT_MININGPOINT       = 411,
	ID_DEBUG_RENDER_PROCEDURAL_PLANT         = 412,
	ID_DEBUG_RENDER_PROCEDURAL_TREE          = 413,
	ID_DEBUG_RENDER_PROCEDURAL_ROCK          = 414,
	ID_DEBUG_RENDER_DESTRUCTIVEOBJECT_BEFORE = 415,
	ID_DEBUG_RENDER_DESTRUCTIVEOBJECT_AFTER  = 416,
	ID_DEBUG_RENDER_EFFECT_AURA              = 417,
	ID_DEBUG_RENDER_EFFECT_KIDAN             = 418,
	ID_DEBUG_RENDER_EFFECT_KAMEHAMEHA        = 419,
	ID_DEBUG_RENDER_EFFECT_DEBRIS            = 420,
	ID_DEBUG_RENDER_EFFECT_SMOKE             = 421,
	ID_DEBUG_RENDER_DISPLAY_QUEST            = 422,
	ID_DEBUG_RENDER_DISPLAY_MESSAGE          = 423,
	ID_DEBUG_RENDER_DISPLAY_BALLOON          = 424,
	ID_DEBUG_RENDER_DISPLAY_ICON             = 425,
	ID_DEBUG_RENDER_UI                       = 426,
	ID_DEBUG_RENDER_POSTEFFECT               = 427,
	ID_DEBUG_PHYSICS                         = 428,
	ID_DEBUG_PHYSICS_SYSTEM_UE4              = 429,
	ID_DEBUG_PHYSICS_SYSTEM_AT               = 430,
	ID_DEBUG_PHYSICS_SOUND                   = 431,
	ID_DEBUG_PHYSICS_CHARACTER_PLAYER        = 432,
	ID_DEBUG_PHYSICS_CHARACTER_FRIENDS       = 433,
	ID_DEBUG_PHYSICS_CHARACTER_ENEMIES       = 434,
	ID_DEBUG_PHYSICS_CHARACTER_ENEMY_BOSS    = 435,
	ID_DEBUG_PHYSICS_BACKGROUND_LANDSCAPE    = 436,
	ID_DEBUG_PHYSICS_BACKGROUND_ROAD         = 437,
	ID_DEBUG_PHYSICS_BACKGROUND_HOUSE        = 438,
	ID_DEBUG_PHYSICS_BACKGROUND_BUILDING     = 439,
	ID_DEBUG_PHYSICS_BACKGROUND_SEA          = 440,
	ID_DEBUG_PHYSICS_BACKGROUND_CLOUD        = 441,
	ID_DEBUG_PHYSICS_OBJECT_NPC              = 442,
	ID_DEBUG_PHYSICS_OBJECT_MOB              = 443,
	ID_DEBUG_PHYSICS_OBJECT_CAR              = 444,
	ID_DEBUG_PHYSICS_OBJECT_PLANE            = 445,
	ID_DEBUG_PHYSICS_OBJECT_ANIMAL           = 446,
	ID_DEBUG_PHYSICS_OBJECT_ZORB             = 447,
	ID_DEBUG_PHYSICS_OBJECT_MININGPOINT      = 448,
	ID_DEBUG_PHYSICS_PROCEDURAL_PLANT        = 449,
	ID_DEBUG_PHYSICS_PROCEDURAL_TREE         = 450,
	ID_DEBUG_PHYSICS_PROCEDURAL_ROCK         = 451,
	ID_DEBUG_PHYSICS_DESTRUCTIVEOBJECT_BEFORE = 452,
	ID_DEBUG_PHYSICS_DESTRUCTIVEOBJECT_AFTER = 453,
	ID_DEBUG_PHYSICS_EFFECT_AURA             = 454,
	ID_DEBUG_PHYSICS_EFFECT_KIDAN            = 455,
	ID_DEBUG_PHYSICS_EFFECT_KAMEHAMEHA       = 456,
	ID_DEBUG_PHYSICS_EFFECT_DEBRIS           = 457,
	ID_DEBUG_PHYSICS_EFFECT_SMOKE            = 458,
	ID_DEBUG_PHYSICS_DISPLAY_QUEST           = 459,
	ID_DEBUG_PHYSICS_DISPLAY_MESSAGE         = 460,
	ID_DEBUG_PHYSICS_DISPLAY_BALLOON         = 461,
	ID_DEBUG_PHYSICS_DISPLAY_ICON            = 462,
	ID_DEBUG_PHYSICS_UI                      = 463,
	ID_DEBUG_PHYSICS_POSTEFFECT              = 464,
	ID_DEBUG_COLLISION                       = 465,
	ID_DEBUG_COLLISION_SYSTEM_UE4            = 466,
	ID_DEBUG_COLLISION_SYSTEM_AT             = 467,
	ID_DEBUG_COLLISION_SOUND                 = 468,
	ID_DEBUG_COLLISION_CHARACTER_PLAYER      = 469,
	ID_DEBUG_COLLISION_CHARACTER_FRIENDS     = 470,
	ID_DEBUG_COLLISION_CHARACTER_ENEMIES     = 471,
	ID_DEBUG_COLLISION_CHARACTER_ENEMY_BOSS  = 472,
	ID_DEBUG_COLLISION_BACKGROUND_LANDSCAPE  = 473,
	ID_DEBUG_COLLISION_BACKGROUND_ROAD       = 474,
	ID_DEBUG_COLLISION_BACKGROUND_HOUSE      = 475,
	ID_DEBUG_COLLISION_BACKGROUND_BUILDING   = 476,
	ID_DEBUG_COLLISION_BACKGROUND_SEA        = 477,
	ID_DEBUG_COLLISION_BACKGROUND_CLOUD      = 478,
	ID_DEBUG_COLLISION_OBJECT_NPC            = 479,
	ID_DEBUG_COLLISION_OBJECT_MOB            = 480,
	ID_DEBUG_COLLISION_OBJECT_CAR            = 481,
	ID_DEBUG_COLLISION_OBJECT_PLANE          = 482,
	ID_DEBUG_COLLISION_OBJECT_ANIMAL         = 483,
	ID_DEBUG_COLLISION_OBJECT_ZORB           = 484,
	ID_DEBUG_COLLISION_OBJECT_MININGPOINT    = 485,
	ID_DEBUG_COLLISION_PROCEDURAL_PLANT      = 486,
	ID_DEBUG_COLLISION_PROCEDURAL_TREE       = 487,
	ID_DEBUG_COLLISION_PROCEDURAL_ROCK       = 488,
	ID_DEBUG_COLLISION_DESTRUCTIVEOBJECT_BEFORE = 489,
	ID_DEBUG_COLLISION_DESTRUCTIVEOBJECT_AFTER = 490,
	ID_DEBUG_COLLISION_EFFECT_AURA           = 491,
	ID_DEBUG_COLLISION_EFFECT_KIDAN          = 492,
	ID_DEBUG_COLLISION_EFFECT_KAMEHAMEHA     = 493,
	ID_DEBUG_COLLISION_EFFECT_DEBRIS         = 494,
	ID_DEBUG_COLLISION_EFFECT_SMOKE          = 495,
	ID_DEBUG_COLLISION_DISPLAY_QUEST         = 496,
	ID_DEBUG_COLLISION_DISPLAY_MESSAGE       = 497,
	ID_DEBUG_COLLISION_DISPLAY_BALLOON       = 498,
	ID_DEBUG_COLLISION_DISPLAY_ICON          = 499,
	ID_DEBUG_COLLISION_UI                    = 500,
	ID_DEBUG_COLLISION_POSTEFFECT            = 501,
	ID_DEBUG_ANIMATION                       = 502,
	ID_DEBUG_ANIMATION_SYSTEM_UE4            = 503,
	ID_DEBUG_ANIMATION_SYSTEM_AT             = 504,
	ID_DEBUG_ANIMATION_SOUND                 = 505,
	ID_DEBUG_ANIMATION_CHARACTER_PLAYER      = 506,
	ID_DEBUG_ANIMATION_CHARACTER_FRIENDS     = 507,
	ID_DEBUG_ANIMATION_CHARACTER_ENEMIES     = 508,
	ID_DEBUG_ANIMATION_CHARACTER_ENEMY_BOSS  = 509,
	ID_DEBUG_ANIMATION_BACKGROUND_LANDSCAPE  = 510,
	ID_DEBUG_ANIMATION_BACKGROUND_ROAD       = 511,
	ID_DEBUG_ANIMATION_BACKGROUND_HOUSE      = 512,
	ID_DEBUG_ANIMATION_BACKGROUND_BUILDING   = 513,
	ID_DEBUG_ANIMATION_BACKGROUND_SEA        = 514,
	ID_DEBUG_ANIMATION_BACKGROUND_CLOUD      = 515,
	ID_DEBUG_ANIMATION_OBJECT_NPC            = 516,
	ID_DEBUG_ANIMATION_OBJECT_MOB            = 517,
	ID_DEBUG_ANIMATION_OBJECT_CAR            = 518,
	ID_DEBUG_ANIMATION_OBJECT_PLANE          = 519,
	ID_DEBUG_ANIMATION_OBJECT_ANIMAL         = 520,
	ID_DEBUG_ANIMATION_OBJECT_ZORB           = 521,
	ID_DEBUG_ANIMATION_OBJECT_MININGPOINT    = 522,
	ID_DEBUG_ANIMATION_PROCEDURAL_PLANT      = 523,
	ID_DEBUG_ANIMATION_PROCEDURAL_TREE       = 524,
	ID_DEBUG_ANIMATION_PROCEDURAL_ROCK       = 525,
	ID_DEBUG_ANIMATION_DESTRUCTIVEOBJECT_BEFORE = 526,
	ID_DEBUG_ANIMATION_DESTRUCTIVEOBJECT_AFTER = 527,
	ID_DEBUG_ANIMATION_EFFECT_AURA           = 528,
	ID_DEBUG_ANIMATION_EFFECT_KIDAN          = 529,
	ID_DEBUG_ANIMATION_EFFECT_KAMEHAMEHA     = 530,
	ID_DEBUG_ANIMATION_EFFECT_DEBRIS         = 531,
	ID_DEBUG_ANIMATION_EFFECT_SMOKE          = 532,
	ID_DEBUG_ANIMATION_DISPLAY_QUEST         = 533,
	ID_DEBUG_ANIMATION_DISPLAY_MESSAGE       = 534,
	ID_DEBUG_ANIMATION_DISPLAY_BALLOON       = 535,
	ID_DEBUG_ANIMATION_DISPLAY_ICON          = 536,
	ID_DEBUG_ANIMATION_UI                    = 537,
	ID_DEBUG_ANIMATION_POSTEFFECT            = 538,
	ID_LEVEL_CATEGORY                        = 539,
	ID_DELAY_SUBLEVEL_ACTIVATION             = 540,
	ID_DEBUG_MISSION                         = 541,
	ID_DEBUG_MISSION_ADD_VALUE_RECIPE        = 542,
	ID_DEBUG_MISSION_ADD_VALUE_MILEAGE       = 543,
	ID_DEBUG_MISSION_ADD_VALUE_DRAGONBALL    = 544,
	ID_DEBUG_MISSION_ADD_VALUE_MONEY         = 545,
	ID_DEBUG_MISSION_ADD_VALUE_PLAYED_TIME   = 546,
	ID_DEBUG_MISSION_ADD_VALUE_DISTANCE      = 547,
	ID_DEBUG_MISSION_ADD_VALUE_LEVEL         = 548,
	ID_DEBUG_MISSION_ADD_VALUE_ZORB_BLUE     = 549,
	ID_DEBUG_MISSION_ADD_VALUE_ZORB_GREEN    = 550,
	ID_DEBUG_MISSION_ADD_VALUE_ZORB_RED      = 551,
	ID_DEBUG_MISSION_ADD_VALUE_ZORB_RAINBOW  = 552,
	ID_DEBUG_MISSION_ADD_VALUE_COMBO         = 553,
	ID_DEBUG_MISSION_ADD_VALUE_SKILL_KILLED_COUNT = 554,
	ID_DEBUG_MISSION_ADD_VALUE_DEFEAT_ENEMY  = 555,
	ID_DEBUG_MISSION_ADD_VALUE_CAPTURE_FISH  = 556,
	ID_DEBUG_MISSION_ADD_VALUE_RACE          = 557,
	ID_DEBUG_MISSION_ADD_VALUE_JUSTHIT       = 558,
	ID_DEBUG_MISSION_ADD_VALUE_LINKBONUS     = 559,
	ID_DEBUG_MISSION_ADD_VALUE_COMMUNITY     = 560,
	ID_DEBUG_MISSION_ADD_VALUE_NPCTALK       = 561,
	ID_DEBUG_SUBJUGATION_MISSION_ADD_VALUE_WIN_VILLAIN_GROUP = 562,
	ID_DEBUG_SUBJUGATION_MISSION_ADD_VALUE_WIN_BIG_VILLAIN_GROUP = 563,
	ID_DEBUG_SUBJUGATION_MISSION_ADD_VALUE_DEFEAT_VILLAIN = 564,
	ID_DEBUG_SUBJUGATION_MISSION_ADD_VALUE_DEFEAT_SKULL_ROBOTS = 565,
	ID_DEBUG_SUBJUGATION_MISSION_ADD_VALUE_DEFEAT_MINI_ROBOTS = 566,
	ID_DEBUG_QUEST                           = 567,
	ID_DEBUG_QUEST_SKIP_EVENT                = 568,
	ID_DEBUG_QUEST_PROGRESS                  = 569,
	ID_DEBUG_QUEST_PHASE                     = 570,
	ID_DEBUG_QUEST_REQUEST_PROGRESS          = 571,
	ID_DEBUG_QUEST_RESET_PROGRESS            = 572,
	ID_DEBUG_QUEST_CHECK_PROGRESS            = 573,
	ID_DEBUG_QUEST_COMPLETE_SUB_QUEST        = 574,
	ID_DEBUG_QUEST_UNLOCK_FUTURE_TRUNKS      = 575,
	ID_DEBUG_QUEST_RELEASE_CONTENTS_01       = 576,
	ID_DEBUG_QUEST_NAVIGATE_TITLEMENU        = 577,
	ID_DEBUG_QUEST_NAVIGATE_AREA             = 578,
	ID_DEBUG_QUEST_SUBSCRIBE                 = 579,
	ID_DEBUG_QUEST_SUBSCRIBE_FAST            = 580,
	ID_DEBUG_QUEST_SUBSCRIBE_INTERVAL        = 581,
	ID_DEBUG_DISPLAY_RECEIVABLE_ITEMS        = 582,
	ID_DEBUG_DISPLAY_CHARACTER_ANIMATION     = 583,
	ID_DEBUG_DISPLAY_CHARACTER_ANIMATION_2D  = 584,
	ID_DEBUG_DISPLAY_CHARACTER_ANIMATION_PROPERTY = 585,
	ID_DEBUG_DISPLAY_CHARACTER_COSTUME       = 586,
	ID_DEBUG_DISPLAY_CHARACTER_TALK_ID       = 587,
	ID_DEBUG_DISPLAY_QUEST_COSTUMES          = 588,
	ID_DEBUG_DISPLAY_QUEST_DLC_ID            = 589,
	ID_DEBUG_DISPLAY_QUEST_FLAGS             = 590,
	ID_DEBUG_DISPLAY_QUEST_TALK_ID           = 591,
	ID_DEBUG_DISPLAY_QUEST_PHASE             = 592,
	ID_DEBUG_DLC3_CLEAR_CONDITIONS_MET       = 593,
	ID_DEBUG_DLC4_CLEAR_CONDITIONS_MET       = 594,
	ID_DEBUG_QUEST_UNLOCK_BNID               = 595,
	ID_DEBUG_DLC5_CLEAR_CONDITIONS_MET       = 596,
	ID_DEBUG_DLC6_CLEAR_CONDITIONS_MET       = 597,
	ID_DEBUG_DRAGONBALL                      = 598,
	ID_DEBUG_DRAGONBALL_PLACEMENT_STATUS     = 599,
	ID_DEBUG_QUEST_ADD_ITEM_DB1              = 600,
	ID_DEBUG_QUEST_ADD_ITEM_DB2              = 601,
	ID_DEBUG_QUEST_ADD_ITEM_DB3              = 602,
	ID_DEBUG_QUEST_ADD_ITEM_DB4              = 603,
	ID_DEBUG_QUEST_ADD_ITEM_DB5              = 604,
	ID_DEBUG_QUEST_ADD_ITEM_DB6              = 605,
	ID_DEBUG_QUEST_ADD_ITEM_DB7              = 606,
	ID_DEBUG_DRAGONBALL_LOCATION_EDITOR      = 607,
	ID_DEBUG_DRAGONBALL_RESET_USETIME        = 608,
	ID_DEBUG_AREA                            = 609,
	ID_DEBUG_AREA_RESET                      = 610,
	ID_DEBUG_AREA_UNLOCK_ALL                 = 611,
	ID_DEBUG_AREA_CUTINPOINT_STAGE_ANGLEPITCH = 612,
	ID_DEBUG_AREA_CUTINPOINT_STAGE_ANGLEROLL = 613,
	ID_DEBUG_AREA_CUTINPOINT_ANGLE_KEEP      = 614,
	ID_DEBUG_PODS                            = 615,
	ID_DEBUG_ENABLED_POD_DEBUG               = 616,
	ID_DEBUG_SPAWN_INTERVAL_TIME             = 617,
	ID_DEBUG_NEXT_SPAWNER_INTERVAL_TIME      = 618,
	ID_DEBUG_DISABLED_CAMERA_TEST            = 619,
	ID_DEBUG_RESET_PODS                      = 620,
	ID_DEBUG_PODTRACTOR_SPEED_RATE           = 621,
	ID_DEBUG_DEVELOPPER_TOOLS                = 622,
	ID_DEBUG_FEVER                           = 623,
	ID_DEBUG_FEVER_FORCE_UNLOCK_FEVER_CONTENTS = 624,
	ID_DEBUG_FEVER_FORCE_START_FEVER         = 625,
	ID_DEBUG_FEVER_SHOW_STATUS               = 626,
	ID_DEBUG_WINDROAD                        = 627,
	ID_DEBUG_WINDROAD_RARE_CERTAINTY         = 628,
	ID_ZORB                                  = 629,
	ID_ZORB_CURRENT_NUM                      = 630,
	ID_PLAYER3                               = 631,
	ID_PLAYER_ON_DAMAGE_CHECK                = 632,
	ID_PLAYER_BUFF_TEST                      = 633,
	ID_PLAYER_ENABLE_BUFF_COOKING            = 634,
	ID_PLAYER_SKILL_FULL_OPEN                = 635,
	ID_PLAYER_RUSH_MOVERUSH_ONLY             = 636,
	ID_PLAYER_RUSH_WRAPAROUND_IGNORE         = 637,
	ID_PLAYER_BREAKRUSH_OFFSET               = 638,
	ID_PLAYER_UPDOWN_HOLDINGWAIT_ENABLE      = 639,
	ID_PLAYER_UPDOWN_HOLDINGWAIT_MILLISEC    = 640,
	ID_PLAYER_SKILL_NONEBATTLE_USE           = 641,
	ID_PLAYER_RUSH_ONLY_PATTERN              = 642,
	ID_PLAYER_RUSH_PATTERN                   = 643,
	ID_PLAYER_SKILLCHAIN_NO_DEG_TIME         = 644,
	ID_PLAYER_SUPER_FINISH_CHECK             = 645,
	ID_PLAYER_JOSTLE_BEAM_SIZE               = 646,
	ID_CHARACTER_PRESET                      = 647,
	ID_CHARACTER_PRESET_INDEX                = 648,
	ID_CHARACTER_PRESET_SAVE                 = 649,
	ID_CHARACTER_PRESET_LOAD                 = 650,
	ID_EFFECT3                               = 651,
	ID_EFFECT_DEBUGDRAW                      = 652,
	ID_DAMAGENOREACTION                      = 653,
	ID_DAMAGENOREACTION_PLAYER               = 654,
	ID_DAMAGENOREACTION_ENEMY                = 655,
	ID_DAMAGE_REACTION_FIXED                 = 656,
	ID_DAMAGE_STRENGTH_FIXED                 = 657,
	ID_DAMAGE_VECTOR_FIXED                   = 658,
	ID_DAMAGE_INVINCIBLE_FLAG_ENABLE_SET     = 659,
	ID_DAMAGE_INVINCIBLE_FLAG_TARGET         = 660,
	ID_DAMAGE_INVINCIBLE_FLAG_VALUE          = 661,
	ID_AI_FREEZER                            = 662,
	ID_AI_FREEZER_SKY_RISING_SPEED           = 663,
	ID_AI_FREEZER_GROUND_CHECK               = 664,
	ID_FISHING                               = 665,
	ID_FISHING_DEBUGDRAW                     = 666,
	ID_FISHING_ADDBAIT_TYPE1                 = 667,
	ID_FISHING_ADDBAIT_TYPE2                 = 668,
	ID_FISHING_ADDBAIT_TYPE3                 = 669,
	ID_BASEBALL                              = 670,
	ID_BASEBALL_START                        = 671,
	ID_BASEBALL_END                          = 672,
	ID_BASEBALL_DEBUGDRAW                    = 673,
	ID_BASEBALL_ENDLESS                      = 674,
	ID_BASEBALL_ENDLESS_HOMERUN              = 675,
	ID_BASEBALL_BALL_SPEED                   = 676,
	ID_BASEBALL_HITTING_BALL_SPEED           = 677,
	ID_BASEBALL_PITCH_TYPE                   = 678,
	ID_BASEBALL_EFFECT_TYPE                  = 679,
	ID_BASEBALL_HIT_TIMING                   = 680,
	ID_BASEBALL_SUCCESS_RING_SIZE            = 681,
	ID_BASEBALL_FIRST_CIRCLE_SIZE            = 682,
	ID_BASEBALL_VERTICAL_BALL_TARGET_OFFSET  = 683,
	ID_BASEBALL_HORIZONTAL_BALL_TARGET_OFFSET = 684,
	ID_BASEBALL_HIT_RANGE_OFFSET             = 685,
	ID_BASEBALL_POWER_CHANGE_FLAG            = 686,
	ID_BASEBALL_POWER_CHANGE                 = 687,
	ID_BASEBALL_CAMERA_FOV                   = 688,
	ID_BASEBALL_CAMERA_LENGTH                = 689,
	ID_BASEBALL_CAMERA_OFFSET_Z              = 690,
	ID_BASEBALL_CAMERA_TARGET_HEIGHT_OFFSET  = 691,
	ID_BASEBALL_CAMERA_WIDTH_OFFSET          = 692,
	ID_BASEBALL_CAMERA_TARGET_WIDTH_OFFSET   = 693,
	ID_BASEBALL_CAMERA_HR_FOV                = 694,
	ID_BASEBALL_CAMERA_HR_LENGTH             = 695,
	ID_BASEBALL_CAMERA_HR_OFFSET_HEIGHT      = 696,
	ID_BASEBALL_CAMERA_HR_TARGET_HEIGHT_OFFSET = 697,
	ID_BASEBALL_CAMERA_HR_WIDTH_OFFSET       = 698,
	ID_BASEBALL_CAMERA_HR_TARGET_WIDTH_OFFSET = 699,
	ID_BASEBALL2                             = 700,
	ID_BASEBALL_JUSTMEET_COUNT_EASY          = 701,
	ID_BASEBALL_JUSTMEET_COUNT_NORMAL        = 702,
	ID_BASEBALL_JUSTMEET_COUNT_HARD          = 703,
	ID_BASEBALL_JUSTMEET_COUNT_VERYHARD      = 704,
	ID_ESCAPEMODE                            = 705,
	ID_ESCAPEMODE_FLG                        = 706,
	ID_ESCAPEMODE_LIMIT                      = 707,
	ID_ESCAPEMODE_DISTANCE                   = 708,
	ID_NEWENCOUNT                            = 709,
	ID_NEWENCOUNT_FLG                        = 710,
	ID_NEWENCOUNT_BACKATK_PLAYER_DEG         = 711,
	ID_BACKATK_ANNOUNCE                      = 712,
	ID_BACKATK_ANNOUNCE_TIME                 = 713,
	ID_UI                                    = 714,
	ID_UI_DRAW_SAFE_FRAME                    = 715,
	ID_UI_STRING_ID_MSG                      = 716,
	ID_UI_TPS_Skill                          = 717,
	ID_UI_FIELD_ICON_RARE                    = 718,
	ID_UI_CHANGE_CHARA_ICON_D                = 719,
	ID_UI_CHANGE_CHARA_ICON_EV               = 720,
	ID_UI_CHANGE_CHARA_ICON_F                = 721,
	ID_UI_CHANGE_CHARA_ICON_SPO              = 722,
	ID_UI_DISABLE_LEVELUP_CUTIN              = 723,
	ID_UI_FADE_IN                            = 724,
	ID_UI_FADE_DISABLE                       = 725,
	ID_UI_FADE_FORCE_ENABLED                 = 726,
	ID_UI_ENDROLL_FASTFORWARD                = 727,
	ID_UI_IMPORTANT_LOG                      = 728,
	ID_LONGBLOWOFF_PL_CAMERA                 = 729,
	ID_LONGBLOWOFF_PL_CAMERA_END_DELAY_RECOVERY = 730,
	ID_SUPERLONGBLOWOFF_HIT                  = 731,
	ID_SUPERLONGBLOWOFF_HIT_STATICMESH_ENABLE_PLAYER = 732,
	ID_SUPERLONGBLOWOFF_HIT_STATICMESH_ENABLE_ENEMY = 733,
	ID_SUPERLONGBLOWOFF_HIT_STATICMESH_DEBUGDRAW = 734,
	ID_SUPERLONGBLOWOFF_HIT_DEBRIS_ENABLE    = 735,
	ID_EFFECT_TERRAINDAMAGE_SKIPPING_ROOT    = 736,
	ID_EFFECT_TERRAINDAMAGE_SKIPPING         = 737,
	ID_EFFECT_TERRAINDAMAGE_SKIPPING_STOP_SPEED = 738,
	ID_EFFECT_TERRAINDAMAGE_SETTING          = 739,
	ID_EFFECT_TERRAINDAMAGE_SETTING_GRASS_REPRODUCE = 740,
	ID_EFFECT_TERRAINDAMAGE_SETTING_DESTROY_DISPLAY = 741,
	ID_EFFECT_TERRAINDAMAGE_SETTING_BLOWOFF_OFFSET = 742,
	ID_POSTEFFECT_CONTROLLER                 = 743,
	ID_POSTEFFECT_CONTROLLER_DEBUGDRAW       = 744,
	ID_POSTEFFECT_CONTROLLER_ENABLE_SILHOUETTE = 745,
	ID_POSTEFFECT_CONTROLLER_ENABLE_CUSTOM_DEPTH_GRASS = 746,
	ID_POSTEFFECT_CONTROLLER_DARK_DISTANCE   = 747,
	ID_BLOW_RUSH_DEBUG                       = 748,
	ID_RUSH_DEBUG_COMBO_ONLY_PATTERN         = 749,
	ID_RUSH_DEBUG_COMBO_PATTERN              = 750,
	ID_RUSH_DEBUG_BLOW_RUSH_ENABLE           = 751,
	ID_RUSH_DEBUG_BLOW_SKILL_UP_VALUE        = 752,
	ID_RUSH_DEBUG_BLOW_MOVE_SPEED            = 753,
	ID_RUSH_DEBUG_BLOW_MOTIONBLUR_AMOUNT     = 754,
	ID_RUSH_DEBUG_BLOW_MOTIONBLUR_MAX        = 755,
	ID_RUSH_DEBUG_BLOW_MOTIONBLUR_SIZE       = 756,
	ID_AURA_RUSH_DEBUG                       = 757,
	ID_RUSH_DEBUG_AURA_RUSH_ENABLE           = 758,
	ID_RUSH_DEBUG_AURA_FINISH_BAFFER_TIME    = 759,
	ID_RUSH_DEBUG_AURA_SKILL_UP_VALUE        = 760,
	ID_FAST_RUSH_DEBUG                       = 761,
	ID_RUSH_DEBUG_FAST_RUSH_ENABLE           = 762,
	ID_RUSH_DEBUG_FAST_RUSH_TYPE             = 763,
	ID_RUSH_DEBUG_FAST_SKILL_UP_VALUE        = 764,
	ID_HATE                                  = 765,
	ID_HATE_DECREASETIME                     = 766,
	ID_HATE_DECREASENUM                      = 767,
	ID_AI_LONGBLOWOF                         = 768,
	ID_AI_LONGBLOWOF_TIME                    = 769,
	ID_PHYSICMATERIAL                        = 770,
	ID_PHYSICMATERIAL_DRAW_TYPE              = 771,
	ID_AUTODEBUG                             = 772,
	ID_AUTODEBUG_INITIALIZE                  = 773,
	ID_AUTODEBUG_ENABLE                      = 774,
	ID_AUTODEBUG_MOVE                        = 775,
	ID_AUTODEBUG_PAD                         = 776,
	ID_AUTODEBUG_DRAWINPUT                   = 777,
	ID_AUTODEBUG_SETTINGUI                   = 778,
	ID_AUTODEBUG_SCREENSHOT                  = 779,
	ID_AUTODEBUG_SCREENSHOT_ZOFFSET          = 780,
	ID_AUTODEBUG_SCREENSHOT_ANGLE_NUM        = 781,
	ID_AUTODEBUG_SCREENSHOT_OVERHEAD_DISTANCE = 782,
	ID_AUTODEBUG_SCREENSHOT_OVERHEAD_ZOFFSET = 783,
	ID_SPARKING_GAUGE                        = 784,
	ID_SPARKING_GAUGE_MAX                    = 785,
	ID_SPARKING_GAUGE_VAL                    = 786,
	ID_SPARKING_GAUGE_RATE                   = 787,
	ID_SPARKING_GAUGE_NOT_USE                = 788,
	ID_SPARKING_GAUGE_ALWAYS_FULL            = 789,
	ID_COMBO_CONFIG                          = 790,
	ID_COMBO_AUTO                            = 791,
	ID_COMBO_LEVEL                           = 792,
	ID_COMBO_R_LEVEL                         = 793,
	ID_COMBO_U_LEVEL                         = 794,
	ID_COMBO_L_LEVEL                         = 795,
	ID_COMBO_D_LEVEL                         = 796,
	ID_COMBO_PATTERN_FIXED                   = 797,
	ID_AURASEARCH                            = 798,
	ID_AURASEARCH_EFFECT_COLORE              = 799,
	ID_CROSSTALK                             = 800,
	ID_CROSSTALK_ENABLE_COMMON               = 801,
	ID_CROSSTALK_ENABLE_CONDITION            = 802,
	ID_CROSSTALK_DEBUGDRAW                   = 803,
	ID_CROSSTALK_ABORT                       = 804,
	ID_CROSSTALK_SET_HP_FRIEND_1             = 805,
	ID_CROSSTALK_SET_HP_FRIEND_2             = 806,
	ID_CROSSTALK_BREAK_DAMAGE_PLAYER         = 807,
	ID_CROSSTALK_BREAK_DAMAGE_FRIEND         = 808,
	ID_CROSSTALK_BREAK_DAMAGE_ENEMY          = 809,
	ID_COOK                                  = 810,
	ID_AUTO_ADD_MATERIAL                     = 811,
	ID_SUPPORTRESCUE                         = 812,
	ID_SUPPORTRESCUE_FLG                     = 813,
	ID_SUPPORTRESCUE_LIKE                    = 814,
	ID_RIDE                                  = 815,
	ID_NOT_REMOVEBATTERY                     = 816,
	ID_RIDE_MODIFY_MACHINE_TYPE              = 817,
	ID_RIDE_ADD_LEVEL                        = 818,
	ID_RIDE_ADD_EXP                          = 819,
	ID_RIDE_ADD_MEMORY_SLOT                  = 820,
	ID_RIDE_ADD_SPEED                        = 821,
	ID_RIDE_ADD_BATTERY                      = 822,
	ID_RIDE_ADD_RADER                        = 823,
	ID_RIDE_ADD_EFFICIENCY                   = 824,
	ID_RIDE_ADD_DISCOVER_ABILITY             = 825,
	ID_RIDE_ADD_NOW_EXP                      = 826,
	ID_RIDE_ADD_NEXT_EXP                     = 827,
	ID_RIDE_CHANGE_COLOR                     = 828,
	ID_RIDE_ADD_USED_MEMORY                  = 829,
	ID_RIDE_ADD_BATTERY_NOW                  = 830,
	ID_RIDE_ADD_BATTERY_MAX                  = 831,
	ID_RIDE_ALL_PARAMETER_MAX                = 832,
	ID_RIDE_FORCE_DLC_TRUNKS_FIRST_LOAD      = 833,
	ID_MINIGAME                              = 834,
	ID_MINIGAME_START                        = 835,
	ID_RACEGAME_TIMERSTOP                    = 836,
	ID_RACEGAME_LIMITSTOP                    = 837,
	ID_RACEGAME_RETRY                        = 838,
	ID_RACEGAME_END                          = 839,
	ID_RACEGAME_TIMEUP                       = 840,
	ID_FORCED_PROGRESSION_EVENT_MINIGAME     = 841,
	ID_PLAYER_CONTROL_TEST                   = 842,
	ID_PLAYER_CONTROL_NEW_STYLE              = 843,
	ID_PLAYER_CONTROL_NEW_STYLE_4            = 844,
	ID_PLAYER_CONTROL_NEW_STYLE_4_NIMBUS     = 845,
	ID_PLAYER_CONTROL_CAMERA_REVERSE_YAW     = 846,
	ID_PLAYER_CONTROL_CAMERA_REVERSE_PITCH   = 847,
	ID_PLAYER_CONTROL_VERTICAL_MOVE_CAMERA_BASE = 848,
	ID_PLAYER_CONTROL_FORCE_UNDER_WATER      = 849,
	ID_PLAYER_CONTROL_INFINITE_OXYGEN        = 850,
	ID_PLAYER_CONTROL_OXYGEN_VALUE_ONE       = 851,
	ID_PLAYER_CONTROL_DISP_JUMP_SCALE        = 852,
	ID_PLAYER_CONTROL_RIDEMENU_FULLOPEN      = 853,
	ID_PLAYER_CONTROL_CAMERA_BLOCK_EXCEPT_FOLIAGEACTOR = 854,
	ID_PLAYER_CONTROL_CAMERA_BLOCK_HIT_COLLISION = 855,
	ID_PLAYER_CONTROL_CAMERA_HITCHECK_TRACE_VISIBLE = 856,
	ID_PLAYER_CONTROL_HILL_ANGLE_TO_PITCHTARGET = 857,
	ID_COMMUNITY                             = 858,
	ID_COMMUNITY_BOARD_CATEGORY_UNLOCK       = 859,
	ID_COMMUNITY_BOARD_TEST_ASSIGN           = 860,
	ID_COMMUNITY_SOUL_EM_GET                 = 861,
	ID_COMMUNITY_SOUL_EM_UNLOCK              = 862,
	ID_COMMUNITY_SOUL_EM_RARITY              = 863,
	ID_COMMUNITY_SOUL_EM_ALL_ITEM_GET        = 864,
	ID_COMMUNITY_SOUL_EM_ALL_LV_RATE         = 865,
	ID_COLLECTION                            = 866,
	ID_COLLECTION_DEBUGDRAW                  = 867,
	ID_COLLECTION_COUNT                      = 868,
	ID_COLLECTION_NPCTALK                    = 869,
	ID_COLLECTION_ANIMAL                     = 870,
	ID_COLLECTION_FISH                       = 871,
	ID_COLLECTION_MINIGAME                   = 872,
	ID_COLLECTION_VICTORY                    = 873,
	ID_COLLECTION_ENEMY                      = 874,
	ID_COLLECTION_SKILL                      = 875,
	ID_COLLECTION_TOWN                       = 876,
	ID_COLLECTION_PAGENAVI                   = 877,
	ID_COLLECTION_OPENALL                    = 878,
	ID_RECORDING_MODE                        = 879,
	ID_RECORDING_MODE_ISON                   = 880,
	ID_TUTORIAL                              = 881,
	ID_TUTORIAL_OPEN_ALL                     = 882,
	ID_DEVELOPMENT                           = 883,
	ID_DEVELOPMENT_MODE                      = 884,
	ID_TROPHY                                = 885,
	ID_TROPHY_ID                             = 886,
	ID_TROPHY_UNLOCK                         = 887,
	ID_TROPHY_UNLOCK_LOG                     = 888,
	ID_TROPHY_OUTPUT_INFO                    = 889,
	ID_TROPHY_BEFORE_VALUE                   = 890,
	ID_TROPHY_ACHIEVED_VALUE                 = 891,
	ID_SCENE                                 = 892,
	ID_SCENE_HIERARCHY                       = 893,
	ID_DEBUG_SET                             = 894,
	ID_DEBUG_SET_LEVEL_CONFIRM               = 895,
	ID_DEBUG_PRESET                          = 896,
	ID_DEBUG_PRESET_SAVE                     = 897,
	ID_DEBUG_PRESET_RESET                    = 898,
	ID_TIMEORB                               = 899,
	ID_TIMEORB_DRAW_LIMIT_TIME               = 900,
	ID_UI_PROFILE_F1                         = 901,
	ID_UI_PROFILE_F2                         = 902,
	ID_UI_PROFILE_B                          = 903,
	ID_UI_PROFILE_EX                         = 904,
	ID_UI_PROFILE_F_1                        = 905,
	ID_UI_PROFILE_F_2                        = 906,
	ID_UI_PROFILE_F_3                        = 907,
	ID_UI_PROFILE_F_4                        = 908,
	ID_UI_PROFILE_F_5                        = 909,
	ID_UI_PROFILE_F_6                        = 910,
	ID_UI_PROFILE_F_7                        = 911,
	ID_UI_PROFILE_F_8                        = 912,
	ID_UI_PROFILE_F_9                        = 913,
	ID_UI_PROFILE_F_10                       = 914,
	ID_UI_PROFILE_F_11                       = 915,
	ID_UI_PROFILE_F_12                       = 916,
	ID_UI_PROFILE_F_13                       = 917,
	ID_UI_PROFILE_F_14                       = 918,
	ID_UI_PROFILE_F_15                       = 919,
	ID_UI_PROFILE_F_16                       = 920,
	ID_UI_PROFILE_F_17                       = 921,
	ID_UI_PROFILE_F_18                       = 922,
	ID_UI_PROFILE_F_19                       = 923,
	ID_UI_PROFILE_F_20                       = 924,
	ID_UI_PROFILE_F_21                       = 925,
	ID_UI_PROFILE_F_22                       = 926,
	ID_UI_PROFILE_F_23                       = 927,
	ID_UI_PROFILE_F_24                       = 928,
	ID_UI_PROFILE_F_25                       = 929,
	ID_UI_PROFILE_F_26                       = 930,
	ID_UI_PROFILE_F_27                       = 931,
	ID_UI_PROFILE_F_28                       = 932,
	ID_UI_PROFILE_F_29                       = 933,
	ID_UI_PROFILE_F_30                       = 934,
	ID_UI_PROFILE_F_31                       = 935,
	ID_UI_PROFILE_F_32                       = 936,
	ID_UI_PROFILE_F_33                       = 937,
	ID_UI_PROFILE_F_34                       = 938,
	ID_UI_PROFILE_F_35                       = 939,
	ID_UI_PROFILE_F_36                       = 940,
	ID_UI_PROFILE_F_37                       = 941,
	ID_UI_PROFILE_F_38                       = 942,
	ID_UI_PROFILE_F_39                       = 943,
	ID_UI_PROFILE_F_40                       = 944,
	ID_UI_PROFILE_F_41                       = 945,
	ID_UI_PROFILE_F_42                       = 946,
	ID_UI_PROFILE_F_43                       = 947,
	ID_UI_PROFILE_F_44                       = 948,
	ID_UI_PROFILE_F_45                       = 949,
	ID_UI_PROFILE_F_46                       = 950,
	ID_UI_PROFILE_F_47                       = 951,
	ID_UI_PROFILE_F_48                       = 952,
	ID_UI_PROFILE_F_49                       = 953,
	ID_UI_PROFILE_F_50                       = 954,
	ID_UI_PROFILE_F_51                       = 955,
	ID_UI_PROFILE_F_52                       = 956,
	ID_UI_PROFILE_F_53                       = 957,
	ID_UI_PROFILE_F_54                       = 958,
	ID_UI_PROFILE_F_55                       = 959,
	ID_UI_PROFILE_F_56                       = 960,
	ID_UI_PROFILE_F_57                       = 961,
	ID_UI_PROFILE_F_58                       = 962,
	ID_UI_PROFILE_F_59                       = 963,
	ID_UI_PROFILE_B_1                        = 964,
	ID_UI_PROFILE_B_2                        = 965,
	ID_UI_PROFILE_B_3                        = 966,
	ID_UI_PROFILE_B_4                        = 967,
	ID_UI_PROFILE_B_5                        = 968,
	ID_UI_PROFILE_B_6                        = 969,
	ID_UI_PROFILE_B_7                        = 970,
	ID_UI_PROFILE_B_8                        = 971,
	ID_UI_PROFILE_B_9                        = 972,
	ID_UI_PROFILE_B_10                       = 973,
	ID_UI_PROFILE_B_11                       = 974,
	ID_UI_PROFILE_B_12                       = 975,
	ID_UI_PROFILE_B_13                       = 976,
	ID_UI_PROFILE_B_14                       = 977,
	ID_UI_PROFILE_B_15                       = 978,
	ID_UI_PROFILE_B_16                       = 979,
	ID_UI_PROFILE_B_17                       = 980,
	ID_UI_PROFILE_B_18                       = 981,
	ID_UI_PROFILE_EX_0                       = 982,
	ID_UI_PROFILE_EX_1                       = 983,
	ID_UI_PROFILE_EX_2                       = 984,
	ID_UI_PROFILE_EX_3                       = 985,
	ID_UI_PROFILE_EX_4                       = 986,
	ID_UI_PROFILE_EX_5                       = 987,
	ID_UI_PROFILE_EX_6                       = 988,
	ID_UI_PROFILE_EX_7                       = 989,
	ID_UI_PROFILE_EX_8                       = 990,
	ID_UI_PROFILE_EX_9                       = 991,
	ID_UI_PROFILE_EX_10                      = 992,
	ID_UI_PROFILE_EX_11                      = 993,
	ID_UI_PROFILE_EX_12                      = 994,
	ID_UI_PROFILE_EX_13                      = 995,
	ID_UI_PROFILE_EX_14                      = 996,
	ID_UI_PROFILE_EX_15                      = 997,
	ID_UI_PROFILE_EX_16                      = 998,
	ID_UI_TALK_WINDOW_INVISIBLE              = 999,
	ID_MONITORING                            = 1000,
	ID_MONITORING_ENABLE_OUTPUT_LOG_CSV      = 1001,
	ID_DLC                                   = 1002,
	ID_DLC_ENABLE_CODE_1                     = 1003,
	ID_DLC_ENABLE_CODE_2                     = 1004,
	ID_DLC_ENABLE_CODE_3                     = 1005,
	ID_DLC_ENABLE_CODE_4                     = 1006,
	ID_DLC_ENABLE_CODE_DLC4                  = 1007,
	ID_DLC_ENABLE_CODE_DLC5                  = 1008,
	ID_DLC_ENABLE_CODE_DLC6                  = 1009,
	ID_DLC_ENABLE_ALL                        = 1010,
	ID_DLC_PURCHASED                         = 1011,
	ID_TCG_BATTLE_MODE_PROGRESS              = 1012,
	ID_TCG_OPPONENT_INDEX                    = 1013,
	ID_TCG_IS_ENCOUNTERED_OPPONENT           = 1014,
	ID_TCG_OPPONENT_VICTORY_COUNT            = 1015,
	ID_TCG_IS_NEW_OPPONENT                   = 1016,
	ID_TCG_SET_OPPONENT                      = 1017,
	ID_MAX                                   = 1018,
};

// Enum AT.EDestructParamType
// NumValues: 0x000B
enum class EDestructParamType : uint8
{
	KIDAN00                                  = 0,
	KIDAN01                                  = 1,
	KIDAN02                                  = 2,
	KAMEHAMEHA                               = 3,
	WALLKICK                                 = 4,
	GRAUNDKICK                               = 5,
	HARDLANDING                              = 6,
	GOKUCRASH                                = 7,
	VEGETACRASH                              = 8,
	APURUCRASH                               = 9,
	EDestructParamType_MAX                   = 10,
};

// Enum AT.EDirectionalLightType
// NumValues: 0x0004
enum class EDirectionalLightType : uint8
{
	None                                     = 0,
	Skill                                    = 1,
	Talk                                     = 2,
	MAX                                      = 3,
};

// Enum AT.EDIRECTION_TYPE
// NumValues: 0x0018
enum class EDIRECTION_TYPE : uint8
{
	DIRECTION_TYPE_NONE                      = 0,
	DIRECTION_TYPE_GAME_START                = 1,
	DIRECTION_TYPE_BATTLE_START              = 2,
	DIRECTION_TYPE_BATTLE_FINISH             = 3,
	DIRECTION_TYPE_NORMAL_SKILL              = 4,
	DIRECTION_TYPE_ASSIST_SKILL              = 5,
	DIRECTION_TYPE_SPECIAL_SKILL             = 6,
	DIRECTION_TYPE_STARSCALE_FINISH          = 7,
	DIRECTION_TYPE_LOCK                      = 8,
	DIRECTION_TYPE_LONGBLOWOFF               = 9,
	DIRECTION_TYPE_PURSUE                    = 10,
	DIRECTION_TYPE_RUSH                      = 11,
	DIRECTION_TYPE_BATTLE_DEMO               = 12,
	DIRECTION_TYPE_RETURN_FIELD              = 13,
	DIRECTION_TYPE_ASSAULT                   = 14,
	DIRECTION_TYPE_REINFORCE                 = 15,
	DIRECTION_TYPE_ANDROID_ASSAULT           = 16,
	DIRECTION_TYPE_COUNT_QTE                 = 17,
	DIRECTION_TYPE_RINGOUT                   = 18,
	DIRECTION_TYPE_SLANDER                   = 19,
	DIRECTION_TYPE_BATTLE_DEMO_FLASHBACK     = 20,
	DIRECTION_TYPE_BATTLE_DEMO_FORM_OFF      = 21,
	DIRECTION_TYPE_RUSH_QTE                  = 22,
	DIRECTION_TYPE_MAX                       = 23,
};

// Enum AT.EWishType
// NumValues: 0x0008
enum class EWishType : uint8
{
	ReviveDeadPeople                         = 0,
	WantToMeet                               = 1,
	WantOrb                                  = 2,
	WantMoney                                = 3,
	WantMoreMoney                            = 4,
	WantRare                                 = 5,
	WantMoreRare                             = 6,
	EWishType_MAX                            = 7,
};

// Enum AT.EWishCountType
// NumValues: 0x0003
enum class EWishCountType : uint8
{
	OneTimeOnly                              = 0,
	AnyNumberOfTimes                         = 1,
	EWishCountType_MAX                       = 2,
};

// Enum AT.EDRAGONBALL_PLACEMENTTYPE
// NumValues: 0x0005
enum class EDRAGONBALL_PLACEMENTTYPE : uint8
{
	NONE                                     = 0,
	RAND_FIELD                               = 1,
	RAND_ENEMY                               = 2,
	QUEST                                    = 3,
	EDRAGONBALL_MAX                          = 4,
};

// Enum AT.EEmbeddedMovieState
// NumValues: 0x0006
enum class EEmbeddedMovieState : uint8
{
	Idle                                     = 0,
	Requested                                = 1,
	Preparing                                = 2,
	Playing                                  = 3,
	Types                                    = 4,
	EEmbeddedMovieState_MAX                  = 5,
};

// Enum AT.E_SPECIAL_PROGRESS_ENCOUNT
// NumValues: 0x0003
enum class E_SPECIAL_PROGRESS_ENCOUNT : uint8
{
	NONE                                     = 0,
	VILLAIN                                  = 1,
	E_SPECIAL_PROGRESS_MAX                   = 2,
};

// Enum AT.E_ATROCIOUS_TYPE
// NumValues: 0x0005
enum class E_ATROCIOUS_TYPE : uint8
{
	NONE                                     = 0,
	MOB                                      = 1,
	NAMED                                    = 2,
	BOSS                                     = 3,
	E_ATROCIOUS_MAX                          = 4,
};

// Enum AT.E_SPAWN_CATEGORY
// NumValues: 0x0004
enum class E_SPAWN_CATEGORY : uint8
{
	VERSATILE                                = 0,
	SPECIFIED                                = 1,
	NONE                                     = 2,
	E_SPAWN_MAX                              = 3,
};

// Enum AT.E_AI_ENCOUNT_BEHAVIOR
// NumValues: 0x0004
enum class E_AI_ENCOUNT_BEHAVIOR : uint8
{
	NONE                                     = 0,
	LOITERING                                = 1,
	WARNING                                  = 2,
	E_AI_ENCOUNT_MAX                         = 3,
};

// Enum AT.EEVENT_TYPE
// NumValues: 0x0098
enum class EEVENT_TYPE : uint8
{
	EVENT_TYPE_NONE                          = 0,
	EVENT_DEFAULT_PLAYER_INITIALIZE_BEGAN    = 1,
	EVENT_DEFAULT_PLAYER_INITIALIZED         = 2,
	EVENT_INGAME_LOAD_COMPLETED              = 3,
	EVENT_INGAME_BEGIN_PLAY                  = 4,
	EVENT_INGAME_BEGIN_PLAY_AUTO_SAVE        = 5,
	EVENT_TYPE_START_ANOMALOUS               = 6,
	EVENT_TYPE_END_ANOMALOUS                 = 7,
	EVENT_TYPE_KNOCK_OUT_ENEMY               = 8,
	EVENT_TYPE_GET_ITEM                      = 9,
	EVENT_TYPE_QUEST_GETDRAGONBALL           = 10,
	EVENT_TYPE_SEARCH_ITEM                   = 11,
	EVENT_TYPE_ARRIVAL                       = 12,
	EVENT_TYPE_OUTOFRANGE                    = 13,
	EVENT_TYPE_TALK                          = 14,
	EVENT_TYPE_TALK_END                      = 15,
	EVENT_TYPE_TALK_QUEST_START              = 16,
	EVENT_TYPE_TALK_QUEST_END                = 17,
	EVENT_TYPE_NPC_TALK_BEGIN                = 18,
	EVENT_TYPE_NPC_TALK_END                  = 19,
	EVENT_TYPE_DAMAGE                        = 20,
	EVENT_TYPE_CRITICAL                      = 21,
	EVENT_TYPE_REDUCE_HP                     = 22,
	EVENT_TYPE_CAMERA_CHANGE                 = 23,
	EVENT_TYPE_SKILL_BEGIN                   = 24,
	EVENT_TYPE_FISHING_WAIT                  = 25,
	EVENT_TYPE_FISHING_START                 = 26,
	EVENT_TYPE_FISHING_LOOP                  = 27,
	EVENT_TYPE_FISHING_END                   = 28,
	EVENT_TYPE_FISHING_POINT                 = 29,
	EVENT_TYPE_FISHING_COOL                  = 30,
	EVENT_TYPE_FISHING_AMAZING               = 31,
	EVENT_TYPE_DESTRUCT_LANDSCAPE            = 32,
	EVENT_TYPE_DESTRUCT_MESH                 = 33,
	EVENT_TYPE_LANDSCAPE_DAMAGE              = 34,
	EVENT_TYPE_WINDOW_SELECT                 = 35,
	EVENT_TYPE_HUNTING_DINO_BEGIN            = 36,
	EVENT_TYPE_HUNTING_DINO_BEGIN_SHOUT      = 37,
	EVENT_TYPE_HUNTING_DINO_END_SHOUT        = 38,
	EVENT_TYPE_HUNTING_DINO_BEGIN_QTE        = 39,
	EVENT_TYPE_HUNTING_DINO_END_QTE          = 40,
	EVENT_TYPE_HUNTING_DINO_BEGIN_SUCCESS    = 41,
	EVENT_TYPE_HUNTING_DINO_END_SUCCESS      = 42,
	EVENT_TYPE_HUNTING_DINO_BEGIN_RESULT_SUCCESS = 43,
	EVENT_TYPE_HUNTING_DINO_END_RESULT_SUCCESS = 44,
	EVENT_TYPE_HUNTING_DINO_END              = 45,
	EVENT_TYPE_TPS_SKILL_START               = 46,
	EVENT_TYPE_TPS_SKILL_END                 = 47,
	EVENT_TYPE_TPS_SKILL_CAMERA_START        = 48,
	EVENT_TYPE_PLAYER_RESCUE                 = 49,
	EVENT_TYPE_SUPPORT_RESCUE                = 50,
	EVENT_TYPE_PAUSE_BEGIN                   = 51,
	EVENT_TYPE_PAUSE_END                     = 52,
	EVENT_TYPE_MINIGAME_START                = 53,
	EVENT_TYPE_MINIGAME_END                  = 54,
	EVENT_TYPE_VEHICLE_START                 = 55,
	EVENT_TYPE_VEHICLE_END                   = 56,
	EVENT_TYPE_VEHICLE_END_FINISH            = 57,
	EVENT_TYPE_SEARCH_START                  = 58,
	EVENT_TYPE_SEARCH_CAMERACHANGED          = 59,
	EVENT_TYPE_SEARCH_END                    = 60,
	EVENT_TYPE_REQUEST_MAPICON_USER_NAVI     = 61,
	EVENT_TYPE_RESPONSE_MAPICON_USER_NAVI    = 62,
	EVENT_TYPE_REMOVE_MAPICON_USER_NAVI      = 63,
	EVENT_TYPE_BATTLE_START_EVENT            = 64,
	EVENT_TYPE_BATTLE_SETTLE                 = 65,
	EVENT_TYPE_BATTLE_END                    = 66,
	EVENT_TYPE_BREAK                         = 67,
	EVENT_TYPE_ANOMALOUS                     = 68,
	EVENT_TYPE_HEAL                          = 69,
	EVENT_TYPE_RESCUE                        = 70,
	EVENT_TYPE_CROSSTALK_TOUCHVOLUME         = 71,
	EVENT_TYPE_TOUCH_AUTOCONTROL             = 72,
	EVENT_TYPE_RACE_CHECKPOINT1              = 73,
	EVENT_TYPE_RACE_CHECKPOINT2              = 74,
	EVENT_TYPE_RACE_CHECKPOINT3              = 75,
	EVENT_TYPE_RACE_START                    = 76,
	EVENT_TYPE_RACE_CRASH1                   = 77,
	EVENT_TYPE_RACE_CRASH2                   = 78,
	EVENT_TYPE_RACE_BOOST                    = 79,
	EVENT_TYPE_RACE_TIMEUP                   = 80,
	EVENT_TYPE_RACE_GOAL                     = 81,
	EVENT_TYPE_GROUPBATTLE_DEFEAT_BOSS       = 82,
	EVENT_TYPE_CROSSTALK_BEGIN               = 83,
	EVENT_TYPE_CROSSTALK_END                 = 84,
	EVENT_TYPE_BATTLE_START_GENERAL          = 85,
	EVENT_TYPE_BATTLE_START_UNKNOWN          = 86,
	EVENT_TYPE_BATTLE_START_ENHANCE          = 87,
	EVENT_TYPE_BATTLE_START_CONTINUOUS       = 88,
	EVENT_TYPE_DISCOVER_ENEMY                = 89,
	EVENT_TYPE_CROSSTALK_REQUEST             = 90,
	EVENT_TYPE_CROSSTALK_UPDATE              = 91,
	EVENT_TYPE_CROSSTALK_LOCKON              = 92,
	EVENT_TYPE_CROSSTALK_HARAHERI_CONTINUATION = 93,
	EVENT_TYPE_BATTLE_JUSTDODGE              = 94,
	EVENT_TYPE_BATTLE_LONGBLOWOFF            = 95,
	EVENT_TYPE_TOUCH_LANDMARK                = 96,
	EVENT_TYPE_BATTLE_COMBO_COUNT            = 97,
	EVENT_TYPE_BATTLE_COMBO_END              = 98,
	EVENT_TYPE_LEVEL_UP_CUT_IN_BEGIN         = 99,
	EVENT_TYPE_LEVEL_UP_CUT_IN_END           = 100,
	EVENT_TYPE_UI_SUBTITLE_BEGIN             = 101,
	EVENT_TYPE_UI_SUBTITLE_END               = 102,
	EVENT_TYPE_LEVEL_UP_NOTICE_BEGIN         = 103,
	EVENT_TYPE_LEVEL_UP_NOTICE_END           = 104,
	EVENT_TYPE_PLATFORM_ICON_CHANGE          = 105,
	EVENT_TYPE_EVENTSECTION_BEGIN            = 106,
	EVENT_TYPE_EVENTSECTION_END              = 107,
	EVENT_TYPE_SUB_STORY_CANCEL              = 108,
	EVENT_TYPE_SHOPMENU_OPEN                 = 109,
	EVENT_TYPE_SHOPMENU_CLOSE                = 110,
	EVENT_TYPE_FIELD_NAVI_WIN_OPEN           = 111,
	EVENT_TYPE_FIELD_NAVI_WIN_CLOSE          = 112,
	EVENT_TYPE_FACE_ACTION_END               = 113,
	EVENT_TYPE_ASSAULT_SETTLE                = 114,
	EVENT_TYPE_FINISHED_ANDROID_ASSAULT_DIRECTION = 115,
	EVENT_TYPE_ENTERD_ANDROID_WARNING_AREA   = 116,
	EVENT_TYPE_DESTROYED_DRONES              = 117,
	EVENT_TYPE_INCREASED_SEARCH_GAUGE        = 118,
	EVENT_TYPE_DRONES_FOUND_PLAYER           = 119,
	EVENT_TYPE_COMING_ANDROID                = 120,
	EVENT_TYPE_VISION_BEGIN                  = 121,
	EVENT_TYPE_VISION_END                    = 122,
	EVENT_TYPE_REVERSAL                      = 123,
	EVENT_TYPE_GUARDAROUND                   = 124,
	EVENT_TYPE_GUARDBREAK                    = 125,
	EVENT_TYPE_HEATUP                        = 126,
	EVENT_TYPE_RAGE                          = 127,
	EVENT_TYPE_GUARD_TIME                    = 128,
	EVENT_TYPE_GROUNDDOWN                    = 129,
	EVENT_TYPE_DOWNCOUNT                     = 130,
	EVENT_TYPE_BATTLE_WIN                    = 131,
	EVENT_TYPE_RINGOUT_RECOVERY              = 132,
	EVENT_TYPE_RINGOUT                       = 133,
	EVENT_TYPE_JOSTLE_START                  = 134,
	EVENT_TYPE_JOSTLE_PLAYER_WIN             = 135,
	EVENT_TYPE_JOSTLE_PLAYER_LOSS            = 136,
	EVENT_TYPE_TENCOUNT_GAMEOVER             = 137,
	EVENT_TYPE_GUARDKEEPEND                  = 138,
	EVENT_TYPE_INGAME_FADE_IN                = 139,
	EVENT_TYPE_SLANDER_QTE                   = 140,
	EVENT_TYPE_FLASHBACK_START               = 141,
	EVENT_TYPE_FLASHBACK_END                 = 142,
	EVENT_TYPE_RUSH_QTE_END                  = 143,
	EVENT_TYPE_GENERAL_BATTLE_RAGE           = 144,
	EVENT_TYPE_REQUEST_AI_CROSSTALK          = 145,
	EVENT_TYPE_DOWN_RECOVERY                 = 146,
	EVENT_TYPE_QTE                           = 147,
	EVENT_TYPE_C003SKILL007FINISH            = 148,
	EVENT_TYPE_C003FORMOFF                   = 149,
	EVENT_TYPE_MAX                           = 150,
	EVENT_MAX                                = 151,
};

// Enum AT.FIELD_POINT_TYPE
// NumValues: 0x000A
enum class EFIELD_POINT_TYPE : uint8
{
	None                                     = 0,
	Fish                                     = 1,
	WindPath                                 = 2,
	Dino                                     = 3,
	Dummy                                    = 4,
	Racing                                   = 5,
	Baseball                                 = 6,
	Rescue                                   = 7,
	Punch                                    = 8,
	Max                                      = 9,
};

// Enum AT.EFIELD_ACTOR_TYPE
// NumValues: 0x0003
enum class EFIELD_ACTOR_TYPE : uint8
{
	NONE                                     = 0,
	COOKING_MACHINE                          = 1,
	MAX                                      = 2,
};

// Enum AT.FISHING_RESULT
// NumValues: 0x0006
enum class EFISHING_RESULT : uint8
{
	SUCCESS                                  = 0,
	SUCCESS_GREAT                            = 1,
	FAILD_NO_HIT                             = 2,
	FAILD_LOST                               = 3,
	FAILD_QTE                                = 4,
	MAX                                      = 5,
};

// Enum AT.EFISH_FORM_TYPE
// NumValues: 0x0004
enum class EFISH_FORM_TYPE : uint8
{
	NORMAL                                   = 0,
	SMALL                                    = 1,
	BIG                                      = 2,
	MAX                                      = 3,
};

// Enum AT.EFISH_RARITY_TYPE
// NumValues: 0x0003
enum class EFISH_RARITY_TYPE : uint8
{
	NORMAL                                   = 0,
	RARE                                     = 1,
	MAX                                      = 2,
};

// Enum AT.EFISH_COLOR_TYPE
// NumValues: 0x0002
enum class EFISH_COLOR_TYPE : uint8
{
	DEFAULT                                  = 0,
	MAX                                      = 1,
};

// Enum AT.EFISH_GROUP
// NumValues: 0x0003
enum class EFISH_GROUP : uint8
{
	RIVER                                    = 0,
	OCEAN                                    = 1,
	MAX                                      = 2,
};

// Enum AT.EFISHING_RESULT_TYPE
// NumValues: 0x0005
enum class EFISHING_RESULT_TYPE : uint8
{
	NONE                                     = 0,
	SUCCESS                                  = 1,
	SUCCESS_GREAT                            = 2,
	FAILD                                    = 3,
	MAX                                      = 4,
};

// Enum AT.EFISHING_QTE_TYPE
// NumValues: 0x0004
enum class EFISHING_QTE_TYPE : uint8
{
	NONE                                     = 0,
	PULL                                     = 1,
	ATTACK                                   = 2,
	MAX                                      = 3,
};

// Enum AT.EFISHING_INPUT_TYPE_NEW
// NumValues: 0x0005
enum class EFISHING_INPUT_TYPE_NEW : uint8
{
	RU                                       = 0,
	RD                                       = 1,
	RL                                       = 2,
	RR                                       = 3,
	MAX                                      = 4,
};

// Enum AT.FISH_ACTION_STATE
// NumValues: 0x0006
enum class EFISH_ACTION_STATE : uint8
{
	PULL                                     = 0,
	SUCCESS                                  = 1,
	MISS                                     = 2,
	RESULT_START                             = 3,
	RESULT_LOOP                              = 4,
	MAX                                      = 5,
};

// Enum AT.EFISHING_STATE_NEW
// NumValues: 0x0014
enum class EFISHING_STATE_NEW : uint8
{
	NONE                                     = 0,
	BITE                                     = 1,
	FISHING_START                            = 2,
	FISHING                                  = 3,
	FISHING_ESCAPE                           = 4,
	FISHING_ESCAPE_WAIT                      = 5,
	FISHING_HIT                              = 6,
	QTE_PULL                                 = 7,
	QTE_ATTACK                               = 8,
	RESULT                                   = 9,
	FISHING_ITEMLIMIT                        = 10,
	FISHING_ITEMLIMIT_WAIT                   = 11,
	UI_HEADER_OUT_BEFORE_RESULT              = 12,
	UI_HEADER_OUT_WAIT                       = 13,
	END                                      = 14,
	FINISH                                   = 15,
	FINISH_END                               = 16,
	TUTORIAL                                 = 17,
	TUTORIAL_WAIT                            = 18,
	MAX                                      = 19,
};

// Enum AT.EFishID
// NumValues: 0x0013
enum class EFishID : uint8
{
	None                                     = 0,
	Ani004p1c01                              = 1,
	Ani004p1c02                              = 2,
	Ani004p1c03                              = 3,
	Ani004p1c04                              = 4,
	Ani004p2c01                              = 5,
	Ani004p2c02                              = 6,
	Ani004p2c03                              = 7,
	Ani004p2c04                              = 8,
	Ani004p3c01                              = 9,
	Ani004p3c02                              = 10,
	Ani004p3c03                              = 11,
	Ani004p3c04                              = 12,
	Ani006c01                                = 13,
	Ani006c02                                = 14,
	Ani006c03                                = 15,
	Ani022c01                                = 16,
	Ani022c02                                = 17,
	Max                                      = 18,
};

// Enum AT.E_SCHOOLOFFISH_TYPE
// NumValues: 0x0014
enum class E_SCHOOLOFFISH_TYPE : uint8
{
	SCHOOLOFFISH_A_00                        = 0,
	SCHOOLOFFISH_A_01                        = 1,
	SCHOOLOFFISH_A_02                        = 2,
	SCHOOLOFFISH_A_03                        = 3,
	SCHOOLOFFISH_B_00                        = 4,
	SCHOOLOFFISH_B_01                        = 5,
	SCHOOLOFFISH_B_02                        = 6,
	SCHOOLOFFISH_B_03                        = 7,
	SCHOOLOFFISH_C_00                        = 8,
	SCHOOLOFFISH_C_01                        = 9,
	SCHOOLOFFISH_C_02                        = 10,
	SCHOOLOFFISH_C_03                        = 11,
	SCHOOLOFFISH_D_00                        = 12,
	SCHOOLOFFISH_D_01                        = 13,
	SCHOOLOFFISH_D_02                        = 14,
	SCHOOLOFFISH_Z_00                        = 15,
	SCHOOLOFFISH_Z_01                        = 16,
	SCHOOLOFFISH_Z_02                        = 17,
	SCHOOLOFFISH_Z_03                        = 18,
	MAX                                      = 19,
};

// Enum AT.E_BAIT_EFFECT_TYPE
// NumValues: 0x0004
enum class E_BAIT_EFFECT_TYPE : uint8
{
	BAIT_EFFECT_NORMAL                       = 0,
	BAIT_EFFECT_RARE                         = 1,
	BAIT_EFFECT_SUPER_RARE                   = 2,
	BAIT_EFFECT_MAX                          = 3,
};

// Enum AT.E_BAIT_TYPE
// NumValues: 0x000B
enum class E_BAIT_TYPE : uint8
{
	BAIT_NONE                                = 0,
	BAIT_FISHSHADOW_UP                       = 1,
	BAIT_REALITY_UP                          = 2,
	BAIT_RAREFISH_ATTENTION_UP               = 3,
	BAIT_FISH_SIZE_UP                        = 4,
	BAIT_REACTION_UP                         = 5,
	BAIT_ESCAPE_DOWN                         = 6,
	BAIT_QTE_SIMPLIE                         = 7,
	BAIT_ITEMGET_LOTUP                       = 8,
	BAIT_ITEMGET_FRAMEUP                     = 9,
	BAIT_MAX                                 = 10,
};

// Enum AT.EFishState
// NumValues: 0x0007
enum class EFishState : uint8
{
	Swim                                     = 0,
	SwimSlow                                 = 1,
	Wait                                     = 2,
	Attracted                                = 3,
	Runaway                                  = 4,
	Caught                                   = 5,
	Max                                      = 6,
};

// Enum AT.E_FLIGHT_PTN
// NumValues: 0x0006
enum class E_FLIGHT_PTN : uint8
{
	PTN_01                                   = 0,
	PTN_02                                   = 1,
	PTN_03                                   = 2,
	PTN_04                                   = 3,
	PTN_05                                   = 4,
	PTN_MAX                                  = 5,
};

// Enum AT.EFusionType
// NumValues: 0x0004
enum class EFusionType : uint8
{
	None                                     = 0,
	Vegito                                   = 1,
	Gotenks                                  = 2,
	Max                                      = 3,
};

// Enum AT.EGrassChannels
// NumValues: 0x0004
enum class EGrassChannels : uint8
{
	Red                                      = 0,
	Green                                    = 1,
	Blue                                     = 2,
	EGrassChannels_MAX                       = 3,
};

// Enum AT.EGrassDataScaling
// NumValues: 0x0004
enum class EGrassDataScaling : uint8
{
	Uniform                                  = 0,
	Free                                     = 1,
	LockXY                                   = 2,
	EGrassDataScaling_MAX                    = 3,
};

// Enum AT.EHudVisibleCategory
// NumValues: 0x0004
enum class EHudVisibleCategory : uint8
{
	HUD_VISHIBLE_NONE                        = 0,
	HUD_VISHIBLE_DEFAULT                     = 1,
	HUD_VISHIBLE_QUEST                       = 2,
	HUD_VISHIBLE_MAX                         = 3,
};

// Enum AT.E_HUD_TYPE
// NumValues: 0x0018
enum class E_HUD_TYPE : uint8
{
	NONE                                     = 0,
	DEMO                                     = 1,
	GENERAL_DEMO                             = 2,
	GENERAL_TALK_DEMO                        = 3,
	TALK                                     = 4,
	NONBATTLE                                = 5,
	BATTLE                                   = 6,
	ENCOUNTER                                = 7,
	BATTLEDEMO                               = 8,
	BTL_SKILL_DEMO                           = 9,
	BACK_ATTACK                              = 10,
	SKILLPALETTE                             = 11,
	EVENT                                    = 12,
	SUBQUEST                                 = 13,
	FISHING                                  = 14,
	MINIGAME_RACE                            = 15,
	MINIGAME_BASEBALL                        = 16,
	MINIGAME_HUNT                            = 17,
	EXCLUSIVE_LEVEL_UP_CUT_IN                = 18,
	WORLD_MAP                                = 19,
	TB_RINGOUT                               = 20,
	BATTLE_WARNING                           = 21,
	ALL                                      = 22,
	MAX                                      = 23,
};

// Enum AT.EITEM_ID
// NumValues: 0x0002
enum class EITEM_ID : uint8
{
	NONE                                     = 0,
	EITEM_MAX                                = 1,
};

// Enum AT.EITEM_ICON_EFF_TYPE
// NumValues: 0x0013
enum class EITEM_ICON_EFF_TYPE : uint8
{
	NONE                                     = 0,
	SOUL_EM_FAV_UP                           = 1,
	SOUL_EM_COOKING_UP                       = 2,
	SOUL_EM_TRAINING_UP                      = 3,
	SOUL_EM_DEVELOP_UP                       = 4,
	SOUL_EM_GODS_UP                          = 5,
	SOUL_EM_ADULT_UP                         = 6,
	SOUL_EM_ADVENTURE_UP                     = 7,
	SOUL_EM_ZFIGHTERS_UP                     = 8,
	SOUL_EM_COOKING_MAXUP                    = 9,
	SOUL_EM_TRAINING_MAXUP                   = 10,
	SOUL_EM_DEVELOP_MAXUP                    = 11,
	SOUL_EM_GODS_MAXUP                       = 12,
	SOUL_EM_ADULT_MAXUP                      = 13,
	SOUL_EM_ADVENTURE_MAXUP                  = 14,
	SOUL_EM_ZFIGHTERS_MAXUP                  = 15,
	HEAL_HP_PARSENT                          = 16,
	HEAL_HP_FIXED                            = 17,
	EITEM_ICON_EFF_MAX                       = 18,
};

// Enum AT.EITEM_ITYPE
// NumValues: 0x0009
enum class EITEM_ITYPE : uint8
{
	NONE                                     = 0,
	CONSUME                                  = 1,
	IMPORTANT                                = 2,
	FOOD                                     = 3,
	MATERIAL                                 = 4,
	RECIPE                                   = 5,
	BENTO                                    = 6,
	SOUL_EM                                  = 7,
	MAX                                      = 8,
};

// Enum AT.EItemChipType
// NumValues: 0x0004
enum class EItemChipType : uint8
{
	CHIP                                     = 0,
	AirCHIP                                  = 1,
	FootCHIP                                 = 2,
	EItemChipType_MAX                        = 3,
};

// Enum AT.ESpecialBentoType
// NumValues: 0x0004
enum class ESpecialBentoType : uint8
{
	None                                     = 0,
	ExpGive                                  = 1,
	MealTicket                               = 2,
	ESpecialBentoType_MAX                    = 3,
};

// Enum AT.EBoolDisplay
// NumValues: 0x0003
enum class EBoolDisplay : uint8
{
	BOOL_FALSE                               = 0,
	BOOL_TRUE                                = 1,
	BOOL_MAX                                 = 2,
};

// Enum AT.EUseItemParticleColor
// NumValues: 0x0005
enum class EUseItemParticleColor : uint8
{
	None                                     = 0,
	Red                                      = 1,
	Green                                    = 2,
	Blue                                     = 3,
	Max                                      = 4,
};

// Enum AT.EUseItemParticle
// NumValues: 0x0007
enum class EUseItemParticle : uint8
{
	None                                     = 0,
	HealS                                    = 1,
	HealM                                    = 2,
	HealL                                    = 3,
	HealContinue                             = 4,
	Beans                                    = 5,
	Max                                      = 6,
};

// Enum AT.EITEM_EFF_TARGET
// NumValues: 0x0004
enum class EITEM_EFF_TARGET : uint8
{
	NONE                                     = 0,
	SET_TARGET                               = 1,
	PARTY_FRIEND_ALL                         = 2,
	EITEM_EFF_MAX                            = 3,
};

// Enum AT.EITEM_ICON_CATEGORY_TYPE
// NumValues: 0x0018
enum class EITEM_ICON_CATEGORY_TYPE : uint8
{
	MEAT                                     = 0,
	FISH                                     = 1,
	RICE                                     = 2,
	NOODLES                                  = 3,
	TENSHIN                                  = 4,
	DESSERT                                  = 5,
	COOK_1                                   = 6,
	ALL                                      = 7,
	RECOVERY                                 = 8,
	IMPORTANT                                = 9,
	Z_WARRIOR                                = 10,
	TRAINING                                 = 11,
	COOK_2                                   = 12,
	DEVELOPMENT                              = 13,
	ADVENTURE                                = 14,
	GODS                                     = 15,
	ADULTS                                   = 16,
	BENTO                                    = 17,
	PARTS_MAT                                = 18,
	PARTS_EQUIP                              = 19,
	ROBOT                                    = 20,
	CAR                                      = 21,
	PRESENT                                  = 22,
	MAX                                      = 23,
};

// Enum AT.EITEM_ICON_TYPE
// NumValues: 0x0048
enum class EITEM_ICON_TYPE : uint8
{
	NONE                                     = 0,
	FISH                                     = 1,
	FRUIT                                    = 2,
	RICE                                     = 3,
	WHEAT                                    = 4,
	MEAT                                     = 5,
	OTHER_FOOD                               = 6,
	BENTO                                    = 7,
	RECIPE                                   = 8,
	GROUP_RECIPE                             = 9,
	SPEED_TIP_1                              = 10,
	SPEED_TIP_2                              = 11,
	SPEED_TIP_3                              = 12,
	BATTERY_TIP_1                            = 13,
	BATTERY_TIP_2                            = 14,
	BATTERY_TIP_3                            = 15,
	RADER_TIP_1                              = 16,
	RADER_TIP_2                              = 17,
	RADER_TIP_3                              = 18,
	EFFICIENCY_TIP_1                         = 19,
	EFFICIENCY_TIP_2                         = 20,
	EFFICIENCY_TIP_3                         = 21,
	DISCOVERABILITY_TIP_1                    = 22,
	DISCOVERABILITY_TIP_2                    = 23,
	DISCOVERABILITY_TIP_3                    = 24,
	GEAR_MATERIAL                            = 25,
	ANIMAL_MATERIAL                          = 26,
	UTIL_CAPSULE                             = 27,
	MECA_CAPSULE                             = 28,
	FISHING_BAIT                             = 29,
	CRYSTAL_MATERIAL                         = 30,
	JEWELY                                   = 31,
	TREASURE                                 = 32,
	BEANS_MEDICINE                           = 33,
	BOTTLE_MEDICINE                          = 34,
	CAN_MEDICINE                             = 35,
	TABLET_MEDICINE                          = 36,
	ZENEY                                    = 37,
	PRESENT                                  = 38,
	EXPERIENCE                               = 39,
	FAVORABILITY                             = 40,
	TROPHY                                   = 41,
	DMEDAL                                   = 42,
	ZORB_BLUE                                = 43,
	ZORB_RED                                 = 44,
	ZORB_GREEN                               = 45,
	ZORB_RAINBOW                             = 46,
	ZORB_WHITE                               = 47,
	ZORB_PUREWHITE                           = 48,
	EXP_ITEM_1                               = 49,
	EXP_ITEM_2                               = 50,
	EXP_ITEM_3                               = 51,
	EXP_ITEM_4                               = 52,
	EXP_ITEM_5                               = 53,
	EXP_ITEM_6                               = 54,
	DRONE_PART                               = 55,
	GRD_SUPERENEMY                           = 56,
	GRD_ENEMY                                = 57,
	OTHER_FOOD_ICE                           = 58,
	OTHER_FOOD_TAKOYAKI                      = 59,
	OTHER_FOOD_HOTDOG                        = 60,
	PUBLIC_ORDER_DADGE_BRONZE                = 61,
	PUBLIC_ORDER_DADGE_SILVER                = 62,
	PUBLIC_ORDER_DADGE_GOLD                  = 63,
	PUBLIC_ORDER_DADGE_PLATINUM              = 64,
	GRD_ENEMY_GROUP                          = 65,
	GRD_ENEMY_ROBOT                          = 66,
	GRD_ENEMY_DRONE                          = 67,
	MEAL_TICKET_NORMAL                       = 68,
	MEAL_TICKET_HIGH_CLASS                   = 69,
	MEAL_TICKET_FULL_COURSE                  = 70,
	MAX                                      = 71,
};

// Enum AT.EItemPaletteFace
// NumValues: 0x0005
enum class EItemPaletteFace : uint8
{
	Right                                    = 0,
	Up                                       = 1,
	Left                                     = 2,
	Down                                     = 3,
	Max                                      = 4,
};

// Enum AT.ERecipeDevelopType
// NumValues: 0x0005
enum class ERecipeDevelopType : uint8
{
	NONE                                     = 0,
	PARTS                                    = 1,
	CHIP                                     = 2,
	MECHA                                    = 3,
	MAX                                      = 4,
};

// Enum AT.ERecipeCondition
// NumValues: 0x0003
enum class ERecipeCondition : uint8
{
	Item                                     = 0,
	Comm                                     = 1,
	ERecipeCondition_MAX                     = 2,
};

// Enum AT.EItemIDSubCategoryRecipe
// NumValues: 0x0008
enum class EItemIDSubCategoryRecipe : uint8
{
	None                                     = 0,
	Meat                                     = 1,
	Fish                                     = 2,
	Rice                                     = 3,
	Noodles                                  = 4,
	Dessert                                  = 5,
	Course                                   = 6,
	EItemIDSubCategoryRecipe_MAX             = 7,
};

// Enum AT.EItemIDSubCategoryValuables
// NumValues: 0x0002
enum class EItemIDSubCategoryValuables : uint8
{
	None                                     = 0,
	EItemIDSubCategoryValuables_MAX          = 1,
};

// Enum AT.EItemIDSubCategoryPresent
// NumValues: 0x000A
enum class EItemIDSubCategoryPresent : uint8
{
	None                                     = 0,
	Cook                                     = 1,
	Training                                 = 2,
	Develop                                  = 3,
	Gods                                     = 4,
	Adult                                    = 5,
	Adventure                                = 6,
	ZFighters                                = 7,
	Specital                                 = 8,
	EItemIDSubCategoryPresent_MAX            = 9,
};

// Enum AT.EItemIDSubCategoryChip
// NumValues: 0x0009
enum class EItemIDSubCategoryChip : uint8
{
	None                                     = 0,
	SpeedUp                                  = 1,
	BatteryUp                                = 2,
	RaderEx                                  = 3,
	GetNumUp                                 = 4,
	RareDropUp                               = 5,
	AllParamUp                               = 6,
	Other                                    = 7,
	EItemIDSubCategoryChip_MAX               = 8,
};

// Enum AT.EItemIDSubCategoryDevelop
// NumValues: 0x0005
enum class EItemIDSubCategoryDevelop : uint8
{
	None                                     = 0,
	Ore                                      = 1,
	MechaParts                               = 2,
	Animal                                   = 3,
	EItemIDSubCategoryDevelop_MAX            = 4,
};

// Enum AT.EItemIDSubCategoryBait
// NumValues: 0x0005
enum class EItemIDSubCategoryBait : uint8
{
	None                                     = 0,
	SuccessRateUp                            = 1,
	Rare                                     = 2,
	Reward                                   = 3,
	EItemIDSubCategoryBait_MAX               = 4,
};

// Enum AT.EItemIDSubCategoryMeterial
// NumValues: 0x0008
enum class EItemIDSubCategoryMeterial : uint8
{
	None                                     = 0,
	Meat                                     = 1,
	Fish                                     = 2,
	Rice                                     = 3,
	Wheat                                    = 4,
	Fruit                                    = 5,
	Other                                    = 6,
	EItemIDSubCategoryMeterial_MAX           = 7,
};

// Enum AT.EItemIDSubCategoryBento
// NumValues: 0x0007
enum class EItemIDSubCategoryBento : uint8
{
	None                                     = 0,
	Meat                                     = 1,
	Fish                                     = 2,
	Rice                                     = 3,
	Noodles                                  = 4,
	Dessert                                  = 5,
	EItemIDSubCategoryBento_MAX              = 6,
};

// Enum AT.EItemIDSubCategoryHeal
// NumValues: 0x0005
enum class EItemIDSubCategoryHeal : uint8
{
	None                                     = 0,
	Fixed                                    = 1,
	Percentage                               = 2,
	Maintain                                 = 3,
	EItemIDSubCategoryHeal_MAX               = 4,
};

// Enum AT.EItemIDCategory
// NumValues: 0x000D
enum class EItemIDCategory : uint8
{
	NONE                                     = 0,
	HEAL                                     = 1,
	BENTO                                    = 2,
	METERIAL                                 = 3,
	BAIT                                     = 4,
	DEVELOP                                  = 5,
	CHIP                                     = 6,
	PRESENT                                  = 7,
	IMPORTANT                                = 8,
	RECIPE                                   = 9,
	CARDDASS                                 = 10,
	FISH                                     = 11,
	MAX                                      = 12,
};

// Enum AT.EItemEffectType
// NumValues: 0x0014
enum class EItemEffectType : uint8
{
	ATK_BLOW                                 = 0,
	ATK_SHOT                                 = 1,
	ATK_SPEED                                = 2,
	ATK_ALL                                  = 3,
	CRI_RATE                                 = 4,
	DEF_BLOW                                 = 5,
	DEF_SHOT                                 = 6,
	DEF_SPEED                                = 7,
	DEF_ALL                                  = 8,
	HP_MAX                                   = 9,
	KI_MAX                                   = 10,
	KI_REGENE                                = 11,
	DROP_COUNT                               = 12,
	EXP                                      = 13,
	Z_ORB                                    = 14,
	BONUS                                    = 15,
	HEAL_PERCENT                             = 16,
	HEAL_FIXED                               = 17,
	HEAL_MAINTAIN                            = 18,
	EItemEffectType_MAX                      = 19,
};

// Enum AT.EHighlightObjectType
// NumValues: 0x000B
enum class EHighlightObjectType : uint8
{
	None                                     = 0,
	Animal                                   = 1,
	RareAnimal                               = 2,
	Tree                                     = 3,
	Pier                                     = 4,
	MiningPoint                              = 5,
	LevelLimit                               = 6,
	Enemy                                    = 7,
	TrainingPoint                            = 8,
	Memories                                 = 9,
	EHighlightObjectType_MAX                 = 10,
};

// Enum AT.EDestructType
// NumValues: 0x0007
enum class EDestructType : uint8
{
	None                                     = 0,
	Sphere                                   = 1,
	Donut                                    = 2,
	Capsule                                  = 3,
	CapsuleSphere                            = 4,
	DeathBeam                                = 5,
	EDestructType_MAX                        = 6,
};

// Enum AT.ELipSyncInterpolateType
// NumValues: 0x0002
enum class ELipSyncInterpolateType : uint8
{
	Linear                                   = 0,
	ELipSyncInterpolateType_MAX              = 1,
};

// Enum AT.ELipSyncType
// NumValues: 0x0002
enum class ELipSyncType : uint8
{
	Area                                     = 0,
	ELipSyncType_MAX                         = 1,
};

// Enum AT.ETALK_TYPE
// NumValues: 0x0003
enum class ETALK_TYPE : uint8
{
	SUBTITLE                                 = 0,
	MESSAGE_BOX                              = 1,
	ETALK_MAX                                = 2,
};

// Enum AT.DRAW_POS
// NumValues: 0x000B
enum class EDRAW_POS : uint8
{
	DRAW_POS_CENTER_CENTER                   = 0,
	DRAW_POS_CENTER_TOP                      = 1,
	DRAW_POS_CENTER_BOTTOM                   = 2,
	DRAW_POS_LEFT_CENTER                     = 3,
	DRAW_POS_RIGHT_CENTER                    = 4,
	DRAW_POS_LEFT_TOP                        = 5,
	DRAW_POS_RIGHT_TOP                       = 6,
	DRAW_POS_LEFT_BOTTOM                     = 7,
	DRAW_POS_RIGHT_BOTTOM                    = 8,
	DRAW_POS_CENTER_BOTTOM_3_4               = 9,
	DRAW_POS_MAX                             = 10,
};

// Enum AT.MOVIE_MODE
// NumValues: 0x0004
enum class EMOVIE_MODE : uint8
{
	MOVIE_MODE_TEXTURE                       = 0,
	MOVIE_MODE_MATERIAL                      = 1,
	MOVIE_MODE_GFX                           = 2,
	MOVIE_MODE_MAX                           = 3,
};

// Enum AT.TEXT_ALIGN
// NumValues: 0x0007
enum class ETEXT_ALIGN : uint8
{
	TEXT_ALIGN_LEFT                          = 0,
	TEXT_ALIGN_RIGHT                         = 1,
	TEXT_ALIGN_CENTER                        = 2,
	TEXT_ALIGN_CENTER_CENTER                 = 3,
	TEXT_ALIGN_LEFT_CENTER                   = 4,
	TEXT_ALIGN_RIGHT_CENTER                  = 5,
	TEXT_ALIGN_MAX                           = 6,
};

// Enum AT.EShowWindowType
// NumValues: 0x0005
enum class EShowWindowType : uint8
{
	GameWindow                               = 0,
	SystemWindow                             = 1,
	Dialog                                   = 2,
	None                                     = 3,
	Max                                      = 4,
};

// Enum AT.EMiniGameStartupType
// NumValues: 0x0005
enum class EMiniGameStartupType : uint8
{
	None                                     = 0,
	Npc                                      = 1,
	Tutorial                                 = 2,
	Quest                                    = 3,
	Max                                      = 4,
};

// Enum AT.EMiniGameFinishType
// NumValues: 0x0008
enum class EMiniGameFinishType : uint8
{
	FINISH_RETIRE                            = 0,
	FINISH_TIMEUP                            = 1,
	FINISH_NEW_RECORD                        = 2,
	FINISH_NOT_NEW_RECORD                    = 3,
	FINISH_NEW_RECORD_HOMERUN                = 4,
	FINISH_NOT_NEW_RECORD_HOMERUN            = 5,
	FINISH_NOT_NEWRECORD_NOT_HOMERUN         = 6,
	FINISH_MAX                               = 7,
};

// Enum AT.EMobIconHiddenDLCType
// NumValues: 0x0008
enum class EMobIconHiddenDLCType : uint8
{
	None                                     = 0,
	DLC1                                     = 1,
	DLC2                                     = 2,
	DLC3                                     = 3,
	DLC4                                     = 4,
	DLC5                                     = 5,
	DLC6                                     = 6,
	EMobIconHiddenDLCType_MAX                = 7,
};

// Enum AT.MOB_ICON_TYPE
// NumValues: 0x001F
enum class EMOB_ICON_TYPE : uint8
{
	NONE                                     = 0,
	TALK                                     = 1,
	CHECKUP                                  = 2,
	MAIN                                     = 3,
	SUB                                      = 4,
	COOKING                                  = 5,
	FOOD                                     = 6,
	INFO                                     = 7,
	MATERIAL                                 = 8,
	BASEBALL                                 = 9,
	RACE                                     = 10,
	Card                                     = 11,
	TRAINING                                 = 12,
	TIME_MACHINE                             = 13,
	SUB_FREEZER                              = 14,
	PARTS_TRADE                              = 15,
	SaiyanHangout                            = 16,
	MedicalRoom                              = 17,
	GRD_ENEMY                                = 18,
	GRD_SUPERENEMY                           = 19,
	ICE_STALL_SHOP                           = 20,
	TAKOYAKI_STALL_SHOP                      = 21,
	HOTDOG_STALL_SHOP                        = 22,
	SUB_DLC05                                = 23,
	Police                                   = 24,
	Restaurant                               = 25,
	GRD_ENEMY_GROUP                          = 26,
	Fortuneteller_BABA                       = 27,
	DlcStory06SubQuest                       = 28,
	MAX_NUM                                  = 29,
	MOB_ICON_MAX                             = 30,
};

// Enum AT.ENpcLook
// NumValues: 0x0005
enum class ENpcLook : uint8
{
	None                                     = 0,
	Random                                   = 1,
	Sometimes                                = 2,
	Always                                   = 3,
	Max                                      = 4,
};

// Enum AT.EAnimalID
// NumValues: 0x0022
enum class EAnimalID : uint8
{
	None                                     = 0,
	Ani001c01                                = 1,
	Ani001c02                                = 2,
	Ani001c03                                = 3,
	Ani002c01                                = 4,
	Ani002c02                                = 5,
	Ani010c01                                = 6,
	Ani010c02                                = 7,
	Ani010c03                                = 8,
	Ani008c01                                = 9,
	Ani009c01                                = 10,
	Ani009c02                                = 11,
	Ani021c01                                = 12,
	Ani016c01                                = 13,
	Ani007c01                                = 14,
	Ani007c02                                = 15,
	Ani007c03                                = 16,
	Ani007c04                                = 17,
	Ani015c01                                = 18,
	Ani015c02                                = 19,
	Ani011c01                                = 20,
	Ani013c01                                = 21,
	Ani013c02                                = 22,
	Ani014c01                                = 23,
	Ani014c02                                = 24,
	Ani014c03                                = 25,
	Ani017c01                                = 26,
	Ani017c02                                = 27,
	Ani017c03                                = 28,
	Ani017c04                                = 29,
	Ani017c05                                = 30,
	Ani019p1c01                              = 31,
	Ani018p1c01                              = 32,
	Max                                      = 33,
};

// Enum AT.ENpcMobType
// NumValues: 0x0016
enum class ENpcMobType : uint8
{
	MHM_01                                   = 0,
	MHM_02                                   = 1,
	MHM_03                                   = 2,
	MHM_04                                   = 3,
	MHM_05                                   = 4,
	MHF_01                                   = 5,
	MHF_03                                   = 6,
	MHF_04                                   = 7,
	MHF_05                                   = 8,
	MNM_01                                   = 9,
	MNM_02                                   = 10,
	MNM_04                                   = 11,
	MNM_05                                   = 12,
	MAM_01                                   = 13,
	MAM_02                                   = 14,
	MAM_03                                   = 15,
	MAM_04                                   = 16,
	MAM_05                                   = 17,
	MAM_06                                   = 18,
	MFM_03                                   = 19,
	OTHER                                    = 20,
	MAX                                      = 21,
};

// Enum AT.ENpcParts
// NumValues: 0x0005
enum class ENpcParts : uint8
{
	FACE                                     = 0,
	HAIR                                     = 1,
	BODY                                     = 2,
	ITEM                                     = 3,
	MAX                                      = 4,
};

// Enum AT.NpcState
// NumValues: 0x0025
enum class ENpcState : uint8
{
	NEUTRAL                                  = 0,
	WAIT                                     = 1,
	TALK                                     = 2,
	WALK                                     = 3,
	RUN                                      = 4,
	SURPRISE                                 = 5,
	STAGGER                                  = 6,
	GREETING                                 = 7,
	FLIGHT                                   = 8,
	CRY                                      = 9,
	GLIDE                                    = 10,
	EAT                                      = 11,
	WATCH                                    = 12,
	SIT                                      = 13,
	SIT_TALK_L_1                             = 14,
	SIT_TALK_L_2                             = 15,
	SIT_TALK_S_1                             = 16,
	SIT_TALK_S_2                             = 17,
	STAND_TALK_L_1                           = 18,
	STAND_TALK_L_2                           = 19,
	STAND_TALK_S_1                           = 20,
	STAND_TALK_S_2                           = 21,
	WAIT_2                                   = 22,
	WAIT_3                                   = 23,
	DOWN                                     = 24,
	HOWL                                     = 25,
	TURN                                     = 26,
	DIVE                                     = 27,
	FARM_WORK_SIT                            = 28,
	FARM_WORK_PLOW                           = 29,
	SIT_CROSS_LEGGED                         = 30,
	SAD_LADY                                 = 31,
	FLOAT_MOB                                = 32,
	FLIGHT_MOB                               = 33,
	DRINK_SIT                                = 34,
	LAUGHTER_SIT                             = 35,
	MAX                                      = 36,
};

// Enum AT.E_NPC_ACTIONTYPE
// NumValues: 0x0041
enum class E_NPC_ACTIONTYPE : uint8
{
	NON_ACTION                               = 0,
	WAITING_1                                = 1,
	WAITING_2                                = 2,
	WAITING_3                                = 3,
	STOP_AND_TALK                            = 4,
	SIT_TALK_L_1                             = 5,
	SIT_TALK_L_2                             = 6,
	SIT_TALK_S_1                             = 7,
	SIT_TALK_S_2                             = 8,
	STAND_TALK_L_1                           = 9,
	STAND_TALK_L_2                           = 10,
	STAND_TALK_S_1                           = 11,
	STAND_TALK_S_2                           = 12,
	WALKING                                  = 13,
	SURPRISE1                                = 14,
	SURPRISE2                                = 15,
	SURPRISE3                                = 16,
	STAGGER_F                                = 17,
	STAGGER_B                                = 18,
	SIT_STAGGER_F                            = 19,
	SIT_STAGGER_B                            = 20,
	ESCAPE                                   = 21,
	WATCH                                    = 22,
	AVOID                                    = 23,
	FLIGHT                                   = 24,
	PATH_FLIGHT                              = 25,
	WANDER                                   = 26,
	CRY                                      = 27,
	GLIDE                                    = 28,
	EAT                                      = 29,
	POINT_FLIGHT                             = 30,
	BRANCH_PATH_FLIGHT                       = 31,
	PATH_WALKING                             = 32,
	SPLINE_MOVE                              = 33,
	RUN                                      = 34,
	FLIGHTFADEOUT                            = 35,
	DOWN                                     = 36,
	HOWL                                     = 37,
	SPAWN_EGG                                = 38,
	HOVERING                                 = 39,
	DOG_BARK                                 = 40,
	DOG_GREET                                = 41,
	DOG_WATCH                                = 42,
	DOG_SMELL                                = 43,
	DIVE                                     = 44,
	SIT                                      = 45,
	GREETING                                 = 46,
	LOOK                                     = 47,
	INVISIBLE                                = 48,
	DESTROY                                  = 49,
	DINOSAUR_WALK                            = 50,
	DINOSAUR_RUN                             = 51,
	DINOSAUR_ROAR                            = 52,
	DINOSAUR_DAMAGE                          = 53,
	DINOSAUR_DOWN                            = 54,
	DINOSAUR_RUNEND                          = 55,
	FARM_WORK_SIT                            = 56,
	FARM_WORK_PLOW                           = 57,
	SIT_CROSS_LEGGED                         = 58,
	SAD_LADY                                 = 59,
	FLOAT_MOB                                = 60,
	FLIGHT_MOB                               = 61,
	DRINK_SIT                                = 62,
	LAUGHTER_SIT                             = 63,
	MAX                                      = 64,
};

// Enum AT.E_NPC_ACTIONTYPE_ID
// NumValues: 0x0041
enum class E_NPC_ACTIONTYPE_ID : uint8
{
	NPC_ACTION_00                            = 0,
	NPC_ACTION_01_1                          = 1,
	NPC_ACTION_01_2                          = 2,
	NPC_ACTION_01_3                          = 3,
	NPC_ACTION_02_1                          = 4,
	NPC_ACTION_02_2_1                        = 5,
	NPC_ACTION_02_2_2                        = 6,
	NPC_ACTION_02_3_1                        = 7,
	NPC_ACTION_02_3_2                        = 8,
	NPC_ACTION_02_4_1                        = 9,
	NPC_ACTION_02_4_2                        = 10,
	NPC_ACTION_02_5_1                        = 11,
	NPC_ACTION_02_5_2                        = 12,
	NPC_ACTION_03                            = 13,
	NPC_ACTION_04_1                          = 14,
	NPC_ACTION_04_2                          = 15,
	NPC_ACTION_04_3                          = 16,
	NPC_ACTION_05_1                          = 17,
	NPC_ACTION_05_2                          = 18,
	NPC_ACTION_05_3                          = 19,
	NPC_ACTION_05_4                          = 20,
	NPC_ACTION_06                            = 21,
	NPC_ACTION_07                            = 22,
	NPC_ACTION_08                            = 23,
	NPC_ACTION_09                            = 24,
	NPC_ACTION_10                            = 25,
	NPC_ACTION_11                            = 26,
	NPC_ACTION_12                            = 27,
	NPC_ACTION_13                            = 28,
	NPC_ACTION_14                            = 29,
	NPC_ACTION_15                            = 30,
	NPC_ACTION_16                            = 31,
	NPC_ACTION_17                            = 32,
	NPC_ACTION_18                            = 33,
	NPC_ACTION_19                            = 34,
	NPC_ACTION_20                            = 35,
	NPC_ACTION_21                            = 36,
	NPC_ACTION_22                            = 37,
	NPC_ACTION_23                            = 38,
	NPC_ACTION_24                            = 39,
	NPC_ACTION_25                            = 40,
	NPC_ACTION_26                            = 41,
	NPC_ACTION_27                            = 42,
	NPC_ACTION_28                            = 43,
	NPC_ACTION_29                            = 44,
	NPC_ACTION_40                            = 45,
	NPC_ACTION_50                            = 46,
	NPC_ACTION_51                            = 47,
	NPC_ACTION_100                           = 48,
	NPC_ACTION_101                           = 49,
	NPC_ACTION_60                            = 50,
	NPC_ACTION_61                            = 51,
	NPC_ACTION_62                            = 52,
	NPC_ACTION_63                            = 53,
	NPC_ACTION_64                            = 54,
	NPC_ACTION_65                            = 55,
	NPC_ACTION_70                            = 56,
	NPC_ACTION_71                            = 57,
	NPC_ACTION_72                            = 58,
	NPC_ACTION_73                            = 59,
	NPC_ACTION_74                            = 60,
	NPC_ACTION_75                            = 61,
	NPC_ACTION_76                            = 62,
	NPC_ACTION_77                            = 63,
	NPC_ACTION_MAX                           = 64,
};

// Enum AT.E_ANIMAL_CONDITION_TYPE
// NumValues: 0x0017
enum class E_ANIMAL_CONDITION_TYPE : uint8
{
	NPC_CONDITION_00                         = 0,
	NPC_CONDITION_01                         = 1,
	NPC_CONDITION_02                         = 2,
	NPC_CONDITION_03                         = 3,
	NPC_CONDITION_04                         = 4,
	NPC_CONDITION_05                         = 5,
	NPC_CONDITION_06                         = 6,
	NPC_CONDITION_07                         = 7,
	NPC_CONDITION_08                         = 8,
	NPC_CONDITION_09                         = 9,
	NPC_CONDITION_10                         = 10,
	NPC_CONDITION_11                         = 11,
	NPC_CONDITION_12                         = 12,
	NPC_CONDITION_13                         = 13,
	NPC_CONDITION_14                         = 14,
	NPC_CONDITION_15                         = 15,
	NPC_CONDITION_16                         = 16,
	NPC_CONDITION_17                         = 17,
	NPC_CONDITION_18                         = 18,
	NPC_CONDITION_19                         = 19,
	NPC_CONDITION_20                         = 20,
	NPC_CONDIIONT_MAX                        = 21,
	NPC_MAX                                  = 22,
};

// Enum AT.E_ANIMAL_ACTION_CATEGORY
// NumValues: 0x0003
enum class E_ANIMAL_ACTION_CATEGORY : uint8
{
	MOVEACTION                               = 0,
	REACTION                                 = 1,
	E_ANIMAL_ACTION_MAX                      = 2,
};

// Enum AT.E_ANIMAL_TYPE
// NumValues: 0x000B
enum class E_ANIMAL_TYPE : uint8
{
	NONE                                     = 0,
	FLYING_DRAGON                            = 1,
	DEER                                     = 2,
	CHICKEN                                  = 3,
	MIGRATORY_BIRDS                          = 4,
	SMALL_BIRD                               = 5,
	DINOSAUR                                 = 6,
	WOLF                                     = 7,
	DOG                                      = 8,
	ANIMAL_MAX                               = 9,
	E_ANIMAL_MAX                             = 10,
};

// Enum AT.E_MOB_CATEGORY
// NumValues: 0x0009
enum class E_MOB_CATEGORY : uint8
{
	MOB_HUMAN1                               = 0,
	MOB_HUMAN2                               = 1,
	MOB_CAR                                  = 2,
	MOB_AIRPLANE                             = 3,
	MOB_ANIMAL                               = 4,
	MOB_DINOSAUR                             = 5,
	MOB_FLYINGHUMAN                          = 6,
	MOB_CATEGORY_MAX                         = 7,
	MOB_MAX                                  = 8,
};

// Enum AT.EATNpcLoopAnimType
// NumValues: 0x000A
enum class EATNpcLoopAnimType : uint8
{
	None                                     = 0,
	FarmWork01_02LP                          = 1,
	FarmWork01_03LP                          = 2,
	FarmWork02_02LP                          = 3,
	FarmWork02_03LP                          = 4,
	SitDrink_02LP                            = 5,
	SitDrink_03LP                            = 6,
	SitLaughter_02LP                         = 7,
	SitLaughter_03LP                         = 8,
	EATNpcLoopAnimType_MAX                   = 9,
};

// Enum AT.ENPC_CHECKMODE
// NumValues: 0x0003
enum class ENPC_CHECKMODE : uint8
{
	Random                                   = 0,
	Hierarchy                                = 1,
	ENPC_MAX                                 = 2,
};

// Enum AT.EPageType
// NumValues: 0x000F
enum class EPageType : uint8
{
	None                                     = 0,
	Contents                                 = 1,
	Items                                    = 2,
	Diagram                                  = 3,
	Carddass                                 = 4,
	Demo                                     = 5,
	Music                                    = 6,
	DetailText                               = 7,
	DetailTextMemory                         = 8,
	DetailImage                              = 9,
	DetailImageMemory                        = 10,
	DetailModel                              = 11,
	Memo                                     = 12,
	CardWarrior                              = 13,
	EPageType_MAX                            = 14,
};

// Enum AT.EPageLayoutType
// NumValues: 0x000A
enum class EPageLayoutType : uint8
{
	None                                     = 0,
	Contents                                 = 1,
	Items                                    = 2,
	Diagram                                  = 3,
	Carddass                                 = 4,
	Demo                                     = 5,
	Music                                    = 6,
	CardWarrior                              = 7,
	Detail                                   = 8,
	EPageLayoutType_MAX                      = 9,
};

// Enum AT.EPageLayoutState
// NumValues: 0x0010
enum class EPageLayoutState : uint8
{
	None                                     = 0,
	BuildRequest                             = 1,
	Initialized                              = 2,
	MoveBack                                 = 3,
	MoveNext                                 = 4,
	JumpIn                                   = 5,
	JumpOut                                  = 6,
	JumpIndex                                = 7,
	MemoRequest                              = 8,
	MemoIn                                   = 9,
	MemoWait                                 = 10,
	MemoOut                                  = 11,
	Animate                                  = 12,
	Idling                                   = 13,
	Closed                                   = 14,
	EPageLayoutState_MAX                     = 15,
};

// Enum AT.EPassiveSkillEffectCategory
// NumValues: 0x0012
enum class EPassiveSkillEffectCategory : uint8
{
	NONE                                     = 0,
	SHORT_RANGE_ATK_UP                       = 1,
	LONG_RANGE_ATK_UP                        = 2,
	SHORT_RANGE_DEF_UP                       = 3,
	LONG_RANGE_DEF_UP                        = 4,
	CRITICAL_UP                              = 5,
	HP_UP                                    = 6,
	REGENE_HEAL                              = 7,
	ENERGY_UP                                = 8,
	ENERGY_RECOVERY_UP                       = 9,
	EXPERIENCE_UP                            = 10,
	GET_ZORB_UP                              = 11,
	DROP_UP                                  = 12,
	DROP_NUM_UP                              = 13,
	OTHER                                    = 14,
	COMBO_LEVEL_UP                           = 15,
	COMBO_FINISH_LEVEL_UP                    = 16,
	MAX                                      = 17,
};

// Enum AT.EItemAccessPointType
// NumValues: 0x0003
enum class EItemAccessPointType : uint8
{
	Type_Mesh                                = 0,
	Type_Skeletal                            = 1,
	Type_MAX                                 = 2,
};

// Enum AT.EProceduralDataMeshDestructType
// NumValues: 0x0003
enum class EProceduralDataMeshDestructType : uint8
{
	DestructErase                            = 0,
	DestructReplace                          = 1,
	EProceduralDataMeshDestructType_MAX      = 2,
};

// Enum AT.EProjectileLockTargetInfo
// NumValues: 0x0005
enum class EProjectileLockTargetInfo : uint8
{
	None_Target                              = 0,
	TPS_Target                               = 1,
	LockOn_Target                            = 2,
	TPSandLockOn_Target                      = 3,
	EProjectileLockTargetInfo_MAX            = 4,
};

// Enum AT.ECpl003SkillS007BeamSize
// NumValues: 0x0004
enum class ECpl003SkillS007BeamSize : uint8
{
	SmallBeam                                = 0,
	MediumBeam                               = 1,
	LargeBeam                                = 2,
	ECpl003SkillS007BeamSize_MAX             = 3,
};

// Enum AT.ESpawnState
// NumValues: 0x0006
enum class ESpawnState : uint8
{
	SPAWN_OMEN_EFFECT                        = 0,
	SPAWN_PROJECTILE                         = 1,
	SPAWN_PROJECTILE_WAIT                    = 2,
	SPAWN_END                                = 3,
	SPAWN_STATE_NUM                          = 4,
	SPAWN_MAX                                = 5,
};

// Enum AT.EShotDirectionType
// NumValues: 0x0004
enum class EShotDirectionType : uint8
{
	LEFT                                     = 0,
	RIGHT                                    = 1,
	RANDOM                                   = 2,
	EShotDirectionType_MAX                   = 3,
};

// Enum AT.ECloseMenuReason
// NumValues: 0x0003
enum class ECloseMenuReason : uint8
{
	Cancel                                   = 0,
	Decide                                   = 1,
	ECloseMenuReason_MAX                     = 2,
};

// Enum AT.EMenuType
// NumValues: 0x0009
enum class EMenuType : uint8
{
	ShopTop                                  = 0,
	SuperTraining                            = 1,
	BreakthroughTraining                     = 2,
	ChallengeToGodOfDestruction              = 3,
	ChallengeFreezerF                        = 4,
	CrowdTraining                            = 5,
	SuperTrainingResult                      = 6,
	CrowdTrainingResult                      = 7,
	EMenuType_MAX                            = 8,
};

// Enum AT.ESubQuestDirectionTiming
// NumValues: 0x0005
enum class ESubQuestDirectionTiming : uint8
{
	DirectionBegan                           = 0,
	FadeOutBegan                             = 1,
	FadeInBegan                              = 2,
	GaveSoulEmblem                           = 3,
	ESubQuestDirectionTiming_MAX             = 4,
};

// Enum AT.EQUEST_GENERAL_TIMING
// NumValues: 0x0008
enum class EQUEST_GENERAL_TIMING : uint8
{
	INVALID                                  = 0,
	BEGIN                                    = 1,
	ADD_ACTOR                                = 2,
	END                                      = 3,
	REMOVE_ACTOR                             = 4,
	FORCE_END                                = 5,
	BREAK                                    = 6,
	EQUEST_GENERAL_MAX                       = 7,
};

// Enum AT.ETalkDemoStateType
// NumValues: 0x0004
enum class ETalkDemoStateType : uint8
{
	BEGIN                                    = 0,
	IDLE                                     = 1,
	FINISH                                   = 2,
	ETalkDemoStateType_MAX                   = 3,
};

// Enum AT.EQuestPauseType
// NumValues: 0x0004
enum class EQuestPauseType : uint8
{
	None                                     = 0,
	MainMenu                                 = 1,
	ReturnToMain                             = 2,
	EQuestPauseType_MAX                      = 3,
};

// Enum AT.ELightTowerKind
// NumValues: 0x0004
enum class ELightTowerKind : uint8
{
	LIGHT_TOWER_KIND_MAIN_QUEST              = 0,
	LIGHT_TOWER_KIND_SUB_QUEST               = 1,
	LIGHT_TOWER_KIND_USER                    = 2,
	LIGHT_TOWER_KIND_MAX                     = 3,
};

// Enum AT.ECHARACTER_HIDDEN_TYPE
// NumValues: 0x000A
enum class ECHARACTER_HIDDEN_TYPE : uint8
{
	None                                     = 0,
	BPFunction                               = 1,
	Demo                                     = 2,
	Event                                    = 4,
	Door                                     = 8,
	Support                                  = 16,
	UniquenessObserver                       = 32,
	UI                                       = 64,
	Need                                     = 128,
	ECHARACTER_HIDDEN_MAX                    = 129,
};

// Enum AT.EQuestBindType
// NumValues: 0x0010
enum class EQuestBindType : uint8
{
	None                                     = 0,
	Idling                                   = 1,
	SimpleTalk                               = 2,
	NpcTalk                                  = 3,
	Fade                                     = 4,
	PhaseFade                                = 5,
	Loading                                  = 6,
	Event                                    = 7,
	TalkEvent                                = 8,
	ChangeCharacter                          = 9,
	Community                                = 10,
	QuestPhase                               = 11,
	AutoControl                              = 12,
	SystemWindow                             = 13,
	Training                                 = 14,
	Max                                      = 15,
};

// Enum AT.EQUEST_UPDATE_TIMING
// NumValues: 0x0003
enum class EQUEST_UPDATE_TIMING : uint8
{
	START                                    = 0,
	END                                      = 1,
	EQUEST_UPDATE_MAX                        = 2,
};

// Enum AT.EHuntingPhaseConditionType
// NumValues: 0x0004
enum class EHuntingPhaseConditionType : uint8
{
	Animal                                   = 0,
	Dinosaurs                                = 1,
	Foods                                    = 2,
	EHuntingPhaseConditionType_MAX           = 3,
};

// Enum AT.ECommunityPhaseCondition
// NumValues: 0x0003
enum class ECommunityPhaseCondition : uint8
{
	EditEmblem                               = 0,
	NotEditEmblem                            = 1,
	ECommunityPhaseCondition_MAX             = 2,
};

// Enum AT.EFADE_COLOR
// NumValues: 0x0004
enum class EFADE_COLOR : uint8
{
	DEFAULT                                  = 0,
	BLACK                                    = 1,
	WHITE                                    = 2,
	EFADE_MAX                                = 3,
};

// Enum AT.EQUEST_WINDOW_TYPE
// NumValues: 0x000A
enum class EQUEST_WINDOW_TYPE : uint8
{
	MAIN_MENU                                = 0,
	COMMUNITY_UP_MENU                        = 1,
	TRAINING_MENU                            = 2,
	ITEM_MENU                                = 3,
	GAME_WINDOW                              = 4,
	TRAINING_ROOM_MENU                       = 5,
	MASTERING_SKILL_MENU                     = 6,
	TEAM_MENU                                = 7,
	BATTLE_HUD                               = 8,
	EQUEST_WINDOW_MAX                        = 9,
};

// Enum AT.EQUEST_PURPOSE_ANIM_TYPE
// NumValues: 0x0004
enum class EQUEST_PURPOSE_ANIM_TYPE : uint8
{
	NEXT_PHASE                               = 0,
	CHANGE_ACTIVE                            = 1,
	UPDATE                                   = 2,
	EQUEST_PURPOSE_ANIM_MAX                  = 3,
};

// Enum AT.EQuestTimingType
// NumValues: 0x0005
enum class EQuestTimingType : uint8
{
	None                                     = 0,
	Begin                                    = 1,
	Clear                                    = 2,
	Break                                    = 3,
	EQuestTimingType_MAX                     = 4,
};

// Enum AT.EDesignatedQuestTypeForEpisodeBattle
// NumValues: 0x0004
enum class EDesignatedQuestTypeForEpisodeBattle : uint8
{
	Default                                  = 0,
	MainQuest                                = 1,
	SubQuest                                 = 2,
	EDesignatedQuestTypeForEpisodeBattle_MAX = 3,
};

// Enum AT.EQuestCharacterState
// NumValues: 0x0005
enum class EQuestCharacterState : uint8
{
	Neutral                                  = 0,
	Talking                                  = 2,
	BoostFlying                              = 24,
	NotLookAtTalking                         = 25,
	EQuestCharacterState_MAX                 = 26,
};

// Enum AT.EQuestRestrictCondition
// NumValues: 0x0004
enum class EQuestRestrictCondition : uint8
{
	Default                                  = 0,
	Forced                                   = 1,
	Nothing                                  = 2,
	EQuestRestrictCondition_MAX              = 3,
};

// Enum AT.EQuestSaveCondition
// NumValues: 0x0004
enum class EQuestSaveCondition : uint8
{
	Default                                  = 0,
	Forced                                   = 1,
	Nothing                                  = 2,
	EQuestSaveCondition_MAX                  = 3,
};

// Enum AT.EQUEST_BGM_CHANGE_PERMISSION
// NumValues: 0x0004
enum class EQUEST_BGM_CHANGE_PERMISSION : uint8
{
	None                                     = 0,
	Permit                                   = 1,
	Prohibit                                 = 2,
	EQUEST_BGM_CHANGE_MAX                    = 3,
};

// Enum AT.EQUEST_SET_PHASE_TIMING
// NumValues: 0x0007
enum class EQUEST_SET_PHASE_TIMING : uint8
{
	X                                        = 0,
	Begin                                    = 1,
	AddActor                                 = 2,
	End                                      = 3,
	RemoveActor                              = 4,
	Loading                                  = 5,
	EQUEST_SET_PHASE_MAX                     = 6,
};

// Enum AT.EQUEST_ALL_ACTORS_TYPES
// NumValues: 0x0005
enum class EQUEST_ALL_ACTORS_TYPES : uint8
{
	ALL_CHARACTER_MOB                        = 0,
	ALL_COOKING_MACHINE                      = 1,
	ALL_FISHING_AREA                         = 2,
	ALL_DINOSAUR                             = 3,
	ALL_MAX                                  = 4,
};

// Enum AT.EQUEST_XO
// NumValues: 0x0003
enum class EQUEST_XO : uint8
{
	X                                        = 0,
	O                                        = 1,
	EQUEST_MAX                               = 2,
};

// Enum AT.EQUEST_TUTORIAL_INDEX
// NumValues: 0x0006
enum class EQUEST_TUTORIAL_INDEX : uint8
{
	NONE                                     = 0,
	FISHING_QUEST                            = 1,
	HOW_TO_GET_FOODS                         = 2,
	HOW_TO_HUNTING                           = 3,
	HOW_TO_GET_MINERAL                       = 4,
	EQUEST_TUTORIAL_MAX                      = 5,
};

// Enum AT.EQUEST_OCCUR_TYPE
// NumValues: 0x0003
enum class EQUEST_OCCUR_TYPE : uint8
{
	STANDING_DEMO                            = 0,
	TALK                                     = 1,
	EQUEST_OCCUR_MAX                         = 2,
};

// Enum AT.EQUEST_GENRE_TYPE
// NumValues: 0x0004
enum class EQUEST_GENRE_TYPE : uint8
{
	MAIN                                     = 0,
	SUB                                      = 1,
	BATTLE                                   = 2,
	MAX                                      = 3,
};

// Enum AT.EQUEST_PHASE_TYPE
// NumValues: 0x0030
enum class EQUEST_PHASE_TYPE : uint8
{
	NONE                                     = 0,
	ARRIVAL                                  = 1,
	OUT_OF_RANGE                             = 2,
	BATTLE                                   = 3,
	BATTLE_END                               = 4,
	BREAK_ENEMY                              = 5,
	SEARCH_ITEM                              = 6,
	GET_ITEM                                 = 7,
	TALK_NPC                                 = 8,
	GET_ITEM_TALK_NPC                        = 9,
	COOKING                                  = 10,
	HUNTING                                  = 11,
	DEVELOPMENT                              = 12,
	DEMO                                     = 13,
	START_DEMO_FADEOUT                       = 14,
	START                                    = 15,
	CLEAR                                    = 16,
	QUEST_CLEAR                              = 17,
	START_DEMO_FADEIN                        = 18,
	IDLING                                   = 19,
	SIMPLE_TALK                              = 20,
	SYSTEM_MESSAGE                           = 21,
	MULTIPLE                                 = 22,
	COMMUNITY                                = 23,
	CHANGE_CHARACTER                         = 24,
	SELECTION                                = 25,
	DOOR                                     = 26,
	BLUR                                     = 27,
	REWARD                                   = 28,
	TUTORIAL                                 = 29,
	MINIGAME                                 = 30,
	GET_FISH                                 = 31,
	WISH_DRAGONBALL                          = 32,
	CAMPING                                  = 33,
	WINDOW_CLOSED                            = 34,
	EVENT_SECTION_BEGIN                      = 35,
	EVENT_SECTION_END                        = 36,
	CONDITIONAL_SIMPLE_TALK                  = 37,
	DESTROY_ENEMIES_BASE                     = 38,
	LOADING                                  = 39,
	PERMIT_NEXT_ATROCIOUS                    = 40,
	EMPTY                                    = 41,
	ASSAULT_BATTLE                           = 42,
	OBJECT_WAIT_EVENT_BEGIN                  = 43,
	MEMORY                                   = 44,
	CREATE_PAN                               = 45,
	DELETE_PAN                               = 46,
	MAX                                      = 47,
};

// Enum AT.EDLC_QUEST_TYPE
// NumValues: 0x0004
enum class EDLC_QUEST_TYPE : uint8
{
	NONE                                     = 0,
	MAINQUEST                                = 1,
	SUBQUEST                                 = 2,
	MAX                                      = 3,
};

// Enum AT.EQUEST_TYPE
// NumValues: 0x0003
enum class EQUEST_TYPE : uint8
{
	NONE                                     = 0,
	GENERAL_QUEST                            = 1,
	MAX                                      = 2,
};

// Enum AT.ERACEGAME_RIDETYPE
// NumValues: 0x0004
enum class ERACEGAME_RIDETYPE : uint8
{
	NONE                                     = 0,
	RIDE_AIRCAR                              = 1,
	RIDE_TWINFOOT                            = 2,
	MAX                                      = 3,
};

// Enum AT.EFishingReactionVoiceTiming
// NumValues: 0x0006
enum class EFishingReactionVoiceTiming : uint8
{
	DemoStart                                = 0,
	Start                                    = 1,
	Failed                                   = 2,
	ResultCool                               = 3,
	ResultAmazing                            = 4,
	EFishingReactionVoiceTiming_MAX          = 5,
};

// Enum AT.E_CALLIMPOSSIBLESTATE
// NumValues: 0x0011
enum class E_CALLIMPOSSIBLESTATE : uint8
{
	POSSIBLE                                 = 0,
	IMPOSSIBLE                               = 1,
	NOT_RIDECHARA                            = 2,
	IN_WATER                                 = 3,
	OBSTACLE                                 = 4,
	FRONT_MOB                                = 5,
	IN_ROOM                                  = 6,
	IN_CAVE                                  = 7,
	IN_FLY                                   = 8,
	COLL_POS_FLY                             = 9,
	NIMBUSMODE                               = 10,
	ENEMY                                    = 11,
	OTHER                                    = 12,
	DINO_DIRECTION                           = 13,
	FALL                                     = 14,
	JUMP                                     = 15,
	E_MAX                                    = 16,
};

// Enum AT.E_MINERALMINIGCIRCLESTATE
// NumValues: 0x0008
enum class E_MINERALMINIGCIRCLESTATE : uint8
{
	ACTIVATE_NONE                            = 0,
	ACTIVATE_START                           = 1,
	ACTIVATE_EXTEND                          = 2,
	ACTIVATE_LOOP                            = 3,
	DEACTIVATE_START                         = 4,
	DEACTIVATE_EXTEND                        = 5,
	DEACTIVATE_LOOP                          = 6,
	E_MAX                                    = 7,
};

// Enum AT.ERideExclusionType
// NumValues: 0x0004
enum class ERideExclusionType : uint8
{
	None                                     = 0,
	Quest                                    = 1,
	Level                                    = 2,
	ERideExclusionType_MAX                   = 3,
};

// Enum AT.ERideMessageWindow
// NumValues: 0x0003
enum class ERideMessageWindow : uint8
{
	Normal                                   = 0,
	Talk                                     = 1,
	ERideMessageWindow_MAX                   = 2,
};

// Enum AT.ERideAction
// NumValues: 0x0003
enum class ERideAction : uint8
{
	On                                       = 0,
	Off                                      = 1,
	ERideAction_MAX                          = 2,
};

// Enum AT.ERideType
// NumValues: 0x0008
enum class ERideType : uint8
{
	None                                     = 0,
	AirCar                                   = 1,
	TwinFoot                                 = 2,
	Nimbus                                   = 3,
	Machine                                  = 4,
	Pillar                                   = 5,
	All                                      = 6,
	ERideType_MAX                            = 7,
};

// Enum AT.ERidingMecha
// NumValues: 0x0003
enum class ERidingMecha : uint8
{
	AIRCAR                                   = 0,
	ROBOT                                    = 1,
	MAX                                      = 2,
};

// Enum AT.ERidingState
// NumValues: 0x0006
enum class ERidingState : uint8
{
	None                                     = 0,
	Start                                    = 1,
	Move                                     = 2,
	Ride                                     = 3,
	End                                      = 4,
	ERidingState_MAX                         = 5,
};

// Enum AT.EWishDemoState
// NumValues: 0x0010
enum class EWishDemoState : uint8
{
	None                                     = 0,
	Load                                     = 1,
	IsLoaded                                 = 2,
	StartDemo                                = 3,
	StartLeaveDemo                           = 4,
	PlayingDemo                              = 5,
	PlayingLeaveDemo                         = 6,
	ShowResult                               = 7,
	ShowResultWindow                         = 8,
	ShowRemainingWishCount                   = 9,
	End                                      = 10,
	EndDemo                                  = 11,
	EndLeaveDemo                             = 12,
	ShowDragonBallRelease                    = 13,
	ShowDragonBallReleaseWindow              = 14,
	EWishDemoState_MAX                       = 15,
};

// Enum AT.EFoundFieldPointStatus
// NumValues: 0x0005
enum class EFoundFieldPointStatus : uint8
{
	None                                     = 0,
	UNREGISTED                               = 1,
	UNFOUND                                  = 2,
	FOUND                                    = 3,
	EFoundFieldPointStatus_MAX               = 4,
};

// Enum AT.EHuntingPointIndex
// NumValues: 0x0010
enum class EHuntingPointIndex : uint8
{
	HUNTING_POINT_01                         = 0,
	HUNTING_POINT_02                         = 1,
	HUNTING_POINT_03                         = 2,
	HUNTING_POINT_04                         = 3,
	HUNTING_POINT_05                         = 4,
	HUNTING_POINT_06                         = 5,
	HUNTING_POINT_07                         = 6,
	HUNTING_POINT_08                         = 7,
	HUNTING_POINT_09                         = 8,
	HUNTING_POINT_10                         = 9,
	HUNTING_POINT_11                         = 10,
	HUNTING_POINT_12                         = 11,
	HUNTING_POINT_13                         = 12,
	HUNTING_POINT_14                         = 13,
	HUNTING_POINT_15                         = 14,
	HUNTING_POINT_MAX                        = 15,
};

// Enum AT.EFishingAreaIndex
// NumValues: 0x0010
enum class EFishingAreaIndex : uint8
{
	FISHING_AREA_01                          = 0,
	FISHING_AREA_02                          = 1,
	FISHING_AREA_03                          = 2,
	FISHING_AREA_04                          = 3,
	FISHING_AREA_05                          = 4,
	FISHING_AREA_06                          = 5,
	FISHING_AREA_07                          = 6,
	FISHING_AREA_08                          = 7,
	FISHING_AREA_09                          = 8,
	FISHING_AREA_10                          = 9,
	FISHING_AREA_11                          = 10,
	FISHING_AREA_12                          = 11,
	FISHING_AREA_13                          = 12,
	FISHING_AREA_14                          = 13,
	FISHING_AREA_15                          = 14,
	FISHING_AREA_MAX                         = 15,
};

// Enum AT.EAerialSkillBranchType
// NumValues: 0x0004
enum class EAerialSkillBranchType : uint8
{
	None                                     = 0,
	SelfOrTarget                             = 1,
	Self                                     = 2,
	Max                                      = 3,
};

// Enum AT.EAuraStrength
// NumValues: 0x0003
enum class EAuraStrength : uint8
{
	BlowAwayCancel                           = 0,
	NoCancel                                 = 1,
	MAX                                      = 2,
};

// Enum AT.ESkillActionType
// NumValues: 0x0007
enum class ESkillActionType : uint8
{
	None                                     = 0,
	Direct                                   = 1,
	Bullet                                   = 2,
	Beam                                     = 3,
	Explosion                                = 4,
	Other                                    = 5,
	Max                                      = 6,
};

// Enum AT.ESkillAttribute
// NumValues: 0x0007
enum class ESkillAttribute : uint8
{
	None                                     = 0,
	Physics                                  = 1,
	Spirit                                   = 2,
	FastMove                                 = 3,
	Sparking                                 = 4,
	Other                                    = 5,
	Max                                      = 6,
};

// Enum AT.ESkillSlot
// NumValues: 0x0015
enum class ESkillSlot : uint8
{
	Slot01                                   = 0,
	Slot02                                   = 1,
	Slot03                                   = 2,
	Slot04                                   = 3,
	Slot05                                   = 4,
	Slot06                                   = 5,
	Slot07                                   = 6,
	Slot08                                   = 7,
	Slot09                                   = 8,
	Slot10                                   = 9,
	Slot11                                   = 10,
	Slot12                                   = 11,
	Slot13                                   = 12,
	Slot14                                   = 13,
	Slot15                                   = 14,
	Slot16                                   = 15,
	Slot17                                   = 16,
	Slot18                                   = 17,
	Slot19                                   = 18,
	Slot20                                   = 19,
	Max                                      = 20,
};

// Enum AT.ESkillPaletteTrigger
// NumValues: 0x0003
enum class ESkillPaletteTrigger : uint8
{
	Right                                    = 0,
	Left                                     = 1,
	Max                                      = 2,
};

// Enum AT.ESkillPaletteFace
// NumValues: 0x0005
enum class ESkillPaletteFace : uint8
{
	Right                                    = 0,
	Up                                       = 1,
	Left                                     = 2,
	Down                                     = 3,
	Max                                      = 4,
};

// Enum AT.EPassiveSkill
// NumValues: 0x0009
enum class EPassiveSkill : uint8
{
	Slot1                                    = 0,
	Slot2                                    = 1,
	Slot3                                    = 2,
	Slot4                                    = 3,
	Slot5                                    = 4,
	Slot6                                    = 5,
	Slot7                                    = 6,
	Slot8                                    = 7,
	Max                                      = 8,
};

// Enum AT.EFormChangeEndCondition
// NumValues: 0x0004
enum class EFormChangeEndCondition : uint32
{
	None                                     = 0,
	Magic                                    = 1,
	Life                                     = 2,
	EFormChangeEndCondition_MAX              = 3,
};

// Enum AT.EVolumeBrushType
// NumValues: 0x0004
enum class EVolumeBrushType : uint8
{
	None                                     = 0,
	Box                                      = 1,
	Sphere                                   = 2,
	Max                                      = 3,
};

// Enum AT.ESuperTrainingMenuType
// NumValues: 0x0006
enum class ESuperTrainingMenuType : uint8
{
	SHOP_TOP                                 = 0,
	SUPER_TRAINING                           = 1,
	BREAKTHROUGH_TRAINING                    = 2,
	CHALLENGE_TO_GOD_OF_DESTRUCTION          = 3,
	CHALLENGE_FREEZER_F                      = 4,
	ESuperTrainingMenuType_MAX               = 5,
};

// Enum AT.EDecorateType
// NumValues: 0x0006
enum class EDecorateType : uint8
{
	Default                                  = 0,
	Decal                                    = 1,
	Debris                                   = 2,
	Effect                                   = 3,
	EdgeEffect                               = 4,
	Max                                      = 5,
};

// Enum AT.ETerrainDecorateEffectState
// NumValues: 0x0004
enum class ETerrainDecorateEffectState : uint8
{
	INIT                                     = 0,
	SPAWN                                    = 1,
	FREE                                     = 2,
	ETerrainDecorateEffectState_MAX          = 3,
};

// Enum AT.ETerrainDecorateHitPhotonType
// NumValues: 0x0004
enum class ETerrainDecorateHitPhotonType : uint8
{
	Sphere                                   = 0,
	SphereKillInOneFrame                     = 1,
	SphereForCharacter                       = 2,
	MAX                                      = 3,
};

// Enum AT.EFadeType
// NumValues: 0x0004
enum class EFadeType : uint8
{
	FadeWithOrder                            = 0,
	FadeOnActivate                           = 1,
	MaxFadeType                              = 2,
	EFadeType_MAX                            = 3,
};

// Enum AT.EDecalType
// NumValues: 0x0007
enum class EDecalType : uint8
{
	Default                                  = 0,
	LineStart                                = 1,
	LineLoop                                 = 2,
	LineEnd                                  = 3,
	Crater                                   = 4,
	MaxDecalType                             = 5,
	EDecalType_MAX                           = 6,
};

// Enum AT.EDestroyType
// NumValues: 0x0060
enum class EDestroyType : uint8
{
	None                                     = 0,
	Flying                                   = 1,
	BoostFlying                              = 2,
	FlyingInField                            = 3,
	BoostFlyingInField                       = 4,
	SmallChakraBullet                        = 5,
	ChakraBullet                             = 6,
	LargeChakraBullet                        = 7,
	SmallBeam                                = 8,
	Beam                                     = 9,
	LargeBeam                                = 10,
	SmallExplosion                           = 11,
	Explosion                                = 12,
	LargeExplosion                           = 13,
	BlowOff                                  = 14,
	LongBlowOff                              = 15,
	LongBlowOffVertical                      = 16,
	LongBlowOffHorizontal                    = 17,
	Combo                                    = 18,
	AirCar                                   = 19,
	AirCarBoost                              = 20,
	Pillar                                   = 21,
	GeneralDestroyType                       = 22,
	GiantStorm                               = 23,
	BlazingStorm                             = 24,
	ShootingStarArrow                        = 25,
	WildQuake                                = 26,
	VanishingBall                            = 27,
	DoubleSunday                             = 28,
	MonkeyStep                               = 29,
	MonkeyRock                               = 30,
	SlashWave                                = 31,
	GodKamehameha                            = 32,
	C008B_G_SKL005_E                         = 33,
	C011C_G_SKL007                           = 34,
	C011C_G_SKL001                           = 35,
	C011C_G_SKL006                           = 36,
	C011C_G_SKL005                           = 37,
	C098A_G_SKL004_E                         = 38,
	C001D_G_SKL001                           = 39,
	C001D_G_SKL101                           = 40,
	C001D_G_SKL201                           = 41,
	C102A_G_SKL001                           = 42,
	C102A_G_SKL002                           = 43,
	C098A_G_SKL001_E                         = 44,
	C008B_G_SKL002_E                         = 45,
	C011B_G_SKL104_E                         = 46,
	C098A_G_SKL003_E                         = 47,
	C101B_G_SKL006                           = 48,
	C001D_G_SKL003                           = 49,
	C001D_G_SKL105                           = 50,
	C001D_G_SKL205                           = 51,
	C104A_G_SKL001                           = 52,
	C001D_G_SKL103                           = 53,
	C011C_G_SKL002                           = 54,
	C001D_G_SKL005                           = 55,
	C011B_G_SKL003_E                         = 56,
	C036B_G_SKL004                           = 57,
	C036B_G_SKL006                           = 58,
	C105A_G_SKL001                           = 59,
	C105A_G_SKL002                           = 60,
	C105A_G_SKL003                           = 61,
	C105A_G_SKL004                           = 62,
	C107A_G_SKL001                           = 63,
	C107A_G_SKL002                           = 64,
	C107A_G_SKL003                           = 65,
	C106A_G_SKL002                           = 66,
	C106A_G_SKL003                           = 67,
	C106A_G_SKL004                           = 68,
	C106A_G_SKL005                           = 69,
	C001F_G_SKL003                           = 70,
	C001F_G_SKL004                           = 71,
	C003E_S_SKL007_Beam                      = 72,
	C003E_S_SKL007_Kidan                     = 73,
	GroundC0107_002_Blowoff                  = 74,
	GroundC001F_G_SKL003_Bound               = 75,
	GroundC106A_G_SKL005                     = 76,
	GroundC106_ZigzagMove                    = 77,
	UniqueDestroyType                        = 78,
	GroundBoostFlying                        = 79,
	GroundChakraBullet                       = 80,
	GroundGroundBeam                         = 81,
	GroundExplosion                          = 82,
	GroundBlowOff                            = 83,
	GroundCombo                              = 84,
	GroundFlying                             = 85,
	GroundStepFB                             = 86,
	GroundStepR                              = 87,
	GroundStepL                              = 88,
	GroundBlowOffBound                       = 89,
	GroundBlowOffRingout                     = 90,
	GroundBlowOffFlying                      = 91,
	GroundC011CWalk                          = 92,
	GroundChakraBulletC001F                  = 93,
	MaxDestroyType                           = 94,
	EDestroyType_MAX                         = 95,
};

// Enum AT.ETrafficLightColor
// NumValues: 0x0004
enum class ETrafficLightColor : uint8
{
	Blue                                     = 0,
	Yellow                                   = 1,
	Red                                      = 2,
	ETrafficLightColor_MAX                   = 3,
};

// Enum AT.ETrafficLightType
// NumValues: 0x0003
enum class ETrafficLightType : uint8
{
	Roadway                                  = 0,
	Crosswalk                                = 1,
	ETrafficLightType_MAX                    = 2,
};

// Enum AT.ETrainingMenuType
// NumValues: 0x0007
enum class ETrainingMenuType : uint8
{
	Training                                 = 0,
	CrowdTraining                            = 1,
	DLC4ClearTraining                        = 2,
	DLC5ClearTraining                        = 3,
	DLC6ClearTraining                        = 4,
	MainStoryExTraining                      = 5,
	ETrainingMenuType_MAX                    = 6,
};

// Enum AT.ETreasureAccessPointCategory
// NumValues: 0x0003
enum class ETreasureAccessPointCategory : uint8
{
	Category_DMedal                          = 0,
	Category_Event_Item                      = 1,
	Category_MAX                             = 2,
};

// Enum AT.ETreasureAccessPointNotifyNowState
// NumValues: 0x0004
enum class ETreasureAccessPointNotifyNowState : uint8
{
	NotifyNowState_Wait                      = 0,
	NotifyNowState_Free                      = 1,
	NotifyNowState_End                       = 2,
	NotifyNowState_MAX                       = 3,
};

// Enum AT.ETreasureAccessPointNotifyState
// NumValues: 0x0003
enum class ETreasureAccessPointNotifyState : uint8
{
	NotifyState_Next                         = 0,
	NotifyState_Cancel                       = 1,
	NotifyState_MAX                          = 2,
};

// Enum AT.ETreasureAccessPointState
// NumValues: 0x000E
enum class ETreasureAccessPointState : uint8
{
	State_TreasureWait                       = 0,
	State_TreasureUIWait                     = 1,
	State_TreasurePlayerStopWait             = 2,
	State_TreasurePlayerActionStart          = 3,
	State_TreasurePlayerActionWait           = 4,
	State_TreasurePlayerActionComplete       = 5,
	State_TreasureDemoStart                  = 6,
	State_TreasureDemoWait                   = 7,
	State_TreasureItemSpawn                  = 8,
	State_TreasureItemWait                   = 9,
	State_TreasureEndActionWait              = 10,
	State_TreasureTaken                      = 11,
	State_TreasureTracking                   = 12,
	State_MAX                                = 13,
};

// Enum AT.ETreasureAccessPointType
// NumValues: 0x0003
enum class ETreasureAccessPointType : uint8
{
	Type_Mesh                                = 0,
	Type_Skeletal                            = 1,
	Type_MAX                                 = 2,
};

// Enum AT.ETwinFootMoveGear
// NumValues: 0x0004
enum class ETwinFootMoveGear : uint8
{
	Zero                                     = 0,
	First                                    = 1,
	Second                                   = 2,
	ETwinFootMoveGear_MAX                    = 3,
};

// Enum AT.ETwinFootMoveState
// NumValues: 0x0011
enum class ETwinFootMoveState : uint8
{
	Stand                                    = 0,
	StandWalkST                              = 1,
	StandWalkLP                              = 2,
	StandWalkED                              = 3,
	StandMoveST                              = 4,
	StandMoveLP                              = 5,
	StandMoveED                              = 6,
	StandLanding                             = 7,
	StandJumpAntST                           = 8,
	StandJumpAntLP                           = 9,
	StandJumpST                              = 10,
	StandJumpLP                              = 11,
	StandJumpED                              = 12,
	BoostJumpLP                              = 13,
	StandFall                                = 14,
	Nothing                                  = 15,
	ETwinFootMoveState_MAX                   = 16,
};

// Enum AT.ETwinFootMoveCategory
// NumValues: 0x0005
enum class ETwinFootMoveCategory : uint8
{
	Stand                                    = 0,
	Jump                                     = 1,
	Fall                                     = 2,
	Nothing                                  = 3,
	ETwinFootMoveCategory_MAX                = 4,
};

// Enum AT.ERenderingPageState
// NumValues: 0x0006
enum class ERenderingPageState : uint32
{
	None                                     = 0,
	LoadRequest                              = 1,
	Idling                                   = 2,
	Rendering                                = 3,
	Destroy                                  = 4,
	ERenderingPageState_MAX                  = 5,
};

// Enum AT.EVoiceType
// NumValues: 0x0003
enum class EVoiceType : uint8
{
	Talk                                     = 0,
	Demo                                     = 1,
	EVoiceType_MAX                           = 2,
};

// Enum AT.EZCompworksCategoryId
// NumValues: 0x001A
enum class EZCompworksCategoryId : uint8
{
	NONE                                     = 0,
	CATEGORY1                                = 1,
	CATEGORY2                                = 2,
	CATEGORY3                                = 3,
	CATEGORY4                                = 4,
	CATEGORY5                                = 5,
	CATEGORY6                                = 6,
	CATEGORY7                                = 7,
	CATEGORY8                                = 8,
	CATEGORY9                                = 9,
	CATEGORY10                               = 10,
	CATEGORY11                               = 11,
	CATEGORY12                               = 12,
	CATEGORY13                               = 13,
	CATEGORY14                               = 14,
	CATEGORY15                               = 15,
	CATEGORY16                               = 16,
	CATEGORY17                               = 17,
	CATEGORY18                               = 18,
	CATEGORY19                               = 19,
	CATEGORY20                               = 20,
	CATEGORY_DLC3                            = 21,
	CATEGORY_DLC4                            = 22,
	CATEGORY_DLC5                            = 23,
	CATEGORY_DLC6                            = 24,
	EZCompworksCategoryId_MAX                = 25,
};

// Enum AT.EZCompworksUIDataType
// NumValues: 0x000C
enum class EZCompworksUIDataType : uint8
{
	Text                                     = 0,
	Picture                                  = 1,
	ModelNormal                              = 2,
	ModelChara                               = 3,
	Diagram                                  = 4,
	Carddass                                 = 5,
	Demo                                     = 6,
	BGM                                      = 7,
	ModelUnique                              = 8,
	TextVoice                                = 9,
	Memory                                   = 10,
	EZCompworksUIDataType_MAX                = 11,
};

// Enum AT.EZCompworksMajorId
// NumValues: 0x000E
enum class EZCompworksMajorId : uint8
{
	NONE                                     = 0,
	STORY                                    = 1,
	DIAGRAM                                  = 2,
	CHARA                                    = 3,
	WORLD                                    = 4,
	ANIMAL                                   = 5,
	VEHICLE                                  = 6,
	ITEM                                     = 7,
	TERM                                     = 8,
	CARD                                     = 9,
	DEMO                                     = 10,
	BGM                                      = 11,
	CARD_WARRIOR                             = 12,
	MAX                                      = 13,
};

// Enum AT.EZCompworksOpenType
// NumValues: 0x0022
enum class EZCompworksOpenType : uint8
{
	NONE                                     = 0,
	MAINQUEST                                = 1,
	SUBQUEST                                 = 2,
	MISSION                                  = 3,
	NPCTALK                                  = 4,
	FAVORABILITY                             = 5,
	TOWN                                     = 6,
	ANIMAL                                   = 7,
	FISH                                     = 8,
	MINIGAME                                 = 9,
	VICTORY                                  = 10,
	ENEMY                                    = 11,
	SKILL                                    = 12,
	ITEM                                     = 13,
	BGM                                      = 14,
	ZCOMPWORKS                               = 15,
	STARTUP                                  = 16,
	MEMORY                                   = 17,
	BREAKTHROUGH                             = 18,
	CHALLENGEBEERUS                          = 19,
	EVENTFREEZER                             = 20,
	STARTUP_DLC                              = 21,
	DLC3_QUEST                               = 22,
	DLC3_TRAINING                            = 23,
	DLC4_QUEST                               = 24,
	DLC4_TRAINING                            = 25,
	DLC4_SUBQUEST                            = 26,
	DLC5_QUEST                               = 27,
	DLC5_SUBQUEST                            = 28,
	DLC5_TRAINING                            = 29,
	DLC6_QUEST                               = 30,
	DLC6_TRAINING                            = 31,
	MainStoryEx_TRAINING                     = 32,
	MAX                                      = 33,
};

// Enum AT.EZCW_Phase
// NumValues: 0x000F
enum class EZCW_Phase : uint8
{
	None                                     = 0,
	Open                                     = 1,
	Close                                    = 2,
	PageNextOne                              = 3,
	PageBackOne                              = 4,
	PageNextFast                             = 5,
	PageBackFast                             = 6,
	MemoLeftIn                               = 7,
	MemoLeftOut                              = 8,
	MemoRightIn                              = 9,
	MemoRightOut                             = 10,
	Before                                   = 11,
	After                                    = 12,
	End                                      = 13,
	EZCW_MAX                                 = 14,
};

// Enum AT.EZCW_BookPage
// NumValues: 0x0005
enum class EZCW_BookPage : uint8
{
	Left                                     = 0,
	Right                                    = 1,
	NextLeft                                 = 2,
	NextRight                                = 3,
	Max                                      = 4,
};

// Enum AT.EZOrbType
// NumValues: 0x000E
enum class EZOrbType : uint8
{
	EZOrbType_Red_S                          = 0,
	EZOrbType_Red_M                          = 1,
	EZOrbType_Red_L                          = 2,
	EZOrbType_Blue_S                         = 3,
	EZOrbType_Blue_M                         = 4,
	EZOrbType_Blue_L                         = 5,
	EZOrbType_Green_S                        = 6,
	EZOrbType_Green_M                        = 7,
	EZOrbType_Green_L                        = 8,
	EZOrbType_Rainbow                        = 9,
	EZOrbType_White                          = 10,
	EZOrbType_PureWhite                      = 11,
	EZOrbType_Time                           = 12,
	EZOrbType_MAX                            = 13,
};

// Enum AT.EZOrbPlaceType
// NumValues: 0x0003
enum class EZOrbPlaceType : uint8
{
	Point                                    = 0,
	Circle                                   = 1,
	EZOrbPlaceType_MAX                       = 2,
};

// Enum AT.EZOrbItemType
// NumValues: 0x0007
enum class EZOrbItemType : uint8
{
	EZOrbItemType_Blue                       = 0,
	EZOrbItemType_Red                        = 1,
	EZOrbItemType_Green                      = 2,
	EZOrbItemType_Rainbow                    = 3,
	EZOrbItemType_White                      = 4,
	EZOrbItemType_PureWhite                  = 5,
	EZOrbItemType_Max                        = 6,
};

// Enum AT.EZOrbRenderMode
// NumValues: 0x0003
enum class EZOrbRenderMode : uint8
{
	RenderModeStaticMesh                     = 0,
	RenderModeEffect                         = 1,
	EZOrbRenderMode_MAX                      = 2,
};

// ScriptStruct AT.EnemyHudInfo
// 0x006C (0x006C - 0x0000)
struct alignas(0x04) FEnemyHudInfo final
{
public:
	uint8                                         Pad_0[0x6C];                                       // 0x0000(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyHudInfo) == 0x000004, "Wrong alignment on FEnemyHudInfo");
static_assert(sizeof(FEnemyHudInfo) == 0x00006C, "Wrong size on FEnemyHudInfo");

// ScriptStruct AT.AttackRangeEffectSetting
// 0x0040 (0x0048 - 0x0008)
struct FAttackRangeEffectSetting final : public FTableRowBase
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalActorScale;                                   // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalActorLifeTime;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHitDestroyDecalActor;                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DecalActorFadeinTime;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalActorFadeoutTime;                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UParticleSystem*>                EffectParticle;                                    // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         EffectActorLifeTime;                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackRangeEffectSetting) == 0x000008, "Wrong alignment on FAttackRangeEffectSetting");
static_assert(sizeof(FAttackRangeEffectSetting) == 0x000048, "Wrong size on FAttackRangeEffectSetting");
static_assert(offsetof(FAttackRangeEffectSetting, DecalMaterial) == 0x000008, "Member 'FAttackRangeEffectSetting::DecalMaterial' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, DecalActorScale) == 0x000010, "Member 'FAttackRangeEffectSetting::DecalActorScale' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, DecalActorLifeTime) == 0x00001C, "Member 'FAttackRangeEffectSetting::DecalActorLifeTime' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, IsHitDestroyDecalActor) == 0x000020, "Member 'FAttackRangeEffectSetting::IsHitDestroyDecalActor' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, DecalActorFadeinTime) == 0x000024, "Member 'FAttackRangeEffectSetting::DecalActorFadeinTime' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, DecalActorFadeoutTime) == 0x000028, "Member 'FAttackRangeEffectSetting::DecalActorFadeoutTime' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, EffectParticle) == 0x000030, "Member 'FAttackRangeEffectSetting::EffectParticle' has a wrong offset!");
static_assert(offsetof(FAttackRangeEffectSetting, EffectActorLifeTime) == 0x000040, "Member 'FAttackRangeEffectSetting::EffectActorLifeTime' has a wrong offset!");

// ScriptStruct AT.ProjectileSphereLaunchTable
// 0x0028 (0x0030 - 0x0008)
struct FProjectileSphereLaunchTable final : public FTableRowBase
{
public:
	float                                         LaunchTime;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaunchNumV;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaunchNumH;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaunchSpaceV;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaunchSpaceH;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaunchOffsetV;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LaunchOffsetH;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDistance;                                    // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Division;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProjectileSphereLaunchTable) == 0x000008, "Wrong alignment on FProjectileSphereLaunchTable");
static_assert(sizeof(FProjectileSphereLaunchTable) == 0x000030, "Wrong size on FProjectileSphereLaunchTable");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchTime) == 0x000008, "Member 'FProjectileSphereLaunchTable::LaunchTime' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchNumV) == 0x00000C, "Member 'FProjectileSphereLaunchTable::LaunchNumV' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchNumH) == 0x000010, "Member 'FProjectileSphereLaunchTable::LaunchNumH' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchSpaceV) == 0x000014, "Member 'FProjectileSphereLaunchTable::LaunchSpaceV' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchSpaceH) == 0x000018, "Member 'FProjectileSphereLaunchTable::LaunchSpaceH' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchOffsetV) == 0x00001C, "Member 'FProjectileSphereLaunchTable::LaunchOffsetV' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchOffsetH) == 0x000020, "Member 'FProjectileSphereLaunchTable::LaunchOffsetH' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, LaunchDistance) == 0x000024, "Member 'FProjectileSphereLaunchTable::LaunchDistance' has a wrong offset!");
static_assert(offsetof(FProjectileSphereLaunchTable, Division) == 0x000028, "Member 'FProjectileSphereLaunchTable::Division' has a wrong offset!");

// ScriptStruct AT.MoveDistanceTbl
// 0x0010 (0x0018 - 0x0008)
struct FMoveDistanceTbl final : public FTableRowBase
{
public:
	float                                         Speed;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayDistance;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveDistanceTbl) == 0x000008, "Wrong alignment on FMoveDistanceTbl");
static_assert(sizeof(FMoveDistanceTbl) == 0x000018, "Wrong size on FMoveDistanceTbl");
static_assert(offsetof(FMoveDistanceTbl, Speed) == 0x000008, "Member 'FMoveDistanceTbl::Speed' has a wrong offset!");
static_assert(offsetof(FMoveDistanceTbl, Distance) == 0x00000C, "Member 'FMoveDistanceTbl::Distance' has a wrong offset!");
static_assert(offsetof(FMoveDistanceTbl, PlayDistance) == 0x000010, "Member 'FMoveDistanceTbl::PlayDistance' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFacialInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetFacialInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PartsClass;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFacialInfo) == 0x000008, "Wrong alignment on FATDataAssetFacialInfo");
static_assert(sizeof(FATDataAssetFacialInfo) == 0x000030, "Wrong size on FATDataAssetFacialInfo");
static_assert(offsetof(FATDataAssetFacialInfo, MasterId) == 0x000000, "Member 'FATDataAssetFacialInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetFacialInfo, PartsClass) == 0x000008, "Member 'FATDataAssetFacialInfo::PartsClass' has a wrong offset!");

// ScriptStruct AT.MinigameTimingArgment
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMinigameTimingArgment final
{
public:
	EMinigameState                                State;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActorName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTimeUp;                                          // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRetire;                                          // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinigameTimingArgment) == 0x000008, "Wrong alignment on FMinigameTimingArgment");
static_assert(sizeof(FMinigameTimingArgment) == 0x000018, "Wrong size on FMinigameTimingArgment");
static_assert(offsetof(FMinigameTimingArgment, State) == 0x000000, "Member 'FMinigameTimingArgment::State' has a wrong offset!");
static_assert(offsetof(FMinigameTimingArgment, ActorName) == 0x000008, "Member 'FMinigameTimingArgment::ActorName' has a wrong offset!");
static_assert(offsetof(FMinigameTimingArgment, IsTimeUp) == 0x000010, "Member 'FMinigameTimingArgment::IsTimeUp' has a wrong offset!");
static_assert(offsetof(FMinigameTimingArgment, IsRetire) == 0x000011, "Member 'FMinigameTimingArgment::IsRetire' has a wrong offset!");

// ScriptStruct AT.AI_BehaviorTbl
// 0x001C (0x001C - 0x0000)
struct FAI_BehaviorTbl final
{
public:
	float                                         St_Wait;                                           // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_BEHAVIOR                                 Behavior;                                          // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorParam;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_BEHAVIOR_END                             EndAnim;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EndAnimParam;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         End_Wait;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAI_BehaviorTbl) == 0x000004, "Wrong alignment on FAI_BehaviorTbl");
static_assert(sizeof(FAI_BehaviorTbl) == 0x00001C, "Wrong size on FAI_BehaviorTbl");
static_assert(offsetof(FAI_BehaviorTbl, St_Wait) == 0x000000, "Member 'FAI_BehaviorTbl::St_Wait' has a wrong offset!");
static_assert(offsetof(FAI_BehaviorTbl, Behavior) == 0x000004, "Member 'FAI_BehaviorTbl::Behavior' has a wrong offset!");
static_assert(offsetof(FAI_BehaviorTbl, BehaviorParam) == 0x000008, "Member 'FAI_BehaviorTbl::BehaviorParam' has a wrong offset!");
static_assert(offsetof(FAI_BehaviorTbl, EndAnim) == 0x00000C, "Member 'FAI_BehaviorTbl::EndAnim' has a wrong offset!");
static_assert(offsetof(FAI_BehaviorTbl, EndAnimParam) == 0x000010, "Member 'FAI_BehaviorTbl::EndAnimParam' has a wrong offset!");
static_assert(offsetof(FAI_BehaviorTbl, EndTime) == 0x000014, "Member 'FAI_BehaviorTbl::EndTime' has a wrong offset!");
static_assert(offsetof(FAI_BehaviorTbl, End_Wait) == 0x000018, "Member 'FAI_BehaviorTbl::End_Wait' has a wrong offset!");

// ScriptStruct AT.PhaseCollisionParam
// 0x0008 (0x0008 - 0x0000)
struct FPhaseCollisionParam final
{
public:
	int32                                         StartNo;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNo;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhaseCollisionParam) == 0x000004, "Wrong alignment on FPhaseCollisionParam");
static_assert(sizeof(FPhaseCollisionParam) == 0x000008, "Wrong size on FPhaseCollisionParam");
static_assert(offsetof(FPhaseCollisionParam, StartNo) == 0x000000, "Member 'FPhaseCollisionParam::StartNo' has a wrong offset!");
static_assert(offsetof(FPhaseCollisionParam, EndNo) == 0x000004, "Member 'FPhaseCollisionParam::EndNo' has a wrong offset!");

// ScriptStruct AT.LoadingRaceGameCommonAsset
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLoadingRaceGameCommonAsset final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingRaceGameCommonAsset) == 0x000008, "Wrong alignment on FLoadingRaceGameCommonAsset");
static_assert(sizeof(FLoadingRaceGameCommonAsset) == 0x000028, "Wrong size on FLoadingRaceGameCommonAsset");

// ScriptStruct AT.ChairOffset
// 0x0018 (0x0018 - 0x0000)
struct FChairOffset final
{
public:
	struct FVector                                LocationOffset;                                    // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChairOffset) == 0x000004, "Wrong alignment on FChairOffset");
static_assert(sizeof(FChairOffset) == 0x000018, "Wrong size on FChairOffset");
static_assert(offsetof(FChairOffset, LocationOffset) == 0x000000, "Member 'FChairOffset::LocationOffset' has a wrong offset!");
static_assert(offsetof(FChairOffset, RotationOffset) == 0x00000C, "Member 'FChairOffset::RotationOffset' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupWishInfo
// 0x0030 (0x0030 - 0x0000)
struct FGameWindowSetupWishInfo final
{
public:
	int32                                         WishInfoId;                                        // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WishName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WishDetail;                                        // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClear;                                          // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupWishInfo) == 0x000008, "Wrong alignment on FGameWindowSetupWishInfo");
static_assert(sizeof(FGameWindowSetupWishInfo) == 0x000030, "Wrong size on FGameWindowSetupWishInfo");
static_assert(offsetof(FGameWindowSetupWishInfo, WishInfoId) == 0x000000, "Member 'FGameWindowSetupWishInfo::WishInfoId' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupWishInfo, WishName) == 0x000008, "Member 'FGameWindowSetupWishInfo::WishName' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupWishInfo, WishDetail) == 0x000018, "Member 'FGameWindowSetupWishInfo::WishDetail' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupWishInfo, bIsClear) == 0x000028, "Member 'FGameWindowSetupWishInfo::bIsClear' has a wrong offset!");

// ScriptStruct AT.ColorGrading
// 0x0018 (0x0018 - 0x0000)
struct FColorGrading final
{
public:
	class UTexture2D*                             ColorGradingLUT;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ColorGradingIntensity;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeIn;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOut;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FColorGrading) == 0x000008, "Wrong alignment on FColorGrading");
static_assert(sizeof(FColorGrading) == 0x000018, "Wrong size on FColorGrading");
static_assert(offsetof(FColorGrading, ColorGradingLUT) == 0x000000, "Member 'FColorGrading::ColorGradingLUT' has a wrong offset!");
static_assert(offsetof(FColorGrading, ColorGradingIntensity) == 0x000008, "Member 'FColorGrading::ColorGradingIntensity' has a wrong offset!");
static_assert(offsetof(FColorGrading, FadeIn) == 0x00000C, "Member 'FColorGrading::FadeIn' has a wrong offset!");
static_assert(offsetof(FColorGrading, FadeOut) == 0x000010, "Member 'FColorGrading::FadeOut' has a wrong offset!");

// ScriptStruct AT.DirectionParameter
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FDirectionParameter final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectionParameter) == 0x000008, "Wrong alignment on FDirectionParameter");
static_assert(sizeof(FDirectionParameter) == 0x000048, "Wrong size on FDirectionParameter");

// ScriptStruct AT.QuestActorSet
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FQuestActorSet final
{
public:
	class FName                                   QuestId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActorName;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupName;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestActorSet) == 0x000008, "Wrong alignment on FQuestActorSet");
static_assert(sizeof(FQuestActorSet) == 0x000018, "Wrong size on FQuestActorSet");
static_assert(offsetof(FQuestActorSet, QuestId) == 0x000000, "Member 'FQuestActorSet::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestActorSet, ActorName) == 0x000008, "Member 'FQuestActorSet::ActorName' has a wrong offset!");
static_assert(offsetof(FQuestActorSet, GroupName) == 0x000010, "Member 'FQuestActorSet::GroupName' has a wrong offset!");

// ScriptStruct AT.ReferenceToAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FReferenceToAssetInstance final
{
public:
	TSubclassOf<class UCFUIUserWidget>            UserWidgetClass;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTablePtr;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToAssetInstance) == 0x000008, "Wrong alignment on FReferenceToAssetInstance");
static_assert(sizeof(FReferenceToAssetInstance) == 0x000010, "Wrong size on FReferenceToAssetInstance");
static_assert(offsetof(FReferenceToAssetInstance, UserWidgetClass) == 0x000000, "Member 'FReferenceToAssetInstance::UserWidgetClass' has a wrong offset!");
static_assert(offsetof(FReferenceToAssetInstance, DataTablePtr) == 0x000008, "Member 'FReferenceToAssetInstance::DataTablePtr' has a wrong offset!");

// ScriptStruct AT.EffectBaseData
// 0x0018 (0x0018 - 0x0000)
struct FEffectBaseData
{
public:
	TArray<EEffectCondition>                      Conditions;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEffectBaseData) == 0x000008, "Wrong alignment on FEffectBaseData");
static_assert(sizeof(FEffectBaseData) == 0x000018, "Wrong size on FEffectBaseData");
static_assert(offsetof(FEffectBaseData, Conditions) == 0x000000, "Member 'FEffectBaseData::Conditions' has a wrong offset!");

// ScriptStruct AT.TrailData
// 0x0028 (0x0040 - 0x0018)
struct FTrailData final : public FEffectBaseData
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstSocketName;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocketName;                                  // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               WidthScaleMode;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidthScaleCurve;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrailData) == 0x000008, "Wrong alignment on FTrailData");
static_assert(sizeof(FTrailData) == 0x000040, "Wrong size on FTrailData");
static_assert(offsetof(FTrailData, ParticleSystem) == 0x000018, "Member 'FTrailData::ParticleSystem' has a wrong offset!");
static_assert(offsetof(FTrailData, FirstSocketName) == 0x000020, "Member 'FTrailData::FirstSocketName' has a wrong offset!");
static_assert(offsetof(FTrailData, SecondSocketName) == 0x000028, "Member 'FTrailData::SecondSocketName' has a wrong offset!");
static_assert(offsetof(FTrailData, WidthScaleMode) == 0x000030, "Member 'FTrailData::WidthScaleMode' has a wrong offset!");
static_assert(offsetof(FTrailData, WidthScaleCurve) == 0x000038, "Member 'FTrailData::WidthScaleCurve' has a wrong offset!");

// ScriptStruct AT.EF_TrailParticleData
// 0x0058 (0x0060 - 0x0008)
struct FEF_TrailParticleData final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AppearOnAnyCharacter;                              // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTrailData                             ParticleData;                                      // 0x0020(0x0040)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEF_TrailParticleData) == 0x000008, "Wrong alignment on FEF_TrailParticleData");
static_assert(sizeof(FEF_TrailParticleData) == 0x000060, "Wrong size on FEF_TrailParticleData");
static_assert(offsetof(FEF_TrailParticleData, CharacterType) == 0x000008, "Member 'FEF_TrailParticleData::CharacterType' has a wrong offset!");
static_assert(offsetof(FEF_TrailParticleData, Tag) == 0x000010, "Member 'FEF_TrailParticleData::Tag' has a wrong offset!");
static_assert(offsetof(FEF_TrailParticleData, AppearOnAnyCharacter) == 0x000018, "Member 'FEF_TrailParticleData::AppearOnAnyCharacter' has a wrong offset!");
static_assert(offsetof(FEF_TrailParticleData, ParticleData) == 0x000020, "Member 'FEF_TrailParticleData::ParticleData' has a wrong offset!");

// ScriptStruct AT.TrackingEffect
// 0x0010 (0x0010 - 0x0000)
struct FTrackingEffect final
{
public:
	struct FVector                                TrackingEffectLocation;                            // 0x0000(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrackingEffect) == 0x000004, "Wrong alignment on FTrackingEffect");
static_assert(sizeof(FTrackingEffect) == 0x000010, "Wrong size on FTrackingEffect");
static_assert(offsetof(FTrackingEffect, TrackingEffectLocation) == 0x000000, "Member 'FTrackingEffect::TrackingEffectLocation' has a wrong offset!");

// ScriptStruct AT.LoadingJostleBeamAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingJostleBeamAsset final
{
public:
	TSoftClassPtr<class UClass>                   ATJostleBeamParam;                                 // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingJostleBeamAsset) == 0x000008, "Wrong alignment on FLoadingJostleBeamAsset");
static_assert(sizeof(FLoadingJostleBeamAsset) == 0x000028, "Wrong size on FLoadingJostleBeamAsset");
static_assert(offsetof(FLoadingJostleBeamAsset, ATJostleBeamParam) == 0x000000, "Member 'FLoadingJostleBeamAsset::ATJostleBeamParam' has a wrong offset!");

// ScriptStruct AT.ATAtrociousPhaseParam
// 0x0010 (0x0010 - 0x0000)
struct FATAtrociousPhaseParam final
{
public:
	TSubclassOf<class UATAtrociousPhaseBase>      PhaseClass;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SaveDataIndex;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATAtrociousPhaseParam) == 0x000008, "Wrong alignment on FATAtrociousPhaseParam");
static_assert(sizeof(FATAtrociousPhaseParam) == 0x000010, "Wrong size on FATAtrociousPhaseParam");
static_assert(offsetof(FATAtrociousPhaseParam, PhaseClass) == 0x000000, "Member 'FATAtrociousPhaseParam::PhaseClass' has a wrong offset!");
static_assert(offsetof(FATAtrociousPhaseParam, SaveDataIndex) == 0x000008, "Member 'FATAtrociousPhaseParam::SaveDataIndex' has a wrong offset!");

// ScriptStruct AT.ATAtrociousPhaseParamArray
// 0x0030 (0x0030 - 0x0000)
struct FATAtrociousPhaseParamArray final
{
public:
	struct FATAtrociousPhaseParam                 PhaseParam[0x3];                                   // 0x0000(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATAtrociousPhaseParamArray) == 0x000008, "Wrong alignment on FATAtrociousPhaseParamArray");
static_assert(sizeof(FATAtrociousPhaseParamArray) == 0x000030, "Wrong size on FATAtrociousPhaseParamArray");
static_assert(offsetof(FATAtrociousPhaseParamArray, PhaseParam) == 0x000000, "Member 'FATAtrociousPhaseParamArray::PhaseParam' has a wrong offset!");

// ScriptStruct AT.ATAtrociousPhaseTable
// 0x0030 (0x0038 - 0x0008)
struct FATAtrociousPhaseTable final : public FTableRowBase
{
public:
	struct FATAtrociousPhaseParamArray            PhaseArray;                                        // 0x0008(0x0030)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATAtrociousPhaseTable) == 0x000008, "Wrong alignment on FATAtrociousPhaseTable");
static_assert(sizeof(FATAtrociousPhaseTable) == 0x000038, "Wrong size on FATAtrociousPhaseTable");
static_assert(offsetof(FATAtrociousPhaseTable, PhaseArray) == 0x000008, "Member 'FATAtrociousPhaseTable::PhaseArray' has a wrong offset!");

// ScriptStruct AT.CmnSkillMenuList00Param
// 0x0030 (0x0030 - 0x0000)
struct FCmnSkillMenuList00Param final
{
public:
	class FName                                   SkillId;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillAttribute                               ActiveSkillType;                                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPassiveSkillEffectCategory                   PassiveSkillType;                                  // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SkillLevel;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0022(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPassiveSkill;                                   // 0x0023(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBanned;                                         // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rarity;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnSkillMenuList00Param) == 0x000008, "Wrong alignment on FCmnSkillMenuList00Param");
static_assert(sizeof(FCmnSkillMenuList00Param) == 0x000030, "Wrong size on FCmnSkillMenuList00Param");
static_assert(offsetof(FCmnSkillMenuList00Param, SkillId) == 0x000000, "Member 'FCmnSkillMenuList00Param::SkillId' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, ItemName) == 0x000008, "Member 'FCmnSkillMenuList00Param::ItemName' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, ActiveSkillType) == 0x000018, "Member 'FCmnSkillMenuList00Param::ActiveSkillType' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, PassiveSkillType) == 0x000019, "Member 'FCmnSkillMenuList00Param::PassiveSkillType' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, SkillLevel) == 0x00001C, "Member 'FCmnSkillMenuList00Param::SkillLevel' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, bIsNew) == 0x000020, "Member 'FCmnSkillMenuList00Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, bIsEquipped) == 0x000021, "Member 'FCmnSkillMenuList00Param::bIsEquipped' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, bIsActive) == 0x000022, "Member 'FCmnSkillMenuList00Param::bIsActive' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, bIsPassiveSkill) == 0x000023, "Member 'FCmnSkillMenuList00Param::bIsPassiveSkill' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, bIsBanned) == 0x000024, "Member 'FCmnSkillMenuList00Param::bIsBanned' has a wrong offset!");
static_assert(offsetof(FCmnSkillMenuList00Param, Rarity) == 0x000028, "Member 'FCmnSkillMenuList00Param::Rarity' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataModel
// 0x0020 (0x0028 - 0x0008)
struct FZCompworksUIDataModel : public FTableRowBase
{
public:
	float                                         LookatOfsX;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookatOfsY;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookatOfsZ;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotX;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraRotZ;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDist;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraFov;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Appendix;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataModel) == 0x000008, "Wrong alignment on FZCompworksUIDataModel");
static_assert(sizeof(FZCompworksUIDataModel) == 0x000028, "Wrong size on FZCompworksUIDataModel");
static_assert(offsetof(FZCompworksUIDataModel, LookatOfsX) == 0x000008, "Member 'FZCompworksUIDataModel::LookatOfsX' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, LookatOfsY) == 0x00000C, "Member 'FZCompworksUIDataModel::LookatOfsY' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, LookatOfsZ) == 0x000010, "Member 'FZCompworksUIDataModel::LookatOfsZ' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, CameraRotX) == 0x000014, "Member 'FZCompworksUIDataModel::CameraRotX' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, CameraRotZ) == 0x000018, "Member 'FZCompworksUIDataModel::CameraRotZ' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, CameraDist) == 0x00001C, "Member 'FZCompworksUIDataModel::CameraDist' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, CameraFov) == 0x000020, "Member 'FZCompworksUIDataModel::CameraFov' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModel, Appendix) == 0x000024, "Member 'FZCompworksUIDataModel::Appendix' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataModelChara
// 0x0018 (0x0040 - 0x0028)
struct FZCompworksUIDataModelChara final : public FZCompworksUIDataModel
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x002A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationPath;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FacialPath;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataModelChara) == 0x000008, "Wrong alignment on FZCompworksUIDataModelChara");
static_assert(sizeof(FZCompworksUIDataModelChara) == 0x000040, "Wrong size on FZCompworksUIDataModelChara");
static_assert(offsetof(FZCompworksUIDataModelChara, CharacterType) == 0x000028, "Member 'FZCompworksUIDataModelChara::CharacterType' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelChara, VariationId) == 0x000029, "Member 'FZCompworksUIDataModelChara::VariationId' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelChara, FormID) == 0x00002A, "Member 'FZCompworksUIDataModelChara::FormID' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelChara, AnimationPath) == 0x000030, "Member 'FZCompworksUIDataModelChara::AnimationPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelChara, FacialPath) == 0x000038, "Member 'FZCompworksUIDataModelChara::FacialPath' has a wrong offset!");

// ScriptStruct AT.ATDataAssetStarScaleFinishInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetStarScaleFinishInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Sequencer;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetStarScaleFinishInfo) == 0x000008, "Wrong alignment on FATDataAssetStarScaleFinishInfo");
static_assert(sizeof(FATDataAssetStarScaleFinishInfo) == 0x000030, "Wrong size on FATDataAssetStarScaleFinishInfo");
static_assert(offsetof(FATDataAssetStarScaleFinishInfo, MasterId) == 0x000000, "Member 'FATDataAssetStarScaleFinishInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetStarScaleFinishInfo, Sequencer) == 0x000008, "Member 'FATDataAssetStarScaleFinishInfo::Sequencer' has a wrong offset!");

// ScriptStruct AT.EffectParameter
// 0x0038 (0x0038 - 0x0000)
struct FEffectParameter final
{
public:
	class UParticleSystem*                        Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotation;                                    // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OffsetSize;                                        // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectParameter) == 0x000008, "Wrong alignment on FEffectParameter");
static_assert(sizeof(FEffectParameter) == 0x000038, "Wrong size on FEffectParameter");
static_assert(offsetof(FEffectParameter, Effect) == 0x000000, "Member 'FEffectParameter::Effect' has a wrong offset!");
static_assert(offsetof(FEffectParameter, OffsetLocation) == 0x000008, "Member 'FEffectParameter::OffsetLocation' has a wrong offset!");
static_assert(offsetof(FEffectParameter, OffsetRotation) == 0x000014, "Member 'FEffectParameter::OffsetRotation' has a wrong offset!");
static_assert(offsetof(FEffectParameter, OffsetSize) == 0x000020, "Member 'FEffectParameter::OffsetSize' has a wrong offset!");
static_assert(offsetof(FEffectParameter, Attached) == 0x00002C, "Member 'FEffectParameter::Attached' has a wrong offset!");
static_assert(offsetof(FEffectParameter, SocketName) == 0x000030, "Member 'FEffectParameter::SocketName' has a wrong offset!");

// ScriptStruct AT.SwitchFormIDEffect
// 0x0048 (0x0048 - 0x0000)
struct FSwitchFormIDEffect final
{
public:
	struct FEffectParameter                       Parameter;                                         // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FormID;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSwitchFormIDEffect) == 0x000008, "Wrong alignment on FSwitchFormIDEffect");
static_assert(sizeof(FSwitchFormIDEffect) == 0x000048, "Wrong size on FSwitchFormIDEffect");
static_assert(offsetof(FSwitchFormIDEffect, Parameter) == 0x000000, "Member 'FSwitchFormIDEffect::Parameter' has a wrong offset!");
static_assert(offsetof(FSwitchFormIDEffect, FormID) == 0x000038, "Member 'FSwitchFormIDEffect::FormID' has a wrong offset!");

// ScriptStruct AT.TelopInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FTelopInfo final
{
public:
	struct FVector2D                              OffsetPos;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETelopViewType                                TelopViewType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TopCharacterNameID;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CenterCharacterNameID;                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BottomCharacterNameID;                             // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTelopInfo) == 0x000008, "Wrong alignment on FTelopInfo");
static_assert(sizeof(FTelopInfo) == 0x000028, "Wrong size on FTelopInfo");
static_assert(offsetof(FTelopInfo, OffsetPos) == 0x000000, "Member 'FTelopInfo::OffsetPos' has a wrong offset!");
static_assert(offsetof(FTelopInfo, TelopViewType) == 0x000008, "Member 'FTelopInfo::TelopViewType' has a wrong offset!");
static_assert(offsetof(FTelopInfo, TopCharacterNameID) == 0x000010, "Member 'FTelopInfo::TopCharacterNameID' has a wrong offset!");
static_assert(offsetof(FTelopInfo, CenterCharacterNameID) == 0x000018, "Member 'FTelopInfo::CenterCharacterNameID' has a wrong offset!");
static_assert(offsetof(FTelopInfo, BottomCharacterNameID) == 0x000020, "Member 'FTelopInfo::BottomCharacterNameID' has a wrong offset!");

// ScriptStruct AT.QuestPartyOrganizeConditionSet
// 0x0010 (0x0018 - 0x0008)
struct FQuestPartyOrganizeConditionSet final : public FTableRowBase
{
public:
	class FName                                   DlcId;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTable;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestPartyOrganizeConditionSet) == 0x000008, "Wrong alignment on FQuestPartyOrganizeConditionSet");
static_assert(sizeof(FQuestPartyOrganizeConditionSet) == 0x000018, "Wrong size on FQuestPartyOrganizeConditionSet");
static_assert(offsetof(FQuestPartyOrganizeConditionSet, DlcId) == 0x000008, "Member 'FQuestPartyOrganizeConditionSet::DlcId' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeConditionSet, DataTable) == 0x000010, "Member 'FQuestPartyOrganizeConditionSet::DataTable' has a wrong offset!");

// ScriptStruct AT.Condition_E
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FCondition_E final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCondition_E) == 0x000004, "Wrong alignment on FCondition_E");
static_assert(sizeof(FCondition_E) == 0x000008, "Wrong size on FCondition_E");

// ScriptStruct AT.ActionCommandParam
// 0x00C0 (0x00C8 - 0x0008)
struct FActionCommandParam final : public FTableRowBase
{
public:
	class FString                                 Command_id;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_command;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_1;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_2;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_3;                                    // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_4;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_5;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_6;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_7;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_8;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_9;                                    // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Action_param_10;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActionCommandParam) == 0x000008, "Wrong alignment on FActionCommandParam");
static_assert(sizeof(FActionCommandParam) == 0x0000C8, "Wrong size on FActionCommandParam");
static_assert(offsetof(FActionCommandParam, Command_id) == 0x000008, "Member 'FActionCommandParam::Command_id' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_command) == 0x000018, "Member 'FActionCommandParam::Action_command' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_1) == 0x000028, "Member 'FActionCommandParam::Action_param_1' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_2) == 0x000038, "Member 'FActionCommandParam::Action_param_2' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_3) == 0x000048, "Member 'FActionCommandParam::Action_param_3' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_4) == 0x000058, "Member 'FActionCommandParam::Action_param_4' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_5) == 0x000068, "Member 'FActionCommandParam::Action_param_5' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_6) == 0x000078, "Member 'FActionCommandParam::Action_param_6' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_7) == 0x000088, "Member 'FActionCommandParam::Action_param_7' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_8) == 0x000098, "Member 'FActionCommandParam::Action_param_8' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_9) == 0x0000A8, "Member 'FActionCommandParam::Action_param_9' has a wrong offset!");
static_assert(offsetof(FActionCommandParam, Action_param_10) == 0x0000B8, "Member 'FActionCommandParam::Action_param_10' has a wrong offset!");

// ScriptStruct AT.LandEffect
// 0x0010 (0x0010 - 0x0000)
struct FLandEffect final
{
public:
	struct FVector                                RayDir;                                            // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpawnOnNotRayHit;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x1];                                        // 0x000D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	ETraceTypeQuery                               TraceType;                                         // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLandEffect) == 0x000004, "Wrong alignment on FLandEffect");
static_assert(sizeof(FLandEffect) == 0x000010, "Wrong size on FLandEffect");
static_assert(offsetof(FLandEffect, RayDir) == 0x000000, "Member 'FLandEffect::RayDir' has a wrong offset!");
static_assert(offsetof(FLandEffect, SpawnOnNotRayHit) == 0x00000C, "Member 'FLandEffect::SpawnOnNotRayHit' has a wrong offset!");
static_assert(offsetof(FLandEffect, TraceType) == 0x00000E, "Member 'FLandEffect::TraceType' has a wrong offset!");

// ScriptStruct AT.BreakThroughParam
// 0x0050 (0x0058 - 0x0008)
struct FBreakThroughParam final : public FTableRowBase
{
public:
	int32                                         TrainingID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengingConditionID;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItemID;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleMessageId;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummaryMessageID;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DlcId;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBreakThroughParam) == 0x000008, "Wrong alignment on FBreakThroughParam");
static_assert(sizeof(FBreakThroughParam) == 0x000058, "Wrong size on FBreakThroughParam");
static_assert(offsetof(FBreakThroughParam, TrainingID) == 0x000008, "Member 'FBreakThroughParam::TrainingID' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, ChallengingConditionID) == 0x00000C, "Member 'FBreakThroughParam::ChallengingConditionID' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, RewardItemID) == 0x000010, "Member 'FBreakThroughParam::RewardItemID' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, EventBattleID) == 0x000018, "Member 'FBreakThroughParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, Recommendedlevel) == 0x000020, "Member 'FBreakThroughParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, TitleMessageId) == 0x000028, "Member 'FBreakThroughParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, SummaryMessageID) == 0x000038, "Member 'FBreakThroughParam::SummaryMessageID' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, CharacterType) == 0x000048, "Member 'FBreakThroughParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FBreakThroughParam, DlcId) == 0x000050, "Member 'FBreakThroughParam::DlcId' has a wrong offset!");

// ScriptStruct AT.ObjectsLoadedOnlyBySpecificDLCs
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FObjectsLoadedOnlyBySpecificDLCs
{
};
#pragma pack(pop)
static_assert(alignof(FObjectsLoadedOnlyBySpecificDLCs) == 0x000001, "Wrong alignment on FObjectsLoadedOnlyBySpecificDLCs");
static_assert(sizeof(FObjectsLoadedOnlyBySpecificDLCs) == 0x000001, "Wrong size on FObjectsLoadedOnlyBySpecificDLCs");

// ScriptStruct AT.ObjectsLoadedOnlyByDLC6
// 0x0140 (0x0140 - 0x0000)
struct FObjectsLoadedOnlyByDLC6 final : public FObjectsLoadedOnlyBySpecificDLCs
{
public:
	TSoftObjectPtr<class UDataTable>              DLC6TreasureSaveTable;                             // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DLC6FieldMemoriesParameter;                        // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ExtendFightingPowerParamTbl;                       // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ExtendZcwAreaNav;                                  // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               CountQTERadialMaterial;                            // 0x00A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> CountQTERadialBlurParam;                           // 0x00C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             CountQTEAlphaLpCurve;                              // 0x00F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             BattleFieldMesh;                                   // 0x0118(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectsLoadedOnlyByDLC6) == 0x000008, "Wrong alignment on FObjectsLoadedOnlyByDLC6");
static_assert(sizeof(FObjectsLoadedOnlyByDLC6) == 0x000140, "Wrong size on FObjectsLoadedOnlyByDLC6");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, DLC6TreasureSaveTable) == 0x000000, "Member 'FObjectsLoadedOnlyByDLC6::DLC6TreasureSaveTable' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, DLC6FieldMemoriesParameter) == 0x000028, "Member 'FObjectsLoadedOnlyByDLC6::DLC6FieldMemoriesParameter' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, ExtendFightingPowerParamTbl) == 0x000050, "Member 'FObjectsLoadedOnlyByDLC6::ExtendFightingPowerParamTbl' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, ExtendZcwAreaNav) == 0x000078, "Member 'FObjectsLoadedOnlyByDLC6::ExtendZcwAreaNav' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, CountQTERadialMaterial) == 0x0000A0, "Member 'FObjectsLoadedOnlyByDLC6::CountQTERadialMaterial' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, CountQTERadialBlurParam) == 0x0000C8, "Member 'FObjectsLoadedOnlyByDLC6::CountQTERadialBlurParam' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, CountQTEAlphaLpCurve) == 0x0000F0, "Member 'FObjectsLoadedOnlyByDLC6::CountQTEAlphaLpCurve' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC6, BattleFieldMesh) == 0x000118, "Member 'FObjectsLoadedOnlyByDLC6::BattleFieldMesh' has a wrong offset!");

// ScriptStruct AT.AttachObject
// 0x0040 (0x0040 - 0x0000)
struct FAttachObject final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttachObject) == 0x000010, "Wrong alignment on FAttachObject");
static_assert(sizeof(FAttachObject) == 0x000040, "Wrong size on FAttachObject");
static_assert(offsetof(FAttachObject, Mesh) == 0x000000, "Member 'FAttachObject::Mesh' has a wrong offset!");
static_assert(offsetof(FAttachObject, AttachName) == 0x000008, "Member 'FAttachObject::AttachName' has a wrong offset!");
static_assert(offsetof(FAttachObject, Offset) == 0x000010, "Member 'FAttachObject::Offset' has a wrong offset!");

// ScriptStruct AT.AuraScale
// 0x0008 (0x0008 - 0x0000)
struct FAuraScale final
{
public:
	float                                         Pow;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAuraScale) == 0x000004, "Wrong alignment on FAuraScale");
static_assert(sizeof(FAuraScale) == 0x000008, "Wrong size on FAuraScale");
static_assert(offsetof(FAuraScale, Pow) == 0x000000, "Member 'FAuraScale::Pow' has a wrong offset!");
static_assert(offsetof(FAuraScale, Scale) == 0x000004, "Member 'FAuraScale::Scale' has a wrong offset!");

// ScriptStruct AT.AccompanyCharaAuraScaleInfo
// 0x0008 (0x0008 - 0x0000)
struct FAccompanyCharaAuraScaleInfo final
{
public:
	ECHARACTER_TYPE                               Charatype;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccompanyCharaAuraScaleInfo) == 0x000004, "Wrong alignment on FAccompanyCharaAuraScaleInfo");
static_assert(sizeof(FAccompanyCharaAuraScaleInfo) == 0x000008, "Wrong size on FAccompanyCharaAuraScaleInfo");
static_assert(offsetof(FAccompanyCharaAuraScaleInfo, Charatype) == 0x000000, "Member 'FAccompanyCharaAuraScaleInfo::Charatype' has a wrong offset!");
static_assert(offsetof(FAccompanyCharaAuraScaleInfo, Scale) == 0x000004, "Member 'FAccompanyCharaAuraScaleInfo::Scale' has a wrong offset!");

// ScriptStruct AT.AuraScaleInfo
// 0x0060 (0x0060 - 0x0000)
struct FAuraScaleInfo final
{
public:
	TArray<struct FAuraScale>                     TypeA_Scale;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAuraScale>                     TypeB_Scale;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAuraScale>                     TypeC_Scale;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAuraScale>                     TypeD_Scale;                                       // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAuraScale>                     TypeE_Scale;                                       // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAccompanyCharaAuraScaleInfo>   TypeE_ByChara;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAuraScaleInfo) == 0x000008, "Wrong alignment on FAuraScaleInfo");
static_assert(sizeof(FAuraScaleInfo) == 0x000060, "Wrong size on FAuraScaleInfo");
static_assert(offsetof(FAuraScaleInfo, TypeA_Scale) == 0x000000, "Member 'FAuraScaleInfo::TypeA_Scale' has a wrong offset!");
static_assert(offsetof(FAuraScaleInfo, TypeB_Scale) == 0x000010, "Member 'FAuraScaleInfo::TypeB_Scale' has a wrong offset!");
static_assert(offsetof(FAuraScaleInfo, TypeC_Scale) == 0x000020, "Member 'FAuraScaleInfo::TypeC_Scale' has a wrong offset!");
static_assert(offsetof(FAuraScaleInfo, TypeD_Scale) == 0x000030, "Member 'FAuraScaleInfo::TypeD_Scale' has a wrong offset!");
static_assert(offsetof(FAuraScaleInfo, TypeE_Scale) == 0x000040, "Member 'FAuraScaleInfo::TypeE_Scale' has a wrong offset!");
static_assert(offsetof(FAuraScaleInfo, TypeE_ByChara) == 0x000050, "Member 'FAuraScaleInfo::TypeE_ByChara' has a wrong offset!");

// ScriptStruct AT.Acconmpany_Timer
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAcconmpany_Timer final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAcconmpany_Timer) == 0x000008, "Wrong alignment on FAcconmpany_Timer");
static_assert(sizeof(FAcconmpany_Timer) == 0x000020, "Wrong size on FAcconmpany_Timer");

// ScriptStruct AT.CookingCharacterMotion
// 0x0038 (0x0038 - 0x0000)
struct FCookingCharacterMotion final
{
public:
	class UAnimMontage*                           M_pStartAnim_ST;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAccessAnim_ST;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAccessAnim_LP;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAccessAnim_ED;                                  // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            StartCameraAnim;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            AccessStartCameraAnim;                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraAnim*                            AccessLoopCameraAnim;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingCharacterMotion) == 0x000008, "Wrong alignment on FCookingCharacterMotion");
static_assert(sizeof(FCookingCharacterMotion) == 0x000038, "Wrong size on FCookingCharacterMotion");
static_assert(offsetof(FCookingCharacterMotion, M_pStartAnim_ST) == 0x000000, "Member 'FCookingCharacterMotion::M_pStartAnim_ST' has a wrong offset!");
static_assert(offsetof(FCookingCharacterMotion, M_pAccessAnim_ST) == 0x000008, "Member 'FCookingCharacterMotion::M_pAccessAnim_ST' has a wrong offset!");
static_assert(offsetof(FCookingCharacterMotion, M_pAccessAnim_LP) == 0x000010, "Member 'FCookingCharacterMotion::M_pAccessAnim_LP' has a wrong offset!");
static_assert(offsetof(FCookingCharacterMotion, M_pAccessAnim_ED) == 0x000018, "Member 'FCookingCharacterMotion::M_pAccessAnim_ED' has a wrong offset!");
static_assert(offsetof(FCookingCharacterMotion, StartCameraAnim) == 0x000020, "Member 'FCookingCharacterMotion::StartCameraAnim' has a wrong offset!");
static_assert(offsetof(FCookingCharacterMotion, AccessStartCameraAnim) == 0x000028, "Member 'FCookingCharacterMotion::AccessStartCameraAnim' has a wrong offset!");
static_assert(offsetof(FCookingCharacterMotion, AccessLoopCameraAnim) == 0x000030, "Member 'FCookingCharacterMotion::AccessLoopCameraAnim' has a wrong offset!");

// ScriptStruct AT.PageLayoutPair
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FPageLayoutPair final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPageLayoutPair) == 0x000008, "Wrong alignment on FPageLayoutPair");
static_assert(sizeof(FPageLayoutPair) == 0x000068, "Wrong size on FPageLayoutPair");

// ScriptStruct AT.LoadingRaceGameAsset
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLoadingRaceGameAsset final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingRaceGameAsset) == 0x000008, "Wrong alignment on FLoadingRaceGameAsset");
static_assert(sizeof(FLoadingRaceGameAsset) == 0x000028, "Wrong size on FLoadingRaceGameAsset");

// ScriptStruct AT.MenuWIndowSetupListNumMenuInfo
// 0x0018 (0x0018 - 0x0000)
struct FMenuWIndowSetupListNumMenuInfo final
{
public:
	class FString                                 MenuName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListNum;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuWIndowSetupListNumMenuInfo) == 0x000008, "Wrong alignment on FMenuWIndowSetupListNumMenuInfo");
static_assert(sizeof(FMenuWIndowSetupListNumMenuInfo) == 0x000018, "Wrong size on FMenuWIndowSetupListNumMenuInfo");
static_assert(offsetof(FMenuWIndowSetupListNumMenuInfo, MenuName) == 0x000000, "Member 'FMenuWIndowSetupListNumMenuInfo::MenuName' has a wrong offset!");
static_assert(offsetof(FMenuWIndowSetupListNumMenuInfo, ListNum) == 0x000010, "Member 'FMenuWIndowSetupListNumMenuInfo::ListNum' has a wrong offset!");

// ScriptStruct AT.DLC6WorldMapActiveParamRow
// 0x0018 (0x0020 - 0x0008)
struct FDLC6WorldMapActiveParamRow final : public FTableRowBase
{
public:
	EWorldStageId                                 StageId;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSubQuestId;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC6WorldMapActiveParamRow) == 0x000008, "Wrong alignment on FDLC6WorldMapActiveParamRow");
static_assert(sizeof(FDLC6WorldMapActiveParamRow) == 0x000020, "Wrong size on FDLC6WorldMapActiveParamRow");
static_assert(offsetof(FDLC6WorldMapActiveParamRow, StageId) == 0x000008, "Member 'FDLC6WorldMapActiveParamRow::StageId' has a wrong offset!");
static_assert(offsetof(FDLC6WorldMapActiveParamRow, StartSubQuestId) == 0x000010, "Member 'FDLC6WorldMapActiveParamRow::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC6WorldMapActiveParamRow, EndSubQuestId) == 0x000018, "Member 'FDLC6WorldMapActiveParamRow::EndSubQuestId' has a wrong offset!");

// ScriptStruct AT.AI_PHEASE
// 0x001C (0x001C - 0x0000)
struct FAI_PHEASE final
{
public:
	uint8                                         Number;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PrioNum;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_PHEASE                                   Phease;                                            // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PheaseNum;                                         // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_CONDITIONS_GROUP                         Conditions1;                                       // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_TARGET                                   Target1;                                           // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Num1;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_CONDITIONAL_EXPRESSION                   Expression1;                                       // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_CONDITIONS_GROUP                         Conditions2;                                       // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_TARGET                                   Target2;                                           // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Num2;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_CONDITIONAL_EXPRESSION                   Expression2;                                       // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_CONDITIONS_GROUP                         Conditions3;                                       // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_TARGET                                   Target3;                                           // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Num3;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAI_PHEASE) == 0x000004, "Wrong alignment on FAI_PHEASE");
static_assert(sizeof(FAI_PHEASE) == 0x00001C, "Wrong size on FAI_PHEASE");
static_assert(offsetof(FAI_PHEASE, Number) == 0x000000, "Member 'FAI_PHEASE::Number' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, PrioNum) == 0x000001, "Member 'FAI_PHEASE::PrioNum' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Phease) == 0x000002, "Member 'FAI_PHEASE::Phease' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, PheaseNum) == 0x000003, "Member 'FAI_PHEASE::PheaseNum' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Conditions1) == 0x000004, "Member 'FAI_PHEASE::Conditions1' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Target1) == 0x000005, "Member 'FAI_PHEASE::Target1' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Num1) == 0x000008, "Member 'FAI_PHEASE::Num1' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Expression1) == 0x00000C, "Member 'FAI_PHEASE::Expression1' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Conditions2) == 0x00000D, "Member 'FAI_PHEASE::Conditions2' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Target2) == 0x00000E, "Member 'FAI_PHEASE::Target2' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Num2) == 0x000010, "Member 'FAI_PHEASE::Num2' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Expression2) == 0x000014, "Member 'FAI_PHEASE::Expression2' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Conditions3) == 0x000015, "Member 'FAI_PHEASE::Conditions3' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Target3) == 0x000016, "Member 'FAI_PHEASE::Target3' has a wrong offset!");
static_assert(offsetof(FAI_PHEASE, Num3) == 0x000018, "Member 'FAI_PHEASE::Num3' has a wrong offset!");

// ScriptStruct AT.AI_ActionTbl
// 0x0038 (0x0038 - 0x0000)
struct FAI_ActionTbl final
{
public:
	struct FAI_PHEASE                             PheaseTbl;                                         // 0x0000(0x001C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	E_AI_ACTION                                   Category;                                          // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Lot;                                               // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReCast;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InterruptFlg;                                      // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAI_BehaviorTbl>                beahviorTbl;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAI_ActionTbl) == 0x000008, "Wrong alignment on FAI_ActionTbl");
static_assert(sizeof(FAI_ActionTbl) == 0x000038, "Wrong size on FAI_ActionTbl");
static_assert(offsetof(FAI_ActionTbl, PheaseTbl) == 0x000000, "Member 'FAI_ActionTbl::PheaseTbl' has a wrong offset!");
static_assert(offsetof(FAI_ActionTbl, Category) == 0x00001C, "Member 'FAI_ActionTbl::Category' has a wrong offset!");
static_assert(offsetof(FAI_ActionTbl, Lot) == 0x00001D, "Member 'FAI_ActionTbl::Lot' has a wrong offset!");
static_assert(offsetof(FAI_ActionTbl, ReCast) == 0x000020, "Member 'FAI_ActionTbl::ReCast' has a wrong offset!");
static_assert(offsetof(FAI_ActionTbl, InterruptFlg) == 0x000024, "Member 'FAI_ActionTbl::InterruptFlg' has a wrong offset!");
static_assert(offsetof(FAI_ActionTbl, beahviorTbl) == 0x000028, "Member 'FAI_ActionTbl::beahviorTbl' has a wrong offset!");

// ScriptStruct AT.EnemyGaugeNumOverwriteInfo
// 0x0010 (0x0018 - 0x0008)
struct FEnemyGaugeNumOverwriteInfo final : public FTableRowBase
{
public:
	class FName                                   EventBattleName;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Type;                                              // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GaugeNum;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyGaugeNumOverwriteInfo) == 0x000008, "Wrong alignment on FEnemyGaugeNumOverwriteInfo");
static_assert(sizeof(FEnemyGaugeNumOverwriteInfo) == 0x000018, "Wrong size on FEnemyGaugeNumOverwriteInfo");
static_assert(offsetof(FEnemyGaugeNumOverwriteInfo, EventBattleName) == 0x000008, "Member 'FEnemyGaugeNumOverwriteInfo::EventBattleName' has a wrong offset!");
static_assert(offsetof(FEnemyGaugeNumOverwriteInfo, Type) == 0x000010, "Member 'FEnemyGaugeNumOverwriteInfo::Type' has a wrong offset!");
static_assert(offsetof(FEnemyGaugeNumOverwriteInfo, GaugeNum) == 0x000014, "Member 'FEnemyGaugeNumOverwriteInfo::GaugeNum' has a wrong offset!");

// ScriptStruct AT.DebriMeshAssetPath
// 0x0030 (0x0030 - 0x0000)
struct FDebriMeshAssetPath final
{
public:
	TSoftObjectPtr<class UStaticMesh>             DebriMesh;                                         // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DebriMeshInstance;                                 // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDebriMeshAssetPath) == 0x000008, "Wrong alignment on FDebriMeshAssetPath");
static_assert(sizeof(FDebriMeshAssetPath) == 0x000030, "Wrong size on FDebriMeshAssetPath");
static_assert(offsetof(FDebriMeshAssetPath, DebriMesh) == 0x000000, "Member 'FDebriMeshAssetPath::DebriMesh' has a wrong offset!");
static_assert(offsetof(FDebriMeshAssetPath, DebriMeshInstance) == 0x000028, "Member 'FDebriMeshAssetPath::DebriMeshInstance' has a wrong offset!");

// ScriptStruct AT.ATCharacterBuffParticle
// 0x0020 (0x0020 - 0x0000)
struct FATCharacterBuffParticle final
{
public:
	class UParticleSystem*                        StartParticle;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LoopParticle;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EndParticle;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ChangeParticle;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterBuffParticle) == 0x000008, "Wrong alignment on FATCharacterBuffParticle");
static_assert(sizeof(FATCharacterBuffParticle) == 0x000020, "Wrong size on FATCharacterBuffParticle");
static_assert(offsetof(FATCharacterBuffParticle, StartParticle) == 0x000000, "Member 'FATCharacterBuffParticle::StartParticle' has a wrong offset!");
static_assert(offsetof(FATCharacterBuffParticle, LoopParticle) == 0x000008, "Member 'FATCharacterBuffParticle::LoopParticle' has a wrong offset!");
static_assert(offsetof(FATCharacterBuffParticle, EndParticle) == 0x000010, "Member 'FATCharacterBuffParticle::EndParticle' has a wrong offset!");
static_assert(offsetof(FATCharacterBuffParticle, ChangeParticle) == 0x000018, "Member 'FATCharacterBuffParticle::ChangeParticle' has a wrong offset!");

// ScriptStruct AT.DirectionalLights
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDirectionalLights final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectionalLights) == 0x000008, "Wrong alignment on FDirectionalLights");
static_assert(sizeof(FDirectionalLights) == 0x000010, "Wrong size on FDirectionalLights");

// ScriptStruct AT.CmnMenuList00Param
// 0x0028 (0x0028 - 0x0000)
struct FCmnMenuList00Param final
{
public:
	EITEM_ICON_CATEGORY_TYPE                      ItemType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               IconType;                                          // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClear;                                          // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIconColor;                                      // 0x001F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnMenuList00Param) == 0x000008, "Wrong alignment on FCmnMenuList00Param");
static_assert(sizeof(FCmnMenuList00Param) == 0x000028, "Wrong size on FCmnMenuList00Param");
static_assert(offsetof(FCmnMenuList00Param, ItemType) == 0x000000, "Member 'FCmnMenuList00Param::ItemType' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, IconType) == 0x000001, "Member 'FCmnMenuList00Param::IconType' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, ItemName) == 0x000008, "Member 'FCmnMenuList00Param::ItemName' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, ItemNum) == 0x000018, "Member 'FCmnMenuList00Param::ItemNum' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, bIsNew) == 0x00001C, "Member 'FCmnMenuList00Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, bIsActive) == 0x00001D, "Member 'FCmnMenuList00Param::bIsActive' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, bIsClear) == 0x00001E, "Member 'FCmnMenuList00Param::bIsClear' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, bIsIconColor) == 0x00001F, "Member 'FCmnMenuList00Param::bIsIconColor' has a wrong offset!");
static_assert(offsetof(FCmnMenuList00Param, Rarity) == 0x000020, "Member 'FCmnMenuList00Param::Rarity' has a wrong offset!");

// ScriptStruct AT.ReferenceToParticleAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToParticleAssetInstance final
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToParticleAssetInstance) == 0x000008, "Wrong alignment on FReferenceToParticleAssetInstance");
static_assert(sizeof(FReferenceToParticleAssetInstance) == 0x000008, "Wrong size on FReferenceToParticleAssetInstance");
static_assert(offsetof(FReferenceToParticleAssetInstance, ParticleSystem) == 0x000000, "Member 'FReferenceToParticleAssetInstance::ParticleSystem' has a wrong offset!");

// ScriptStruct AT.UIQuestDetail
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FUIQuestDetail final
{
public:
	class FName                                   DetailTxt;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestType;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollectionStartNum;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CollectionEndNum;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIQuestDetail) == 0x000008, "Wrong alignment on FUIQuestDetail");
static_assert(sizeof(FUIQuestDetail) == 0x000018, "Wrong size on FUIQuestDetail");
static_assert(offsetof(FUIQuestDetail, DetailTxt) == 0x000000, "Member 'FUIQuestDetail::DetailTxt' has a wrong offset!");
static_assert(offsetof(FUIQuestDetail, QuestType) == 0x000008, "Member 'FUIQuestDetail::QuestType' has a wrong offset!");
static_assert(offsetof(FUIQuestDetail, CollectionStartNum) == 0x00000C, "Member 'FUIQuestDetail::CollectionStartNum' has a wrong offset!");
static_assert(offsetof(FUIQuestDetail, CollectionEndNum) == 0x000010, "Member 'FUIQuestDetail::CollectionEndNum' has a wrong offset!");

// ScriptStruct AT.UIQuestInfo
// 0x0080 (0x0080 - 0x0000)
struct FUIQuestInfo final
{
public:
	bool                                          bIsReplay;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMainQuest;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestCaptionTitle;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestCaptionDetail;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConvertedQuestCaptionDetail;                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestProgressDetail;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReplaceTxtCtn;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   QuestListId;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestListTitle;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConvertedQuestListTitle;                           // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FUIQuestDetail>                 QuestList;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         ListReplaceTxtCtn;                                 // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIQuestInfo) == 0x000008, "Wrong alignment on FUIQuestInfo");
static_assert(sizeof(FUIQuestInfo) == 0x000080, "Wrong size on FUIQuestInfo");
static_assert(offsetof(FUIQuestInfo, bIsReplay) == 0x000000, "Member 'FUIQuestInfo::bIsReplay' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, bIsMainQuest) == 0x000001, "Member 'FUIQuestInfo::bIsMainQuest' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, QuestCaptionTitle) == 0x000008, "Member 'FUIQuestInfo::QuestCaptionTitle' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, QuestCaptionDetail) == 0x000010, "Member 'FUIQuestInfo::QuestCaptionDetail' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, ConvertedQuestCaptionDetail) == 0x000018, "Member 'FUIQuestInfo::ConvertedQuestCaptionDetail' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, QuestProgressDetail) == 0x000028, "Member 'FUIQuestInfo::QuestProgressDetail' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, ReplaceTxtCtn) == 0x000030, "Member 'FUIQuestInfo::ReplaceTxtCtn' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, QuestListId) == 0x000040, "Member 'FUIQuestInfo::QuestListId' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, QuestListTitle) == 0x000048, "Member 'FUIQuestInfo::QuestListTitle' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, ConvertedQuestListTitle) == 0x000050, "Member 'FUIQuestInfo::ConvertedQuestListTitle' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, QuestList) == 0x000060, "Member 'FUIQuestInfo::QuestList' has a wrong offset!");
static_assert(offsetof(FUIQuestInfo, ListReplaceTxtCtn) == 0x000070, "Member 'FUIQuestInfo::ListReplaceTxtCtn' has a wrong offset!");

// ScriptStruct AT.ATDamagePositiveParam
// 0x0038 (0x0038 - 0x0000)
struct FATDamagePositiveParam final
{
public:
	class FName                                   DamageId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackRate;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackAngleV;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackAngleH;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageDirectionType                          KnockbackType;                                     // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BLOWVECTOR                                  ImpulseType;                                       // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_REACTION_TYPE                               ReactionId;                                        // 0x001E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDamageStrength                               StrengthId;                                        // 0x001F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStop;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraShake                                  CameraShakeType;                                   // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HoldTime;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddHoldTime_SupportChar;                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OffsetStrength;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDamagePositiveParam) == 0x000008, "Wrong alignment on FATDamagePositiveParam");
static_assert(sizeof(FATDamagePositiveParam) == 0x000038, "Wrong size on FATDamagePositiveParam");
static_assert(offsetof(FATDamagePositiveParam, DamageId) == 0x000000, "Member 'FATDamagePositiveParam::DamageId' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, DamageType) == 0x000008, "Member 'FATDamagePositiveParam::DamageType' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, KnockbackRate) == 0x000010, "Member 'FATDamagePositiveParam::KnockbackRate' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, KnockbackAngleV) == 0x000014, "Member 'FATDamagePositiveParam::KnockbackAngleV' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, KnockbackAngleH) == 0x000018, "Member 'FATDamagePositiveParam::KnockbackAngleH' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, KnockbackType) == 0x00001C, "Member 'FATDamagePositiveParam::KnockbackType' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, ImpulseType) == 0x00001D, "Member 'FATDamagePositiveParam::ImpulseType' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, ReactionId) == 0x00001E, "Member 'FATDamagePositiveParam::ReactionId' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, StrengthId) == 0x00001F, "Member 'FATDamagePositiveParam::StrengthId' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, HitStop) == 0x000020, "Member 'FATDamagePositiveParam::HitStop' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, CameraShakeType) == 0x000024, "Member 'FATDamagePositiveParam::CameraShakeType' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, HoldTime) == 0x000028, "Member 'FATDamagePositiveParam::HoldTime' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, AddHoldTime_SupportChar) == 0x00002C, "Member 'FATDamagePositiveParam::AddHoldTime_SupportChar' has a wrong offset!");
static_assert(offsetof(FATDamagePositiveParam, OffsetStrength) == 0x000030, "Member 'FATDamagePositiveParam::OffsetStrength' has a wrong offset!");

// ScriptStruct AT.EnemyParamDistRelationTbl
// 0x0040 (0x0048 - 0x0008)
struct FEnemyParamDistRelationTbl final : public FTableRowBase
{
public:
	float                                         Outlock_deg;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Outlock_dist;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Energy_dist;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Short_dist;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Middle_dist;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Long_dist;                                         // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackAtk_enable_dist;                               // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BackAtk_enable_deg;                                // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncountStartDist;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncountBattleStartDist;                            // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutrageRadius;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutrageDistance;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutrageKnockbackRate;                              // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutrageKnockbackDepression;                        // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundEncountStartDist;                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyParamDistRelationTbl) == 0x000008, "Wrong alignment on FEnemyParamDistRelationTbl");
static_assert(sizeof(FEnemyParamDistRelationTbl) == 0x000048, "Wrong size on FEnemyParamDistRelationTbl");
static_assert(offsetof(FEnemyParamDistRelationTbl, Outlock_deg) == 0x000008, "Member 'FEnemyParamDistRelationTbl::Outlock_deg' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, Outlock_dist) == 0x00000C, "Member 'FEnemyParamDistRelationTbl::Outlock_dist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, Energy_dist) == 0x000010, "Member 'FEnemyParamDistRelationTbl::Energy_dist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, Short_dist) == 0x000014, "Member 'FEnemyParamDistRelationTbl::Short_dist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, Middle_dist) == 0x000018, "Member 'FEnemyParamDistRelationTbl::Middle_dist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, Long_dist) == 0x00001C, "Member 'FEnemyParamDistRelationTbl::Long_dist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, BackAtk_enable_dist) == 0x000020, "Member 'FEnemyParamDistRelationTbl::BackAtk_enable_dist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, BackAtk_enable_deg) == 0x000024, "Member 'FEnemyParamDistRelationTbl::BackAtk_enable_deg' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, EncountStartDist) == 0x000028, "Member 'FEnemyParamDistRelationTbl::EncountStartDist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, EncountBattleStartDist) == 0x00002C, "Member 'FEnemyParamDistRelationTbl::EncountBattleStartDist' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, OutrageRadius) == 0x000030, "Member 'FEnemyParamDistRelationTbl::OutrageRadius' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, OutrageDistance) == 0x000034, "Member 'FEnemyParamDistRelationTbl::OutrageDistance' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, OutrageKnockbackRate) == 0x000038, "Member 'FEnemyParamDistRelationTbl::OutrageKnockbackRate' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, OutrageKnockbackDepression) == 0x00003C, "Member 'FEnemyParamDistRelationTbl::OutrageKnockbackDepression' has a wrong offset!");
static_assert(offsetof(FEnemyParamDistRelationTbl, GroundEncountStartDist) == 0x000040, "Member 'FEnemyParamDistRelationTbl::GroundEncountStartDist' has a wrong offset!");

// ScriptStruct AT.FeverIgnoreSubQuestTableRow
// 0x0008 (0x0010 - 0x0008)
struct FFeverIgnoreSubQuestTableRow final : public FTableRowBase
{
public:
	class FName                                   IgnoreQuest;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeverIgnoreSubQuestTableRow) == 0x000008, "Wrong alignment on FFeverIgnoreSubQuestTableRow");
static_assert(sizeof(FFeverIgnoreSubQuestTableRow) == 0x000010, "Wrong size on FFeverIgnoreSubQuestTableRow");
static_assert(offsetof(FFeverIgnoreSubQuestTableRow, IgnoreQuest) == 0x000008, "Member 'FFeverIgnoreSubQuestTableRow::IgnoreQuest' has a wrong offset!");

// ScriptStruct AT.ItemListWindowParam
// 0x0010 (0x0018 - 0x0008)
struct FItemListWindowParam final : public FTableRowBase
{
public:
	class FName                                   TitleMessageId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItemID;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemListWindowParam) == 0x000008, "Wrong alignment on FItemListWindowParam");
static_assert(sizeof(FItemListWindowParam) == 0x000018, "Wrong size on FItemListWindowParam");
static_assert(offsetof(FItemListWindowParam, TitleMessageId) == 0x000008, "Member 'FItemListWindowParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FItemListWindowParam, RewardItemID) == 0x000010, "Member 'FItemListWindowParam::RewardItemID' has a wrong offset!");

// ScriptStruct AT.MoveForwardTbl
// 0x0010 (0x0018 - 0x0008)
struct FMoveForwardTbl final : public FTableRowBase
{
public:
	float                                         MinSpeed;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinFuraDistance;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxFuraDistance;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMoveForwardTbl) == 0x000008, "Wrong alignment on FMoveForwardTbl");
static_assert(sizeof(FMoveForwardTbl) == 0x000018, "Wrong size on FMoveForwardTbl");
static_assert(offsetof(FMoveForwardTbl, MinSpeed) == 0x000008, "Member 'FMoveForwardTbl::MinSpeed' has a wrong offset!");
static_assert(offsetof(FMoveForwardTbl, MaxSpeed) == 0x00000C, "Member 'FMoveForwardTbl::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMoveForwardTbl, MinFuraDistance) == 0x000010, "Member 'FMoveForwardTbl::MinFuraDistance' has a wrong offset!");
static_assert(offsetof(FMoveForwardTbl, MaxFuraDistance) == 0x000014, "Member 'FMoveForwardTbl::MaxFuraDistance' has a wrong offset!");

// ScriptStruct AT.StateEffectParameter
// 0x0038 (0x0038 - 0x0000)
struct FStateEffectParameter final
{
public:
	class UParticleSystem*                        Effect;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetLocation;                                    // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotation;                                    // 0x0014(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OffsetSize;                                        // 0x0020(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStateEffectParameter) == 0x000008, "Wrong alignment on FStateEffectParameter");
static_assert(sizeof(FStateEffectParameter) == 0x000038, "Wrong size on FStateEffectParameter");
static_assert(offsetof(FStateEffectParameter, Effect) == 0x000000, "Member 'FStateEffectParameter::Effect' has a wrong offset!");
static_assert(offsetof(FStateEffectParameter, OffsetLocation) == 0x000008, "Member 'FStateEffectParameter::OffsetLocation' has a wrong offset!");
static_assert(offsetof(FStateEffectParameter, OffsetRotation) == 0x000014, "Member 'FStateEffectParameter::OffsetRotation' has a wrong offset!");
static_assert(offsetof(FStateEffectParameter, OffsetSize) == 0x000020, "Member 'FStateEffectParameter::OffsetSize' has a wrong offset!");
static_assert(offsetof(FStateEffectParameter, Attached) == 0x00002C, "Member 'FStateEffectParameter::Attached' has a wrong offset!");
static_assert(offsetof(FStateEffectParameter, SocketName) == 0x000030, "Member 'FStateEffectParameter::SocketName' has a wrong offset!");

// ScriptStruct AT.ATDamageCollision
// 0x0008 (0x0008 - 0x0000)
struct FATDamageCollision final
{
public:
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x0000(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDamageCollision) == 0x000008, "Wrong alignment on FATDamageCollision");
static_assert(sizeof(FATDamageCollision) == 0x000008, "Wrong size on FATDamageCollision");
static_assert(offsetof(FATDamageCollision, CapsuleComponent) == 0x000000, "Member 'FATDamageCollision::CapsuleComponent' has a wrong offset!");

// ScriptStruct AT.MoveAroundTbl
// 0x0028 (0x0030 - 0x0008)
struct FMoveAroundTbl final : public FTableRowBase
{
public:
	float                                         MinSpeed;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSpeed;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VariableSpeed;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinVariableSpeedTime;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVariableSpeedTime;                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayDistance;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TowardDistanceSpeed;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMoveAroundTbl) == 0x000008, "Wrong alignment on FMoveAroundTbl");
static_assert(sizeof(FMoveAroundTbl) == 0x000030, "Wrong size on FMoveAroundTbl");
static_assert(offsetof(FMoveAroundTbl, MinSpeed) == 0x000008, "Member 'FMoveAroundTbl::MinSpeed' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, MaxSpeed) == 0x00000C, "Member 'FMoveAroundTbl::MaxSpeed' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, VariableSpeed) == 0x000010, "Member 'FMoveAroundTbl::VariableSpeed' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, MinVariableSpeedTime) == 0x000014, "Member 'FMoveAroundTbl::MinVariableSpeedTime' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, MaxVariableSpeedTime) == 0x000018, "Member 'FMoveAroundTbl::MaxVariableSpeedTime' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, MinDistance) == 0x00001C, "Member 'FMoveAroundTbl::MinDistance' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, MaxDistance) == 0x000020, "Member 'FMoveAroundTbl::MaxDistance' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, PlayDistance) == 0x000024, "Member 'FMoveAroundTbl::PlayDistance' has a wrong offset!");
static_assert(offsetof(FMoveAroundTbl, TowardDistanceSpeed) == 0x000028, "Member 'FMoveAroundTbl::TowardDistanceSpeed' has a wrong offset!");

// ScriptStruct AT.SaveLoadBarParam
// 0x0080 (0x0080 - 0x0000)
struct FSaveLoadBarParam final
{
public:
	class UTexture2D*                             ScreenTex;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x78];                                       // 0x0008(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveLoadBarParam) == 0x000008, "Wrong alignment on FSaveLoadBarParam");
static_assert(sizeof(FSaveLoadBarParam) == 0x000080, "Wrong size on FSaveLoadBarParam");
static_assert(offsetof(FSaveLoadBarParam, ScreenTex) == 0x000000, "Member 'FSaveLoadBarParam::ScreenTex' has a wrong offset!");

// ScriptStruct AT.AI_TPSActionBehaviorTbl
// 0x0038 (0x0040 - 0x0008)
struct FAI_TPSActionBehaviorTbl final : public FTableRowBase
{
public:
	float                                         ResetDist;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MoveLot;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CurveLot;                                          // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StepLot;                                           // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovingDistanceMin;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovingDistanceMax;                                 // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTimeMin;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTimeMax;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistScale;                                         // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveDistMin;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveDistMax;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegMin;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DegMax;                                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveCenterDistMin;                                // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurveCenterDistMax;                                // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAI_TPSActionBehaviorTbl) == 0x000008, "Wrong alignment on FAI_TPSActionBehaviorTbl");
static_assert(sizeof(FAI_TPSActionBehaviorTbl) == 0x000040, "Wrong size on FAI_TPSActionBehaviorTbl");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, ResetDist) == 0x000008, "Member 'FAI_TPSActionBehaviorTbl::ResetDist' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, MoveLot) == 0x00000C, "Member 'FAI_TPSActionBehaviorTbl::MoveLot' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, CurveLot) == 0x00000D, "Member 'FAI_TPSActionBehaviorTbl::CurveLot' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, StepLot) == 0x00000E, "Member 'FAI_TPSActionBehaviorTbl::StepLot' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, MovingDistanceMin) == 0x000010, "Member 'FAI_TPSActionBehaviorTbl::MovingDistanceMin' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, MovingDistanceMax) == 0x000014, "Member 'FAI_TPSActionBehaviorTbl::MovingDistanceMax' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, WaitTimeMin) == 0x000018, "Member 'FAI_TPSActionBehaviorTbl::WaitTimeMin' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, WaitTimeMax) == 0x00001C, "Member 'FAI_TPSActionBehaviorTbl::WaitTimeMax' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, Interval) == 0x000020, "Member 'FAI_TPSActionBehaviorTbl::Interval' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, DistScale) == 0x000024, "Member 'FAI_TPSActionBehaviorTbl::DistScale' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, CurveDistMin) == 0x000028, "Member 'FAI_TPSActionBehaviorTbl::CurveDistMin' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, CurveDistMax) == 0x00002C, "Member 'FAI_TPSActionBehaviorTbl::CurveDistMax' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, DegMin) == 0x000030, "Member 'FAI_TPSActionBehaviorTbl::DegMin' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, DegMax) == 0x000034, "Member 'FAI_TPSActionBehaviorTbl::DegMax' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, CurveCenterDistMin) == 0x000038, "Member 'FAI_TPSActionBehaviorTbl::CurveCenterDistMin' has a wrong offset!");
static_assert(offsetof(FAI_TPSActionBehaviorTbl, CurveCenterDistMax) == 0x00003C, "Member 'FAI_TPSActionBehaviorTbl::CurveCenterDistMax' has a wrong offset!");

// ScriptStruct AT.EffectData
// 0x0028 (0x0040 - 0x0018)
struct FEffectData : public FEffectBaseData
{
public:
	bool                                          Inverce;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRelative;                                        // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyAtEnd;                                      // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DetachedAtEnd;                                     // 0x003A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEffectData) == 0x000008, "Wrong alignment on FEffectData");
static_assert(sizeof(FEffectData) == 0x000040, "Wrong size on FEffectData");
static_assert(offsetof(FEffectData, Inverce) == 0x000018, "Member 'FEffectData::Inverce' has a wrong offset!");
static_assert(offsetof(FEffectData, IsRelative) == 0x000019, "Member 'FEffectData::IsRelative' has a wrong offset!");
static_assert(offsetof(FEffectData, LocationOffset) == 0x00001C, "Member 'FEffectData::LocationOffset' has a wrong offset!");
static_assert(offsetof(FEffectData, RotationOffset) == 0x000028, "Member 'FEffectData::RotationOffset' has a wrong offset!");
static_assert(offsetof(FEffectData, Scale) == 0x000034, "Member 'FEffectData::Scale' has a wrong offset!");
static_assert(offsetof(FEffectData, Attached) == 0x000038, "Member 'FEffectData::Attached' has a wrong offset!");
static_assert(offsetof(FEffectData, DestroyAtEnd) == 0x000039, "Member 'FEffectData::DestroyAtEnd' has a wrong offset!");
static_assert(offsetof(FEffectData, DetachedAtEnd) == 0x00003A, "Member 'FEffectData::DetachedAtEnd' has a wrong offset!");

// ScriptStruct AT.EF_ParticleData
// 0x0010 (0x0050 - 0x0040)
struct FEF_ParticleData final : public FEffectData
{
public:
	class FName                                   SocketName;                                        // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSystem;                                    // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEF_ParticleData) == 0x000008, "Wrong alignment on FEF_ParticleData");
static_assert(sizeof(FEF_ParticleData) == 0x000050, "Wrong size on FEF_ParticleData");
static_assert(offsetof(FEF_ParticleData, SocketName) == 0x000040, "Member 'FEF_ParticleData::SocketName' has a wrong offset!");
static_assert(offsetof(FEF_ParticleData, ParticleSystem) == 0x000048, "Member 'FEF_ParticleData::ParticleSystem' has a wrong offset!");

// ScriptStruct AT.KeyTipsParam
// 0x0020 (0x0028 - 0x0008)
struct FKeyTipsParam final : public FTableRowBase
{
public:
	class FName                                   TipsId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlaceId;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BtnId;                                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FuncId;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyTipsParam) == 0x000008, "Wrong alignment on FKeyTipsParam");
static_assert(sizeof(FKeyTipsParam) == 0x000028, "Wrong size on FKeyTipsParam");
static_assert(offsetof(FKeyTipsParam, TipsId) == 0x000008, "Member 'FKeyTipsParam::TipsId' has a wrong offset!");
static_assert(offsetof(FKeyTipsParam, PlaceId) == 0x000010, "Member 'FKeyTipsParam::PlaceId' has a wrong offset!");
static_assert(offsetof(FKeyTipsParam, BtnId) == 0x000018, "Member 'FKeyTipsParam::BtnId' has a wrong offset!");
static_assert(offsetof(FKeyTipsParam, FuncId) == 0x000020, "Member 'FKeyTipsParam::FuncId' has a wrong offset!");

// ScriptStruct AT.LoadingItemAsset
// 0x0001 (0x0001 - 0x0000)
struct FLoadingItemAsset final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingItemAsset) == 0x000001, "Wrong alignment on FLoadingItemAsset");
static_assert(sizeof(FLoadingItemAsset) == 0x000001, "Wrong size on FLoadingItemAsset");

// ScriptStruct AT.SpawnList
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FSpawnList final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnList) == 0x000008, "Wrong alignment on FSpawnList");
static_assert(sizeof(FSpawnList) == 0x000050, "Wrong size on FSpawnList");

// ScriptStruct AT.WishCountParam
// 0x0028 (0x0030 - 0x0008)
struct FWishCountParam final : public FTableRowBase
{
public:
	class FName                                   StartQuestId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseCount;                                          // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxCount;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWishCountParam) == 0x000008, "Wrong alignment on FWishCountParam");
static_assert(sizeof(FWishCountParam) == 0x000030, "Wrong size on FWishCountParam");
static_assert(offsetof(FWishCountParam, StartQuestId) == 0x000008, "Member 'FWishCountParam::StartQuestId' has a wrong offset!");
static_assert(offsetof(FWishCountParam, StartPhaseNo) == 0x000010, "Member 'FWishCountParam::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishCountParam, EndQuestId) == 0x000018, "Member 'FWishCountParam::EndQuestId' has a wrong offset!");
static_assert(offsetof(FWishCountParam, EndPhaseNo) == 0x000020, "Member 'FWishCountParam::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishCountParam, UseCount) == 0x000024, "Member 'FWishCountParam::UseCount' has a wrong offset!");
static_assert(offsetof(FWishCountParam, MaxCount) == 0x000028, "Member 'FWishCountParam::MaxCount' has a wrong offset!");

// ScriptStruct AT.FloatTableRow
// 0x0008 (0x0010 - 0x0008)
struct FFloatTableRow final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFloatTableRow) == 0x000008, "Wrong alignment on FFloatTableRow");
static_assert(sizeof(FFloatTableRow) == 0x000010, "Wrong size on FFloatTableRow");
static_assert(offsetof(FFloatTableRow, Value) == 0x000008, "Member 'FFloatTableRow::Value' has a wrong offset!");

// ScriptStruct AT.SpawnParam
// 0x0018 (0x0018 - 0x0000)
struct FSpawnParam final
{
public:
	class AAT_Character*                          Chara;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Target;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnParam) == 0x000008, "Wrong alignment on FSpawnParam");
static_assert(sizeof(FSpawnParam) == 0x000018, "Wrong size on FSpawnParam");
static_assert(offsetof(FSpawnParam, Chara) == 0x000000, "Member 'FSpawnParam::Chara' has a wrong offset!");
static_assert(offsetof(FSpawnParam, Target) == 0x000008, "Member 'FSpawnParam::Target' has a wrong offset!");

// ScriptStruct AT.AssaultBattlePhaseCondition
// 0x0018 (0x0020 - 0x0008)
struct FAssaultBattlePhaseCondition final : public FTableRowBase
{
public:
	class FName                                   DefaultQuestId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GameOverQuestId;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleFadeId;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssaultBattlePhaseCondition) == 0x000008, "Wrong alignment on FAssaultBattlePhaseCondition");
static_assert(sizeof(FAssaultBattlePhaseCondition) == 0x000020, "Wrong size on FAssaultBattlePhaseCondition");
static_assert(offsetof(FAssaultBattlePhaseCondition, DefaultQuestId) == 0x000008, "Member 'FAssaultBattlePhaseCondition::DefaultQuestId' has a wrong offset!");
static_assert(offsetof(FAssaultBattlePhaseCondition, GameOverQuestId) == 0x000010, "Member 'FAssaultBattlePhaseCondition::GameOverQuestId' has a wrong offset!");
static_assert(offsetof(FAssaultBattlePhaseCondition, BattleFadeId) == 0x000018, "Member 'FAssaultBattlePhaseCondition::BattleFadeId' has a wrong offset!");

// ScriptStruct AT.AndroidAssaultDroneSpawnPattern
// 0x0010 (0x0010 - 0x0000)
struct FAndroidAssaultDroneSpawnPattern final
{
public:
	TArray<class AAndroidAssaultSpawnPoint*>      SpawnPoints;                                       // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAndroidAssaultDroneSpawnPattern) == 0x000008, "Wrong alignment on FAndroidAssaultDroneSpawnPattern");
static_assert(sizeof(FAndroidAssaultDroneSpawnPattern) == 0x000010, "Wrong size on FAndroidAssaultDroneSpawnPattern");
static_assert(offsetof(FAndroidAssaultDroneSpawnPattern, SpawnPoints) == 0x000000, "Member 'FAndroidAssaultDroneSpawnPattern::SpawnPoints' has a wrong offset!");

// ScriptStruct AT.ATDataAssetDamageTypeInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetDamageTypeInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DamageTypeClass;                                   // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetDamageTypeInfo) == 0x000008, "Wrong alignment on FATDataAssetDamageTypeInfo");
static_assert(sizeof(FATDataAssetDamageTypeInfo) == 0x000030, "Wrong size on FATDataAssetDamageTypeInfo");
static_assert(offsetof(FATDataAssetDamageTypeInfo, MasterId) == 0x000000, "Member 'FATDataAssetDamageTypeInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetDamageTypeInfo, DamageTypeClass) == 0x000008, "Member 'FATDataAssetDamageTypeInfo::DamageTypeClass' has a wrong offset!");

// ScriptStruct AT.AndroidAssaultDroneTable
// 0x0010 (0x0018 - 0x0008)
struct FAndroidAssaultDroneTable final : public FTableRowBase
{
public:
	EAndroidAssaultDrone                          Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupIndex;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveIndex;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAndroidAssaultDroneTable) == 0x000008, "Wrong alignment on FAndroidAssaultDroneTable");
static_assert(sizeof(FAndroidAssaultDroneTable) == 0x000018, "Wrong size on FAndroidAssaultDroneTable");
static_assert(offsetof(FAndroidAssaultDroneTable, Type) == 0x000008, "Member 'FAndroidAssaultDroneTable::Type' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultDroneTable, GroupIndex) == 0x00000C, "Member 'FAndroidAssaultDroneTable::GroupIndex' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultDroneTable, SaveIndex) == 0x000010, "Member 'FAndroidAssaultDroneTable::SaveIndex' has a wrong offset!");

// ScriptStruct AT.LoadingFishCurveParamAsset
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FLoadingFishCurveParamAsset final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingFishCurveParamAsset) == 0x000008, "Wrong alignment on FLoadingFishCurveParamAsset");
static_assert(sizeof(FLoadingFishCurveParamAsset) == 0x000078, "Wrong size on FLoadingFishCurveParamAsset");

// ScriptStruct AT.LoadingEventBattleAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingEventBattleAsset final
{
public:
	TSoftClassPtr<class UClass>                   EventBattle;                                       // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingEventBattleAsset) == 0x000008, "Wrong alignment on FLoadingEventBattleAsset");
static_assert(sizeof(FLoadingEventBattleAsset) == 0x000028, "Wrong size on FLoadingEventBattleAsset");
static_assert(offsetof(FLoadingEventBattleAsset, EventBattle) == 0x000000, "Member 'FLoadingEventBattleAsset::EventBattle' has a wrong offset!");

// ScriptStruct AT.PageLayout
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FPageLayout final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPageLayout) == 0x000008, "Wrong alignment on FPageLayout");
static_assert(sizeof(FPageLayout) == 0x000030, "Wrong size on FPageLayout");

// ScriptStruct AT.AnimalParam
// 0x0018 (0x0020 - 0x0008)
struct FAnimalParam final : public FTableRowBase
{
public:
	class FName                                   Name;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimalEventCategory                          EventCategory;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReStartTime;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReStartCount;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimalParam) == 0x000008, "Wrong alignment on FAnimalParam");
static_assert(sizeof(FAnimalParam) == 0x000020, "Wrong size on FAnimalParam");
static_assert(offsetof(FAnimalParam, Name) == 0x000008, "Member 'FAnimalParam::Name' has a wrong offset!");
static_assert(offsetof(FAnimalParam, EventCategory) == 0x000010, "Member 'FAnimalParam::EventCategory' has a wrong offset!");
static_assert(offsetof(FAnimalParam, ReStartTime) == 0x000014, "Member 'FAnimalParam::ReStartTime' has a wrong offset!");
static_assert(offsetof(FAnimalParam, ReStartCount) == 0x000018, "Member 'FAnimalParam::ReStartCount' has a wrong offset!");

// ScriptStruct AT.EffectConditionData
// 0x0002 (0x0002 - 0x0000)
struct FEffectConditionData final
{
public:
	EEffectCondition                              Cond;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Inverce;                                           // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEffectConditionData) == 0x000001, "Wrong alignment on FEffectConditionData");
static_assert(sizeof(FEffectConditionData) == 0x000002, "Wrong size on FEffectConditionData");
static_assert(offsetof(FEffectConditionData, Cond) == 0x000000, "Member 'FEffectConditionData::Cond' has a wrong offset!");
static_assert(offsetof(FEffectConditionData, Inverce) == 0x000001, "Member 'FEffectConditionData::Inverce' has a wrong offset!");

// ScriptStruct AT.AnimalSpawnSettingData
// 0x0020 (0x0020 - 0x0000)
struct FAnimalSpawnSettingData
{
public:
	TSubclassOf<class AActor>                     ClassToSpawn;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAnimalNum;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnInsideTree;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDeletePlayerOutsideVolume;                        // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         M_SpawnedActorArray;                               // 0x0010(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimalSpawnSettingData) == 0x000008, "Wrong alignment on FAnimalSpawnSettingData");
static_assert(sizeof(FAnimalSpawnSettingData) == 0x000020, "Wrong size on FAnimalSpawnSettingData");
static_assert(offsetof(FAnimalSpawnSettingData, ClassToSpawn) == 0x000000, "Member 'FAnimalSpawnSettingData::ClassToSpawn' has a wrong offset!");
static_assert(offsetof(FAnimalSpawnSettingData, MaxAnimalNum) == 0x000008, "Member 'FAnimalSpawnSettingData::MaxAnimalNum' has a wrong offset!");
static_assert(offsetof(FAnimalSpawnSettingData, bSpawnInsideTree) == 0x00000C, "Member 'FAnimalSpawnSettingData::bSpawnInsideTree' has a wrong offset!");
static_assert(offsetof(FAnimalSpawnSettingData, bDeletePlayerOutsideVolume) == 0x00000D, "Member 'FAnimalSpawnSettingData::bDeletePlayerOutsideVolume' has a wrong offset!");
static_assert(offsetof(FAnimalSpawnSettingData, M_SpawnedActorArray) == 0x000010, "Member 'FAnimalSpawnSettingData::M_SpawnedActorArray' has a wrong offset!");

// ScriptStruct AT.GeneralCrossTalkConditionParam
// 0x0020 (0x0028 - 0x0008)
struct FGeneralCrossTalkConditionParam final : public FTableRowBase
{
public:
	class FName                                   QuestPhaseST;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestPhaseED;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECrossTalkCondition>                   CrossTalkCondition;                                // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralCrossTalkConditionParam) == 0x000008, "Wrong alignment on FGeneralCrossTalkConditionParam");
static_assert(sizeof(FGeneralCrossTalkConditionParam) == 0x000028, "Wrong size on FGeneralCrossTalkConditionParam");
static_assert(offsetof(FGeneralCrossTalkConditionParam, QuestPhaseST) == 0x000008, "Member 'FGeneralCrossTalkConditionParam::QuestPhaseST' has a wrong offset!");
static_assert(offsetof(FGeneralCrossTalkConditionParam, QuestPhaseED) == 0x000010, "Member 'FGeneralCrossTalkConditionParam::QuestPhaseED' has a wrong offset!");
static_assert(offsetof(FGeneralCrossTalkConditionParam, CrossTalkCondition) == 0x000018, "Member 'FGeneralCrossTalkConditionParam::CrossTalkCondition' has a wrong offset!");

// ScriptStruct AT.FishManagerParam
// 0x00B8 (0x00B8 - 0x0000)
struct FFishManagerParam final
{
public:
	float                                         RippleMaxSize;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<float, float>                            RippleList;                                        // 0x0008(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<float, float>                            RippleEffSizeList;                                 // 0x0058(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         RippleBeComeWeak;                                  // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TailHitDist;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishEscapeDist;                                    // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaitWindowDrawTime;                                // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishManagerParam) == 0x000008, "Wrong alignment on FFishManagerParam");
static_assert(sizeof(FFishManagerParam) == 0x0000B8, "Wrong size on FFishManagerParam");
static_assert(offsetof(FFishManagerParam, RippleMaxSize) == 0x000000, "Member 'FFishManagerParam::RippleMaxSize' has a wrong offset!");
static_assert(offsetof(FFishManagerParam, RippleList) == 0x000008, "Member 'FFishManagerParam::RippleList' has a wrong offset!");
static_assert(offsetof(FFishManagerParam, RippleEffSizeList) == 0x000058, "Member 'FFishManagerParam::RippleEffSizeList' has a wrong offset!");
static_assert(offsetof(FFishManagerParam, RippleBeComeWeak) == 0x0000A8, "Member 'FFishManagerParam::RippleBeComeWeak' has a wrong offset!");
static_assert(offsetof(FFishManagerParam, TailHitDist) == 0x0000AC, "Member 'FFishManagerParam::TailHitDist' has a wrong offset!");
static_assert(offsetof(FFishManagerParam, FishEscapeDist) == 0x0000B0, "Member 'FFishManagerParam::FishEscapeDist' has a wrong offset!");
static_assert(offsetof(FFishManagerParam, BaitWindowDrawTime) == 0x0000B4, "Member 'FFishManagerParam::BaitWindowDrawTime' has a wrong offset!");

// ScriptStruct AT.MiniGameAcquiredReward
// 0x0008 (0x0008 - 0x0000)
struct FMiniGameAcquiredReward final
{
public:
	uint32                                        ID;                                                // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayed;                                        // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniGameAcquiredReward) == 0x000004, "Wrong alignment on FMiniGameAcquiredReward");
static_assert(sizeof(FMiniGameAcquiredReward) == 0x000008, "Wrong size on FMiniGameAcquiredReward");
static_assert(offsetof(FMiniGameAcquiredReward, ID) == 0x000000, "Member 'FMiniGameAcquiredReward::ID' has a wrong offset!");
static_assert(offsetof(FMiniGameAcquiredReward, bDisplayed) == 0x000004, "Member 'FMiniGameAcquiredReward::bDisplayed' has a wrong offset!");

// ScriptStruct AT.MessageItem
// 0x0058 (0x0060 - 0x0008)
struct FMessageItem final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x58];                                       // 0x0008(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMessageItem) == 0x000008, "Wrong alignment on FMessageItem");
static_assert(sizeof(FMessageItem) == 0x000060, "Wrong size on FMessageItem");

// ScriptStruct AT.AnimalSpawnSettingData_Sky
// 0x0000 (0x0020 - 0x0020)
struct FAnimalSpawnSettingData_Sky final : public FAnimalSpawnSettingData
{
};
static_assert(alignof(FAnimalSpawnSettingData_Sky) == 0x000008, "Wrong alignment on FAnimalSpawnSettingData_Sky");
static_assert(sizeof(FAnimalSpawnSettingData_Sky) == 0x000020, "Wrong size on FAnimalSpawnSettingData_Sky");

// ScriptStruct AT.ATEnemyZOrbTable
// 0x0018 (0x0020 - 0x0008)
struct FATEnemyZOrbTable final : public FTableRowBase
{
public:
	int32                                         ZOrb_Red;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Blue;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Green;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Rainbow;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Super;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Ultimate;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATEnemyZOrbTable) == 0x000008, "Wrong alignment on FATEnemyZOrbTable");
static_assert(sizeof(FATEnemyZOrbTable) == 0x000020, "Wrong size on FATEnemyZOrbTable");
static_assert(offsetof(FATEnemyZOrbTable, ZOrb_Red) == 0x000008, "Member 'FATEnemyZOrbTable::ZOrb_Red' has a wrong offset!");
static_assert(offsetof(FATEnemyZOrbTable, ZOrb_Blue) == 0x00000C, "Member 'FATEnemyZOrbTable::ZOrb_Blue' has a wrong offset!");
static_assert(offsetof(FATEnemyZOrbTable, ZOrb_Green) == 0x000010, "Member 'FATEnemyZOrbTable::ZOrb_Green' has a wrong offset!");
static_assert(offsetof(FATEnemyZOrbTable, ZOrb_Rainbow) == 0x000014, "Member 'FATEnemyZOrbTable::ZOrb_Rainbow' has a wrong offset!");
static_assert(offsetof(FATEnemyZOrbTable, ZOrb_Super) == 0x000018, "Member 'FATEnemyZOrbTable::ZOrb_Super' has a wrong offset!");
static_assert(offsetof(FATEnemyZOrbTable, ZOrb_Ultimate) == 0x00001C, "Member 'FATEnemyZOrbTable::ZOrb_Ultimate' has a wrong offset!");

// ScriptStruct AT.PassiveSkillTable
// 0x0060 (0x0068 - 0x0008)
struct FPassiveSkillTable final : public FTableRowBase
{
public:
	class FString                                 PassiveSkillNameID;                                // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PassiveSkillDecID;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPassiveSkillEffectCategory                   EffectCategory;                                    // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EffectValue;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BuffName[0x5];                                     // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsSuperPassive;                                    // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoActivate;                                      // 0x0061(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLearnTraining;                                    // 0x0062(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x1];                                       // 0x0063(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PassiveGroupID;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveSkillTable) == 0x000008, "Wrong alignment on FPassiveSkillTable");
static_assert(sizeof(FPassiveSkillTable) == 0x000068, "Wrong size on FPassiveSkillTable");
static_assert(offsetof(FPassiveSkillTable, PassiveSkillNameID) == 0x000008, "Member 'FPassiveSkillTable::PassiveSkillNameID' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, PassiveSkillDecID) == 0x000018, "Member 'FPassiveSkillTable::PassiveSkillDecID' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, Rarity) == 0x000028, "Member 'FPassiveSkillTable::Rarity' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, EffectCategory) == 0x00002C, "Member 'FPassiveSkillTable::EffectCategory' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, EffectValue) == 0x000030, "Member 'FPassiveSkillTable::EffectValue' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, BuffName) == 0x000038, "Member 'FPassiveSkillTable::BuffName' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, IsSuperPassive) == 0x000060, "Member 'FPassiveSkillTable::IsSuperPassive' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, AutoActivate) == 0x000061, "Member 'FPassiveSkillTable::AutoActivate' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, bLearnTraining) == 0x000062, "Member 'FPassiveSkillTable::bLearnTraining' has a wrong offset!");
static_assert(offsetof(FPassiveSkillTable, PassiveGroupID) == 0x000064, "Member 'FPassiveSkillTable::PassiveGroupID' has a wrong offset!");

// ScriptStruct AT.AT_CharacterCameraParam
// 0x0030 (0x0038 - 0x0008)
struct FAT_CharacterCameraParam final : public FTableRowBase
{
public:
	float                                         NormalCameraOffsetZ;                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraOffsetZ;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalCameraTargetLength;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraTargetLength;                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraBoostTargetLength;                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraVerticalUpBoostTargetLength;              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraVerticalDownBoostTargetLength;            // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LandBoostVerticalChargeTargetLength;               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraShortBoostTargetLength;                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraShortBoostLookForwardTargetLength;        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraFloatRollSecondTargetLength;              // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyCameraFloatRollThirdTargetLength;               // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAT_CharacterCameraParam) == 0x000008, "Wrong alignment on FAT_CharacterCameraParam");
static_assert(sizeof(FAT_CharacterCameraParam) == 0x000038, "Wrong size on FAT_CharacterCameraParam");
static_assert(offsetof(FAT_CharacterCameraParam, NormalCameraOffsetZ) == 0x000008, "Member 'FAT_CharacterCameraParam::NormalCameraOffsetZ' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraOffsetZ) == 0x00000C, "Member 'FAT_CharacterCameraParam::FlyCameraOffsetZ' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, NormalCameraTargetLength) == 0x000010, "Member 'FAT_CharacterCameraParam::NormalCameraTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraTargetLength) == 0x000014, "Member 'FAT_CharacterCameraParam::FlyCameraTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraBoostTargetLength) == 0x000018, "Member 'FAT_CharacterCameraParam::FlyCameraBoostTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraVerticalUpBoostTargetLength) == 0x00001C, "Member 'FAT_CharacterCameraParam::FlyCameraVerticalUpBoostTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraVerticalDownBoostTargetLength) == 0x000020, "Member 'FAT_CharacterCameraParam::FlyCameraVerticalDownBoostTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, LandBoostVerticalChargeTargetLength) == 0x000024, "Member 'FAT_CharacterCameraParam::LandBoostVerticalChargeTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraShortBoostTargetLength) == 0x000028, "Member 'FAT_CharacterCameraParam::FlyCameraShortBoostTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraShortBoostLookForwardTargetLength) == 0x00002C, "Member 'FAT_CharacterCameraParam::FlyCameraShortBoostLookForwardTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraFloatRollSecondTargetLength) == 0x000030, "Member 'FAT_CharacterCameraParam::FlyCameraFloatRollSecondTargetLength' has a wrong offset!");
static_assert(offsetof(FAT_CharacterCameraParam, FlyCameraFloatRollThirdTargetLength) == 0x000034, "Member 'FAT_CharacterCameraParam::FlyCameraFloatRollThirdTargetLength' has a wrong offset!");

// ScriptStruct AT.ParticleRefs
// 0x0020 (0x0020 - 0x0000)
struct FParticleRefs final
{
public:
	class UParticleSystemComponent*               Appear;                                            // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        AppearSystem;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               Disappear;                                         // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        DisappearSystem;                                   // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleRefs) == 0x000008, "Wrong alignment on FParticleRefs");
static_assert(sizeof(FParticleRefs) == 0x000020, "Wrong size on FParticleRefs");
static_assert(offsetof(FParticleRefs, Appear) == 0x000000, "Member 'FParticleRefs::Appear' has a wrong offset!");
static_assert(offsetof(FParticleRefs, AppearSystem) == 0x000008, "Member 'FParticleRefs::AppearSystem' has a wrong offset!");
static_assert(offsetof(FParticleRefs, Disappear) == 0x000010, "Member 'FParticleRefs::Disappear' has a wrong offset!");
static_assert(offsetof(FParticleRefs, DisappearSystem) == 0x000018, "Member 'FParticleRefs::DisappearSystem' has a wrong offset!");

// ScriptStruct AT.LoadingParticleAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingParticleAsset final
{
public:
	TSoftObjectPtr<class UParticleSystem>         ParticleSystem;                                    // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingParticleAsset) == 0x000008, "Wrong alignment on FLoadingParticleAsset");
static_assert(sizeof(FLoadingParticleAsset) == 0x000028, "Wrong size on FLoadingParticleAsset");
static_assert(offsetof(FLoadingParticleAsset, ParticleSystem) == 0x000000, "Member 'FLoadingParticleAsset::ParticleSystem' has a wrong offset!");

// ScriptStruct AT.CookingChairOffsetParameter
// 0x0048 (0x0050 - 0x0008)
struct FCookingChairOffsetParameter final : public FTableRowBase
{
public:
	struct FChairOffset                           CenterChair;                                       // 0x0008(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FChairOffset                           LeftChair;                                         // 0x0020(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FChairOffset                           RightChair;                                        // 0x0038(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingChairOffsetParameter) == 0x000008, "Wrong alignment on FCookingChairOffsetParameter");
static_assert(sizeof(FCookingChairOffsetParameter) == 0x000050, "Wrong size on FCookingChairOffsetParameter");
static_assert(offsetof(FCookingChairOffsetParameter, CenterChair) == 0x000008, "Member 'FCookingChairOffsetParameter::CenterChair' has a wrong offset!");
static_assert(offsetof(FCookingChairOffsetParameter, LeftChair) == 0x000020, "Member 'FCookingChairOffsetParameter::LeftChair' has a wrong offset!");
static_assert(offsetof(FCookingChairOffsetParameter, RightChair) == 0x000038, "Member 'FCookingChairOffsetParameter::RightChair' has a wrong offset!");

// ScriptStruct AT.AnimNode_LookAtEx
// 0x0010 (0x0230 - 0x0220)
struct FAnimNode_LookAtEx final : public FAnimNode_LookAt
{
public:
	bool                                          bReset;                                            // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0xF];                                      // 0x0221(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_LookAtEx) == 0x000010, "Wrong alignment on FAnimNode_LookAtEx");
static_assert(sizeof(FAnimNode_LookAtEx) == 0x000230, "Wrong size on FAnimNode_LookAtEx");
static_assert(offsetof(FAnimNode_LookAtEx, bReset) == 0x000220, "Member 'FAnimNode_LookAtEx::bReset' has a wrong offset!");

// ScriptStruct AT.ATGameHUDSettings
// 0x0028 (0x0028 - 0x0000)
struct FATGameHUDSettings final
{
public:
	TSoftClassPtr<class UClass>                   Class;                                             // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATGameHUDSettings) == 0x000008, "Wrong alignment on FATGameHUDSettings");
static_assert(sizeof(FATGameHUDSettings) == 0x000028, "Wrong size on FATGameHUDSettings");
static_assert(offsetof(FATGameHUDSettings, Class) == 0x000000, "Member 'FATGameHUDSettings::Class' has a wrong offset!");

// ScriptStruct AT.Cpl005GSkill003
// 0x0038 (0x0038 - 0x0000)
struct FCpl005GSkill003 final
{
public:
	bool                                          FallToPlayer;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FallToPredict;                                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FallPosition;                                      // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnTime;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AProjectile_Cpl005GSkill003Fall> FallProjectileClass;                               // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystemComponent*               OmeParticleComponent;                              // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCpl005GSkill003) == 0x000008, "Wrong alignment on FCpl005GSkill003");
static_assert(sizeof(FCpl005GSkill003) == 0x000038, "Wrong size on FCpl005GSkill003");
static_assert(offsetof(FCpl005GSkill003, FallToPlayer) == 0x000000, "Member 'FCpl005GSkill003::FallToPlayer' has a wrong offset!");
static_assert(offsetof(FCpl005GSkill003, FallToPredict) == 0x000001, "Member 'FCpl005GSkill003::FallToPredict' has a wrong offset!");
static_assert(offsetof(FCpl005GSkill003, FallPosition) == 0x000004, "Member 'FCpl005GSkill003::FallPosition' has a wrong offset!");
static_assert(offsetof(FCpl005GSkill003, SpawnTime) == 0x000010, "Member 'FCpl005GSkill003::SpawnTime' has a wrong offset!");
static_assert(offsetof(FCpl005GSkill003, FallProjectileClass) == 0x000018, "Member 'FCpl005GSkill003::FallProjectileClass' has a wrong offset!");
static_assert(offsetof(FCpl005GSkill003, OmeParticleComponent) == 0x000020, "Member 'FCpl005GSkill003::OmeParticleComponent' has a wrong offset!");

// ScriptStruct AT.FallPatternParam
// 0x0010 (0x0010 - 0x0000)
struct FFallPatternParam final
{
public:
	TArray<struct FCpl005GSkill003>               ProjectileParam;                                   // 0x0000(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFallPatternParam) == 0x000008, "Wrong alignment on FFallPatternParam");
static_assert(sizeof(FFallPatternParam) == 0x000010, "Wrong size on FFallPatternParam");
static_assert(offsetof(FFallPatternParam, ProjectileParam) == 0x000000, "Member 'FFallPatternParam::ProjectileParam' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamBase
// 0x0018 (0x0020 - 0x0008)
struct FZCompworksParamBase : public FTableRowBase
{
public:
	EZCompworksCategoryId                         Category;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZCompworksOpenType                           OpenType1;                                         // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OpenId1;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenCount1;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideOpenId1;                                      // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksParamBase) == 0x000008, "Wrong alignment on FZCompworksParamBase");
static_assert(sizeof(FZCompworksParamBase) == 0x000020, "Wrong size on FZCompworksParamBase");
static_assert(offsetof(FZCompworksParamBase, Category) == 0x000008, "Member 'FZCompworksParamBase::Category' has a wrong offset!");
static_assert(offsetof(FZCompworksParamBase, OpenType1) == 0x000009, "Member 'FZCompworksParamBase::OpenType1' has a wrong offset!");
static_assert(offsetof(FZCompworksParamBase, OpenId1) == 0x000010, "Member 'FZCompworksParamBase::OpenId1' has a wrong offset!");
static_assert(offsetof(FZCompworksParamBase, OpenCount1) == 0x000018, "Member 'FZCompworksParamBase::OpenCount1' has a wrong offset!");
static_assert(offsetof(FZCompworksParamBase, bHideOpenId1) == 0x00001C, "Member 'FZCompworksParamBase::bHideOpenId1' has a wrong offset!");

// ScriptStruct AT.AnimNode_LookAtEyeBlend
// 0x0128 (0x0180 - 0x0058)
struct alignas(0x10) FAnimNode_LookAtEyeBlend final : public FAnimNode_AssetPlayerBase
{
public:
	struct FPoseLink                              BasePose;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FBoneReference                         BoneOfEyesParent;                                  // 0x0068(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpaceBase*                        EyeBlendSpace;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LookAtLocation;                                    // 0x0088(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ClampAngle;                                        // 0x0094(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBlendFilter                           BlendFilter;                                       // 0x00A0(0x0090)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FBlendSampleData>               BlendSampleDataCache;                              // 0x0130(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBlendSpaceBase*                        PreviousBlendSpace;                                // 0x0140(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x38];                                     // 0x0148(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimNode_LookAtEyeBlend) == 0x000010, "Wrong alignment on FAnimNode_LookAtEyeBlend");
static_assert(sizeof(FAnimNode_LookAtEyeBlend) == 0x000180, "Wrong size on FAnimNode_LookAtEyeBlend");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, BasePose) == 0x000058, "Member 'FAnimNode_LookAtEyeBlend::BasePose' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, BoneOfEyesParent) == 0x000068, "Member 'FAnimNode_LookAtEyeBlend::BoneOfEyesParent' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, EyeBlendSpace) == 0x000080, "Member 'FAnimNode_LookAtEyeBlend::EyeBlendSpace' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, LookAtLocation) == 0x000088, "Member 'FAnimNode_LookAtEyeBlend::LookAtLocation' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, ClampAngle) == 0x000094, "Member 'FAnimNode_LookAtEyeBlend::ClampAngle' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, BlendFilter) == 0x0000A0, "Member 'FAnimNode_LookAtEyeBlend::BlendFilter' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, BlendSampleDataCache) == 0x000130, "Member 'FAnimNode_LookAtEyeBlend::BlendSampleDataCache' has a wrong offset!");
static_assert(offsetof(FAnimNode_LookAtEyeBlend, PreviousBlendSpace) == 0x000140, "Member 'FAnimNode_LookAtEyeBlend::PreviousBlendSpace' has a wrong offset!");

// ScriptStruct AT.ReferenceToStarScaleFinishAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToStarScaleFinishAssetInstance final
{
public:
	TSubclassOf<class ALevelSequenceActor>        Sequencer;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToStarScaleFinishAssetInstance) == 0x000008, "Wrong alignment on FReferenceToStarScaleFinishAssetInstance");
static_assert(sizeof(FReferenceToStarScaleFinishAssetInstance) == 0x000008, "Wrong size on FReferenceToStarScaleFinishAssetInstance");
static_assert(offsetof(FReferenceToStarScaleFinishAssetInstance, Sequencer) == 0x000000, "Member 'FReferenceToStarScaleFinishAssetInstance::Sequencer' has a wrong offset!");

// ScriptStruct AT.CooperationRushMontageInfo
// 0x0010 (0x0010 - 0x0000)
struct FCooperationRushMontageInfo final
{
public:
	class UAnimMontage*                           MontageAttack;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MontageDamageID;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCooperationRushMontageInfo) == 0x000008, "Wrong alignment on FCooperationRushMontageInfo");
static_assert(sizeof(FCooperationRushMontageInfo) == 0x000010, "Wrong size on FCooperationRushMontageInfo");
static_assert(offsetof(FCooperationRushMontageInfo, MontageAttack) == 0x000000, "Member 'FCooperationRushMontageInfo::MontageAttack' has a wrong offset!");
static_assert(offsetof(FCooperationRushMontageInfo, MontageDamageID) == 0x000008, "Member 'FCooperationRushMontageInfo::MontageDamageID' has a wrong offset!");

// ScriptStruct AT.ItemInfoParam
// 0x0038 (0x0040 - 0x0008)
struct FItemInfoParam : public FTableRowBase
{
public:
	class FName                                   JName;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ToGetId;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               IconType;                                          // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Maximum;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyPrice;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellPrice;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartsTradingCost;                                  // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortNumber;                                        // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveIndex;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoolDisplay                                  Hidden;                                            // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenGetImportantItemWindow;                        // 0x003D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemInfoParam) == 0x000008, "Wrong alignment on FItemInfoParam");
static_assert(sizeof(FItemInfoParam) == 0x000040, "Wrong size on FItemInfoParam");
static_assert(offsetof(FItemInfoParam, JName) == 0x000008, "Member 'FItemInfoParam::JName' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, Rarity) == 0x000010, "Member 'FItemInfoParam::Rarity' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, ToGetId) == 0x000018, "Member 'FItemInfoParam::ToGetId' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, IconType) == 0x000020, "Member 'FItemInfoParam::IconType' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, Maximum) == 0x000024, "Member 'FItemInfoParam::Maximum' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, BuyPrice) == 0x000028, "Member 'FItemInfoParam::BuyPrice' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, SellPrice) == 0x00002C, "Member 'FItemInfoParam::SellPrice' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, PartsTradingCost) == 0x000030, "Member 'FItemInfoParam::PartsTradingCost' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, SortNumber) == 0x000034, "Member 'FItemInfoParam::SortNumber' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, SaveIndex) == 0x000038, "Member 'FItemInfoParam::SaveIndex' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, Hidden) == 0x00003C, "Member 'FItemInfoParam::Hidden' has a wrong offset!");
static_assert(offsetof(FItemInfoParam, OpenGetImportantItemWindow) == 0x00003D, "Member 'FItemInfoParam::OpenGetImportantItemWindow' has a wrong offset!");

// ScriptStruct AT.ItemTableRecipe
// 0x0010 (0x0050 - 0x0040)
struct FItemTableRecipe final : public FItemInfoParam
{
public:
	class FName                                   UnLockBentoRecipeId;                               // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnLockCourseRecipeId;                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTableRecipe) == 0x000008, "Wrong alignment on FItemTableRecipe");
static_assert(sizeof(FItemTableRecipe) == 0x000050, "Wrong size on FItemTableRecipe");
static_assert(offsetof(FItemTableRecipe, UnLockBentoRecipeId) == 0x000040, "Member 'FItemTableRecipe::UnLockBentoRecipeId' has a wrong offset!");
static_assert(offsetof(FItemTableRecipe, UnLockCourseRecipeId) == 0x000048, "Member 'FItemTableRecipe::UnLockCourseRecipeId' has a wrong offset!");

// ScriptStruct AT.SupportRecoveryHpParameter
// 0x000C (0x000C - 0x0000)
struct FSupportRecoveryHpParameter final
{
public:
	float                                         FavorBorder;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryRate;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryFixed;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportRecoveryHpParameter) == 0x000004, "Wrong alignment on FSupportRecoveryHpParameter");
static_assert(sizeof(FSupportRecoveryHpParameter) == 0x00000C, "Wrong size on FSupportRecoveryHpParameter");
static_assert(offsetof(FSupportRecoveryHpParameter, FavorBorder) == 0x000000, "Member 'FSupportRecoveryHpParameter::FavorBorder' has a wrong offset!");
static_assert(offsetof(FSupportRecoveryHpParameter, RecoveryRate) == 0x000004, "Member 'FSupportRecoveryHpParameter::RecoveryRate' has a wrong offset!");
static_assert(offsetof(FSupportRecoveryHpParameter, RecoveryFixed) == 0x000008, "Member 'FSupportRecoveryHpParameter::RecoveryFixed' has a wrong offset!");

// ScriptStruct AT.MapInformation
// 0x0050 (0x0058 - 0x0008)
struct FMapInformation final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Map_name;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled_debug_quest;                               // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Episode;                                           // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Part;                                              // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Phase;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Quest_progress;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Group_id;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Page_id;                                           // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Debug_config_id;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Symbol;                                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapInformation) == 0x000008, "Wrong alignment on FMapInformation");
static_assert(sizeof(FMapInformation) == 0x000058, "Wrong size on FMapInformation");
static_assert(offsetof(FMapInformation, Name) == 0x000008, "Member 'FMapInformation::Name' has a wrong offset!");
static_assert(offsetof(FMapInformation, Map_name) == 0x000018, "Member 'FMapInformation::Map_name' has a wrong offset!");
static_assert(offsetof(FMapInformation, Enabled_debug_quest) == 0x000020, "Member 'FMapInformation::Enabled_debug_quest' has a wrong offset!");
static_assert(offsetof(FMapInformation, Episode) == 0x000024, "Member 'FMapInformation::Episode' has a wrong offset!");
static_assert(offsetof(FMapInformation, Chapter) == 0x000028, "Member 'FMapInformation::Chapter' has a wrong offset!");
static_assert(offsetof(FMapInformation, Part) == 0x00002C, "Member 'FMapInformation::Part' has a wrong offset!");
static_assert(offsetof(FMapInformation, Phase) == 0x000030, "Member 'FMapInformation::Phase' has a wrong offset!");
static_assert(offsetof(FMapInformation, Quest_progress) == 0x000038, "Member 'FMapInformation::Quest_progress' has a wrong offset!");
static_assert(offsetof(FMapInformation, Group_id) == 0x000040, "Member 'FMapInformation::Group_id' has a wrong offset!");
static_assert(offsetof(FMapInformation, Page_id) == 0x000044, "Member 'FMapInformation::Page_id' has a wrong offset!");
static_assert(offsetof(FMapInformation, Debug_config_id) == 0x000048, "Member 'FMapInformation::Debug_config_id' has a wrong offset!");
static_assert(offsetof(FMapInformation, Symbol) == 0x000050, "Member 'FMapInformation::Symbol' has a wrong offset!");

// ScriptStruct AT.SpawnEnemyAttackSignsAtMultipleAngleSetting
// 0x0008 (0x0008 - 0x0000)
struct FSpawnEnemyAttackSignsAtMultipleAngleSetting final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnEnemyAttackSignsAtMultipleAngleSetting) == 0x000004, "Wrong alignment on FSpawnEnemyAttackSignsAtMultipleAngleSetting");
static_assert(sizeof(FSpawnEnemyAttackSignsAtMultipleAngleSetting) == 0x000008, "Wrong size on FSpawnEnemyAttackSignsAtMultipleAngleSetting");
static_assert(offsetof(FSpawnEnemyAttackSignsAtMultipleAngleSetting, Distance) == 0x000000, "Member 'FSpawnEnemyAttackSignsAtMultipleAngleSetting::Distance' has a wrong offset!");
static_assert(offsetof(FSpawnEnemyAttackSignsAtMultipleAngleSetting, Angle) == 0x000004, "Member 'FSpawnEnemyAttackSignsAtMultipleAngleSetting::Angle' has a wrong offset!");

// ScriptStruct AT.BalloonTalkParam
// 0x0050 (0x0058 - 0x0008)
struct FBalloonTalkParam final : public FTableRowBase
{
public:
	class FName                                   TalkID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TalkGroupID;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringID;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleRangeMin;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleRangeMax;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BeginActionCommandId;                              // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedActionCommandId;                          // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBalloonTalkParam) == 0x000008, "Wrong alignment on FBalloonTalkParam");
static_assert(sizeof(FBalloonTalkParam) == 0x000058, "Wrong size on FBalloonTalkParam");
static_assert(offsetof(FBalloonTalkParam, TalkID) == 0x000008, "Member 'FBalloonTalkParam::TalkID' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, TalkGroupID) == 0x000010, "Member 'FBalloonTalkParam::TalkGroupID' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, StringID) == 0x000018, "Member 'FBalloonTalkParam::StringID' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, VisibleRangeMin) == 0x000028, "Member 'FBalloonTalkParam::VisibleRangeMin' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, VisibleRangeMax) == 0x00002C, "Member 'FBalloonTalkParam::VisibleRangeMax' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, Priority) == 0x000030, "Member 'FBalloonTalkParam::Priority' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, Probability) == 0x000034, "Member 'FBalloonTalkParam::Probability' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, BeginActionCommandId) == 0x000038, "Member 'FBalloonTalkParam::BeginActionCommandId' has a wrong offset!");
static_assert(offsetof(FBalloonTalkParam, CompletedActionCommandId) == 0x000048, "Member 'FBalloonTalkParam::CompletedActionCommandId' has a wrong offset!");

// ScriptStruct AT.ATFormData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FATFormData final
{
public:
	class FName                                   CharaCodeUI;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Weight;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATFormData) == 0x000008, "Wrong alignment on FATFormData");
static_assert(sizeof(FATFormData) == 0x000010, "Wrong size on FATFormData");
static_assert(offsetof(FATFormData, CharaCodeUI) == 0x000000, "Member 'FATFormData::CharaCodeUI' has a wrong offset!");
static_assert(offsetof(FATFormData, Height) == 0x000008, "Member 'FATFormData::Height' has a wrong offset!");
static_assert(offsetof(FATFormData, Weight) == 0x00000C, "Member 'FATFormData::Weight' has a wrong offset!");

// ScriptStruct AT.ATVariationData
// 0x0040 (0x0040 - 0x0000)
struct FATVariationData final
{
public:
	TArray<struct FATFormData>                    FormData;                                          // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   FormChangeAuraName;                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HeatUpAuraName;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AuraScale;                                         // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AuraColor;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FresnelColor;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OutlineColor;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATVariationData) == 0x000008, "Wrong alignment on FATVariationData");
static_assert(sizeof(FATVariationData) == 0x000040, "Wrong size on FATVariationData");
static_assert(offsetof(FATVariationData, FormData) == 0x000000, "Member 'FATVariationData::FormData' has a wrong offset!");
static_assert(offsetof(FATVariationData, FormChangeAuraName) == 0x000010, "Member 'FATVariationData::FormChangeAuraName' has a wrong offset!");
static_assert(offsetof(FATVariationData, HeatUpAuraName) == 0x000018, "Member 'FATVariationData::HeatUpAuraName' has a wrong offset!");
static_assert(offsetof(FATVariationData, AuraScale) == 0x000020, "Member 'FATVariationData::AuraScale' has a wrong offset!");
static_assert(offsetof(FATVariationData, AuraColor) == 0x000028, "Member 'FATVariationData::AuraColor' has a wrong offset!");
static_assert(offsetof(FATVariationData, FresnelColor) == 0x000030, "Member 'FATVariationData::FresnelColor' has a wrong offset!");
static_assert(offsetof(FATVariationData, OutlineColor) == 0x000038, "Member 'FATVariationData::OutlineColor' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupItemInfo
// 0x0020 (0x0020 - 0x0000)
struct FGameWindowSetupItemInfo final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               ItemIconType;                                      // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_CATEGORY_TYPE                      ItemCategoryType;                                  // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemRarity;                                        // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupItemInfo) == 0x000008, "Wrong alignment on FGameWindowSetupItemInfo");
static_assert(sizeof(FGameWindowSetupItemInfo) == 0x000020, "Wrong size on FGameWindowSetupItemInfo");
static_assert(offsetof(FGameWindowSetupItemInfo, ItemName) == 0x000000, "Member 'FGameWindowSetupItemInfo::ItemName' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupItemInfo, ItemNum) == 0x000010, "Member 'FGameWindowSetupItemInfo::ItemNum' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupItemInfo, ItemIconType) == 0x000014, "Member 'FGameWindowSetupItemInfo::ItemIconType' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupItemInfo, ItemCategoryType) == 0x000015, "Member 'FGameWindowSetupItemInfo::ItemCategoryType' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupItemInfo, ItemRarity) == 0x000018, "Member 'FGameWindowSetupItemInfo::ItemRarity' has a wrong offset!");

// ScriptStruct AT.ProjectileLaunchData
// 0x0010 (0x0010 - 0x0000)
struct FProjectileLaunchData final
{
public:
	float                                         LaunchAngleH;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchAngleV;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchDistance;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchRoll;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileLaunchData) == 0x000004, "Wrong alignment on FProjectileLaunchData");
static_assert(sizeof(FProjectileLaunchData) == 0x000010, "Wrong size on FProjectileLaunchData");
static_assert(offsetof(FProjectileLaunchData, LaunchAngleH) == 0x000000, "Member 'FProjectileLaunchData::LaunchAngleH' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchData, LaunchAngleV) == 0x000004, "Member 'FProjectileLaunchData::LaunchAngleV' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchData, LaunchDistance) == 0x000008, "Member 'FProjectileLaunchData::LaunchDistance' has a wrong offset!");
static_assert(offsetof(FProjectileLaunchData, LaunchRoll) == 0x00000C, "Member 'FProjectileLaunchData::LaunchRoll' has a wrong offset!");

// ScriptStruct AT.ProjectileLaunchPattern
// 0x0010 (0x0010 - 0x0000)
struct FProjectileLaunchPattern final
{
public:
	TArray<struct FProjectileLaunchData>          LaunchData;                                        // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileLaunchPattern) == 0x000008, "Wrong alignment on FProjectileLaunchPattern");
static_assert(sizeof(FProjectileLaunchPattern) == 0x000010, "Wrong size on FProjectileLaunchPattern");
static_assert(offsetof(FProjectileLaunchPattern, LaunchData) == 0x000000, "Member 'FProjectileLaunchPattern::LaunchData' has a wrong offset!");

// ScriptStruct AT.EncountPositionTableRow
// 0x0008 (0x0010 - 0x0008)
struct FEncountPositionTableRow final : public FTableRowBase
{
public:
	uint8                                         PartyNum;                                          // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pos1;                                              // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pos2;                                              // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pos3;                                              // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pos4;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Pos5;                                              // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncountPositionTableRow) == 0x000008, "Wrong alignment on FEncountPositionTableRow");
static_assert(sizeof(FEncountPositionTableRow) == 0x000010, "Wrong size on FEncountPositionTableRow");
static_assert(offsetof(FEncountPositionTableRow, PartyNum) == 0x000008, "Member 'FEncountPositionTableRow::PartyNum' has a wrong offset!");
static_assert(offsetof(FEncountPositionTableRow, Pos1) == 0x000009, "Member 'FEncountPositionTableRow::Pos1' has a wrong offset!");
static_assert(offsetof(FEncountPositionTableRow, Pos2) == 0x00000A, "Member 'FEncountPositionTableRow::Pos2' has a wrong offset!");
static_assert(offsetof(FEncountPositionTableRow, Pos3) == 0x00000B, "Member 'FEncountPositionTableRow::Pos3' has a wrong offset!");
static_assert(offsetof(FEncountPositionTableRow, Pos4) == 0x00000C, "Member 'FEncountPositionTableRow::Pos4' has a wrong offset!");
static_assert(offsetof(FEncountPositionTableRow, Pos5) == 0x00000D, "Member 'FEncountPositionTableRow::Pos5' has a wrong offset!");

// ScriptStruct AT.QuestCameraShake
// 0x0010 (0x0018 - 0x0008)
struct FQuestCameraShake final : public FTableRowBase
{
public:
	float                                         LocationRange;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRange;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationIn;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DurationOut;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestCameraShake) == 0x000008, "Wrong alignment on FQuestCameraShake");
static_assert(sizeof(FQuestCameraShake) == 0x000018, "Wrong size on FQuestCameraShake");
static_assert(offsetof(FQuestCameraShake, LocationRange) == 0x000008, "Member 'FQuestCameraShake::LocationRange' has a wrong offset!");
static_assert(offsetof(FQuestCameraShake, RotationRange) == 0x00000C, "Member 'FQuestCameraShake::RotationRange' has a wrong offset!");
static_assert(offsetof(FQuestCameraShake, DurationIn) == 0x000010, "Member 'FQuestCameraShake::DurationIn' has a wrong offset!");
static_assert(offsetof(FQuestCameraShake, DurationOut) == 0x000014, "Member 'FQuestCameraShake::DurationOut' has a wrong offset!");

// ScriptStruct AT.ExchangeItemData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FExchangeItemData final
{
public:
	class FName                                   BeforeItemId;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeItemNum;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AfterItemId;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterItemNum;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExchangeSuccessRequestCommand;                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExchangeItemData) == 0x000008, "Wrong alignment on FExchangeItemData");
static_assert(sizeof(FExchangeItemData) == 0x000028, "Wrong size on FExchangeItemData");
static_assert(offsetof(FExchangeItemData, BeforeItemId) == 0x000000, "Member 'FExchangeItemData::BeforeItemId' has a wrong offset!");
static_assert(offsetof(FExchangeItemData, BeforeItemNum) == 0x000008, "Member 'FExchangeItemData::BeforeItemNum' has a wrong offset!");
static_assert(offsetof(FExchangeItemData, AfterItemId) == 0x000010, "Member 'FExchangeItemData::AfterItemId' has a wrong offset!");
static_assert(offsetof(FExchangeItemData, AfterItemNum) == 0x000018, "Member 'FExchangeItemData::AfterItemNum' has a wrong offset!");
static_assert(offsetof(FExchangeItemData, ExchangeSuccessRequestCommand) == 0x000020, "Member 'FExchangeItemData::ExchangeSuccessRequestCommand' has a wrong offset!");

// ScriptStruct AT.DLC6ScalingTownMapIconParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDLC6ScalingTownMapIconParam final
{
public:
	EMapIcon                                      MapIcon;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TownName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC6ScalingTownMapIconParam) == 0x000008, "Wrong alignment on FDLC6ScalingTownMapIconParam");
static_assert(sizeof(FDLC6ScalingTownMapIconParam) == 0x000018, "Wrong size on FDLC6ScalingTownMapIconParam");
static_assert(offsetof(FDLC6ScalingTownMapIconParam, MapIcon) == 0x000000, "Member 'FDLC6ScalingTownMapIconParam::MapIcon' has a wrong offset!");
static_assert(offsetof(FDLC6ScalingTownMapIconParam, TownName) == 0x000008, "Member 'FDLC6ScalingTownMapIconParam::TownName' has a wrong offset!");
static_assert(offsetof(FDLC6ScalingTownMapIconParam, Scale) == 0x000010, "Member 'FDLC6ScalingTownMapIconParam::Scale' has a wrong offset!");

// ScriptStruct AT.ATCharacterStatus
// 0x0078 (0x0078 - 0x0000)
struct FATCharacterStatus final
{
public:
	double                                        HitPoint;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MagicPoint;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        HitPointRecover;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MagicPointRecover;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ShortOffensivePow;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        LongOffensivePow;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MoveOffensivePow;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        ShortDefensivePow;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        LongDefensivePow;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MoveDefensivePow;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        CriticalRate;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        MoveSpeed;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        BreakGaugeValueMax;                                // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        BreakOffensivePow;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        GuardBreakValueMax;                                // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterStatus) == 0x000008, "Wrong alignment on FATCharacterStatus");
static_assert(sizeof(FATCharacterStatus) == 0x000078, "Wrong size on FATCharacterStatus");
static_assert(offsetof(FATCharacterStatus, HitPoint) == 0x000000, "Member 'FATCharacterStatus::HitPoint' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, MagicPoint) == 0x000008, "Member 'FATCharacterStatus::MagicPoint' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, HitPointRecover) == 0x000010, "Member 'FATCharacterStatus::HitPointRecover' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, MagicPointRecover) == 0x000018, "Member 'FATCharacterStatus::MagicPointRecover' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, ShortOffensivePow) == 0x000020, "Member 'FATCharacterStatus::ShortOffensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, LongOffensivePow) == 0x000028, "Member 'FATCharacterStatus::LongOffensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, MoveOffensivePow) == 0x000030, "Member 'FATCharacterStatus::MoveOffensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, ShortDefensivePow) == 0x000038, "Member 'FATCharacterStatus::ShortDefensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, LongDefensivePow) == 0x000040, "Member 'FATCharacterStatus::LongDefensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, MoveDefensivePow) == 0x000048, "Member 'FATCharacterStatus::MoveDefensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, CriticalRate) == 0x000050, "Member 'FATCharacterStatus::CriticalRate' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, MoveSpeed) == 0x000058, "Member 'FATCharacterStatus::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, BreakGaugeValueMax) == 0x000060, "Member 'FATCharacterStatus::BreakGaugeValueMax' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, BreakOffensivePow) == 0x000068, "Member 'FATCharacterStatus::BreakOffensivePow' has a wrong offset!");
static_assert(offsetof(FATCharacterStatus, GuardBreakValueMax) == 0x000070, "Member 'FATCharacterStatus::GuardBreakValueMax' has a wrong offset!");

// ScriptStruct AT.ATCharacterStatusTable
// 0x0078 (0x0080 - 0x0008)
struct FATCharacterStatusTable final : public FTableRowBase
{
public:
	struct FATCharacterStatus                     Status;                                            // 0x0008(0x0078)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterStatusTable) == 0x000008, "Wrong alignment on FATCharacterStatusTable");
static_assert(sizeof(FATCharacterStatusTable) == 0x000080, "Wrong size on FATCharacterStatusTable");
static_assert(offsetof(FATCharacterStatusTable, Status) == 0x000008, "Member 'FATCharacterStatusTable::Status' has a wrong offset!");

// ScriptStruct AT.CharacterOffsetSetting
// 0x0020 (0x0028 - 0x0008)
struct FCharacterOffsetSetting final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ParticleOffset;                                    // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayLength;                                         // 0x0018(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterOffsetSetting) == 0x000008, "Wrong alignment on FCharacterOffsetSetting");
static_assert(sizeof(FCharacterOffsetSetting) == 0x000028, "Wrong size on FCharacterOffsetSetting");
static_assert(offsetof(FCharacterOffsetSetting, CharacterType) == 0x000008, "Member 'FCharacterOffsetSetting::CharacterType' has a wrong offset!");
static_assert(offsetof(FCharacterOffsetSetting, ParticleOffset) == 0x00000C, "Member 'FCharacterOffsetSetting::ParticleOffset' has a wrong offset!");
static_assert(offsetof(FCharacterOffsetSetting, RayLength) == 0x000018, "Member 'FCharacterOffsetSetting::RayLength' has a wrong offset!");

// ScriptStruct AT.BonfireDataParam
// 0x0068 (0x0070 - 0x0008)
struct FBonfireDataParam final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemDetailMessageID;                               // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           ItemModel;                                         // 0x0020(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ItemOffsetPosition;                                // 0x0048(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ItemRotation;                                      // 0x0054(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EItemIDCategory                               ItemCategory;                                      // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ResultItemID;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonfireDataParam) == 0x000008, "Wrong alignment on FBonfireDataParam");
static_assert(sizeof(FBonfireDataParam) == 0x000070, "Wrong size on FBonfireDataParam");
static_assert(offsetof(FBonfireDataParam, ItemId) == 0x000008, "Member 'FBonfireDataParam::ItemId' has a wrong offset!");
static_assert(offsetof(FBonfireDataParam, ItemDetailMessageID) == 0x000010, "Member 'FBonfireDataParam::ItemDetailMessageID' has a wrong offset!");
static_assert(offsetof(FBonfireDataParam, ItemModel) == 0x000020, "Member 'FBonfireDataParam::ItemModel' has a wrong offset!");
static_assert(offsetof(FBonfireDataParam, ItemOffsetPosition) == 0x000048, "Member 'FBonfireDataParam::ItemOffsetPosition' has a wrong offset!");
static_assert(offsetof(FBonfireDataParam, ItemRotation) == 0x000054, "Member 'FBonfireDataParam::ItemRotation' has a wrong offset!");
static_assert(offsetof(FBonfireDataParam, ItemCategory) == 0x000060, "Member 'FBonfireDataParam::ItemCategory' has a wrong offset!");
static_assert(offsetof(FBonfireDataParam, ResultItemID) == 0x000068, "Member 'FBonfireDataParam::ResultItemID' has a wrong offset!");

// ScriptStruct AT.CharacterEffectSetting
// 0x0058 (0x0060 - 0x0008)
struct FCharacterEffectSetting final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AppearOnAnyCharacter;                              // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEF_ParticleData                       ParticleData;                                      // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterEffectSetting) == 0x000008, "Wrong alignment on FCharacterEffectSetting");
static_assert(sizeof(FCharacterEffectSetting) == 0x000060, "Wrong size on FCharacterEffectSetting");
static_assert(offsetof(FCharacterEffectSetting, CharacterType) == 0x000008, "Member 'FCharacterEffectSetting::CharacterType' has a wrong offset!");
static_assert(offsetof(FCharacterEffectSetting, AppearOnAnyCharacter) == 0x000009, "Member 'FCharacterEffectSetting::AppearOnAnyCharacter' has a wrong offset!");
static_assert(offsetof(FCharacterEffectSetting, ParticleData) == 0x000010, "Member 'FCharacterEffectSetting::ParticleData' has a wrong offset!");

// ScriptStruct AT.ATDebugPresetCharacterDataTableRow
// 0x0180 (0x0188 - 0x0008)
struct FATDebugPresetCharacterDataTableRow final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterLevel;                                    // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PaletteSkills[0x8];                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotSkills[0x14];                                  // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SupportSkill[0x2];                                 // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OpenSkillTreeId;                                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           HaveSkillTreeId;                                   // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PassiveSkills[0x8];                                // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SparkingSkills[0x4];                               // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SparkingSkill;                                     // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDebugPresetCharacterDataTableRow) == 0x000008, "Wrong alignment on FATDebugPresetCharacterDataTableRow");
static_assert(sizeof(FATDebugPresetCharacterDataTableRow) == 0x000188, "Wrong size on FATDebugPresetCharacterDataTableRow");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, CharacterType) == 0x000008, "Member 'FATDebugPresetCharacterDataTableRow::CharacterType' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, VariationId) == 0x000009, "Member 'FATDebugPresetCharacterDataTableRow::VariationId' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, FormID) == 0x00000A, "Member 'FATDebugPresetCharacterDataTableRow::FormID' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, CharacterLevel) == 0x00000C, "Member 'FATDebugPresetCharacterDataTableRow::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, PaletteSkills) == 0x000010, "Member 'FATDebugPresetCharacterDataTableRow::PaletteSkills' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, SlotSkills) == 0x000050, "Member 'FATDebugPresetCharacterDataTableRow::SlotSkills' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, SupportSkill) == 0x0000F0, "Member 'FATDebugPresetCharacterDataTableRow::SupportSkill' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, OpenSkillTreeId) == 0x000100, "Member 'FATDebugPresetCharacterDataTableRow::OpenSkillTreeId' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, HaveSkillTreeId) == 0x000110, "Member 'FATDebugPresetCharacterDataTableRow::HaveSkillTreeId' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, PassiveSkills) == 0x000120, "Member 'FATDebugPresetCharacterDataTableRow::PassiveSkills' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, SparkingSkills) == 0x000160, "Member 'FATDebugPresetCharacterDataTableRow::SparkingSkills' has a wrong offset!");
static_assert(offsetof(FATDebugPresetCharacterDataTableRow, SparkingSkill) == 0x000180, "Member 'FATDebugPresetCharacterDataTableRow::SparkingSkill' has a wrong offset!");

// ScriptStruct AT.RandomItemRewardParam
// 0x0068 (0x0070 - 0x0008)
struct FRandomItemRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardItem01;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem04;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem05;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMaxNum01;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMaxNum02;                                // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMaxNum03;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMaxNum04;                                // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMaxNum05;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMinNum01;                                // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMinNum02;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMinNum03;                                // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMinNum04;                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemMinNum05;                                // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemFacterNum01;                             // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemFacterNum02;                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemFacterNum03;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemFacterNum04;                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemFacterNum05;                             // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRandomItemRewardParam) == 0x000008, "Wrong alignment on FRandomItemRewardParam");
static_assert(sizeof(FRandomItemRewardParam) == 0x000070, "Wrong size on FRandomItemRewardParam");
static_assert(offsetof(FRandomItemRewardParam, RewardItem01) == 0x000008, "Member 'FRandomItemRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItem02) == 0x000010, "Member 'FRandomItemRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItem03) == 0x000018, "Member 'FRandomItemRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItem04) == 0x000020, "Member 'FRandomItemRewardParam::RewardItem04' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItem05) == 0x000028, "Member 'FRandomItemRewardParam::RewardItem05' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMaxNum01) == 0x000030, "Member 'FRandomItemRewardParam::RewardItemMaxNum01' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMaxNum02) == 0x000034, "Member 'FRandomItemRewardParam::RewardItemMaxNum02' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMaxNum03) == 0x000038, "Member 'FRandomItemRewardParam::RewardItemMaxNum03' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMaxNum04) == 0x00003C, "Member 'FRandomItemRewardParam::RewardItemMaxNum04' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMaxNum05) == 0x000040, "Member 'FRandomItemRewardParam::RewardItemMaxNum05' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMinNum01) == 0x000044, "Member 'FRandomItemRewardParam::RewardItemMinNum01' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMinNum02) == 0x000048, "Member 'FRandomItemRewardParam::RewardItemMinNum02' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMinNum03) == 0x00004C, "Member 'FRandomItemRewardParam::RewardItemMinNum03' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMinNum04) == 0x000050, "Member 'FRandomItemRewardParam::RewardItemMinNum04' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemMinNum05) == 0x000054, "Member 'FRandomItemRewardParam::RewardItemMinNum05' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemFacterNum01) == 0x000058, "Member 'FRandomItemRewardParam::RewardItemFacterNum01' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemFacterNum02) == 0x00005C, "Member 'FRandomItemRewardParam::RewardItemFacterNum02' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemFacterNum03) == 0x000060, "Member 'FRandomItemRewardParam::RewardItemFacterNum03' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemFacterNum04) == 0x000064, "Member 'FRandomItemRewardParam::RewardItemFacterNum04' has a wrong offset!");
static_assert(offsetof(FRandomItemRewardParam, RewardItemFacterNum05) == 0x000068, "Member 'FRandomItemRewardParam::RewardItemFacterNum05' has a wrong offset!");

// ScriptStruct AT.QuestProgressPair
// 0x0040 (0x0040 - 0x0000)
struct FQuestProgressPair final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MapName;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestProgress;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProgressPhase;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnabledDebugQuest;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupId;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestProgressPair) == 0x000008, "Wrong alignment on FQuestProgressPair");
static_assert(sizeof(FQuestProgressPair) == 0x000040, "Wrong size on FQuestProgressPair");
static_assert(offsetof(FQuestProgressPair, Name) == 0x000000, "Member 'FQuestProgressPair::Name' has a wrong offset!");
static_assert(offsetof(FQuestProgressPair, MapName) == 0x000010, "Member 'FQuestProgressPair::MapName' has a wrong offset!");
static_assert(offsetof(FQuestProgressPair, QuestProgress) == 0x000020, "Member 'FQuestProgressPair::QuestProgress' has a wrong offset!");
static_assert(offsetof(FQuestProgressPair, ProgressPhase) == 0x000030, "Member 'FQuestProgressPair::ProgressPhase' has a wrong offset!");
static_assert(offsetof(FQuestProgressPair, EnabledDebugQuest) == 0x000034, "Member 'FQuestProgressPair::EnabledDebugQuest' has a wrong offset!");
static_assert(offsetof(FQuestProgressPair, GroupId) == 0x000038, "Member 'FQuestProgressPair::GroupId' has a wrong offset!");

// ScriptStruct AT.LoadingAsset
// 0x0050 (0x0050 - 0x0000)
struct FLoadingAsset final
{
public:
	TSoftClassPtr<class UClass>                   UserWidgetClass;                                   // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DataTableAsset;                                    // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingAsset) == 0x000008, "Wrong alignment on FLoadingAsset");
static_assert(sizeof(FLoadingAsset) == 0x000050, "Wrong size on FLoadingAsset");
static_assert(offsetof(FLoadingAsset, UserWidgetClass) == 0x000000, "Member 'FLoadingAsset::UserWidgetClass' has a wrong offset!");
static_assert(offsetof(FLoadingAsset, DataTableAsset) == 0x000028, "Member 'FLoadingAsset::DataTableAsset' has a wrong offset!");

// ScriptStruct AT.SupportTeamBonusParam
// 0x0060 (0x0068 - 0x0008)
struct FSupportTeamBonusParam final : public FTableRowBase
{
public:
	class FName                                   QuestPhaseId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BonusNameId;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BonusMessageId;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Character1;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Character2;                                        // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Character3;                                        // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeaderCheck;                                       // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffenceDamageRate;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefenceDamageRate;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CoolTimeRate;                                      // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TensionAddRate;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FormChangeBuffId;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillCostRate;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeatUpTimeRate;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefenceGuardBreakRate;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffenceGuardBreakRate;                             // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffenceStunRate;                                   // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PinchStatusBuffId;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PinchStatusHPLimitRate;                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRateForStun;                                 // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportTeamBonusParam) == 0x000008, "Wrong alignment on FSupportTeamBonusParam");
static_assert(sizeof(FSupportTeamBonusParam) == 0x000068, "Wrong size on FSupportTeamBonusParam");
static_assert(offsetof(FSupportTeamBonusParam, QuestPhaseId) == 0x000008, "Member 'FSupportTeamBonusParam::QuestPhaseId' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, BonusNameId) == 0x000010, "Member 'FSupportTeamBonusParam::BonusNameId' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, BonusMessageId) == 0x000018, "Member 'FSupportTeamBonusParam::BonusMessageId' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, Character1) == 0x000020, "Member 'FSupportTeamBonusParam::Character1' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, Character2) == 0x000021, "Member 'FSupportTeamBonusParam::Character2' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, Character3) == 0x000022, "Member 'FSupportTeamBonusParam::Character3' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, LeaderCheck) == 0x000023, "Member 'FSupportTeamBonusParam::LeaderCheck' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, OffenceDamageRate) == 0x000024, "Member 'FSupportTeamBonusParam::OffenceDamageRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, DefenceDamageRate) == 0x000028, "Member 'FSupportTeamBonusParam::DefenceDamageRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, CoolTimeRate) == 0x00002C, "Member 'FSupportTeamBonusParam::CoolTimeRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, TensionAddRate) == 0x000030, "Member 'FSupportTeamBonusParam::TensionAddRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, FormChangeBuffId) == 0x000038, "Member 'FSupportTeamBonusParam::FormChangeBuffId' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, SkillCostRate) == 0x000040, "Member 'FSupportTeamBonusParam::SkillCostRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, HeatUpTimeRate) == 0x000044, "Member 'FSupportTeamBonusParam::HeatUpTimeRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, DefenceGuardBreakRate) == 0x000048, "Member 'FSupportTeamBonusParam::DefenceGuardBreakRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, OffenceGuardBreakRate) == 0x00004C, "Member 'FSupportTeamBonusParam::OffenceGuardBreakRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, OffenceStunRate) == 0x000050, "Member 'FSupportTeamBonusParam::OffenceStunRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, PinchStatusBuffId) == 0x000058, "Member 'FSupportTeamBonusParam::PinchStatusBuffId' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, PinchStatusHPLimitRate) == 0x000060, "Member 'FSupportTeamBonusParam::PinchStatusHPLimitRate' has a wrong offset!");
static_assert(offsetof(FSupportTeamBonusParam, DamageRateForStun) == 0x000064, "Member 'FSupportTeamBonusParam::DamageRateForStun' has a wrong offset!");

// ScriptStruct AT.ShopListDataTableType
// 0x0010 (0x0018 - 0x0008)
struct FShopListDataTableType final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfStocks;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopListDataTableType) == 0x000008, "Wrong alignment on FShopListDataTableType");
static_assert(sizeof(FShopListDataTableType) == 0x000018, "Wrong size on FShopListDataTableType");
static_assert(offsetof(FShopListDataTableType, ItemId) == 0x000008, "Member 'FShopListDataTableType::ItemId' has a wrong offset!");
static_assert(offsetof(FShopListDataTableType, NumberOfStocks) == 0x000010, "Member 'FShopListDataTableType::NumberOfStocks' has a wrong offset!");
static_assert(offsetof(FShopListDataTableType, Rate) == 0x000014, "Member 'FShopListDataTableType::Rate' has a wrong offset!");

// ScriptStruct AT.ATDataAssetLoadType
// 0x0010 (0x0018 - 0x0008)
struct FATDataAssetLoadType final : public FTableRowBase
{
public:
	EATDataAssetKind                              Kind;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MasterId;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetLoadType) == 0x000008, "Wrong alignment on FATDataAssetLoadType");
static_assert(sizeof(FATDataAssetLoadType) == 0x000018, "Wrong size on FATDataAssetLoadType");
static_assert(offsetof(FATDataAssetLoadType, Kind) == 0x000008, "Member 'FATDataAssetLoadType::Kind' has a wrong offset!");
static_assert(offsetof(FATDataAssetLoadType, MasterId) == 0x000010, "Member 'FATDataAssetLoadType::MasterId' has a wrong offset!");

// ScriptStruct AT.TelopDataParam
// 0x0040 (0x0048 - 0x0008)
struct FTelopDataParam final : public FTableRowBase
{
public:
	class FString                                 CharacterNameId;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoiceActorId;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAsiaOnly;                                       // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VoiceActorId2;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAsiaOnly2;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTelopDataParam) == 0x000008, "Wrong alignment on FTelopDataParam");
static_assert(sizeof(FTelopDataParam) == 0x000048, "Wrong size on FTelopDataParam");
static_assert(offsetof(FTelopDataParam, CharacterNameId) == 0x000008, "Member 'FTelopDataParam::CharacterNameId' has a wrong offset!");
static_assert(offsetof(FTelopDataParam, VoiceActorId) == 0x000018, "Member 'FTelopDataParam::VoiceActorId' has a wrong offset!");
static_assert(offsetof(FTelopDataParam, bIsAsiaOnly) == 0x000028, "Member 'FTelopDataParam::bIsAsiaOnly' has a wrong offset!");
static_assert(offsetof(FTelopDataParam, VoiceActorId2) == 0x000030, "Member 'FTelopDataParam::VoiceActorId2' has a wrong offset!");
static_assert(offsetof(FTelopDataParam, bIsAsiaOnly2) == 0x000040, "Member 'FTelopDataParam::bIsAsiaOnly2' has a wrong offset!");

// ScriptStruct AT.GroundBattleSparkingComboFinishSkillCutinInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FGroundBattleSparkingComboFinishSkillCutinInfo final
{
public:
	bool                                          EnableStartCutin;                                  // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableModifyEnv;                                   // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableLockTarget;                                  // 0x0002(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseAttachSocket;                                   // 0x0003(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetAttachSocket;                                // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PutTargetCharacter;                                // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PutTargetLocation;                                 // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TargetMontage;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetMontageId;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UAnimMontage*>        TargetMontagePrivate;                              // 0x0030(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          UseSafetyPoint;                                    // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCutinProjectileDestroyType              ProjectileDestroyType;                             // 0x0081(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillCutinActorPauseType                     ActorPauseType;                                    // 0x0082(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ActorPauseActionReset;                             // 0x0083(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraAnim*                            CutinCameraAnim;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CutinCameraLoop;                                   // 0x0090(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CutinCameraFlip;                                   // 0x0091(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipEndProcess;                                    // 0x0092(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCustomStencil;                                  // 0x0093(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsCustomStencilValue;                              // 0x0094(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CustomStencilValue;                                // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OwnerEnableInvincible;                             // 0x009C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForcePlayCutin;                                 // 0x009D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGroundBattleSparkingComboFinishSkillCutinInfo) == 0x000008, "Wrong alignment on FGroundBattleSparkingComboFinishSkillCutinInfo");
static_assert(sizeof(FGroundBattleSparkingComboFinishSkillCutinInfo) == 0x0000A0, "Wrong size on FGroundBattleSparkingComboFinishSkillCutinInfo");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, EnableStartCutin) == 0x000000, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::EnableStartCutin' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, EnableModifyEnv) == 0x000001, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::EnableModifyEnv' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, EnableLockTarget) == 0x000002, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::EnableLockTarget' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, UseAttachSocket) == 0x000003, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::UseAttachSocket' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, TargetAttachSocket) == 0x000008, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::TargetAttachSocket' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, PutTargetCharacter) == 0x000010, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::PutTargetCharacter' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, PutTargetLocation) == 0x000014, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::PutTargetLocation' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, TargetMontage) == 0x000020, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::TargetMontage' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, TargetMontageId) == 0x000028, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::TargetMontageId' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, TargetMontagePrivate) == 0x000030, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::TargetMontagePrivate' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, UseSafetyPoint) == 0x000080, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::UseSafetyPoint' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, ProjectileDestroyType) == 0x000081, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::ProjectileDestroyType' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, ActorPauseType) == 0x000082, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::ActorPauseType' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, ActorPauseActionReset) == 0x000083, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::ActorPauseActionReset' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, CutinCameraAnim) == 0x000088, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::CutinCameraAnim' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, CutinCameraLoop) == 0x000090, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::CutinCameraLoop' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, CutinCameraFlip) == 0x000091, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::CutinCameraFlip' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, SkipEndProcess) == 0x000092, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::SkipEndProcess' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, UseCustomStencil) == 0x000093, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::UseCustomStencil' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, IsCustomStencilValue) == 0x000094, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::IsCustomStencilValue' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, CustomStencilValue) == 0x000098, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::CustomStencilValue' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, OwnerEnableInvincible) == 0x00009C, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::OwnerEnableInvincible' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboFinishSkillCutinInfo, bIsForcePlayCutin) == 0x00009D, "Member 'FGroundBattleSparkingComboFinishSkillCutinInfo::bIsForcePlayCutin' has a wrong offset!");

// ScriptStruct AT.MapMIconLegend
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMapMIconLegend final
{
public:
	EMapIcon                                      IconType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgId;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysVisible;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapMIconLegend) == 0x000008, "Wrong alignment on FMapMIconLegend");
static_assert(sizeof(FMapMIconLegend) == 0x000018, "Wrong size on FMapMIconLegend");
static_assert(offsetof(FMapMIconLegend, IconType) == 0x000000, "Member 'FMapMIconLegend::IconType' has a wrong offset!");
static_assert(offsetof(FMapMIconLegend, MsgId) == 0x000008, "Member 'FMapMIconLegend::MsgId' has a wrong offset!");
static_assert(offsetof(FMapMIconLegend, IsAlwaysVisible) == 0x000010, "Member 'FMapMIconLegend::IsAlwaysVisible' has a wrong offset!");

// ScriptStruct AT.ReferenceToTPSSkillViewCancelAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToTPSSkillViewCancelAssetInstance final
{
public:
	class UDataTable*                             TPSSkillViewCancelDataTable;                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToTPSSkillViewCancelAssetInstance) == 0x000008, "Wrong alignment on FReferenceToTPSSkillViewCancelAssetInstance");
static_assert(sizeof(FReferenceToTPSSkillViewCancelAssetInstance) == 0x000008, "Wrong size on FReferenceToTPSSkillViewCancelAssetInstance");
static_assert(offsetof(FReferenceToTPSSkillViewCancelAssetInstance, TPSSkillViewCancelDataTable) == 0x000000, "Member 'FReferenceToTPSSkillViewCancelAssetInstance::TPSSkillViewCancelDataTable' has a wrong offset!");

// ScriptStruct AT.SubQuestStartMontageTableRow
// 0x0028 (0x0030 - 0x0008)
struct FSubQuestStartMontageTableRow final : public FTableRowBase
{
public:
	class UAnimMontage*                           StartInMontage;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TitleInMontage;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FacialMontage;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TitleInFacialMontage;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlayTitleInFacial;                               // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopBlinkAnimation;                                // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubQuestStartMontageTableRow) == 0x000008, "Wrong alignment on FSubQuestStartMontageTableRow");
static_assert(sizeof(FSubQuestStartMontageTableRow) == 0x000030, "Wrong size on FSubQuestStartMontageTableRow");
static_assert(offsetof(FSubQuestStartMontageTableRow, StartInMontage) == 0x000008, "Member 'FSubQuestStartMontageTableRow::StartInMontage' has a wrong offset!");
static_assert(offsetof(FSubQuestStartMontageTableRow, TitleInMontage) == 0x000010, "Member 'FSubQuestStartMontageTableRow::TitleInMontage' has a wrong offset!");
static_assert(offsetof(FSubQuestStartMontageTableRow, FacialMontage) == 0x000018, "Member 'FSubQuestStartMontageTableRow::FacialMontage' has a wrong offset!");
static_assert(offsetof(FSubQuestStartMontageTableRow, TitleInFacialMontage) == 0x000020, "Member 'FSubQuestStartMontageTableRow::TitleInFacialMontage' has a wrong offset!");
static_assert(offsetof(FSubQuestStartMontageTableRow, IsPlayTitleInFacial) == 0x000028, "Member 'FSubQuestStartMontageTableRow::IsPlayTitleInFacial' has a wrong offset!");
static_assert(offsetof(FSubQuestStartMontageTableRow, StopBlinkAnimation) == 0x000029, "Member 'FSubQuestStartMontageTableRow::StopBlinkAnimation' has a wrong offset!");

// ScriptStruct AT.SkillAssistTable
// 0x0008 (0x0010 - 0x0008)
struct FSkillAssistTable final : public FTableRowBase
{
public:
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillAssistTable) == 0x000008, "Wrong alignment on FSkillAssistTable");
static_assert(sizeof(FSkillAssistTable) == 0x000010, "Wrong size on FSkillAssistTable");
static_assert(offsetof(FSkillAssistTable, Priority) == 0x000008, "Member 'FSkillAssistTable::Priority' has a wrong offset!");
static_assert(offsetof(FSkillAssistTable, Value) == 0x00000C, "Member 'FSkillAssistTable::Value' has a wrong offset!");

// ScriptStruct AT.Cpl024SpecialProjectileParam
// 0x0030 (0x0030 - 0x0000)
struct FCpl024SpecialProjectileParam final
{
public:
	int32                                         ProjectileNum;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PosInterval;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormH_to_H;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormH_to_V;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormH_to_C;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormV_to_H;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormV_to_V;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormV_to_C;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormC_to_H;                                     // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormC_to_V;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATKFormC_to_C;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESndCodeBattle                                ShotSeID;                                          // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCpl024SpecialProjectileParam) == 0x000004, "Wrong alignment on FCpl024SpecialProjectileParam");
static_assert(sizeof(FCpl024SpecialProjectileParam) == 0x000030, "Wrong size on FCpl024SpecialProjectileParam");
static_assert(offsetof(FCpl024SpecialProjectileParam, ProjectileNum) == 0x000000, "Member 'FCpl024SpecialProjectileParam::ProjectileNum' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, PosInterval) == 0x000004, "Member 'FCpl024SpecialProjectileParam::PosInterval' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormH_to_H) == 0x000008, "Member 'FCpl024SpecialProjectileParam::ATKFormH_to_H' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormH_to_V) == 0x00000C, "Member 'FCpl024SpecialProjectileParam::ATKFormH_to_V' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormH_to_C) == 0x000010, "Member 'FCpl024SpecialProjectileParam::ATKFormH_to_C' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormV_to_H) == 0x000014, "Member 'FCpl024SpecialProjectileParam::ATKFormV_to_H' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormV_to_V) == 0x000018, "Member 'FCpl024SpecialProjectileParam::ATKFormV_to_V' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormV_to_C) == 0x00001C, "Member 'FCpl024SpecialProjectileParam::ATKFormV_to_C' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormC_to_H) == 0x000020, "Member 'FCpl024SpecialProjectileParam::ATKFormC_to_H' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormC_to_V) == 0x000024, "Member 'FCpl024SpecialProjectileParam::ATKFormC_to_V' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ATKFormC_to_C) == 0x000028, "Member 'FCpl024SpecialProjectileParam::ATKFormC_to_C' has a wrong offset!");
static_assert(offsetof(FCpl024SpecialProjectileParam, ShotSeID) == 0x00002C, "Member 'FCpl024SpecialProjectileParam::ShotSeID' has a wrong offset!");

// ScriptStruct AT.ShotRotParam
// 0x001C (0x001C - 0x0000)
struct FShotRotParam final
{
public:
	float                                         ShotRotTime;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSideRot;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandSideRotMax;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandSideRotMin;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseUpRot;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandUpRotMax;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandUpRotMin;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShotRotParam) == 0x000004, "Wrong alignment on FShotRotParam");
static_assert(sizeof(FShotRotParam) == 0x00001C, "Wrong size on FShotRotParam");
static_assert(offsetof(FShotRotParam, ShotRotTime) == 0x000000, "Member 'FShotRotParam::ShotRotTime' has a wrong offset!");
static_assert(offsetof(FShotRotParam, BaseSideRot) == 0x000004, "Member 'FShotRotParam::BaseSideRot' has a wrong offset!");
static_assert(offsetof(FShotRotParam, RandSideRotMax) == 0x000008, "Member 'FShotRotParam::RandSideRotMax' has a wrong offset!");
static_assert(offsetof(FShotRotParam, RandSideRotMin) == 0x00000C, "Member 'FShotRotParam::RandSideRotMin' has a wrong offset!");
static_assert(offsetof(FShotRotParam, BaseUpRot) == 0x000010, "Member 'FShotRotParam::BaseUpRot' has a wrong offset!");
static_assert(offsetof(FShotRotParam, RandUpRotMax) == 0x000014, "Member 'FShotRotParam::RandUpRotMax' has a wrong offset!");
static_assert(offsetof(FShotRotParam, RandUpRotMin) == 0x000018, "Member 'FShotRotParam::RandUpRotMin' has a wrong offset!");

// ScriptStruct AT.QuestDataAssetPair
// 0x0050 (0x0058 - 0x0008)
struct FQuestDataAssetPair final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UDataTable>              AssetReference;                                    // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdBegin;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdEnd;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingExtendProgressIdBegin;                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingExtendProgressIdEnd;                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoadingAtMainStory;                             // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoadingAtDLCStory;                              // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestDataAssetPair) == 0x000008, "Wrong alignment on FQuestDataAssetPair");
static_assert(sizeof(FQuestDataAssetPair) == 0x000058, "Wrong size on FQuestDataAssetPair");
static_assert(offsetof(FQuestDataAssetPair, AssetReference) == 0x000008, "Member 'FQuestDataAssetPair::AssetReference' has a wrong offset!");
static_assert(offsetof(FQuestDataAssetPair, LoadingProgressIdBegin) == 0x000030, "Member 'FQuestDataAssetPair::LoadingProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FQuestDataAssetPair, LoadingProgressIdEnd) == 0x000038, "Member 'FQuestDataAssetPair::LoadingProgressIdEnd' has a wrong offset!");
static_assert(offsetof(FQuestDataAssetPair, LoadingExtendProgressIdBegin) == 0x000040, "Member 'FQuestDataAssetPair::LoadingExtendProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FQuestDataAssetPair, LoadingExtendProgressIdEnd) == 0x000048, "Member 'FQuestDataAssetPair::LoadingExtendProgressIdEnd' has a wrong offset!");
static_assert(offsetof(FQuestDataAssetPair, bIsLoadingAtMainStory) == 0x000050, "Member 'FQuestDataAssetPair::bIsLoadingAtMainStory' has a wrong offset!");
static_assert(offsetof(FQuestDataAssetPair, bIsLoadingAtDLCStory) == 0x000051, "Member 'FQuestDataAssetPair::bIsLoadingAtDLCStory' has a wrong offset!");

// ScriptStruct AT.CommandPaletteBase
// 0x0004 (0x0004 - 0x0000)
struct FCommandPaletteBase
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandPaletteBase) == 0x000001, "Wrong alignment on FCommandPaletteBase");
static_assert(sizeof(FCommandPaletteBase) == 0x000004, "Wrong size on FCommandPaletteBase");

// ScriptStruct AT.CommandPaletteSkill
// 0x002C (0x0030 - 0x0004)
struct FCommandPaletteSkill : public FCommandPaletteBase
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillId;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkillName;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandPaletteSkill) == 0x000008, "Wrong alignment on FCommandPaletteSkill");
static_assert(sizeof(FCommandPaletteSkill) == 0x000030, "Wrong size on FCommandPaletteSkill");
static_assert(offsetof(FCommandPaletteSkill, SkillId) == 0x000008, "Member 'FCommandPaletteSkill::SkillId' has a wrong offset!");
static_assert(offsetof(FCommandPaletteSkill, SkillName) == 0x000018, "Member 'FCommandPaletteSkill::SkillName' has a wrong offset!");

// ScriptStruct AT.CommandPaletteFormChange
// 0x0008 (0x0038 - 0x0030)
struct FCommandPaletteFormChange final : public FCommandPaletteSkill
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandPaletteFormChange) == 0x000008, "Wrong alignment on FCommandPaletteFormChange");
static_assert(sizeof(FCommandPaletteFormChange) == 0x000038, "Wrong size on FCommandPaletteFormChange");

// ScriptStruct AT.QuestDefeatEnemiesSet
// 0x0010 (0x0018 - 0x0008)
struct FQuestDefeatEnemiesSet final : public FTableRowBase
{
public:
	class FName                                   GroupId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               TargetType;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Count;                                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestDefeatEnemiesSet) == 0x000008, "Wrong alignment on FQuestDefeatEnemiesSet");
static_assert(sizeof(FQuestDefeatEnemiesSet) == 0x000018, "Wrong size on FQuestDefeatEnemiesSet");
static_assert(offsetof(FQuestDefeatEnemiesSet, GroupId) == 0x000008, "Member 'FQuestDefeatEnemiesSet::GroupId' has a wrong offset!");
static_assert(offsetof(FQuestDefeatEnemiesSet, TargetType) == 0x000010, "Member 'FQuestDefeatEnemiesSet::TargetType' has a wrong offset!");
static_assert(offsetof(FQuestDefeatEnemiesSet, Count) == 0x000014, "Member 'FQuestDefeatEnemiesSet::Count' has a wrong offset!");

// ScriptStruct AT.CharacterActionClassData
// 0x0018 (0x0018 - 0x0000)
struct FCharacterActionClassData final
{
public:
	class FName                                   ActionId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ActionIdOffset;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UATActBase>                 ActionClass;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterActionClassData) == 0x000008, "Wrong alignment on FCharacterActionClassData");
static_assert(sizeof(FCharacterActionClassData) == 0x000018, "Wrong size on FCharacterActionClassData");
static_assert(offsetof(FCharacterActionClassData, ActionId) == 0x000000, "Member 'FCharacterActionClassData::ActionId' has a wrong offset!");
static_assert(offsetof(FCharacterActionClassData, ActionIdOffset) == 0x000008, "Member 'FCharacterActionClassData::ActionIdOffset' has a wrong offset!");
static_assert(offsetof(FCharacterActionClassData, ActionClass) == 0x000010, "Member 'FCharacterActionClassData::ActionClass' has a wrong offset!");

// ScriptStruct AT.ItemTableMaterial
// 0x0008 (0x0048 - 0x0040)
struct FItemTableMaterial final : public FItemInfoParam
{
public:
	class FName                                   BoostId;                                           // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTableMaterial) == 0x000008, "Wrong alignment on FItemTableMaterial");
static_assert(sizeof(FItemTableMaterial) == 0x000048, "Wrong size on FItemTableMaterial");
static_assert(offsetof(FItemTableMaterial, BoostId) == 0x000040, "Member 'FItemTableMaterial::BoostId' has a wrong offset!");

// ScriptStruct AT.LandEffectSetting
// 0x0058 (0x0060 - 0x0008)
struct FLandEffectSetting final : public FTableRowBase
{
public:
	EPhysicalSurface                              SurfaceType;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RotationDontAttach;                                // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AppearOnAnySurface;                                // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FEF_ParticleData                       ParticleData;                                      // 0x0010(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandEffectSetting) == 0x000008, "Wrong alignment on FLandEffectSetting");
static_assert(sizeof(FLandEffectSetting) == 0x000060, "Wrong size on FLandEffectSetting");
static_assert(offsetof(FLandEffectSetting, SurfaceType) == 0x000008, "Member 'FLandEffectSetting::SurfaceType' has a wrong offset!");
static_assert(offsetof(FLandEffectSetting, RotationDontAttach) == 0x000009, "Member 'FLandEffectSetting::RotationDontAttach' has a wrong offset!");
static_assert(offsetof(FLandEffectSetting, AppearOnAnySurface) == 0x00000A, "Member 'FLandEffectSetting::AppearOnAnySurface' has a wrong offset!");
static_assert(offsetof(FLandEffectSetting, ParticleData) == 0x000010, "Member 'FLandEffectSetting::ParticleData' has a wrong offset!");

// ScriptStruct AT.ATWindRoadPointParamBlur
// 0x0018 (0x0018 - 0x0000)
struct FATWindRoadPointParamBlur final
{
public:
	float                                         AmountMin;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AmountMax;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTime;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutDuration;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWindRoadPointParamBlur) == 0x000004, "Wrong alignment on FATWindRoadPointParamBlur");
static_assert(sizeof(FATWindRoadPointParamBlur) == 0x000018, "Wrong size on FATWindRoadPointParamBlur");
static_assert(offsetof(FATWindRoadPointParamBlur, AmountMin) == 0x000000, "Member 'FATWindRoadPointParamBlur::AmountMin' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamBlur, AmountMax) == 0x000004, "Member 'FATWindRoadPointParamBlur::AmountMax' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamBlur, Radius) == 0x000008, "Member 'FATWindRoadPointParamBlur::Radius' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamBlur, Exponent) == 0x00000C, "Member 'FATWindRoadPointParamBlur::Exponent' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamBlur, InterpTime) == 0x000010, "Member 'FATWindRoadPointParamBlur::InterpTime' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamBlur, FadeOutDuration) == 0x000014, "Member 'FATWindRoadPointParamBlur::FadeOutDuration' has a wrong offset!");

// ScriptStruct AT.WindRoadParamTableType
// 0x0040 (0x0048 - 0x0008)
struct FWindRoadParamTableType final : public FTableRowBase
{
public:
	int32                                         RespawnInterval;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOrbAutoGetRadius;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemAutoGetRadius;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationEffectOffsetX;                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationEffectOffsetZ;                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationEffectScale;                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationConditionSpeedRate;                       // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationFadeInTime;                               // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiationFadeOutTime;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FATWindRoadPointParamBlur              Blur;                                              // 0x002C(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWindRoadParamTableType) == 0x000008, "Wrong alignment on FWindRoadParamTableType");
static_assert(sizeof(FWindRoadParamTableType) == 0x000048, "Wrong size on FWindRoadParamTableType");
static_assert(offsetof(FWindRoadParamTableType, RespawnInterval) == 0x000008, "Member 'FWindRoadParamTableType::RespawnInterval' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, ZOrbAutoGetRadius) == 0x00000C, "Member 'FWindRoadParamTableType::ZOrbAutoGetRadius' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, ItemAutoGetRadius) == 0x000010, "Member 'FWindRoadParamTableType::ItemAutoGetRadius' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, RadiationEffectOffsetX) == 0x000014, "Member 'FWindRoadParamTableType::RadiationEffectOffsetX' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, RadiationEffectOffsetZ) == 0x000018, "Member 'FWindRoadParamTableType::RadiationEffectOffsetZ' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, RadiationEffectScale) == 0x00001C, "Member 'FWindRoadParamTableType::RadiationEffectScale' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, RadiationConditionSpeedRate) == 0x000020, "Member 'FWindRoadParamTableType::RadiationConditionSpeedRate' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, RadiationFadeInTime) == 0x000024, "Member 'FWindRoadParamTableType::RadiationFadeInTime' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, RadiationFadeOutTime) == 0x000028, "Member 'FWindRoadParamTableType::RadiationFadeOutTime' has a wrong offset!");
static_assert(offsetof(FWindRoadParamTableType, Blur) == 0x00002C, "Member 'FWindRoadParamTableType::Blur' has a wrong offset!");

// ScriptStruct AT.StateSwitchFormIDEffect
// 0x0050 (0x0050 - 0x0000)
struct FStateSwitchFormIDEffect final
{
public:
	struct FStateEffectParameter                  Parameter;                                         // 0x0000(0x0038)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FormID;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateSwitchFormIDEffect) == 0x000008, "Wrong alignment on FStateSwitchFormIDEffect");
static_assert(sizeof(FStateSwitchFormIDEffect) == 0x000050, "Wrong size on FStateSwitchFormIDEffect");
static_assert(offsetof(FStateSwitchFormIDEffect, Parameter) == 0x000000, "Member 'FStateSwitchFormIDEffect::Parameter' has a wrong offset!");
static_assert(offsetof(FStateSwitchFormIDEffect, FormID) == 0x000038, "Member 'FStateSwitchFormIDEffect::FormID' has a wrong offset!");
static_assert(offsetof(FStateSwitchFormIDEffect, CharacterType) == 0x000048, "Member 'FStateSwitchFormIDEffect::CharacterType' has a wrong offset!");

// ScriptStruct AT.LoadingDamageTypeAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingDamageTypeAsset final
{
public:
	TSoftClassPtr<class UClass>                   DamageType;                                        // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingDamageTypeAsset) == 0x000008, "Wrong alignment on FLoadingDamageTypeAsset");
static_assert(sizeof(FLoadingDamageTypeAsset) == 0x000028, "Wrong size on FLoadingDamageTypeAsset");
static_assert(offsetof(FLoadingDamageTypeAsset, DamageType) == 0x000000, "Member 'FLoadingDamageTypeAsset::DamageType' has a wrong offset!");

// ScriptStruct AT.ShopInfoParam
// 0x0030 (0x0038 - 0x0008)
struct FShopInfoParam final : public FTableRowBase
{
public:
	EAreaIndex                                    InformationStoreArea;                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Chapter;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemNameId;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemInfoId;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShopInfoType                                 InformationType;                                   // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopInfoParam) == 0x000008, "Wrong alignment on FShopInfoParam");
static_assert(sizeof(FShopInfoParam) == 0x000038, "Wrong size on FShopInfoParam");
static_assert(offsetof(FShopInfoParam, InformationStoreArea) == 0x000008, "Member 'FShopInfoParam::InformationStoreArea' has a wrong offset!");
static_assert(offsetof(FShopInfoParam, Chapter) == 0x00000C, "Member 'FShopInfoParam::Chapter' has a wrong offset!");
static_assert(offsetof(FShopInfoParam, ItemNameId) == 0x000010, "Member 'FShopInfoParam::ItemNameId' has a wrong offset!");
static_assert(offsetof(FShopInfoParam, ItemInfoId) == 0x000020, "Member 'FShopInfoParam::ItemInfoId' has a wrong offset!");
static_assert(offsetof(FShopInfoParam, InformationType) == 0x000030, "Member 'FShopInfoParam::InformationType' has a wrong offset!");
static_assert(offsetof(FShopInfoParam, Price) == 0x000034, "Member 'FShopInfoParam::Price' has a wrong offset!");

// ScriptStruct AT.RadialBlurParam
// 0x0060 (0x0060 - 0x0000)
struct FRadialBlurParam final
{
public:
	class UMaterialInstanceDynamic*               DynamicMaterial;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x58];                                       // 0x0008(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRadialBlurParam) == 0x000008, "Wrong alignment on FRadialBlurParam");
static_assert(sizeof(FRadialBlurParam) == 0x000060, "Wrong size on FRadialBlurParam");
static_assert(offsetof(FRadialBlurParam, DynamicMaterial) == 0x000000, "Member 'FRadialBlurParam::DynamicMaterial' has a wrong offset!");

// ScriptStruct AT.RestoreItemSet
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FRestoreItemSet final
{
public:
	class FName                                   RestoreItemId;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveDataIndex;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRestoreItemSet) == 0x000008, "Wrong alignment on FRestoreItemSet");
static_assert(sizeof(FRestoreItemSet) == 0x000010, "Wrong size on FRestoreItemSet");
static_assert(offsetof(FRestoreItemSet, RestoreItemId) == 0x000000, "Member 'FRestoreItemSet::RestoreItemId' has a wrong offset!");
static_assert(offsetof(FRestoreItemSet, SaveDataIndex) == 0x000008, "Member 'FRestoreItemSet::SaveDataIndex' has a wrong offset!");

// ScriptStruct AT.ATDataAssetEventBattleInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetEventBattleInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EventBattleClass;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetEventBattleInfo) == 0x000008, "Wrong alignment on FATDataAssetEventBattleInfo");
static_assert(sizeof(FATDataAssetEventBattleInfo) == 0x000030, "Wrong size on FATDataAssetEventBattleInfo");
static_assert(offsetof(FATDataAssetEventBattleInfo, MasterId) == 0x000000, "Member 'FATDataAssetEventBattleInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattleInfo, EventBattleClass) == 0x000008, "Member 'FATDataAssetEventBattleInfo::EventBattleClass' has a wrong offset!");

// ScriptStruct AT.BonfireAnimationTable
// 0x00A8 (0x00B0 - 0x0008)
struct FBonfireAnimationTable final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimMontage>            SitMontage;                                        // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SitLoopMontage;                                    // 0x0038(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StandMontage;                                      // 0x0060(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FullMontage;                                       // 0x0088(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonfireAnimationTable) == 0x000008, "Wrong alignment on FBonfireAnimationTable");
static_assert(sizeof(FBonfireAnimationTable) == 0x0000B0, "Wrong size on FBonfireAnimationTable");
static_assert(offsetof(FBonfireAnimationTable, CharacterType) == 0x000008, "Member 'FBonfireAnimationTable::CharacterType' has a wrong offset!");
static_assert(offsetof(FBonfireAnimationTable, SitMontage) == 0x000010, "Member 'FBonfireAnimationTable::SitMontage' has a wrong offset!");
static_assert(offsetof(FBonfireAnimationTable, SitLoopMontage) == 0x000038, "Member 'FBonfireAnimationTable::SitLoopMontage' has a wrong offset!");
static_assert(offsetof(FBonfireAnimationTable, StandMontage) == 0x000060, "Member 'FBonfireAnimationTable::StandMontage' has a wrong offset!");
static_assert(offsetof(FBonfireAnimationTable, FullMontage) == 0x000088, "Member 'FBonfireAnimationTable::FullMontage' has a wrong offset!");

// ScriptStruct AT.ATCharacterEffectTableIDSet
// 0x0010 (0x0010 - 0x0000)
struct FATCharacterEffectTableIDSet final
{
public:
	class UDataTable*                             CharacterEffectTable;                              // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharacterEffectID;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterEffectTableIDSet) == 0x000008, "Wrong alignment on FATCharacterEffectTableIDSet");
static_assert(sizeof(FATCharacterEffectTableIDSet) == 0x000010, "Wrong size on FATCharacterEffectTableIDSet");
static_assert(offsetof(FATCharacterEffectTableIDSet, CharacterEffectTable) == 0x000000, "Member 'FATCharacterEffectTableIDSet::CharacterEffectTable' has a wrong offset!");
static_assert(offsetof(FATCharacterEffectTableIDSet, CharacterEffectID) == 0x000008, "Member 'FATCharacterEffectTableIDSet::CharacterEffectID' has a wrong offset!");

// ScriptStruct AT.XlistList05Lay7Param
// 0x0028 (0x0028 - 0x0000)
struct FXlistList05Lay7Param final
{
public:
	class FName                                   SkillTreeID;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatedPlay;                                     // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMapIcon                                      IconType;                                          // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CurrentTrainingLevel;                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClear;                                          // 0x0026(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_27[0x1];                                       // 0x0027(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXlistList05Lay7Param) == 0x000008, "Wrong alignment on FXlistList05Lay7Param");
static_assert(sizeof(FXlistList05Lay7Param) == 0x000028, "Wrong size on FXlistList05Lay7Param");
static_assert(offsetof(FXlistList05Lay7Param, SkillTreeID) == 0x000000, "Member 'FXlistList05Lay7Param::SkillTreeID' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, ItemName) == 0x000008, "Member 'FXlistList05Lay7Param::ItemName' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, Recommendedlevel) == 0x000018, "Member 'FXlistList05Lay7Param::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, bRepeatedPlay) == 0x00001C, "Member 'FXlistList05Lay7Param::bRepeatedPlay' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, IconType) == 0x00001D, "Member 'FXlistList05Lay7Param::IconType' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, CurrentTrainingLevel) == 0x000020, "Member 'FXlistList05Lay7Param::CurrentTrainingLevel' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, bIsNew) == 0x000024, "Member 'FXlistList05Lay7Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, bIsActive) == 0x000025, "Member 'FXlistList05Lay7Param::bIsActive' has a wrong offset!");
static_assert(offsetof(FXlistList05Lay7Param, bIsClear) == 0x000026, "Member 'FXlistList05Lay7Param::bIsClear' has a wrong offset!");

// ScriptStruct AT.ATCharacterTickFunction
// 0x0028 (0x0080 - 0x0058)
struct FATCharacterTickFunction final : public FActorTickFunction
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATCharacterTickFunction) == 0x000008, "Wrong alignment on FATCharacterTickFunction");
static_assert(sizeof(FATCharacterTickFunction) == 0x000080, "Wrong size on FATCharacterTickFunction");

// ScriptStruct AT.ATDefaultInputAssignParam
// 0x0048 (0x0050 - 0x0008)
struct FATDefaultInputAssignParam final : public FTableRowBase
{
public:
	struct FKey                                   QWERTY;                                            // 0x0008(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   QWERTZ;                                            // 0x0020(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   AZERTY;                                            // 0x0038(0x0018)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDefaultInputAssignParam) == 0x000008, "Wrong alignment on FATDefaultInputAssignParam");
static_assert(sizeof(FATDefaultInputAssignParam) == 0x000050, "Wrong size on FATDefaultInputAssignParam");
static_assert(offsetof(FATDefaultInputAssignParam, QWERTY) == 0x000008, "Member 'FATDefaultInputAssignParam::QWERTY' has a wrong offset!");
static_assert(offsetof(FATDefaultInputAssignParam, QWERTZ) == 0x000020, "Member 'FATDefaultInputAssignParam::QWERTZ' has a wrong offset!");
static_assert(offsetof(FATDefaultInputAssignParam, AZERTY) == 0x000038, "Member 'FATDefaultInputAssignParam::AZERTY' has a wrong offset!");

// ScriptStruct AT.QuestImageAssetsReference
// 0x0028 (0x0030 - 0x0008)
struct FQuestImageAssetsReference final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture>                ImageAsset;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestImageAssetsReference) == 0x000008, "Wrong alignment on FQuestImageAssetsReference");
static_assert(sizeof(FQuestImageAssetsReference) == 0x000030, "Wrong size on FQuestImageAssetsReference");
static_assert(offsetof(FQuestImageAssetsReference, ImageAsset) == 0x000008, "Member 'FQuestImageAssetsReference::ImageAsset' has a wrong offset!");

// ScriptStruct AT.SparkingComboInfo
// 0x0018 (0x0018 - 0x0000)
struct FSparkingComboInfo final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   Montage;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSparkingComboInfo) == 0x000008, "Wrong alignment on FSparkingComboInfo");
static_assert(sizeof(FSparkingComboInfo) == 0x000018, "Wrong size on FSparkingComboInfo");
static_assert(offsetof(FSparkingComboInfo, FormChangeID) == 0x000000, "Member 'FSparkingComboInfo::FormChangeID' has a wrong offset!");
static_assert(offsetof(FSparkingComboInfo, Montage) == 0x000008, "Member 'FSparkingComboInfo::Montage' has a wrong offset!");

// ScriptStruct AT.ShortComboInfo
// 0x00F8 (0x00F8 - 0x0000)
struct FShortComboInfo final
{
public:
	TArray<class UAnimMontage*>                   MontageCombo;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv2;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv3;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv4;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv5;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageComboFinishCut;                             // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageComboFinishCutLv4;                          // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageComboFinishCutLv5;                          // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 RightComboAdditionalDamage;                        // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageUpComboNormal;                              // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageUpComboSpecial;                             // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPercentageUpComboAffect;                         // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpComboAffect;                                     // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 UpComboAdditionalAffect;                           // 0x0090(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageDownComboNormal;                            // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageDownComboSpecial;                           // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPercentageDownComboAffect;                       // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DownComboAffect;                                   // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 DownComboAdditionalDamage;                         // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageLeftComboNormal;                            // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageLeftComboSpecial;                           // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPercentageLeftComboAffect;                       // 0x00D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftComboAffect;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftComboInputNum;                                 // 0x00E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftComboInputValuePer;                            // 0x00E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSparkingComboInfo>             MontageComboSp;                                    // 0x00E8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShortComboInfo) == 0x000008, "Wrong alignment on FShortComboInfo");
static_assert(sizeof(FShortComboInfo) == 0x0000F8, "Wrong size on FShortComboInfo");
static_assert(offsetof(FShortComboInfo, MontageCombo) == 0x000000, "Member 'FShortComboInfo::MontageCombo' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboLv2) == 0x000010, "Member 'FShortComboInfo::MontageComboLv2' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboLv3) == 0x000020, "Member 'FShortComboInfo::MontageComboLv3' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboLv4) == 0x000030, "Member 'FShortComboInfo::MontageComboLv4' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboLv5) == 0x000040, "Member 'FShortComboInfo::MontageComboLv5' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboFinishCut) == 0x000050, "Member 'FShortComboInfo::MontageComboFinishCut' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboFinishCutLv4) == 0x000058, "Member 'FShortComboInfo::MontageComboFinishCutLv4' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboFinishCutLv5) == 0x000060, "Member 'FShortComboInfo::MontageComboFinishCutLv5' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, RightComboAdditionalDamage) == 0x000068, "Member 'FShortComboInfo::RightComboAdditionalDamage' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageUpComboNormal) == 0x000078, "Member 'FShortComboInfo::MontageUpComboNormal' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageUpComboSpecial) == 0x000080, "Member 'FShortComboInfo::MontageUpComboSpecial' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, IsPercentageUpComboAffect) == 0x000088, "Member 'FShortComboInfo::IsPercentageUpComboAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, UpComboAffect) == 0x00008C, "Member 'FShortComboInfo::UpComboAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, UpComboAdditionalAffect) == 0x000090, "Member 'FShortComboInfo::UpComboAdditionalAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageDownComboNormal) == 0x0000A0, "Member 'FShortComboInfo::MontageDownComboNormal' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageDownComboSpecial) == 0x0000A8, "Member 'FShortComboInfo::MontageDownComboSpecial' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, IsPercentageDownComboAffect) == 0x0000B0, "Member 'FShortComboInfo::IsPercentageDownComboAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, DownComboAffect) == 0x0000B4, "Member 'FShortComboInfo::DownComboAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, DownComboAdditionalDamage) == 0x0000B8, "Member 'FShortComboInfo::DownComboAdditionalDamage' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageLeftComboNormal) == 0x0000C8, "Member 'FShortComboInfo::MontageLeftComboNormal' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageLeftComboSpecial) == 0x0000D0, "Member 'FShortComboInfo::MontageLeftComboSpecial' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, IsPercentageLeftComboAffect) == 0x0000D8, "Member 'FShortComboInfo::IsPercentageLeftComboAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, LeftComboAffect) == 0x0000DC, "Member 'FShortComboInfo::LeftComboAffect' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, LeftComboInputNum) == 0x0000E0, "Member 'FShortComboInfo::LeftComboInputNum' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, LeftComboInputValuePer) == 0x0000E4, "Member 'FShortComboInfo::LeftComboInputValuePer' has a wrong offset!");
static_assert(offsetof(FShortComboInfo, MontageComboSp) == 0x0000E8, "Member 'FShortComboInfo::MontageComboSp' has a wrong offset!");

// ScriptStruct AT.CarExplodeCarEffectInfo
// 0x0010 (0x0010 - 0x0000)
struct FCarExplodeCarEffectInfo final
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystem*                        ExplodeCarEffect;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarExplodeCarEffectInfo) == 0x000008, "Wrong alignment on FCarExplodeCarEffectInfo");
static_assert(sizeof(FCarExplodeCarEffectInfo) == 0x000010, "Wrong size on FCarExplodeCarEffectInfo");
static_assert(offsetof(FCarExplodeCarEffectInfo, CharacterType) == 0x000000, "Member 'FCarExplodeCarEffectInfo::CharacterType' has a wrong offset!");
static_assert(offsetof(FCarExplodeCarEffectInfo, ExplodeCarEffect) == 0x000008, "Member 'FCarExplodeCarEffectInfo::ExplodeCarEffect' has a wrong offset!");

// ScriptStruct AT.AT_CharacterConstParam
// 0x0008 (0x0010 - 0x0008)
struct FAT_CharacterConstParam final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_CharacterConstParam) == 0x000008, "Wrong alignment on FAT_CharacterConstParam");
static_assert(sizeof(FAT_CharacterConstParam) == 0x000010, "Wrong size on FAT_CharacterConstParam");
static_assert(offsetof(FAT_CharacterConstParam, Value) == 0x000008, "Member 'FAT_CharacterConstParam::Value' has a wrong offset!");

// ScriptStruct AT.DamageParam
// 0x0018 (0x0018 - 0x0000)
struct FDamageParam final
{
public:
	class FString                                 DamageComponentName;                               // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageMagnification;                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageParam) == 0x000008, "Wrong alignment on FDamageParam");
static_assert(sizeof(FDamageParam) == 0x000018, "Wrong size on FDamageParam");
static_assert(offsetof(FDamageParam, DamageComponentName) == 0x000000, "Member 'FDamageParam::DamageComponentName' has a wrong offset!");
static_assert(offsetof(FDamageParam, DamageMagnification) == 0x000010, "Member 'FDamageParam::DamageMagnification' has a wrong offset!");

// ScriptStruct AT.QuestImageParameter
// 0x0030 (0x0038 - 0x0008)
struct FQuestImageParameter final : public FTableRowBase
{
public:
	EQuestImageState                              Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReferenceId;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitLoading;                                      // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitFade;                                         // 0x0025(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverridePanAnimationTime;                          // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            OverrideAnimEasingCurve;                           // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestImageParameter) == 0x000008, "Wrong alignment on FQuestImageParameter");
static_assert(sizeof(FQuestImageParameter) == 0x000038, "Wrong size on FQuestImageParameter");
static_assert(offsetof(FQuestImageParameter, Type) == 0x000008, "Member 'FQuestImageParameter::Type' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, ReferenceId) == 0x000010, "Member 'FQuestImageParameter::ReferenceId' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, Duration) == 0x000018, "Member 'FQuestImageParameter::Duration' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, FadeOutTime) == 0x00001C, "Member 'FQuestImageParameter::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, FadeInTime) == 0x000020, "Member 'FQuestImageParameter::FadeInTime' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, bWaitLoading) == 0x000024, "Member 'FQuestImageParameter::bWaitLoading' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, bWaitFade) == 0x000025, "Member 'FQuestImageParameter::bWaitFade' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, OverridePanAnimationTime) == 0x000028, "Member 'FQuestImageParameter::OverridePanAnimationTime' has a wrong offset!");
static_assert(offsetof(FQuestImageParameter, OverrideAnimEasingCurve) == 0x000030, "Member 'FQuestImageParameter::OverrideAnimEasingCurve' has a wrong offset!");

// ScriptStruct AT.ATEnemyExpTable
// 0x0008 (0x0010 - 0x0008)
struct FATEnemyExpTable final : public FTableRowBase
{
public:
	int32                                         Exp;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATEnemyExpTable) == 0x000008, "Wrong alignment on FATEnemyExpTable");
static_assert(sizeof(FATEnemyExpTable) == 0x000010, "Wrong size on FATEnemyExpTable");
static_assert(offsetof(FATEnemyExpTable, Exp) == 0x000008, "Member 'FATEnemyExpTable::Exp' has a wrong offset!");

// ScriptStruct AT.CharacterSupportParameter
// 0x0020 (0x0028 - 0x0008)
struct FCharacterSupportParameter final : public FTableRowBase
{
public:
	ESupportStyle                                 SupportStyle;                                      // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SupportDyingHpRate;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SupportDyingTime;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PursueSkillId;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ComboCutSkillId;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterSupportParameter) == 0x000008, "Wrong alignment on FCharacterSupportParameter");
static_assert(sizeof(FCharacterSupportParameter) == 0x000028, "Wrong size on FCharacterSupportParameter");
static_assert(offsetof(FCharacterSupportParameter, SupportStyle) == 0x000008, "Member 'FCharacterSupportParameter::SupportStyle' has a wrong offset!");
static_assert(offsetof(FCharacterSupportParameter, SupportDyingHpRate) == 0x00000C, "Member 'FCharacterSupportParameter::SupportDyingHpRate' has a wrong offset!");
static_assert(offsetof(FCharacterSupportParameter, SupportDyingTime) == 0x000010, "Member 'FCharacterSupportParameter::SupportDyingTime' has a wrong offset!");
static_assert(offsetof(FCharacterSupportParameter, PursueSkillId) == 0x000018, "Member 'FCharacterSupportParameter::PursueSkillId' has a wrong offset!");
static_assert(offsetof(FCharacterSupportParameter, ComboCutSkillId) == 0x000020, "Member 'FCharacterSupportParameter::ComboCutSkillId' has a wrong offset!");

// ScriptStruct AT.TargetInfo
// 0x0034 (0x0034 - 0x0000)
struct alignas(0x04) FTargetInfo final
{
public:
	uint8                                         Pad_0[0x34];                                       // 0x0000(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTargetInfo) == 0x000004, "Wrong alignment on FTargetInfo");
static_assert(sizeof(FTargetInfo) == 0x000034, "Wrong size on FTargetInfo");

// ScriptStruct AT.CookEffectData
// 0x0020 (0x0020 - 0x0000)
struct FCookEffectData final
{
public:
	class UParticleSystem*                        CookEatingRank2;                                   // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CookEatingRank3;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CookCompletionRank2;                               // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CookCompletionRank3;                               // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookEffectData) == 0x000008, "Wrong alignment on FCookEffectData");
static_assert(sizeof(FCookEffectData) == 0x000020, "Wrong size on FCookEffectData");
static_assert(offsetof(FCookEffectData, CookEatingRank2) == 0x000000, "Member 'FCookEffectData::CookEatingRank2' has a wrong offset!");
static_assert(offsetof(FCookEffectData, CookEatingRank3) == 0x000008, "Member 'FCookEffectData::CookEatingRank3' has a wrong offset!");
static_assert(offsetof(FCookEffectData, CookCompletionRank2) == 0x000010, "Member 'FCookEffectData::CookCompletionRank2' has a wrong offset!");
static_assert(offsetof(FCookEffectData, CookCompletionRank3) == 0x000018, "Member 'FCookEffectData::CookCompletionRank3' has a wrong offset!");

// ScriptStruct AT.SkillAssistTriggerTable
// 0x0008 (0x0010 - 0x0008)
struct FSkillAssistTriggerTable final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillAssistTriggerTable) == 0x000008, "Wrong alignment on FSkillAssistTriggerTable");
static_assert(sizeof(FSkillAssistTriggerTable) == 0x000010, "Wrong size on FSkillAssistTriggerTable");
static_assert(offsetof(FSkillAssistTriggerTable, Value) == 0x000008, "Member 'FSkillAssistTriggerTable::Value' has a wrong offset!");

// ScriptStruct AT.GroundBattleSparkingComboInfo
// 0x00C0 (0x00C0 - 0x0000)
struct FGroundBattleSparkingComboInfo final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   Montage;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          IsUseHeatupFinishSkillCutin;                       // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGroundBattleSparkingComboFinishSkillCutinInfo HeatupFinishSkillCutin;                            // 0x0020(0x00A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundBattleSparkingComboInfo) == 0x000008, "Wrong alignment on FGroundBattleSparkingComboInfo");
static_assert(sizeof(FGroundBattleSparkingComboInfo) == 0x0000C0, "Wrong size on FGroundBattleSparkingComboInfo");
static_assert(offsetof(FGroundBattleSparkingComboInfo, FormChangeID) == 0x000000, "Member 'FGroundBattleSparkingComboInfo::FormChangeID' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboInfo, Montage) == 0x000008, "Member 'FGroundBattleSparkingComboInfo::Montage' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboInfo, IsUseHeatupFinishSkillCutin) == 0x000018, "Member 'FGroundBattleSparkingComboInfo::IsUseHeatupFinishSkillCutin' has a wrong offset!");
static_assert(offsetof(FGroundBattleSparkingComboInfo, HeatupFinishSkillCutin) == 0x000020, "Member 'FGroundBattleSparkingComboInfo::HeatupFinishSkillCutin' has a wrong offset!");

// ScriptStruct AT.LoadingNpcMesh
// 0x0028 (0x0028 - 0x0000)
struct FLoadingNpcMesh final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingNpcMesh) == 0x000008, "Wrong alignment on FLoadingNpcMesh");
static_assert(sizeof(FLoadingNpcMesh) == 0x000028, "Wrong size on FLoadingNpcMesh");
static_assert(offsetof(FLoadingNpcMesh, Mesh) == 0x000000, "Member 'FLoadingNpcMesh::Mesh' has a wrong offset!");

// ScriptStruct AT.SupportRecoveryMpParameter
// 0x000C (0x000C - 0x0000)
struct FSupportRecoveryMpParameter final
{
public:
	float                                         FavorBorder;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryRate;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryFixed;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportRecoveryMpParameter) == 0x000004, "Wrong alignment on FSupportRecoveryMpParameter");
static_assert(sizeof(FSupportRecoveryMpParameter) == 0x00000C, "Wrong size on FSupportRecoveryMpParameter");
static_assert(offsetof(FSupportRecoveryMpParameter, FavorBorder) == 0x000000, "Member 'FSupportRecoveryMpParameter::FavorBorder' has a wrong offset!");
static_assert(offsetof(FSupportRecoveryMpParameter, RecoveryRate) == 0x000004, "Member 'FSupportRecoveryMpParameter::RecoveryRate' has a wrong offset!");
static_assert(offsetof(FSupportRecoveryMpParameter, RecoveryFixed) == 0x000008, "Member 'FSupportRecoveryMpParameter::RecoveryFixed' has a wrong offset!");

// ScriptStruct AT.ATReferenceToFormMeshAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FATReferenceToFormMeshAssetInstance final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AATFormParts>               Mesh;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATReferenceToFormMeshAssetInstance) == 0x000008, "Wrong alignment on FATReferenceToFormMeshAssetInstance");
static_assert(sizeof(FATReferenceToFormMeshAssetInstance) == 0x000010, "Wrong size on FATReferenceToFormMeshAssetInstance");
static_assert(offsetof(FATReferenceToFormMeshAssetInstance, MasterId) == 0x000000, "Member 'FATReferenceToFormMeshAssetInstance::MasterId' has a wrong offset!");
static_assert(offsetof(FATReferenceToFormMeshAssetInstance, Mesh) == 0x000008, "Member 'FATReferenceToFormMeshAssetInstance::Mesh' has a wrong offset!");

// ScriptStruct AT.SupportActionParameter
// 0x0010 (0x0010 - 0x0000)
struct FSupportActionParameter final
{
public:
	ESupportActionCategory                        ActionCategory;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SupportGaugeRate;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecastTime;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportActionParameter) == 0x000004, "Wrong alignment on FSupportActionParameter");
static_assert(sizeof(FSupportActionParameter) == 0x000010, "Wrong size on FSupportActionParameter");
static_assert(offsetof(FSupportActionParameter, ActionCategory) == 0x000000, "Member 'FSupportActionParameter::ActionCategory' has a wrong offset!");
static_assert(offsetof(FSupportActionParameter, SupportGaugeRate) == 0x000004, "Member 'FSupportActionParameter::SupportGaugeRate' has a wrong offset!");
static_assert(offsetof(FSupportActionParameter, Probability) == 0x000008, "Member 'FSupportActionParameter::Probability' has a wrong offset!");
static_assert(offsetof(FSupportActionParameter, RecastTime) == 0x00000C, "Member 'FSupportActionParameter::RecastTime' has a wrong offset!");

// ScriptStruct AT.SupportStyleParameter
// 0x0010 (0x0010 - 0x0000)
struct FSupportStyleParameter final
{
public:
	TArray<struct FSupportActionParameter>        SupportActionTable;                                // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportStyleParameter) == 0x000008, "Wrong alignment on FSupportStyleParameter");
static_assert(sizeof(FSupportStyleParameter) == 0x000010, "Wrong size on FSupportStyleParameter");
static_assert(offsetof(FSupportStyleParameter, SupportActionTable) == 0x000000, "Member 'FSupportStyleParameter::SupportActionTable' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFishGameMeshInfo
// 0x0058 (0x0058 - 0x0000)
struct FATDataAssetFishGameMeshInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           FishMesh;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AnimationBP;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFishGameMeshInfo) == 0x000008, "Wrong alignment on FATDataAssetFishGameMeshInfo");
static_assert(sizeof(FATDataAssetFishGameMeshInfo) == 0x000058, "Wrong size on FATDataAssetFishGameMeshInfo");
static_assert(offsetof(FATDataAssetFishGameMeshInfo, MasterId) == 0x000000, "Member 'FATDataAssetFishGameMeshInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameMeshInfo, FishMesh) == 0x000008, "Member 'FATDataAssetFishGameMeshInfo::FishMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameMeshInfo, AnimationBP) == 0x000030, "Member 'FATDataAssetFishGameMeshInfo::AnimationBP' has a wrong offset!");

// ScriptStruct AT.ItemInventory
// 0x000C (0x000C - 0x0000)
struct FItemInventory final
{
public:
	int32                                         ItemNumSlot;                                       // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ValidSlotIndex;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewFlg;                                           // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemInventory) == 0x000004, "Wrong alignment on FItemInventory");
static_assert(sizeof(FItemInventory) == 0x00000C, "Wrong size on FItemInventory");
static_assert(offsetof(FItemInventory, ItemNumSlot) == 0x000000, "Member 'FItemInventory::ItemNumSlot' has a wrong offset!");
static_assert(offsetof(FItemInventory, ValidSlotIndex) == 0x000004, "Member 'FItemInventory::ValidSlotIndex' has a wrong offset!");
static_assert(offsetof(FItemInventory, bNewFlg) == 0x000008, "Member 'FItemInventory::bNewFlg' has a wrong offset!");

// ScriptStruct AT.RecipeTableDevelop
// 0x0068 (0x0070 - 0x0008)
struct FRecipeTableDevelop final : public FTableRowBase
{
public:
	int32                                         SortNumber;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERecipeDevelopType                            Type;                                              // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CmcLevel;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Money;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId01;                                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount01;                                       // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId02;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount02;                                       // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId03;                                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount03;                                       // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId04;                                          // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount04;                                       // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId05;                                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount05;                                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RewardItem;                                        // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecipeTableDevelop) == 0x000008, "Wrong alignment on FRecipeTableDevelop");
static_assert(sizeof(FRecipeTableDevelop) == 0x000070, "Wrong size on FRecipeTableDevelop");
static_assert(offsetof(FRecipeTableDevelop, SortNumber) == 0x000008, "Member 'FRecipeTableDevelop::SortNumber' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, Type) == 0x00000C, "Member 'FRecipeTableDevelop::Type' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, CmcLevel) == 0x000010, "Member 'FRecipeTableDevelop::CmcLevel' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, Money) == 0x000014, "Member 'FRecipeTableDevelop::Money' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemId01) == 0x000018, "Member 'FRecipeTableDevelop::ItemId01' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemCount01) == 0x000020, "Member 'FRecipeTableDevelop::ItemCount01' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemId02) == 0x000028, "Member 'FRecipeTableDevelop::ItemId02' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemCount02) == 0x000030, "Member 'FRecipeTableDevelop::ItemCount02' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemId03) == 0x000038, "Member 'FRecipeTableDevelop::ItemId03' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemCount03) == 0x000040, "Member 'FRecipeTableDevelop::ItemCount03' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemId04) == 0x000048, "Member 'FRecipeTableDevelop::ItemId04' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemCount04) == 0x000050, "Member 'FRecipeTableDevelop::ItemCount04' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemId05) == 0x000058, "Member 'FRecipeTableDevelop::ItemId05' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, ItemCount05) == 0x000060, "Member 'FRecipeTableDevelop::ItemCount05' has a wrong offset!");
static_assert(offsetof(FRecipeTableDevelop, RewardItem) == 0x000068, "Member 'FRecipeTableDevelop::RewardItem' has a wrong offset!");

// ScriptStruct AT.ExternalEncounterHudParam
// 0x000C (0x000C - 0x0000)
struct FExternalEncounterHudParam final
{
public:
	ECHARACTER_TYPE                               Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExternalEncounterHudParam) == 0x000004, "Wrong alignment on FExternalEncounterHudParam");
static_assert(sizeof(FExternalEncounterHudParam) == 0x00000C, "Wrong size on FExternalEncounterHudParam");
static_assert(offsetof(FExternalEncounterHudParam, Type) == 0x000000, "Member 'FExternalEncounterHudParam::Type' has a wrong offset!");
static_assert(offsetof(FExternalEncounterHudParam, Num) == 0x000004, "Member 'FExternalEncounterHudParam::Num' has a wrong offset!");
static_assert(offsetof(FExternalEncounterHudParam, VariationId) == 0x000008, "Member 'FExternalEncounterHudParam::VariationId' has a wrong offset!");
static_assert(offsetof(FExternalEncounterHudParam, FormID) == 0x000009, "Member 'FExternalEncounterHudParam::FormID' has a wrong offset!");

// ScriptStruct AT.FishingConditionParameter
// 0x0010 (0x0018 - 0x0008)
struct FFishingConditionParameter final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AvailableProgress;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishingConditionParameter) == 0x000008, "Wrong alignment on FFishingConditionParameter");
static_assert(sizeof(FFishingConditionParameter) == 0x000018, "Wrong size on FFishingConditionParameter");
static_assert(offsetof(FFishingConditionParameter, CharacterType) == 0x000008, "Member 'FFishingConditionParameter::CharacterType' has a wrong offset!");
static_assert(offsetof(FFishingConditionParameter, AvailableProgress) == 0x000010, "Member 'FFishingConditionParameter::AvailableProgress' has a wrong offset!");

// ScriptStruct AT.ATBattleDemoDataTable
// 0x0008 (0x0010 - 0x0008)
struct FATBattleDemoDataTable final : public FTableRowBase
{
public:
	TSubclassOf<class UATBattleDemoData>          DataClass;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATBattleDemoDataTable) == 0x000008, "Wrong alignment on FATBattleDemoDataTable");
static_assert(sizeof(FATBattleDemoDataTable) == 0x000010, "Wrong size on FATBattleDemoDataTable");
static_assert(offsetof(FATBattleDemoDataTable, DataClass) == 0x000008, "Member 'FATBattleDemoDataTable::DataClass' has a wrong offset!");

// ScriptStruct AT.ObjectsLoadedOnlyByDLC5
// 0x0320 (0x0320 - 0x0000)
struct FObjectsLoadedOnlyByDLC5 final : public FObjectsLoadedOnlyBySpecificDLCs
{
public:
	TSoftObjectPtr<class UDataTable>              AtrociousAdjustParamDLC5;                          // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              AtrociousPhaseTableDLC5;                           // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DLC5TreasureSaveTable;                             // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         DefaultBoostNimbus;                                // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         DefaultBoostNimbusBgn;                             // 0x00A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         DefaultBoostNimbusEnd;                             // 0x00C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               CountQTERadialMaterial;                            // 0x00F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> CountQTERadialBlurParam;                           // 0x0118(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             CountQTEAlphaLpCurve;                              // 0x0140(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SubjugationMissionDataTable;                       // 0x0168(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SubjugationMissionPhaseDataTable;                  // 0x0190(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              EventBattleMobPlacePatternTable;                   // 0x01B8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialParameterCollection> NimbusTrailMaterialParam;                          // 0x01E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ExtendFightingPowerParamTbl;                       // 0x0208(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ExtendZcwAreaNav;                                  // 0x0230(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             BattleFieldMesh;                                   // 0x0258(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffect;                                 // 0x0280(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffectL;                                // 0x02A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffectLL;                               // 0x02D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffectXL;                               // 0x02F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectsLoadedOnlyByDLC5) == 0x000008, "Wrong alignment on FObjectsLoadedOnlyByDLC5");
static_assert(sizeof(FObjectsLoadedOnlyByDLC5) == 0x000320, "Wrong size on FObjectsLoadedOnlyByDLC5");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, AtrociousAdjustParamDLC5) == 0x000000, "Member 'FObjectsLoadedOnlyByDLC5::AtrociousAdjustParamDLC5' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, AtrociousPhaseTableDLC5) == 0x000028, "Member 'FObjectsLoadedOnlyByDLC5::AtrociousPhaseTableDLC5' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, DLC5TreasureSaveTable) == 0x000050, "Member 'FObjectsLoadedOnlyByDLC5::DLC5TreasureSaveTable' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, DefaultBoostNimbus) == 0x000078, "Member 'FObjectsLoadedOnlyByDLC5::DefaultBoostNimbus' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, DefaultBoostNimbusBgn) == 0x0000A0, "Member 'FObjectsLoadedOnlyByDLC5::DefaultBoostNimbusBgn' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, DefaultBoostNimbusEnd) == 0x0000C8, "Member 'FObjectsLoadedOnlyByDLC5::DefaultBoostNimbusEnd' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, CountQTERadialMaterial) == 0x0000F0, "Member 'FObjectsLoadedOnlyByDLC5::CountQTERadialMaterial' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, CountQTERadialBlurParam) == 0x000118, "Member 'FObjectsLoadedOnlyByDLC5::CountQTERadialBlurParam' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, CountQTEAlphaLpCurve) == 0x000140, "Member 'FObjectsLoadedOnlyByDLC5::CountQTEAlphaLpCurve' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, SubjugationMissionDataTable) == 0x000168, "Member 'FObjectsLoadedOnlyByDLC5::SubjugationMissionDataTable' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, SubjugationMissionPhaseDataTable) == 0x000190, "Member 'FObjectsLoadedOnlyByDLC5::SubjugationMissionPhaseDataTable' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, EventBattleMobPlacePatternTable) == 0x0001B8, "Member 'FObjectsLoadedOnlyByDLC5::EventBattleMobPlacePatternTable' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, NimbusTrailMaterialParam) == 0x0001E0, "Member 'FObjectsLoadedOnlyByDLC5::NimbusTrailMaterialParam' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, ExtendFightingPowerParamTbl) == 0x000208, "Member 'FObjectsLoadedOnlyByDLC5::ExtendFightingPowerParamTbl' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, ExtendZcwAreaNav) == 0x000230, "Member 'FObjectsLoadedOnlyByDLC5::ExtendZcwAreaNav' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, BattleFieldMesh) == 0x000258, "Member 'FObjectsLoadedOnlyByDLC5::BattleFieldMesh' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, PowerUpAuraEffect) == 0x000280, "Member 'FObjectsLoadedOnlyByDLC5::PowerUpAuraEffect' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, PowerUpAuraEffectL) == 0x0002A8, "Member 'FObjectsLoadedOnlyByDLC5::PowerUpAuraEffectL' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, PowerUpAuraEffectLL) == 0x0002D0, "Member 'FObjectsLoadedOnlyByDLC5::PowerUpAuraEffectLL' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC5, PowerUpAuraEffectXL) == 0x0002F8, "Member 'FObjectsLoadedOnlyByDLC5::PowerUpAuraEffectXL' has a wrong offset!");

// ScriptStruct AT.ItemMessageData
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FItemMessageData final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemMessageData) == 0x000008, "Wrong alignment on FItemMessageData");
static_assert(sizeof(FItemMessageData) == 0x000030, "Wrong size on FItemMessageData");

// ScriptStruct AT.ObjectsLoadedOnlyByDLC4
// 0x0118 (0x0118 - 0x0000)
struct FObjectsLoadedOnlyByDLC4 final : public FObjectsLoadedOnlyBySpecificDLCs
{
public:
	TSoftObjectPtr<class UDataTable>              DLC4TreasureSaveTable;                             // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffect;                                 // 0x0028(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffectL;                                // 0x0050(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffectLL;                               // 0x0078(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         PowerUpAuraEffectXL;                               // 0x00A0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FormChangeAuraZH;                                  // 0x00C8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         HeatUpAuraZH;                                      // 0x00F0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectsLoadedOnlyByDLC4) == 0x000008, "Wrong alignment on FObjectsLoadedOnlyByDLC4");
static_assert(sizeof(FObjectsLoadedOnlyByDLC4) == 0x000118, "Wrong size on FObjectsLoadedOnlyByDLC4");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, DLC4TreasureSaveTable) == 0x000000, "Member 'FObjectsLoadedOnlyByDLC4::DLC4TreasureSaveTable' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, PowerUpAuraEffect) == 0x000028, "Member 'FObjectsLoadedOnlyByDLC4::PowerUpAuraEffect' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, PowerUpAuraEffectL) == 0x000050, "Member 'FObjectsLoadedOnlyByDLC4::PowerUpAuraEffectL' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, PowerUpAuraEffectLL) == 0x000078, "Member 'FObjectsLoadedOnlyByDLC4::PowerUpAuraEffectLL' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, PowerUpAuraEffectXL) == 0x0000A0, "Member 'FObjectsLoadedOnlyByDLC4::PowerUpAuraEffectXL' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, FormChangeAuraZH) == 0x0000C8, "Member 'FObjectsLoadedOnlyByDLC4::FormChangeAuraZH' has a wrong offset!");
static_assert(offsetof(FObjectsLoadedOnlyByDLC4, HeatUpAuraZH) == 0x0000F0, "Member 'FObjectsLoadedOnlyByDLC4::HeatUpAuraZH' has a wrong offset!");

// ScriptStruct AT.ATPreLoadFile
// 0x0018 (0x0020 - 0x0008)
struct FATPreLoadFile final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        AssetId;                                           // 0x0008(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATPreLoadFile) == 0x000008, "Wrong alignment on FATPreLoadFile");
static_assert(sizeof(FATPreLoadFile) == 0x000020, "Wrong size on FATPreLoadFile");
static_assert(offsetof(FATPreLoadFile, AssetId) == 0x000008, "Member 'FATPreLoadFile::AssetId' has a wrong offset!");

// ScriptStruct AT.DestructibleRegisterMeshData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDestructibleRegisterMeshData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructibleRegisterMeshData) == 0x000008, "Wrong alignment on FDestructibleRegisterMeshData");
static_assert(sizeof(FDestructibleRegisterMeshData) == 0x000018, "Wrong size on FDestructibleRegisterMeshData");

// ScriptStruct AT.LightTowerSetting
// 0x0028 (0x0030 - 0x0008)
struct FLightTowerSetting final : public FTableRowBase
{
public:
	float                                         LightTowerHideDist;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightTowerDecalHideDist;                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightTowerDecalMaxDisplayDist;                     // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserLightTowerRaycastTop;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UserLightTowerRaycastBottom;                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LightTowerSortPriority;                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LightTowerHalfArea;                                // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLightTowerSetting) == 0x000008, "Wrong alignment on FLightTowerSetting");
static_assert(sizeof(FLightTowerSetting) == 0x000030, "Wrong size on FLightTowerSetting");
static_assert(offsetof(FLightTowerSetting, LightTowerHideDist) == 0x000008, "Member 'FLightTowerSetting::LightTowerHideDist' has a wrong offset!");
static_assert(offsetof(FLightTowerSetting, LightTowerDecalHideDist) == 0x00000C, "Member 'FLightTowerSetting::LightTowerDecalHideDist' has a wrong offset!");
static_assert(offsetof(FLightTowerSetting, LightTowerDecalMaxDisplayDist) == 0x000010, "Member 'FLightTowerSetting::LightTowerDecalMaxDisplayDist' has a wrong offset!");
static_assert(offsetof(FLightTowerSetting, UserLightTowerRaycastTop) == 0x000014, "Member 'FLightTowerSetting::UserLightTowerRaycastTop' has a wrong offset!");
static_assert(offsetof(FLightTowerSetting, UserLightTowerRaycastBottom) == 0x000018, "Member 'FLightTowerSetting::UserLightTowerRaycastBottom' has a wrong offset!");
static_assert(offsetof(FLightTowerSetting, LightTowerSortPriority) == 0x00001C, "Member 'FLightTowerSetting::LightTowerSortPriority' has a wrong offset!");
static_assert(offsetof(FLightTowerSetting, LightTowerHalfArea) == 0x000020, "Member 'FLightTowerSetting::LightTowerHalfArea' has a wrong offset!");

// ScriptStruct AT.KpiBNIDData
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FKpiBNIDData
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKpiBNIDData) == 0x000004, "Wrong alignment on FKpiBNIDData");
static_assert(sizeof(FKpiBNIDData) == 0x000004, "Wrong size on FKpiBNIDData");

// ScriptStruct AT.KpiBNIDCheckStatusData
// 0x0014 (0x0018 - 0x0004)
struct alignas(0x08) FKpiBNIDCheckStatusData final : public FKpiBNIDData
{
public:
	uint8                                         Pad_4[0x14];                                       // 0x0004(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKpiBNIDCheckStatusData) == 0x000008, "Wrong alignment on FKpiBNIDCheckStatusData");
static_assert(sizeof(FKpiBNIDCheckStatusData) == 0x000018, "Wrong size on FKpiBNIDCheckStatusData");

// ScriptStruct AT.TransformFaceInfo
// 0x0010 (0x0010 - 0x0000)
struct FTransformFaceInfo final
{
public:
	class FName                                   TransformID;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TransformFaceMontage;                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTransformFaceInfo) == 0x000008, "Wrong alignment on FTransformFaceInfo");
static_assert(sizeof(FTransformFaceInfo) == 0x000010, "Wrong size on FTransformFaceInfo");
static_assert(offsetof(FTransformFaceInfo, TransformID) == 0x000000, "Member 'FTransformFaceInfo::TransformID' has a wrong offset!");
static_assert(offsetof(FTransformFaceInfo, TransformFaceMontage) == 0x000008, "Member 'FTransformFaceInfo::TransformFaceMontage' has a wrong offset!");

// ScriptStruct AT.Hit
// 0x0090 (0x0090 - 0x0000)
struct FHit final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(BlueprintVisible, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bHitGround;                                        // 0x0088(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHit) == 0x000008, "Wrong alignment on FHit");
static_assert(sizeof(FHit) == 0x000090, "Wrong size on FHit");
static_assert(offsetof(FHit, HitResult) == 0x000000, "Member 'FHit::HitResult' has a wrong offset!");
static_assert(offsetof(FHit, bHitGround) == 0x000088, "Member 'FHit::bHitGround' has a wrong offset!");

// ScriptStruct AT.IntPlane
// 0x0004 (0x0010 - 0x000C)
struct FIntPlane final : public FIntVector
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntPlane) == 0x000004, "Wrong alignment on FIntPlane");
static_assert(sizeof(FIntPlane) == 0x000010, "Wrong size on FIntPlane");

// ScriptStruct AT.KpiBNIDEraseData
// 0x0000 (0x0004 - 0x0004)
struct FKpiBNIDEraseData final : public FKpiBNIDData
{
};
static_assert(alignof(FKpiBNIDEraseData) == 0x000004, "Wrong alignment on FKpiBNIDEraseData");
static_assert(sizeof(FKpiBNIDEraseData) == 0x000004, "Wrong size on FKpiBNIDEraseData");

// ScriptStruct AT.CharacterName
// 0x0010 (0x0018 - 0x0008)
struct FCharacterName final : public FTableRowBase
{
public:
	class FString                                 CharacterName;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterName) == 0x000008, "Wrong alignment on FCharacterName");
static_assert(sizeof(FCharacterName) == 0x000018, "Wrong size on FCharacterName");
static_assert(offsetof(FCharacterName, CharacterName) == 0x000008, "Member 'FCharacterName::CharacterName' has a wrong offset!");

// ScriptStruct AT.ReferenceToUiCaptureAssetInstance
// 0x0040 (0x0040 - 0x0000)
struct FReferenceToUiCaptureAssetInstance final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkelMesh;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimBlueprint*                         AnimBP;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimationAsset*>                Animations;                                        // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToUiCaptureAssetInstance) == 0x000008, "Wrong alignment on FReferenceToUiCaptureAssetInstance");
static_assert(sizeof(FReferenceToUiCaptureAssetInstance) == 0x000040, "Wrong size on FReferenceToUiCaptureAssetInstance");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, StaticMesh) == 0x000000, "Member 'FReferenceToUiCaptureAssetInstance::StaticMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, SkelMesh) == 0x000008, "Member 'FReferenceToUiCaptureAssetInstance::SkelMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, AnimBP) == 0x000010, "Member 'FReferenceToUiCaptureAssetInstance::AnimBP' has a wrong offset!");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, Animations) == 0x000018, "Member 'FReferenceToUiCaptureAssetInstance::Animations' has a wrong offset!");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, Particle) == 0x000028, "Member 'FReferenceToUiCaptureAssetInstance::Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, ActorClass) == 0x000030, "Member 'FReferenceToUiCaptureAssetInstance::ActorClass' has a wrong offset!");
static_assert(offsetof(FReferenceToUiCaptureAssetInstance, Montage) == 0x000038, "Member 'FReferenceToUiCaptureAssetInstance::Montage' has a wrong offset!");

// ScriptStruct AT.ATWindRoadCameraParam
// 0x0001 (0x0001 - 0x0000)
struct FATWindRoadCameraParam final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATWindRoadCameraParam) == 0x000001, "Wrong alignment on FATWindRoadCameraParam");
static_assert(sizeof(FATWindRoadCameraParam) == 0x000001, "Wrong size on FATWindRoadCameraParam");

// ScriptStruct AT.DlcMenuTable
// 0x00F0 (0x00F8 - 0x0008)
struct FDlcMenuTable final : public FTableRowBase
{
public:
	class FName                                   CommonId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Image_Path;                                        // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Summary;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_Id;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_dlc_Id;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_dlc2_Id;                                    // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_dlc3_Id;                                    // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_DLC4_Id;                                    // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_DLC5_Id;                                    // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_DLC6_Id;                                    // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_FirstNotice_Id;                             // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_unusable_Id;                                // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Details_Id;                                        // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestId;                                           // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDlcMenuTable) == 0x000008, "Wrong alignment on FDlcMenuTable");
static_assert(sizeof(FDlcMenuTable) == 0x0000F8, "Wrong size on FDlcMenuTable");
static_assert(offsetof(FDlcMenuTable, CommonId) == 0x000008, "Member 'FDlcMenuTable::CommonId' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Image_Path) == 0x000010, "Member 'FDlcMenuTable::Image_Path' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Summary) == 0x000020, "Member 'FDlcMenuTable::Summary' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Title) == 0x000030, "Member 'FDlcMenuTable::Title' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_Id) == 0x000040, "Member 'FDlcMenuTable::Dialog_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_dlc_Id) == 0x000050, "Member 'FDlcMenuTable::Dialog_dlc_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_dlc2_Id) == 0x000060, "Member 'FDlcMenuTable::Dialog_dlc2_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_dlc3_Id) == 0x000070, "Member 'FDlcMenuTable::Dialog_dlc3_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_DLC4_Id) == 0x000080, "Member 'FDlcMenuTable::Dialog_DLC4_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_DLC5_Id) == 0x000090, "Member 'FDlcMenuTable::Dialog_DLC5_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_DLC6_Id) == 0x0000A0, "Member 'FDlcMenuTable::Dialog_DLC6_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_FirstNotice_Id) == 0x0000B0, "Member 'FDlcMenuTable::Dialog_FirstNotice_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Dialog_unusable_Id) == 0x0000C0, "Member 'FDlcMenuTable::Dialog_unusable_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Details_Id) == 0x0000D0, "Member 'FDlcMenuTable::Details_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, Comment) == 0x0000E0, "Member 'FDlcMenuTable::Comment' has a wrong offset!");
static_assert(offsetof(FDlcMenuTable, QuestId) == 0x0000F0, "Member 'FDlcMenuTable::QuestId' has a wrong offset!");

// ScriptStruct AT.BreakThroughRewardParam
// 0x0048 (0x0050 - 0x0008)
struct FBreakThroughRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardSkillID;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem01;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem04;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem05;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum01;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum02;                                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum03;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum04;                                   // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum05;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBreakThroughRewardParam) == 0x000008, "Wrong alignment on FBreakThroughRewardParam");
static_assert(sizeof(FBreakThroughRewardParam) == 0x000050, "Wrong size on FBreakThroughRewardParam");
static_assert(offsetof(FBreakThroughRewardParam, RewardSkillID) == 0x000008, "Member 'FBreakThroughRewardParam::RewardSkillID' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItem01) == 0x000010, "Member 'FBreakThroughRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItem02) == 0x000018, "Member 'FBreakThroughRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItem03) == 0x000020, "Member 'FBreakThroughRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItem04) == 0x000028, "Member 'FBreakThroughRewardParam::RewardItem04' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItem05) == 0x000030, "Member 'FBreakThroughRewardParam::RewardItem05' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItemNum01) == 0x000038, "Member 'FBreakThroughRewardParam::RewardItemNum01' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItemNum02) == 0x00003C, "Member 'FBreakThroughRewardParam::RewardItemNum02' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItemNum03) == 0x000040, "Member 'FBreakThroughRewardParam::RewardItemNum03' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItemNum04) == 0x000044, "Member 'FBreakThroughRewardParam::RewardItemNum04' has a wrong offset!");
static_assert(offsetof(FBreakThroughRewardParam, RewardItemNum05) == 0x000048, "Member 'FBreakThroughRewardParam::RewardItemNum05' has a wrong offset!");

// ScriptStruct AT.CharacterUIParamTableRow
// 0x0010 (0x0018 - 0x0008)
struct FCharacterUIParamTableRow final : public FTableRowBase
{
public:
	class FName                                   SpeakerID;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Char3Code;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterUIParamTableRow) == 0x000008, "Wrong alignment on FCharacterUIParamTableRow");
static_assert(sizeof(FCharacterUIParamTableRow) == 0x000018, "Wrong size on FCharacterUIParamTableRow");
static_assert(offsetof(FCharacterUIParamTableRow, SpeakerID) == 0x000008, "Member 'FCharacterUIParamTableRow::SpeakerID' has a wrong offset!");
static_assert(offsetof(FCharacterUIParamTableRow, Char3Code) == 0x000010, "Member 'FCharacterUIParamTableRow::Char3Code' has a wrong offset!");

// ScriptStruct AT.GrassData
// 0x0040 (0x0040 - 0x0000)
struct FGrassData final
{
public:
	class UStaticMesh*                            GrassMesh;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrassDensity;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlacementJitter;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartCullDistance;                                 // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndCullDistance;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinLOD;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGrassDataScaling                             Scaling;                                           // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFloatInterval                         ScaleX;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ScaleY;                                            // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatInterval                         ScaleZ;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RandomRotation;                                    // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlignToSurface;                                    // 0x0039(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLightingChannels                      LightingChannels;                                  // 0x003A(0x0001)(Edit, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bReceivesDecals;                                   // 0x003B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrassData) == 0x000008, "Wrong alignment on FGrassData");
static_assert(sizeof(FGrassData) == 0x000040, "Wrong size on FGrassData");
static_assert(offsetof(FGrassData, GrassMesh) == 0x000000, "Member 'FGrassData::GrassMesh' has a wrong offset!");
static_assert(offsetof(FGrassData, GrassDensity) == 0x000008, "Member 'FGrassData::GrassDensity' has a wrong offset!");
static_assert(offsetof(FGrassData, PlacementJitter) == 0x00000C, "Member 'FGrassData::PlacementJitter' has a wrong offset!");
static_assert(offsetof(FGrassData, StartCullDistance) == 0x000010, "Member 'FGrassData::StartCullDistance' has a wrong offset!");
static_assert(offsetof(FGrassData, EndCullDistance) == 0x000014, "Member 'FGrassData::EndCullDistance' has a wrong offset!");
static_assert(offsetof(FGrassData, MinLOD) == 0x000018, "Member 'FGrassData::MinLOD' has a wrong offset!");
static_assert(offsetof(FGrassData, Scaling) == 0x00001C, "Member 'FGrassData::Scaling' has a wrong offset!");
static_assert(offsetof(FGrassData, ScaleX) == 0x000020, "Member 'FGrassData::ScaleX' has a wrong offset!");
static_assert(offsetof(FGrassData, ScaleY) == 0x000028, "Member 'FGrassData::ScaleY' has a wrong offset!");
static_assert(offsetof(FGrassData, ScaleZ) == 0x000030, "Member 'FGrassData::ScaleZ' has a wrong offset!");
static_assert(offsetof(FGrassData, RandomRotation) == 0x000038, "Member 'FGrassData::RandomRotation' has a wrong offset!");
static_assert(offsetof(FGrassData, AlignToSurface) == 0x000039, "Member 'FGrassData::AlignToSurface' has a wrong offset!");
static_assert(offsetof(FGrassData, LightingChannels) == 0x00003A, "Member 'FGrassData::LightingChannels' has a wrong offset!");
static_assert(offsetof(FGrassData, bReceivesDecals) == 0x00003B, "Member 'FGrassData::bReceivesDecals' has a wrong offset!");

// ScriptStruct AT.StatusTableRow
// 0x0060 (0x0068 - 0x0008)
struct FStatusTableRow final : public FTableRowBase
{
public:
	int32                                         HP;                                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MP;                                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MAXMP_NON_BATTLE;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MINMP_BATTLE;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MAXMP_BATTLE;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CHARGE_SPEED;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CHARGE_VALUE;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         STR;                                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DEF;                                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KiSTR;                                             // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KiDEF;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AGL;                                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SPD;                                               // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakSTR;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakDEF;                                          // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MpRecoverBattleMove;                               // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MpRecoverBattleStop;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MpRecoverNoBattle;                                 // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakRecoverBattleMove;                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakRecoverBattleStop;                            // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakRecoverNoBattle;                              // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStatusTableRow) == 0x000008, "Wrong alignment on FStatusTableRow");
static_assert(sizeof(FStatusTableRow) == 0x000068, "Wrong size on FStatusTableRow");
static_assert(offsetof(FStatusTableRow, HP) == 0x000008, "Member 'FStatusTableRow::HP' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MP) == 0x00000C, "Member 'FStatusTableRow::MP' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MAXMP_NON_BATTLE) == 0x000010, "Member 'FStatusTableRow::MAXMP_NON_BATTLE' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MINMP_BATTLE) == 0x000014, "Member 'FStatusTableRow::MINMP_BATTLE' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MAXMP_BATTLE) == 0x000018, "Member 'FStatusTableRow::MAXMP_BATTLE' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, CHARGE_SPEED) == 0x00001C, "Member 'FStatusTableRow::CHARGE_SPEED' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, CHARGE_VALUE) == 0x000020, "Member 'FStatusTableRow::CHARGE_VALUE' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, STR) == 0x000024, "Member 'FStatusTableRow::STR' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, DEF) == 0x000028, "Member 'FStatusTableRow::DEF' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, KiSTR) == 0x00002C, "Member 'FStatusTableRow::KiSTR' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, KiDEF) == 0x000030, "Member 'FStatusTableRow::KiDEF' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, AGL) == 0x000034, "Member 'FStatusTableRow::AGL' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, SPD) == 0x000038, "Member 'FStatusTableRow::SPD' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, BreakSTR) == 0x00003C, "Member 'FStatusTableRow::BreakSTR' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, BreakDEF) == 0x000040, "Member 'FStatusTableRow::BreakDEF' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MpRecoverBattleMove) == 0x000044, "Member 'FStatusTableRow::MpRecoverBattleMove' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MpRecoverBattleStop) == 0x000048, "Member 'FStatusTableRow::MpRecoverBattleStop' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, MpRecoverNoBattle) == 0x00004C, "Member 'FStatusTableRow::MpRecoverNoBattle' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, BreakRecoverBattleMove) == 0x000050, "Member 'FStatusTableRow::BreakRecoverBattleMove' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, BreakRecoverBattleStop) == 0x000054, "Member 'FStatusTableRow::BreakRecoverBattleStop' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, BreakRecoverNoBattle) == 0x000058, "Member 'FStatusTableRow::BreakRecoverNoBattle' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, Level) == 0x00005C, "Member 'FStatusTableRow::Level' has a wrong offset!");
static_assert(offsetof(FStatusTableRow, Exp) == 0x000060, "Member 'FStatusTableRow::Exp' has a wrong offset!");

// ScriptStruct AT.RareWindRoadAppearanceDataTableType
// 0x0010 (0x0018 - 0x0008)
struct FRareWindRoadAppearanceDataTableType final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaIndex;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rate;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareMax;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRareWindRoadAppearanceDataTableType) == 0x000008, "Wrong alignment on FRareWindRoadAppearanceDataTableType");
static_assert(sizeof(FRareWindRoadAppearanceDataTableType) == 0x000018, "Wrong size on FRareWindRoadAppearanceDataTableType");
static_assert(offsetof(FRareWindRoadAppearanceDataTableType, AreaIndex) == 0x000008, "Member 'FRareWindRoadAppearanceDataTableType::AreaIndex' has a wrong offset!");
static_assert(offsetof(FRareWindRoadAppearanceDataTableType, Rate) == 0x00000C, "Member 'FRareWindRoadAppearanceDataTableType::Rate' has a wrong offset!");
static_assert(offsetof(FRareWindRoadAppearanceDataTableType, RareMax) == 0x000010, "Member 'FRareWindRoadAppearanceDataTableType::RareMax' has a wrong offset!");

// ScriptStruct AT.CmnQuestMenuList06Param
// 0x0048 (0x0048 - 0x0000)
struct FCmnQuestMenuList06Param final
{
public:
	uint8                                         IconType;                                          // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CaptionTxt;                                        // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionId;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QuestLevel;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTrophy;                                         // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheck;                                          // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNavi;                                           // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0043(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRepeat;                                         // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClear;                                          // 0x0046(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_47[0x1];                                       // 0x0047(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnQuestMenuList06Param) == 0x000008, "Wrong alignment on FCmnQuestMenuList06Param");
static_assert(sizeof(FCmnQuestMenuList06Param) == 0x000048, "Wrong size on FCmnQuestMenuList06Param");
static_assert(offsetof(FCmnQuestMenuList06Param, IconType) == 0x000000, "Member 'FCmnQuestMenuList06Param::IconType' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, ItemName) == 0x000008, "Member 'FCmnQuestMenuList06Param::ItemName' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, CaptionTxt) == 0x000018, "Member 'FCmnQuestMenuList06Param::CaptionTxt' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, MissionId) == 0x000028, "Member 'FCmnQuestMenuList06Param::MissionId' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, QuestLevel) == 0x000030, "Member 'FCmnQuestMenuList06Param::QuestLevel' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsTrophy) == 0x000040, "Member 'FCmnQuestMenuList06Param::bIsTrophy' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsCheck) == 0x000041, "Member 'FCmnQuestMenuList06Param::bIsCheck' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsNavi) == 0x000042, "Member 'FCmnQuestMenuList06Param::bIsNavi' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsNew) == 0x000043, "Member 'FCmnQuestMenuList06Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsActive) == 0x000044, "Member 'FCmnQuestMenuList06Param::bIsActive' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsRepeat) == 0x000045, "Member 'FCmnQuestMenuList06Param::bIsRepeat' has a wrong offset!");
static_assert(offsetof(FCmnQuestMenuList06Param, bIsClear) == 0x000046, "Member 'FCmnQuestMenuList06Param::bIsClear' has a wrong offset!");

// ScriptStruct AT.AT_TableRow_Float
// 0x0008 (0x0010 - 0x0008)
struct FAT_TableRow_Float final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_TableRow_Float) == 0x000008, "Wrong alignment on FAT_TableRow_Float");
static_assert(sizeof(FAT_TableRow_Float) == 0x000010, "Wrong size on FAT_TableRow_Float");
static_assert(offsetof(FAT_TableRow_Float, Value) == 0x000008, "Member 'FAT_TableRow_Float::Value' has a wrong offset!");

// ScriptStruct AT.AT_TalkAnimNode_LookAt
// 0x0060 (0x0280 - 0x0220)
struct FAT_TalkAnimNode_LookAt final : public FAnimNode_LookAt
{
public:
	float                                         LookAtClampUpDown;                                 // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseInitTargetLoc;                                 // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_225[0x3];                                      // 0x0225(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                InitTargetLocation;                                // 0x0228(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopUntilAngleLateral;                             // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopUntilAngleLongitudinal;                        // 0x0238(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23C[0x44];                                     // 0x023C(0x0044)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_TalkAnimNode_LookAt) == 0x000010, "Wrong alignment on FAT_TalkAnimNode_LookAt");
static_assert(sizeof(FAT_TalkAnimNode_LookAt) == 0x000280, "Wrong size on FAT_TalkAnimNode_LookAt");
static_assert(offsetof(FAT_TalkAnimNode_LookAt, LookAtClampUpDown) == 0x000220, "Member 'FAT_TalkAnimNode_LookAt::LookAtClampUpDown' has a wrong offset!");
static_assert(offsetof(FAT_TalkAnimNode_LookAt, bUseInitTargetLoc) == 0x000224, "Member 'FAT_TalkAnimNode_LookAt::bUseInitTargetLoc' has a wrong offset!");
static_assert(offsetof(FAT_TalkAnimNode_LookAt, InitTargetLocation) == 0x000228, "Member 'FAT_TalkAnimNode_LookAt::InitTargetLocation' has a wrong offset!");
static_assert(offsetof(FAT_TalkAnimNode_LookAt, StopUntilAngleLateral) == 0x000234, "Member 'FAT_TalkAnimNode_LookAt::StopUntilAngleLateral' has a wrong offset!");
static_assert(offsetof(FAT_TalkAnimNode_LookAt, StopUntilAngleLongitudinal) == 0x000238, "Member 'FAT_TalkAnimNode_LookAt::StopUntilAngleLongitudinal' has a wrong offset!");

// ScriptStruct AT.ATDataAssetMiniGameInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetMiniGameInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UserWidgetClass;                                   // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetMiniGameInfo) == 0x000008, "Wrong alignment on FATDataAssetMiniGameInfo");
static_assert(sizeof(FATDataAssetMiniGameInfo) == 0x000030, "Wrong size on FATDataAssetMiniGameInfo");
static_assert(offsetof(FATDataAssetMiniGameInfo, MasterId) == 0x000000, "Member 'FATDataAssetMiniGameInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetMiniGameInfo, UserWidgetClass) == 0x000008, "Member 'FATDataAssetMiniGameInfo::UserWidgetClass' has a wrong offset!");

// ScriptStruct AT.UISkillTreeLayout
// 0x0078 (0x0080 - 0x0008)
struct FUISkillTreeLayout final : public FTableRowBase
{
public:
	int32                                         Col1;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col2;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col3;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col4;                                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col5;                                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col6;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col7;                                              // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col8;                                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col9;                                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col10;                                             // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col11;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col12;                                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col13;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col14;                                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col15;                                             // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col16;                                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col17;                                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col18;                                             // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col19;                                             // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col20;                                             // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col21;                                             // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col22;                                             // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col23;                                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col24;                                             // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col25;                                             // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col26;                                             // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col27;                                             // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col28;                                             // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col29;                                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Col30;                                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUISkillTreeLayout) == 0x000008, "Wrong alignment on FUISkillTreeLayout");
static_assert(sizeof(FUISkillTreeLayout) == 0x000080, "Wrong size on FUISkillTreeLayout");
static_assert(offsetof(FUISkillTreeLayout, Col1) == 0x000008, "Member 'FUISkillTreeLayout::Col1' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col2) == 0x00000C, "Member 'FUISkillTreeLayout::Col2' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col3) == 0x000010, "Member 'FUISkillTreeLayout::Col3' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col4) == 0x000014, "Member 'FUISkillTreeLayout::Col4' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col5) == 0x000018, "Member 'FUISkillTreeLayout::Col5' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col6) == 0x00001C, "Member 'FUISkillTreeLayout::Col6' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col7) == 0x000020, "Member 'FUISkillTreeLayout::Col7' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col8) == 0x000024, "Member 'FUISkillTreeLayout::Col8' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col9) == 0x000028, "Member 'FUISkillTreeLayout::Col9' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col10) == 0x00002C, "Member 'FUISkillTreeLayout::Col10' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col11) == 0x000030, "Member 'FUISkillTreeLayout::Col11' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col12) == 0x000034, "Member 'FUISkillTreeLayout::Col12' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col13) == 0x000038, "Member 'FUISkillTreeLayout::Col13' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col14) == 0x00003C, "Member 'FUISkillTreeLayout::Col14' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col15) == 0x000040, "Member 'FUISkillTreeLayout::Col15' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col16) == 0x000044, "Member 'FUISkillTreeLayout::Col16' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col17) == 0x000048, "Member 'FUISkillTreeLayout::Col17' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col18) == 0x00004C, "Member 'FUISkillTreeLayout::Col18' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col19) == 0x000050, "Member 'FUISkillTreeLayout::Col19' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col20) == 0x000054, "Member 'FUISkillTreeLayout::Col20' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col21) == 0x000058, "Member 'FUISkillTreeLayout::Col21' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col22) == 0x00005C, "Member 'FUISkillTreeLayout::Col22' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col23) == 0x000060, "Member 'FUISkillTreeLayout::Col23' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col24) == 0x000064, "Member 'FUISkillTreeLayout::Col24' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col25) == 0x000068, "Member 'FUISkillTreeLayout::Col25' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col26) == 0x00006C, "Member 'FUISkillTreeLayout::Col26' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col27) == 0x000070, "Member 'FUISkillTreeLayout::Col27' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col28) == 0x000074, "Member 'FUISkillTreeLayout::Col28' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col29) == 0x000078, "Member 'FUISkillTreeLayout::Col29' has a wrong offset!");
static_assert(offsetof(FUISkillTreeLayout, Col30) == 0x00007C, "Member 'FUISkillTreeLayout::Col30' has a wrong offset!");

// ScriptStruct AT.MissionProgress
// 0x0018 (0x0018 - 0x0000)
struct FMissionProgress final
{
public:
	class FName                                   PhaseID;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        CurrentValue;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionPhaseProgressType                     ProgressType;                                      // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionProgress) == 0x000008, "Wrong alignment on FMissionProgress");
static_assert(sizeof(FMissionProgress) == 0x000018, "Wrong size on FMissionProgress");
static_assert(offsetof(FMissionProgress, PhaseID) == 0x000000, "Member 'FMissionProgress::PhaseID' has a wrong offset!");
static_assert(offsetof(FMissionProgress, CurrentValue) == 0x000008, "Member 'FMissionProgress::CurrentValue' has a wrong offset!");
static_assert(offsetof(FMissionProgress, ProgressType) == 0x000010, "Member 'FMissionProgress::ProgressType' has a wrong offset!");

// ScriptStruct AT.SpawnCharacterParam
// 0x000C (0x000C - 0x0000)
struct FSpawnCharacterParam final
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VariationId;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FormID;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnCharacterParam) == 0x000004, "Wrong alignment on FSpawnCharacterParam");
static_assert(sizeof(FSpawnCharacterParam) == 0x00000C, "Wrong size on FSpawnCharacterParam");
static_assert(offsetof(FSpawnCharacterParam, CharacterType) == 0x000000, "Member 'FSpawnCharacterParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FSpawnCharacterParam, VariationId) == 0x000004, "Member 'FSpawnCharacterParam::VariationId' has a wrong offset!");
static_assert(offsetof(FSpawnCharacterParam, FormID) == 0x000008, "Member 'FSpawnCharacterParam::FormID' has a wrong offset!");

// ScriptStruct AT.QuestPhaseProgress
// 0x0008 (0x0008 - 0x0000)
struct FQuestPhaseProgress final
{
public:
	int32                                         OrderNo;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentValue;                                      // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestPhaseProgress) == 0x000004, "Wrong alignment on FQuestPhaseProgress");
static_assert(sizeof(FQuestPhaseProgress) == 0x000008, "Wrong size on FQuestPhaseProgress");
static_assert(offsetof(FQuestPhaseProgress, OrderNo) == 0x000000, "Member 'FQuestPhaseProgress::OrderNo' has a wrong offset!");
static_assert(offsetof(FQuestPhaseProgress, CurrentValue) == 0x000004, "Member 'FQuestPhaseProgress::CurrentValue' has a wrong offset!");

// ScriptStruct AT.QuestPhaseProgressSet
// 0x0018 (0x0018 - 0x0000)
struct FQuestPhaseProgressSet final
{
public:
	class FName                                   PhaseID;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQuestPhaseProgress>            ProgressList;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestPhaseProgressSet) == 0x000008, "Wrong alignment on FQuestPhaseProgressSet");
static_assert(sizeof(FQuestPhaseProgressSet) == 0x000018, "Wrong size on FQuestPhaseProgressSet");
static_assert(offsetof(FQuestPhaseProgressSet, PhaseID) == 0x000000, "Member 'FQuestPhaseProgressSet::PhaseID' has a wrong offset!");
static_assert(offsetof(FQuestPhaseProgressSet, ProgressList) == 0x000008, "Member 'FQuestPhaseProgressSet::ProgressList' has a wrong offset!");

// ScriptStruct AT.RequestQuestInfo
// 0x0048 (0x0048 - 0x0000)
struct FRequestQuestInfo final
{
public:
	class FName                                   QuestId;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseNo;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestActorName;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName1;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName2;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName3;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQuestPhaseProgressSet>         PhaseProgressList;                                 // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsReceiveCancel;                                  // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestQuestInfo) == 0x000008, "Wrong alignment on FRequestQuestInfo");
static_assert(sizeof(FRequestQuestInfo) == 0x000048, "Wrong size on FRequestQuestInfo");
static_assert(offsetof(FRequestQuestInfo, QuestId) == 0x000000, "Member 'FRequestQuestInfo::QuestId' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, PhaseNo) == 0x000008, "Member 'FRequestQuestInfo::PhaseNo' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, QuestActorName) == 0x000010, "Member 'FRequestQuestInfo::QuestActorName' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, SubLevelName1) == 0x000018, "Member 'FRequestQuestInfo::SubLevelName1' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, SubLevelName2) == 0x000020, "Member 'FRequestQuestInfo::SubLevelName2' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, SubLevelName3) == 0x000028, "Member 'FRequestQuestInfo::SubLevelName3' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, PhaseProgressList) == 0x000030, "Member 'FRequestQuestInfo::PhaseProgressList' has a wrong offset!");
static_assert(offsetof(FRequestQuestInfo, bIsReceiveCancel) == 0x000040, "Member 'FRequestQuestInfo::bIsReceiveCancel' has a wrong offset!");

// ScriptStruct AT.CookingSequenceResourceName
// 0x0018 (0x0020 - 0x0008)
struct FCookingSequenceResourceName final : public FTableRowBase
{
public:
	class FName                                   C001SequenceResourceName;                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   C002CSequenceResourceName;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   C002DSequenceResourceName;                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingSequenceResourceName) == 0x000008, "Wrong alignment on FCookingSequenceResourceName");
static_assert(sizeof(FCookingSequenceResourceName) == 0x000020, "Wrong size on FCookingSequenceResourceName");
static_assert(offsetof(FCookingSequenceResourceName, C001SequenceResourceName) == 0x000008, "Member 'FCookingSequenceResourceName::C001SequenceResourceName' has a wrong offset!");
static_assert(offsetof(FCookingSequenceResourceName, C002CSequenceResourceName) == 0x000010, "Member 'FCookingSequenceResourceName::C002CSequenceResourceName' has a wrong offset!");
static_assert(offsetof(FCookingSequenceResourceName, C002DSequenceResourceName) == 0x000018, "Member 'FCookingSequenceResourceName::C002DSequenceResourceName' has a wrong offset!");

// ScriptStruct AT.LoadProgress
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLoadProgress final
{
public:
	class FName                                   ExtendProgressIdBegin;                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtendProgressIdEnd;                               // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadProgress) == 0x000008, "Wrong alignment on FLoadProgress");
static_assert(sizeof(FLoadProgress) == 0x000010, "Wrong size on FLoadProgress");
static_assert(offsetof(FLoadProgress, ExtendProgressIdBegin) == 0x000000, "Member 'FLoadProgress::ExtendProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FLoadProgress, ExtendProgressIdEnd) == 0x000008, "Member 'FLoadProgress::ExtendProgressIdEnd' has a wrong offset!");

// ScriptStruct AT.LoadProgressDataForWidgets
// 0x0038 (0x0038 - 0x0000)
struct FLoadProgressDataForWidgets final
{
public:
	TSoftClassPtr<class UClass>                   Widget;                                            // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLoadProgress>                  ExtendLoadProgresses;                              // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadProgressDataForWidgets) == 0x000008, "Wrong alignment on FLoadProgressDataForWidgets");
static_assert(sizeof(FLoadProgressDataForWidgets) == 0x000038, "Wrong size on FLoadProgressDataForWidgets");
static_assert(offsetof(FLoadProgressDataForWidgets, Widget) == 0x000000, "Member 'FLoadProgressDataForWidgets::Widget' has a wrong offset!");
static_assert(offsetof(FLoadProgressDataForWidgets, ExtendLoadProgresses) == 0x000028, "Member 'FLoadProgressDataForWidgets::ExtendLoadProgresses' has a wrong offset!");

// ScriptStruct AT.BattleWidgetData
// 0x0070 (0x0070 - 0x0000)
struct FBattleWidgetData final
{
public:
	struct FLoadProgressDataForWidgets            BattleCountQTE;                                    // 0x0000(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLoadProgressDataForWidgets            MashQTE;                                           // 0x0038(0x0038)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleWidgetData) == 0x000008, "Wrong alignment on FBattleWidgetData");
static_assert(sizeof(FBattleWidgetData) == 0x000070, "Wrong size on FBattleWidgetData");
static_assert(offsetof(FBattleWidgetData, BattleCountQTE) == 0x000000, "Member 'FBattleWidgetData::BattleCountQTE' has a wrong offset!");
static_assert(offsetof(FBattleWidgetData, MashQTE) == 0x000038, "Member 'FBattleWidgetData::MashQTE' has a wrong offset!");

// ScriptStruct AT.ATWindRoadPointParamChangeSpeed
// 0x000C (0x000C - 0x0000)
struct FATWindRoadPointParamChangeSpeed final
{
public:
	bool                                          bApply;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedRate;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedRateInterp;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWindRoadPointParamChangeSpeed) == 0x000004, "Wrong alignment on FATWindRoadPointParamChangeSpeed");
static_assert(sizeof(FATWindRoadPointParamChangeSpeed) == 0x00000C, "Wrong size on FATWindRoadPointParamChangeSpeed");
static_assert(offsetof(FATWindRoadPointParamChangeSpeed, bApply) == 0x000000, "Member 'FATWindRoadPointParamChangeSpeed::bApply' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamChangeSpeed, SpeedRate) == 0x000004, "Member 'FATWindRoadPointParamChangeSpeed::SpeedRate' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamChangeSpeed, SpeedRateInterp) == 0x000008, "Member 'FATWindRoadPointParamChangeSpeed::SpeedRateInterp' has a wrong offset!");

// ScriptStruct AT.ReferenceToSoundAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToSoundAssetInstance final
{
public:
	class USoundAtomCueSheet*                     Sheet;                                             // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToSoundAssetInstance) == 0x000008, "Wrong alignment on FReferenceToSoundAssetInstance");
static_assert(sizeof(FReferenceToSoundAssetInstance) == 0x000008, "Wrong size on FReferenceToSoundAssetInstance");
static_assert(offsetof(FReferenceToSoundAssetInstance, Sheet) == 0x000000, "Member 'FReferenceToSoundAssetInstance::Sheet' has a wrong offset!");

// ScriptStruct AT.ATCharacterBuff
// 0x00E8 (0x00E8 - 0x0000)
struct FATCharacterBuff final
{
public:
	ECharacterBuffCalcuration                     BuffCalc;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterBuffCondition                       BuffCondition;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<E_STATE_ICON_TYPE>                     IconList;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ECharacterBuffEffect                          EffectType;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectValue1;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectValue2;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EffectValueName;                                   // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FATCharacterStatus                     Status;                                            // 0x0030(0x0078)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ItemDropRate;                                      // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemDropNum;                                       // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExpRate;                                           // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZOrbNumRate;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FATCharacterBuffParticle               Particle;                                          // 0x00C0(0x0020)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESndCodeBattle                                LoopSe;                                            // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ECharacterDeBuffType                          DebuffType;                                        // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterBuff) == 0x000008, "Wrong alignment on FATCharacterBuff");
static_assert(sizeof(FATCharacterBuff) == 0x0000E8, "Wrong size on FATCharacterBuff");
static_assert(offsetof(FATCharacterBuff, BuffCalc) == 0x000000, "Member 'FATCharacterBuff::BuffCalc' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, BuffCondition) == 0x000004, "Member 'FATCharacterBuff::BuffCondition' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, IconList) == 0x000008, "Member 'FATCharacterBuff::IconList' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, EffectType) == 0x000018, "Member 'FATCharacterBuff::EffectType' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, EffectValue1) == 0x00001C, "Member 'FATCharacterBuff::EffectValue1' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, EffectValue2) == 0x000020, "Member 'FATCharacterBuff::EffectValue2' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, EffectValueName) == 0x000028, "Member 'FATCharacterBuff::EffectValueName' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, Status) == 0x000030, "Member 'FATCharacterBuff::Status' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, ItemDropRate) == 0x0000A8, "Member 'FATCharacterBuff::ItemDropRate' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, ItemDropNum) == 0x0000AC, "Member 'FATCharacterBuff::ItemDropNum' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, ExpRate) == 0x0000B0, "Member 'FATCharacterBuff::ExpRate' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, ZOrbNumRate) == 0x0000B4, "Member 'FATCharacterBuff::ZOrbNumRate' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, Time) == 0x0000B8, "Member 'FATCharacterBuff::Time' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, Particle) == 0x0000C0, "Member 'FATCharacterBuff::Particle' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, LoopSe) == 0x0000E0, "Member 'FATCharacterBuff::LoopSe' has a wrong offset!");
static_assert(offsetof(FATCharacterBuff, DebuffType) == 0x0000E4, "Member 'FATCharacterBuff::DebuffType' has a wrong offset!");

// ScriptStruct AT.BattleTipsTutorialParam
// 0x0010 (0x0018 - 0x0008)
struct FBattleTipsTutorialParam final : public FTableRowBase
{
public:
	class FName                                   FunctionMsgId;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ButtonMsgId;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleTipsTutorialParam) == 0x000008, "Wrong alignment on FBattleTipsTutorialParam");
static_assert(sizeof(FBattleTipsTutorialParam) == 0x000018, "Wrong size on FBattleTipsTutorialParam");
static_assert(offsetof(FBattleTipsTutorialParam, FunctionMsgId) == 0x000008, "Member 'FBattleTipsTutorialParam::FunctionMsgId' has a wrong offset!");
static_assert(offsetof(FBattleTipsTutorialParam, ButtonMsgId) == 0x000010, "Member 'FBattleTipsTutorialParam::ButtonMsgId' has a wrong offset!");

// ScriptStruct AT.NpcSplineSpawnInfo
// 0x0010 (0x0010 - 0x0000)
struct FNpcSplineSpawnInfo final
{
public:
	TArray<class AActor*>                         Mob;                                               // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcSplineSpawnInfo) == 0x000008, "Wrong alignment on FNpcSplineSpawnInfo");
static_assert(sizeof(FNpcSplineSpawnInfo) == 0x000010, "Wrong size on FNpcSplineSpawnInfo");
static_assert(offsetof(FNpcSplineSpawnInfo, Mob) == 0x000000, "Member 'FNpcSplineSpawnInfo::Mob' has a wrong offset!");

// ScriptStruct AT.SubjugationSendInfo
// 0x0018 (0x0020 - 0x0008)
struct FSubjugationSendInfo final : public FTableRowBase
{
public:
	class FString                                 ItemStringID;                                      // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               IconType;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubjugationSendInfo) == 0x000008, "Wrong alignment on FSubjugationSendInfo");
static_assert(sizeof(FSubjugationSendInfo) == 0x000020, "Wrong size on FSubjugationSendInfo");
static_assert(offsetof(FSubjugationSendInfo, ItemStringID) == 0x000008, "Member 'FSubjugationSendInfo::ItemStringID' has a wrong offset!");
static_assert(offsetof(FSubjugationSendInfo, IconType) == 0x000018, "Member 'FSubjugationSendInfo::IconType' has a wrong offset!");

// ScriptStruct AT.HitPhotonHistory
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FHitPhotonHistory final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitPhotonHistory) == 0x000004, "Wrong alignment on FHitPhotonHistory");
static_assert(sizeof(FHitPhotonHistory) == 0x00001C, "Wrong size on FHitPhotonHistory");

// ScriptStruct AT.ResultCountInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FResultCountInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResultCountInfo) == 0x000008, "Wrong alignment on FResultCountInfo");
static_assert(sizeof(FResultCountInfo) == 0x000018, "Wrong size on FResultCountInfo");

// ScriptStruct AT.LoadingTipsTableRow
// 0x0030 (0x0038 - 0x0008)
struct FLoadingTipsTableRow final : public FTableRowBase
{
public:
	int32                                         MinChapterNumber;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinEpisodeNumber;                                  // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxChapterNumber;                                  // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxEpisodeNumber;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TipsTitleMessageId;                                // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TipsDetailMessageId;                               // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingTipsTableRow) == 0x000008, "Wrong alignment on FLoadingTipsTableRow");
static_assert(sizeof(FLoadingTipsTableRow) == 0x000038, "Wrong size on FLoadingTipsTableRow");
static_assert(offsetof(FLoadingTipsTableRow, MinChapterNumber) == 0x000008, "Member 'FLoadingTipsTableRow::MinChapterNumber' has a wrong offset!");
static_assert(offsetof(FLoadingTipsTableRow, MinEpisodeNumber) == 0x00000C, "Member 'FLoadingTipsTableRow::MinEpisodeNumber' has a wrong offset!");
static_assert(offsetof(FLoadingTipsTableRow, MaxChapterNumber) == 0x000010, "Member 'FLoadingTipsTableRow::MaxChapterNumber' has a wrong offset!");
static_assert(offsetof(FLoadingTipsTableRow, MaxEpisodeNumber) == 0x000014, "Member 'FLoadingTipsTableRow::MaxEpisodeNumber' has a wrong offset!");
static_assert(offsetof(FLoadingTipsTableRow, TipsTitleMessageId) == 0x000018, "Member 'FLoadingTipsTableRow::TipsTitleMessageId' has a wrong offset!");
static_assert(offsetof(FLoadingTipsTableRow, TipsDetailMessageId) == 0x000028, "Member 'FLoadingTipsTableRow::TipsDetailMessageId' has a wrong offset!");

// ScriptStruct AT.QuestProgressTextureTableRow
// 0x0040 (0x0048 - 0x0008)
struct FQuestProgressTextureTableRow final : public FTableRowBase
{
public:
	class FName                                   QuestId;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestPhaseId;                                      // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TextureId;                                         // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummaryMsgId;                                      // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DlcId;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeerusTransition;                                 // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestProgressTextureTableRow) == 0x000008, "Wrong alignment on FQuestProgressTextureTableRow");
static_assert(sizeof(FQuestProgressTextureTableRow) == 0x000048, "Wrong size on FQuestProgressTextureTableRow");
static_assert(offsetof(FQuestProgressTextureTableRow, QuestId) == 0x000008, "Member 'FQuestProgressTextureTableRow::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestProgressTextureTableRow, QuestPhaseId) == 0x000010, "Member 'FQuestProgressTextureTableRow::QuestPhaseId' has a wrong offset!");
static_assert(offsetof(FQuestProgressTextureTableRow, TextureId) == 0x000018, "Member 'FQuestProgressTextureTableRow::TextureId' has a wrong offset!");
static_assert(offsetof(FQuestProgressTextureTableRow, SummaryMsgId) == 0x000028, "Member 'FQuestProgressTextureTableRow::SummaryMsgId' has a wrong offset!");
static_assert(offsetof(FQuestProgressTextureTableRow, DlcId) == 0x000038, "Member 'FQuestProgressTextureTableRow::DlcId' has a wrong offset!");
static_assert(offsetof(FQuestProgressTextureTableRow, bBeerusTransition) == 0x000040, "Member 'FQuestProgressTextureTableRow::bBeerusTransition' has a wrong offset!");

// ScriptStruct AT.XlistBar04Info
// 0x0058 (0x0058 - 0x0000)
struct FXlistBar04Info final
{
public:
	EXlistBar04InfoMode                           Mode;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Price;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         basePrice;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanPurchese;                                      // 0x003C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumberOfSold;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfPossession;                                // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfStocks;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShopMode                                     ShopMode;                                          // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rarity;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConsumable;                                     // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXlistBar04Info) == 0x000008, "Wrong alignment on FXlistBar04Info");
static_assert(sizeof(FXlistBar04Info) == 0x000058, "Wrong size on FXlistBar04Info");
static_assert(offsetof(FXlistBar04Info, Mode) == 0x000000, "Member 'FXlistBar04Info::Mode' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, ItemId) == 0x000008, "Member 'FXlistBar04Info::ItemId' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, Name) == 0x000010, "Member 'FXlistBar04Info::Name' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, Description) == 0x000020, "Member 'FXlistBar04Info::Description' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, Type) == 0x000030, "Member 'FXlistBar04Info::Type' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, IsNew) == 0x000031, "Member 'FXlistBar04Info::IsNew' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, Price) == 0x000034, "Member 'FXlistBar04Info::Price' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, basePrice) == 0x000038, "Member 'FXlistBar04Info::basePrice' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, bCanPurchese) == 0x00003C, "Member 'FXlistBar04Info::bCanPurchese' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, NumberOfSold) == 0x000040, "Member 'FXlistBar04Info::NumberOfSold' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, NumberOfPossession) == 0x000044, "Member 'FXlistBar04Info::NumberOfPossession' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, NumberOfStocks) == 0x000048, "Member 'FXlistBar04Info::NumberOfStocks' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, ShopMode) == 0x00004C, "Member 'FXlistBar04Info::ShopMode' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, Rarity) == 0x000050, "Member 'FXlistBar04Info::Rarity' has a wrong offset!");
static_assert(offsetof(FXlistBar04Info, bIsConsumable) == 0x000054, "Member 'FXlistBar04Info::bIsConsumable' has a wrong offset!");

// ScriptStruct AT.QuestEventBattleTable
// 0x0048 (0x0050 - 0x0008)
struct FQuestEventBattleTable final : public FTableRowBase
{
public:
	class FName                                   QuestId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Episode;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Part;                                              // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ResultMsgId;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResultMsgId_Override_var_1;                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResultMsgId_Override_var_2;                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               MainCharacter;                                     // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBossBattle;                                      // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDesignatedQuestTypeForEpisodeBattle          DesignatedQuestType;                               // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InvolvedSubQuestId;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Comment;                                           // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestEventBattleTable) == 0x000008, "Wrong alignment on FQuestEventBattleTable");
static_assert(sizeof(FQuestEventBattleTable) == 0x000050, "Wrong size on FQuestEventBattleTable");
static_assert(offsetof(FQuestEventBattleTable, QuestId) == 0x000008, "Member 'FQuestEventBattleTable::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, Episode) == 0x000010, "Member 'FQuestEventBattleTable::Episode' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, Chapter) == 0x000014, "Member 'FQuestEventBattleTable::Chapter' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, Part) == 0x000018, "Member 'FQuestEventBattleTable::Part' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, ResultMsgId) == 0x000020, "Member 'FQuestEventBattleTable::ResultMsgId' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, ResultMsgId_Override_var_1) == 0x000028, "Member 'FQuestEventBattleTable::ResultMsgId_Override_var_1' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, ResultMsgId_Override_var_2) == 0x000030, "Member 'FQuestEventBattleTable::ResultMsgId_Override_var_2' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, MainCharacter) == 0x000038, "Member 'FQuestEventBattleTable::MainCharacter' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, IsBossBattle) == 0x000039, "Member 'FQuestEventBattleTable::IsBossBattle' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, DesignatedQuestType) == 0x00003A, "Member 'FQuestEventBattleTable::DesignatedQuestType' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, InvolvedSubQuestId) == 0x000040, "Member 'FQuestEventBattleTable::InvolvedSubQuestId' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleTable, Comment) == 0x000048, "Member 'FQuestEventBattleTable::Comment' has a wrong offset!");

// ScriptStruct AT.CmnTabIconParam
// 0x0002 (0x0002 - 0x0000)
struct FCmnTabIconParam final
{
public:
	EITEM_ICON_CATEGORY_TYPE                      CmnIconType;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnable;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCmnTabIconParam) == 0x000001, "Wrong alignment on FCmnTabIconParam");
static_assert(sizeof(FCmnTabIconParam) == 0x000002, "Wrong size on FCmnTabIconParam");
static_assert(offsetof(FCmnTabIconParam, CmnIconType) == 0x000000, "Member 'FCmnTabIconParam::CmnIconType' has a wrong offset!");
static_assert(offsetof(FCmnTabIconParam, bIsEnable) == 0x000001, "Member 'FCmnTabIconParam::bIsEnable' has a wrong offset!");

// ScriptStruct AT.SpecialNameForLongAttack
// 0x0018 (0x0020 - 0x0008)
struct FSpecialNameForLongAttack final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MessageId;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpecialNameForLongAttack) == 0x000008, "Wrong alignment on FSpecialNameForLongAttack");
static_assert(sizeof(FSpecialNameForLongAttack) == 0x000020, "Wrong size on FSpecialNameForLongAttack");
static_assert(offsetof(FSpecialNameForLongAttack, CharacterType) == 0x000008, "Member 'FSpecialNameForLongAttack::CharacterType' has a wrong offset!");
static_assert(offsetof(FSpecialNameForLongAttack, MessageId) == 0x000010, "Member 'FSpecialNameForLongAttack::MessageId' has a wrong offset!");

// ScriptStruct AT.SkillActionData
// 0x0030 (0x0030 - 0x0000)
struct FSkillActionData final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClassTable;                                  // 0x0008(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillActionData) == 0x000008, "Wrong alignment on FSkillActionData");
static_assert(sizeof(FSkillActionData) == 0x000030, "Wrong size on FSkillActionData");
static_assert(offsetof(FSkillActionData, ID) == 0x000000, "Member 'FSkillActionData::ID' has a wrong offset!");
static_assert(offsetof(FSkillActionData, ActionClassTable) == 0x000008, "Member 'FSkillActionData::ActionClassTable' has a wrong offset!");

// ScriptStruct AT.TrainingDetailTaskData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FTrainingDetailTaskData final
{
public:
	uint8                                         Pad_0[0x70];                                       // 0x0000(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrainingDetailTaskData) == 0x000008, "Wrong alignment on FTrainingDetailTaskData");
static_assert(sizeof(FTrainingDetailTaskData) == 0x000070, "Wrong size on FTrainingDetailTaskData");

// ScriptStruct AT.CommandPaletteItem
// 0x002C (0x0030 - 0x0004)
struct FCommandPaletteItem final : public FCommandPaletteBase
{
public:
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId;                                            // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandPaletteItem) == 0x000008, "Wrong alignment on FCommandPaletteItem");
static_assert(sizeof(FCommandPaletteItem) == 0x000030, "Wrong size on FCommandPaletteItem");
static_assert(offsetof(FCommandPaletteItem, ItemName) == 0x000010, "Member 'FCommandPaletteItem::ItemName' has a wrong offset!");
static_assert(offsetof(FCommandPaletteItem, ItemId) == 0x000020, "Member 'FCommandPaletteItem::ItemId' has a wrong offset!");

// ScriptStruct AT.CommandPaletteSupport
// 0x007C (0x0080 - 0x0004)
struct FCommandPaletteSupport final : public FCommandPaletteBase
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             CharIcon;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20[0x60];                                      // 0x0020(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandPaletteSupport) == 0x000008, "Wrong alignment on FCommandPaletteSupport");
static_assert(sizeof(FCommandPaletteSupport) == 0x000080, "Wrong size on FCommandPaletteSupport");
static_assert(offsetof(FCommandPaletteSupport, CharIcon) == 0x000008, "Member 'FCommandPaletteSupport::CharIcon' has a wrong offset!");
static_assert(offsetof(FCommandPaletteSupport, CharName) == 0x000010, "Member 'FCommandPaletteSupport::CharName' has a wrong offset!");

// ScriptStruct AT.CharacterMontage
// 0x0010 (0x0010 - 0x0000)
struct FCharacterMontage final
{
public:
	class FName                                   MontageId;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterMontage) == 0x000008, "Wrong alignment on FCharacterMontage");
static_assert(sizeof(FCharacterMontage) == 0x000010, "Wrong size on FCharacterMontage");
static_assert(offsetof(FCharacterMontage, MontageId) == 0x000000, "Member 'FCharacterMontage::MontageId' has a wrong offset!");
static_assert(offsetof(FCharacterMontage, Montage) == 0x000008, "Member 'FCharacterMontage::Montage' has a wrong offset!");

// ScriptStruct AT.StateIconInfo
// 0x0010 (0x0010 - 0x0000)
struct FStateIconInfo final
{
public:
	E_STATE_ICON_TYPE                             IconType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BuffTimeSec;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftBuffTimeSec;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIconActive;                                       // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewFlg;                                           // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStateIconInfo) == 0x000004, "Wrong alignment on FStateIconInfo");
static_assert(sizeof(FStateIconInfo) == 0x000010, "Wrong size on FStateIconInfo");
static_assert(offsetof(FStateIconInfo, IconType) == 0x000000, "Member 'FStateIconInfo::IconType' has a wrong offset!");
static_assert(offsetof(FStateIconInfo, BuffTimeSec) == 0x000004, "Member 'FStateIconInfo::BuffTimeSec' has a wrong offset!");
static_assert(offsetof(FStateIconInfo, LeftBuffTimeSec) == 0x000008, "Member 'FStateIconInfo::LeftBuffTimeSec' has a wrong offset!");
static_assert(offsetof(FStateIconInfo, bIconActive) == 0x00000C, "Member 'FStateIconInfo::bIconActive' has a wrong offset!");
static_assert(offsetof(FStateIconInfo, bNewFlg) == 0x00000D, "Member 'FStateIconInfo::bNewFlg' has a wrong offset!");

// ScriptStruct AT.BonfireFacialTable
// 0x0030 (0x0038 - 0x0008)
struct FBonfireFacialTable final : public FTableRowBase
{
public:
	class FName                                   CharacterID;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FacialMontage;                                     // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBonfireFacialTable) == 0x000008, "Wrong alignment on FBonfireFacialTable");
static_assert(sizeof(FBonfireFacialTable) == 0x000038, "Wrong size on FBonfireFacialTable");
static_assert(offsetof(FBonfireFacialTable, CharacterID) == 0x000008, "Member 'FBonfireFacialTable::CharacterID' has a wrong offset!");
static_assert(offsetof(FBonfireFacialTable, FacialMontage) == 0x000010, "Member 'FBonfireFacialTable::FacialMontage' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamCarddass
// 0x0010 (0x0030 - 0x0020)
struct FZCompworksParamCarddass final : public FZCompworksParamBase
{
public:
	class FName                                   ItemId;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZCompworksUIDataType                         UIDataType;                                        // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksParamCarddass) == 0x000008, "Wrong alignment on FZCompworksParamCarddass");
static_assert(sizeof(FZCompworksParamCarddass) == 0x000030, "Wrong size on FZCompworksParamCarddass");
static_assert(offsetof(FZCompworksParamCarddass, ItemId) == 0x000020, "Member 'FZCompworksParamCarddass::ItemId' has a wrong offset!");
static_assert(offsetof(FZCompworksParamCarddass, UIDataType) == 0x000028, "Member 'FZCompworksParamCarddass::UIDataType' has a wrong offset!");

// ScriptStruct AT.CommandPaletteSupportSkill
// 0x002C (0x0030 - 0x0004)
struct FCommandPaletteSupportSkill final : public FCommandPaletteBase
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillId;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillAttribute                               SkillAttr;                                         // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SkillName;                                         // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCommandPaletteSupportSkill) == 0x000008, "Wrong alignment on FCommandPaletteSupportSkill");
static_assert(sizeof(FCommandPaletteSupportSkill) == 0x000030, "Wrong size on FCommandPaletteSupportSkill");
static_assert(offsetof(FCommandPaletteSupportSkill, SkillId) == 0x000008, "Member 'FCommandPaletteSupportSkill::SkillId' has a wrong offset!");
static_assert(offsetof(FCommandPaletteSupportSkill, SkillAttr) == 0x000010, "Member 'FCommandPaletteSupportSkill::SkillAttr' has a wrong offset!");
static_assert(offsetof(FCommandPaletteSupportSkill, SkillName) == 0x000018, "Member 'FCommandPaletteSupportSkill::SkillName' has a wrong offset!");

// ScriptStruct AT.CommandPaletteRoot
// 0x0014 (0x0018 - 0x0004)
struct FCommandPaletteRoot final : public FCommandPaletteBase
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CommandText;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCommandPaletteRoot) == 0x000008, "Wrong alignment on FCommandPaletteRoot");
static_assert(sizeof(FCommandPaletteRoot) == 0x000018, "Wrong size on FCommandPaletteRoot");
static_assert(offsetof(FCommandPaletteRoot, CommandText) == 0x000008, "Member 'FCommandPaletteRoot::CommandText' has a wrong offset!");

// ScriptStruct AT.SupportCharacterIconData
// 0x0020 (0x0020 - 0x0000)
struct FSupportCharacterIconData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportCharacterIconData) == 0x000008, "Wrong alignment on FSupportCharacterIconData");
static_assert(sizeof(FSupportCharacterIconData) == 0x000020, "Wrong size on FSupportCharacterIconData");
static_assert(offsetof(FSupportCharacterIconData, Icon) == 0x000018, "Member 'FSupportCharacterIconData::Icon' has a wrong offset!");

// ScriptStruct AT.BattleBarrierParam
// 0x0014 (0x0014 - 0x0000)
struct FBattleBarrierParam final
{
public:
	float                                         BarrierRadius;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierHeight;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierMoveUpRange;                                // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierMoveDownRange;                              // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierLimitOffset;                                // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleBarrierParam) == 0x000004, "Wrong alignment on FBattleBarrierParam");
static_assert(sizeof(FBattleBarrierParam) == 0x000014, "Wrong size on FBattleBarrierParam");
static_assert(offsetof(FBattleBarrierParam, BarrierRadius) == 0x000000, "Member 'FBattleBarrierParam::BarrierRadius' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParam, BarrierHeight) == 0x000004, "Member 'FBattleBarrierParam::BarrierHeight' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParam, BarrierMoveUpRange) == 0x000008, "Member 'FBattleBarrierParam::BarrierMoveUpRange' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParam, BarrierMoveDownRange) == 0x00000C, "Member 'FBattleBarrierParam::BarrierMoveDownRange' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParam, BarrierLimitOffset) == 0x000010, "Member 'FBattleBarrierParam::BarrierLimitOffset' has a wrong offset!");

// ScriptStruct AT.CharacterResourceInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCharacterResourceInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterResourceInfo) == 0x000008, "Wrong alignment on FCharacterResourceInfo");
static_assert(sizeof(FCharacterResourceInfo) == 0x000020, "Wrong size on FCharacterResourceInfo");

// ScriptStruct AT.LinkPanelInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLinkPanelInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLinkPanelInfo) == 0x000008, "Wrong alignment on FLinkPanelInfo");
static_assert(sizeof(FLinkPanelInfo) == 0x000010, "Wrong size on FLinkPanelInfo");

// ScriptStruct AT.ATWindRoadEnterParam
// 0x0001 (0x0001 - 0x0000)
struct FATWindRoadEnterParam final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATWindRoadEnterParam) == 0x000001, "Wrong alignment on FATWindRoadEnterParam");
static_assert(sizeof(FATWindRoadEnterParam) == 0x000001, "Wrong size on FATWindRoadEnterParam");

// ScriptStruct AT.LinkBonusVoice
// 0x0060 (0x0068 - 0x0008)
struct FLinkBonusVoice final : public FTableRowBase
{
public:
	class FName                                   JName;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ProgressCheck;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MsgId_1;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_2;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_3;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_4;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_5;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_6;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_7;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_8;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_9;                                           // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_10;                                          // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinkBonusVoice) == 0x000008, "Wrong alignment on FLinkBonusVoice");
static_assert(sizeof(FLinkBonusVoice) == 0x000068, "Wrong size on FLinkBonusVoice");
static_assert(offsetof(FLinkBonusVoice, JName) == 0x000008, "Member 'FLinkBonusVoice::JName' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, ProgressCheck) == 0x000010, "Member 'FLinkBonusVoice::ProgressCheck' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_1) == 0x000018, "Member 'FLinkBonusVoice::MsgId_1' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_2) == 0x000020, "Member 'FLinkBonusVoice::MsgId_2' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_3) == 0x000028, "Member 'FLinkBonusVoice::MsgId_3' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_4) == 0x000030, "Member 'FLinkBonusVoice::MsgId_4' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_5) == 0x000038, "Member 'FLinkBonusVoice::MsgId_5' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_6) == 0x000040, "Member 'FLinkBonusVoice::MsgId_6' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_7) == 0x000048, "Member 'FLinkBonusVoice::MsgId_7' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_8) == 0x000050, "Member 'FLinkBonusVoice::MsgId_8' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_9) == 0x000058, "Member 'FLinkBonusVoice::MsgId_9' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoice, MsgId_10) == 0x000060, "Member 'FLinkBonusVoice::MsgId_10' has a wrong offset!");

// ScriptStruct AT.DTOfflinePracticeOpponentParam
// 0x0070 (0x0078 - 0x0008)
struct FDTOfflinePracticeOpponentParam final : public FTableRowBase
{
public:
	int32                                         PracticeNo;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PracticeUserId;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PlayerName;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeaderIconId;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DifficultyCategory;                                // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Difficulty;                                        // 0x0025(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AILevel;                                           // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AIPreset;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AIPresetOverride;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SleeveId;                                          // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FieldId;                                           // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstTitleId;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondTitleId;                                     // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Comment;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeaderHP;                                          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StarDifficulty;                                    // 0x005C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnlocked;                                       // 0x005D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FirstReward;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleReward;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RandomReward;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDTOfflinePracticeOpponentParam) == 0x000008, "Wrong alignment on FDTOfflinePracticeOpponentParam");
static_assert(sizeof(FDTOfflinePracticeOpponentParam) == 0x000078, "Wrong size on FDTOfflinePracticeOpponentParam");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, PracticeNo) == 0x000008, "Member 'FDTOfflinePracticeOpponentParam::PracticeNo' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, PracticeUserId) == 0x000010, "Member 'FDTOfflinePracticeOpponentParam::PracticeUserId' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, PlayerName) == 0x000018, "Member 'FDTOfflinePracticeOpponentParam::PlayerName' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, LeaderIconId) == 0x000020, "Member 'FDTOfflinePracticeOpponentParam::LeaderIconId' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, DifficultyCategory) == 0x000024, "Member 'FDTOfflinePracticeOpponentParam::DifficultyCategory' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, Difficulty) == 0x000025, "Member 'FDTOfflinePracticeOpponentParam::Difficulty' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, AILevel) == 0x000028, "Member 'FDTOfflinePracticeOpponentParam::AILevel' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, AIPreset) == 0x000030, "Member 'FDTOfflinePracticeOpponentParam::AIPreset' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, AIPresetOverride) == 0x000038, "Member 'FDTOfflinePracticeOpponentParam::AIPresetOverride' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, SleeveId) == 0x000040, "Member 'FDTOfflinePracticeOpponentParam::SleeveId' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, FieldId) == 0x000044, "Member 'FDTOfflinePracticeOpponentParam::FieldId' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, FirstTitleId) == 0x000048, "Member 'FDTOfflinePracticeOpponentParam::FirstTitleId' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, SecondTitleId) == 0x00004C, "Member 'FDTOfflinePracticeOpponentParam::SecondTitleId' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, Comment) == 0x000050, "Member 'FDTOfflinePracticeOpponentParam::Comment' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, LeaderHP) == 0x000058, "Member 'FDTOfflinePracticeOpponentParam::LeaderHP' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, StarDifficulty) == 0x00005C, "Member 'FDTOfflinePracticeOpponentParam::StarDifficulty' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, bIsUnlocked) == 0x00005D, "Member 'FDTOfflinePracticeOpponentParam::bIsUnlocked' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, FirstReward) == 0x000060, "Member 'FDTOfflinePracticeOpponentParam::FirstReward' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, BattleReward) == 0x000068, "Member 'FDTOfflinePracticeOpponentParam::BattleReward' has a wrong offset!");
static_assert(offsetof(FDTOfflinePracticeOpponentParam, RandomReward) == 0x000070, "Member 'FDTOfflinePracticeOpponentParam::RandomReward' has a wrong offset!");

// ScriptStruct AT.CreditDetail
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCreditDetail final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCreditDetail) == 0x000008, "Wrong alignment on FCreditDetail");
static_assert(sizeof(FCreditDetail) == 0x000020, "Wrong size on FCreditDetail");

// ScriptStruct AT.DTIconTextureParam
// 0x0018 (0x0020 - 0x0008)
struct FDTIconTextureParam final : public FTableRowBase
{
public:
	struct FSoftObjectPath                        IconImagePath;                                     // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDTIconTextureParam) == 0x000008, "Wrong alignment on FDTIconTextureParam");
static_assert(sizeof(FDTIconTextureParam) == 0x000020, "Wrong size on FDTIconTextureParam");
static_assert(offsetof(FDTIconTextureParam, IconImagePath) == 0x000008, "Member 'FDTIconTextureParam::IconImagePath' has a wrong offset!");

// ScriptStruct AT.NpcSoundInfo
// 0x0010 (0x0010 - 0x0000)
struct FNpcSoundInfo final
{
public:
	ENpcState                                     PlayState;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayRange;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayIntervalTime;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcSoundInfo) == 0x000004, "Wrong alignment on FNpcSoundInfo");
static_assert(sizeof(FNpcSoundInfo) == 0x000010, "Wrong size on FNpcSoundInfo");
static_assert(offsetof(FNpcSoundInfo, PlayState) == 0x000000, "Member 'FNpcSoundInfo::PlayState' has a wrong offset!");
static_assert(offsetof(FNpcSoundInfo, PlayRange) == 0x000004, "Member 'FNpcSoundInfo::PlayRange' has a wrong offset!");
static_assert(offsetof(FNpcSoundInfo, PlayIntervalTime) == 0x000008, "Member 'FNpcSoundInfo::PlayIntervalTime' has a wrong offset!");

// ScriptStruct AT.AT_UICompZListParam
// 0x0030 (0x0030 - 0x0000)
struct FAT_UICompZListParam final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemLabel;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemMax;                                           // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IconType;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpen;                                            // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsClosedOpen;                                      // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x002E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_UICompZListParam) == 0x000008, "Wrong alignment on FAT_UICompZListParam");
static_assert(sizeof(FAT_UICompZListParam) == 0x000030, "Wrong size on FAT_UICompZListParam");
static_assert(offsetof(FAT_UICompZListParam, ItemId) == 0x000000, "Member 'FAT_UICompZListParam::ItemId' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, ItemName) == 0x000008, "Member 'FAT_UICompZListParam::ItemName' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, ItemLabel) == 0x000010, "Member 'FAT_UICompZListParam::ItemLabel' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, ItemNum) == 0x000020, "Member 'FAT_UICompZListParam::ItemNum' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, ItemMax) == 0x000024, "Member 'FAT_UICompZListParam::ItemMax' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, IconType) == 0x000028, "Member 'FAT_UICompZListParam::IconType' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, IsOpen) == 0x00002C, "Member 'FAT_UICompZListParam::IsOpen' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, IsClosedOpen) == 0x00002D, "Member 'FAT_UICompZListParam::IsClosedOpen' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListParam, IsNew) == 0x00002E, "Member 'FAT_UICompZListParam::IsNew' has a wrong offset!");

// ScriptStruct AT.AT_UICompZListBgmParam
// 0x0028 (0x0028 - 0x0000)
struct FAT_UICompZListBgmParam final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemLabel;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAppendix;                                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPlaying;                                         // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpen;                                            // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0023(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_UICompZListBgmParam) == 0x000008, "Wrong alignment on FAT_UICompZListBgmParam");
static_assert(sizeof(FAT_UICompZListBgmParam) == 0x000028, "Wrong size on FAT_UICompZListBgmParam");
static_assert(offsetof(FAT_UICompZListBgmParam, ItemId) == 0x000000, "Member 'FAT_UICompZListBgmParam::ItemId' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListBgmParam, ItemName) == 0x000008, "Member 'FAT_UICompZListBgmParam::ItemName' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListBgmParam, ItemLabel) == 0x000010, "Member 'FAT_UICompZListBgmParam::ItemLabel' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListBgmParam, IsAppendix) == 0x000020, "Member 'FAT_UICompZListBgmParam::IsAppendix' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListBgmParam, IsPlaying) == 0x000021, "Member 'FAT_UICompZListBgmParam::IsPlaying' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListBgmParam, IsOpen) == 0x000022, "Member 'FAT_UICompZListBgmParam::IsOpen' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListBgmParam, IsNew) == 0x000023, "Member 'FAT_UICompZListBgmParam::IsNew' has a wrong offset!");

// ScriptStruct AT.SkillMontageFormChangeCutinInfo
// 0x0010 (0x0010 - 0x0000)
struct FSkillMontageFormChangeCutinInfo final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillMontageFormChangeCutinInfo) == 0x000008, "Wrong alignment on FSkillMontageFormChangeCutinInfo");
static_assert(sizeof(FSkillMontageFormChangeCutinInfo) == 0x000010, "Wrong size on FSkillMontageFormChangeCutinInfo");
static_assert(offsetof(FSkillMontageFormChangeCutinInfo, FormChangeID) == 0x000000, "Member 'FSkillMontageFormChangeCutinInfo::FormChangeID' has a wrong offset!");
static_assert(offsetof(FSkillMontageFormChangeCutinInfo, Montage) == 0x000008, "Member 'FSkillMontageFormChangeCutinInfo::Montage' has a wrong offset!");

// ScriptStruct AT.SkillMontageInfo_GR
// 0x0078 (0x0078 - 0x0000)
struct FSkillMontageInfo_GR final
{
public:
	class UAnimMontage*                           WaitMontage;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitLoopTime;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitLoopTimeTargetDistance;                        // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitCancelNotPlayer;                               // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackMontage;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopTime;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopTimeSupportRatio;                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackLoopNum;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopDistance;                                // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackEndTime;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackCutinMontage;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkillMontageFormChangeCutinInfo> FormChangeCutinInfo;                               // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttackCutinTargetMontage;                          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttackCutinTargetMontageID;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttackCutinAdjustDestructObject;                   // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackFizzleFlag;                                  // 0x0061(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackFizzleMontage;                               // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroundMontage;                                    // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipEndState;                                      // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AttackHitNotChageState;                            // 0x0072(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillMontageInfo_GR) == 0x000008, "Wrong alignment on FSkillMontageInfo_GR");
static_assert(sizeof(FSkillMontageInfo_GR) == 0x000078, "Wrong size on FSkillMontageInfo_GR");
static_assert(offsetof(FSkillMontageInfo_GR, WaitMontage) == 0x000000, "Member 'FSkillMontageInfo_GR::WaitMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, WaitLoopTime) == 0x000008, "Member 'FSkillMontageInfo_GR::WaitLoopTime' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, WaitLoopTimeTargetDistance) == 0x00000C, "Member 'FSkillMontageInfo_GR::WaitLoopTimeTargetDistance' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, WaitCancelNotPlayer) == 0x000010, "Member 'FSkillMontageInfo_GR::WaitCancelNotPlayer' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackMontage) == 0x000018, "Member 'FSkillMontageInfo_GR::AttackMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackLoopTime) == 0x000020, "Member 'FSkillMontageInfo_GR::AttackLoopTime' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackLoopTimeSupportRatio) == 0x000024, "Member 'FSkillMontageInfo_GR::AttackLoopTimeSupportRatio' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackLoopNum) == 0x000028, "Member 'FSkillMontageInfo_GR::AttackLoopNum' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackLoopDistance) == 0x00002C, "Member 'FSkillMontageInfo_GR::AttackLoopDistance' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackEndTime) == 0x000030, "Member 'FSkillMontageInfo_GR::AttackEndTime' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackCutinMontage) == 0x000038, "Member 'FSkillMontageInfo_GR::AttackCutinMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, FormChangeCutinInfo) == 0x000040, "Member 'FSkillMontageInfo_GR::FormChangeCutinInfo' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackCutinTargetMontage) == 0x000050, "Member 'FSkillMontageInfo_GR::AttackCutinTargetMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackCutinTargetMontageID) == 0x000058, "Member 'FSkillMontageInfo_GR::AttackCutinTargetMontageID' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackCutinAdjustDestructObject) == 0x000060, "Member 'FSkillMontageInfo_GR::AttackCutinAdjustDestructObject' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackFizzleFlag) == 0x000061, "Member 'FSkillMontageInfo_GR::AttackFizzleFlag' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackFizzleMontage) == 0x000068, "Member 'FSkillMontageInfo_GR::AttackFizzleMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, bGroundMontage) == 0x000070, "Member 'FSkillMontageInfo_GR::bGroundMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, SkipEndState) == 0x000071, "Member 'FSkillMontageInfo_GR::SkipEndState' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo_GR, AttackHitNotChageState) == 0x000072, "Member 'FSkillMontageInfo_GR::AttackHitNotChageState' has a wrong offset!");

// ScriptStruct AT.AT_UICompZListCardWarriorParam
// 0x0020 (0x0020 - 0x0000)
struct FAT_UICompZListCardWarriorParam final
{
public:
	class FString                                 ItemIcon;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemLabel;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Victory;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StarDifficulty;                                    // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_UICompZListCardWarriorParam) == 0x000008, "Wrong alignment on FAT_UICompZListCardWarriorParam");
static_assert(sizeof(FAT_UICompZListCardWarriorParam) == 0x000020, "Wrong size on FAT_UICompZListCardWarriorParam");
static_assert(offsetof(FAT_UICompZListCardWarriorParam, ItemIcon) == 0x000000, "Member 'FAT_UICompZListCardWarriorParam::ItemIcon' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardWarriorParam, ItemLabel) == 0x000010, "Member 'FAT_UICompZListCardWarriorParam::ItemLabel' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardWarriorParam, Victory) == 0x000018, "Member 'FAT_UICompZListCardWarriorParam::Victory' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardWarriorParam, StarDifficulty) == 0x00001C, "Member 'FAT_UICompZListCardWarriorParam::StarDifficulty' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardWarriorParam, bIsNew) == 0x00001D, "Member 'FAT_UICompZListCardWarriorParam::bIsNew' has a wrong offset!");

// ScriptStruct AT.NpcFightingPowerParam
// 0x0030 (0x0038 - 0x0008)
struct FNpcFightingPowerParam final : public FTableRowBase
{
public:
	class FName                                   CharaId;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartQuestId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcFightingPowerType                         Type;                                              // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Power;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcFightingPowerParam) == 0x000008, "Wrong alignment on FNpcFightingPowerParam");
static_assert(sizeof(FNpcFightingPowerParam) == 0x000038, "Wrong size on FNpcFightingPowerParam");
static_assert(offsetof(FNpcFightingPowerParam, CharaId) == 0x000008, "Member 'FNpcFightingPowerParam::CharaId' has a wrong offset!");
static_assert(offsetof(FNpcFightingPowerParam, StartQuestId) == 0x000010, "Member 'FNpcFightingPowerParam::StartQuestId' has a wrong offset!");
static_assert(offsetof(FNpcFightingPowerParam, StartPhaseNo) == 0x000018, "Member 'FNpcFightingPowerParam::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FNpcFightingPowerParam, EndQuestId) == 0x000020, "Member 'FNpcFightingPowerParam::EndQuestId' has a wrong offset!");
static_assert(offsetof(FNpcFightingPowerParam, EndPhaseNo) == 0x000028, "Member 'FNpcFightingPowerParam::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FNpcFightingPowerParam, Type) == 0x00002C, "Member 'FNpcFightingPowerParam::Type' has a wrong offset!");
static_assert(offsetof(FNpcFightingPowerParam, Power) == 0x000030, "Member 'FNpcFightingPowerParam::Power' has a wrong offset!");

// ScriptStruct AT.QuestEventRestoreCondition
// 0x0058 (0x0060 - 0x0008)
struct FQuestEventRestoreCondition final : public FTableRowBase
{
public:
	TMap<class FName, class FName>                RestoreIds;                                        // 0x0008(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          RestoreSavedCrossTalkIds;                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestEventRestoreCondition) == 0x000008, "Wrong alignment on FQuestEventRestoreCondition");
static_assert(sizeof(FQuestEventRestoreCondition) == 0x000060, "Wrong size on FQuestEventRestoreCondition");
static_assert(offsetof(FQuestEventRestoreCondition, RestoreIds) == 0x000008, "Member 'FQuestEventRestoreCondition::RestoreIds' has a wrong offset!");
static_assert(offsetof(FQuestEventRestoreCondition, RestoreSavedCrossTalkIds) == 0x000058, "Member 'FQuestEventRestoreCondition::RestoreSavedCrossTalkIds' has a wrong offset!");

// ScriptStruct AT.SkillAttackInfo_S015
// 0x0038 (0x0038 - 0x0000)
struct FSkillAttackInfo_S015 final
{
public:
	float                                         InputTime;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecMpRate;                                         // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecMpRate_LV2;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecMpRate_LV3;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRate;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StunDamageRate;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakDamageRate;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LoopSectionName;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageShot;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageCutin_TargetStun;                           // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillAttackInfo_S015) == 0x000008, "Wrong alignment on FSkillAttackInfo_S015");
static_assert(sizeof(FSkillAttackInfo_S015) == 0x000038, "Wrong size on FSkillAttackInfo_S015");
static_assert(offsetof(FSkillAttackInfo_S015, InputTime) == 0x000000, "Member 'FSkillAttackInfo_S015::InputTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, DecMpRate) == 0x000004, "Member 'FSkillAttackInfo_S015::DecMpRate' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, DecMpRate_LV2) == 0x000008, "Member 'FSkillAttackInfo_S015::DecMpRate_LV2' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, DecMpRate_LV3) == 0x00000C, "Member 'FSkillAttackInfo_S015::DecMpRate_LV3' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, DamageRate) == 0x000010, "Member 'FSkillAttackInfo_S015::DamageRate' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, StunDamageRate) == 0x000014, "Member 'FSkillAttackInfo_S015::StunDamageRate' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, BreakDamageRate) == 0x000018, "Member 'FSkillAttackInfo_S015::BreakDamageRate' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, LoopSectionName) == 0x000020, "Member 'FSkillAttackInfo_S015::LoopSectionName' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, MontageShot) == 0x000028, "Member 'FSkillAttackInfo_S015::MontageShot' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S015, MontageCutin_TargetStun) == 0x000030, "Member 'FSkillAttackInfo_S015::MontageCutin_TargetStun' has a wrong offset!");

// ScriptStruct AT.AT_UICompZListCardParam
// 0x0048 (0x0048 - 0x0000)
struct FAT_UICompZListCardParam final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemCardFileName;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemTitle;                                         // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemText;                                          // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOpen;                                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVertical;                                       // 0x0042(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPremiumRare;                                    // 0x0043(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_UICompZListCardParam) == 0x000008, "Wrong alignment on FAT_UICompZListCardParam");
static_assert(sizeof(FAT_UICompZListCardParam) == 0x000048, "Wrong size on FAT_UICompZListCardParam");
static_assert(offsetof(FAT_UICompZListCardParam, ItemId) == 0x000000, "Member 'FAT_UICompZListCardParam::ItemId' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, ItemName) == 0x000008, "Member 'FAT_UICompZListCardParam::ItemName' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, ItemCardFileName) == 0x000010, "Member 'FAT_UICompZListCardParam::ItemCardFileName' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, ItemTitle) == 0x000020, "Member 'FAT_UICompZListCardParam::ItemTitle' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, ItemText) == 0x000030, "Member 'FAT_UICompZListCardParam::ItemText' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, bIsOpen) == 0x000040, "Member 'FAT_UICompZListCardParam::bIsOpen' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, bIsNew) == 0x000041, "Member 'FAT_UICompZListCardParam::bIsNew' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, bIsVertical) == 0x000042, "Member 'FAT_UICompZListCardParam::bIsVertical' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListCardParam, bIsPremiumRare) == 0x000043, "Member 'FAT_UICompZListCardParam::bIsPremiumRare' has a wrong offset!");

// ScriptStruct AT.MiniGameBaseballSaveDetails
// 0x0030 (0x0030 - 0x0000)
struct FMiniGameBaseballSaveDetails final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        BestRecord;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        LastPlayRecord;                                    // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewRecord;                                      // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayCount;                                         // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalJustMeetCount;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalHitCount;                                     // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalNumberofBats;                                 // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniGameBaseballSaveDetails) == 0x000008, "Wrong alignment on FMiniGameBaseballSaveDetails");
static_assert(sizeof(FMiniGameBaseballSaveDetails) == 0x000030, "Wrong size on FMiniGameBaseballSaveDetails");
static_assert(offsetof(FMiniGameBaseballSaveDetails, CharacterName) == 0x000000, "Member 'FMiniGameBaseballSaveDetails::CharacterName' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, BestRecord) == 0x000010, "Member 'FMiniGameBaseballSaveDetails::BestRecord' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, LastPlayRecord) == 0x000014, "Member 'FMiniGameBaseballSaveDetails::LastPlayRecord' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, bIsNewRecord) == 0x000018, "Member 'FMiniGameBaseballSaveDetails::bIsNewRecord' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, PlayCount) == 0x00001C, "Member 'FMiniGameBaseballSaveDetails::PlayCount' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, TotalJustMeetCount) == 0x000020, "Member 'FMiniGameBaseballSaveDetails::TotalJustMeetCount' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, TotalHitCount) == 0x000024, "Member 'FMiniGameBaseballSaveDetails::TotalHitCount' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseballSaveDetails, TotalNumberofBats) == 0x000028, "Member 'FMiniGameBaseballSaveDetails::TotalNumberofBats' has a wrong offset!");

// ScriptStruct AT.AT_UICompZListDemoParam
// 0x0048 (0x0048 - 0x0000)
struct FAT_UICompZListDemoParam final
{
public:
	int32                                         ItemId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemScene;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemChapter;                                       // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemEpisode;                                       // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOpen;                                            // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNew;                                             // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_UICompZListDemoParam) == 0x000008, "Wrong alignment on FAT_UICompZListDemoParam");
static_assert(sizeof(FAT_UICompZListDemoParam) == 0x000048, "Wrong size on FAT_UICompZListDemoParam");
static_assert(offsetof(FAT_UICompZListDemoParam, ItemId) == 0x000000, "Member 'FAT_UICompZListDemoParam::ItemId' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListDemoParam, ItemName) == 0x000008, "Member 'FAT_UICompZListDemoParam::ItemName' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListDemoParam, ItemScene) == 0x000010, "Member 'FAT_UICompZListDemoParam::ItemScene' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListDemoParam, ItemChapter) == 0x000020, "Member 'FAT_UICompZListDemoParam::ItemChapter' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListDemoParam, ItemEpisode) == 0x000030, "Member 'FAT_UICompZListDemoParam::ItemEpisode' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListDemoParam, IsOpen) == 0x000040, "Member 'FAT_UICompZListDemoParam::IsOpen' has a wrong offset!");
static_assert(offsetof(FAT_UICompZListDemoParam, IsNew) == 0x000041, "Member 'FAT_UICompZListDemoParam::IsNew' has a wrong offset!");

// ScriptStruct AT.QuestAnimationParameter
// 0x00E8 (0x00F0 - 0x0008)
struct FQuestAnimationParameter final : public FTableRowBase
{
public:
	class UAnimMontage*                           RefInitialPlayerStandingCarryMontage;              // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefInitialPlayerStandingCarryMontageLP;            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefCharacterCarriedStandMontageST;                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefCharacterCarriedStandMontageLP;                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefCharacterCarriedStandMontageED;                 // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefCharacterCarriedMoveMontageST;                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefCharacterCarriedMoveMontageLP;                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefCharacterCarriedMoveMontageED;                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefPlayerStandingCarryMontageST;                   // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefPlayerStandingCarryMontageLP;                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefPlayerStandingCarryMontageED;                   // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefPlayerMovingCarryMontageST;                     // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefPlayerMovingCarryMontageLP;                     // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RefPlayerMovingCarryMontageED;                     // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FindQuestCharacterName;                            // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 RefAnimBlueprintGeneratedClass;                    // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimBlueprint*                         RefCharacterAnimationBP;                           // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CryingDistance;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingDistance;                                  // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CryingDuration;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StandingAnimationBelndTime;                        // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AttachOffset;                                      // 0x00A8(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CryingMontageId;                                   // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BeginCryingQuestCommandId;                         // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndCryingQuestCommandId;                           // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CameraAnimationCount;                              // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestAnimationParameter) == 0x000008, "Wrong alignment on FQuestAnimationParameter");
static_assert(sizeof(FQuestAnimationParameter) == 0x0000F0, "Wrong size on FQuestAnimationParameter");
static_assert(offsetof(FQuestAnimationParameter, RefInitialPlayerStandingCarryMontage) == 0x000008, "Member 'FQuestAnimationParameter::RefInitialPlayerStandingCarryMontage' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefInitialPlayerStandingCarryMontageLP) == 0x000010, "Member 'FQuestAnimationParameter::RefInitialPlayerStandingCarryMontageLP' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterCarriedStandMontageST) == 0x000018, "Member 'FQuestAnimationParameter::RefCharacterCarriedStandMontageST' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterCarriedStandMontageLP) == 0x000020, "Member 'FQuestAnimationParameter::RefCharacterCarriedStandMontageLP' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterCarriedStandMontageED) == 0x000028, "Member 'FQuestAnimationParameter::RefCharacterCarriedStandMontageED' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterCarriedMoveMontageST) == 0x000030, "Member 'FQuestAnimationParameter::RefCharacterCarriedMoveMontageST' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterCarriedMoveMontageLP) == 0x000038, "Member 'FQuestAnimationParameter::RefCharacterCarriedMoveMontageLP' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterCarriedMoveMontageED) == 0x000040, "Member 'FQuestAnimationParameter::RefCharacterCarriedMoveMontageED' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefPlayerStandingCarryMontageST) == 0x000048, "Member 'FQuestAnimationParameter::RefPlayerStandingCarryMontageST' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefPlayerStandingCarryMontageLP) == 0x000050, "Member 'FQuestAnimationParameter::RefPlayerStandingCarryMontageLP' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefPlayerStandingCarryMontageED) == 0x000058, "Member 'FQuestAnimationParameter::RefPlayerStandingCarryMontageED' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefPlayerMovingCarryMontageST) == 0x000060, "Member 'FQuestAnimationParameter::RefPlayerMovingCarryMontageST' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefPlayerMovingCarryMontageLP) == 0x000068, "Member 'FQuestAnimationParameter::RefPlayerMovingCarryMontageLP' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefPlayerMovingCarryMontageED) == 0x000070, "Member 'FQuestAnimationParameter::RefPlayerMovingCarryMontageED' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, FindQuestCharacterName) == 0x000078, "Member 'FQuestAnimationParameter::FindQuestCharacterName' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefAnimBlueprintGeneratedClass) == 0x000088, "Member 'FQuestAnimationParameter::RefAnimBlueprintGeneratedClass' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, RefCharacterAnimationBP) == 0x000090, "Member 'FQuestAnimationParameter::RefCharacterAnimationBP' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, CryingDistance) == 0x000098, "Member 'FQuestAnimationParameter::CryingDistance' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, StandingDistance) == 0x00009C, "Member 'FQuestAnimationParameter::StandingDistance' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, CryingDuration) == 0x0000A0, "Member 'FQuestAnimationParameter::CryingDuration' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, StandingAnimationBelndTime) == 0x0000A4, "Member 'FQuestAnimationParameter::StandingAnimationBelndTime' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, AttachOffset) == 0x0000A8, "Member 'FQuestAnimationParameter::AttachOffset' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, CryingMontageId) == 0x0000B8, "Member 'FQuestAnimationParameter::CryingMontageId' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, BeginCryingQuestCommandId) == 0x0000C8, "Member 'FQuestAnimationParameter::BeginCryingQuestCommandId' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, EndCryingQuestCommandId) == 0x0000D8, "Member 'FQuestAnimationParameter::EndCryingQuestCommandId' has a wrong offset!");
static_assert(offsetof(FQuestAnimationParameter, CameraAnimationCount) == 0x0000E8, "Member 'FQuestAnimationParameter::CameraAnimationCount' has a wrong offset!");

// ScriptStruct AT.CookTextBarInfo
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FCookTextBarInfo final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCookTextBarInfo) == 0x000008, "Wrong alignment on FCookTextBarInfo");
static_assert(sizeof(FCookTextBarInfo) == 0x000068, "Wrong size on FCookTextBarInfo");

// ScriptStruct AT.EnemyPartyAccessTable
// 0x0008 (0x0010 - 0x0008)
struct FEnemyPartyAccessTable final : public FTableRowBase
{
public:
	class UDataTable*                             Table;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyPartyAccessTable) == 0x000008, "Wrong alignment on FEnemyPartyAccessTable");
static_assert(sizeof(FEnemyPartyAccessTable) == 0x000010, "Wrong size on FEnemyPartyAccessTable");
static_assert(offsetof(FEnemyPartyAccessTable, Table) == 0x000008, "Member 'FEnemyPartyAccessTable::Table' has a wrong offset!");

// ScriptStruct AT.AT_ViewActorPlayerMoveParam
// 0x0048 (0x0050 - 0x0008)
struct FAT_ViewActorPlayerMoveParam final : public FTableRowBase
{
public:
	bool                                          UseActorYawRotate;                                 // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseActorPitchRotate;                               // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoYawAccel;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoYawDecel;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoYawMaxSpeed;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoYawCategory;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoYawNoRotateTime;                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchUpAccel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchDownAccel;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchMaxSpeed;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchTarget;                                   // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchDecelRange;                               // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchBeginJumpOrFallTime;                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoPitchCategory;                                 // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoPitchNoRotateTime;                             // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtOffsetZ;                                     // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtOffsetZDelay;                                // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtOffsetZDuration;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_ViewActorPlayerMoveParam) == 0x000008, "Wrong alignment on FAT_ViewActorPlayerMoveParam");
static_assert(sizeof(FAT_ViewActorPlayerMoveParam) == 0x000050, "Wrong size on FAT_ViewActorPlayerMoveParam");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, UseActorYawRotate) == 0x000008, "Member 'FAT_ViewActorPlayerMoveParam::UseActorYawRotate' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, UseActorPitchRotate) == 0x000009, "Member 'FAT_ViewActorPlayerMoveParam::UseActorPitchRotate' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoYawAccel) == 0x00000C, "Member 'FAT_ViewActorPlayerMoveParam::AutoYawAccel' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoYawDecel) == 0x000010, "Member 'FAT_ViewActorPlayerMoveParam::AutoYawDecel' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoYawMaxSpeed) == 0x000014, "Member 'FAT_ViewActorPlayerMoveParam::AutoYawMaxSpeed' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoYawCategory) == 0x000018, "Member 'FAT_ViewActorPlayerMoveParam::AutoYawCategory' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoYawNoRotateTime) == 0x00001C, "Member 'FAT_ViewActorPlayerMoveParam::AutoYawNoRotateTime' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchUpAccel) == 0x000020, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchUpAccel' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchDownAccel) == 0x000024, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchDownAccel' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchMaxSpeed) == 0x000028, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchMaxSpeed' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchTarget) == 0x00002C, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchTarget' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchDecelRange) == 0x000030, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchDecelRange' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchBeginJumpOrFallTime) == 0x000034, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchBeginJumpOrFallTime' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchCategory) == 0x000038, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchCategory' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, AutoPitchNoRotateTime) == 0x00003C, "Member 'FAT_ViewActorPlayerMoveParam::AutoPitchNoRotateTime' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, LookAtOffsetZ) == 0x000040, "Member 'FAT_ViewActorPlayerMoveParam::LookAtOffsetZ' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, LookAtOffsetZDelay) == 0x000044, "Member 'FAT_ViewActorPlayerMoveParam::LookAtOffsetZDelay' has a wrong offset!");
static_assert(offsetof(FAT_ViewActorPlayerMoveParam, LookAtOffsetZDuration) == 0x000048, "Member 'FAT_ViewActorPlayerMoveParam::LookAtOffsetZDuration' has a wrong offset!");

// ScriptStruct AT.FoodWidgetInfo
// 0x0040 (0x0040 - 0x0000)
struct FFoodWidgetInfo final
{
public:
	class UCFUIUserWidget*                        All_Nut;                                           // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 Txt_Num;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAT_UIXcmnCheckBox*                     WL_Xmenu_Check;                                    // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 IconItem;                                          // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 BarBaseImg;                                        // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Img_Win_hr01;                                   // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 Txt_FoodName;                                      // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       EnterAnim;                                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FFoodWidgetInfo) == 0x000008, "Wrong alignment on FFoodWidgetInfo");
static_assert(sizeof(FFoodWidgetInfo) == 0x000040, "Wrong size on FFoodWidgetInfo");
static_assert(offsetof(FFoodWidgetInfo, All_Nut) == 0x000000, "Member 'FFoodWidgetInfo::All_Nut' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, Txt_Num) == 0x000008, "Member 'FFoodWidgetInfo::Txt_Num' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, WL_Xmenu_Check) == 0x000010, "Member 'FFoodWidgetInfo::WL_Xmenu_Check' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, IconItem) == 0x000018, "Member 'FFoodWidgetInfo::IconItem' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, BarBaseImg) == 0x000020, "Member 'FFoodWidgetInfo::BarBaseImg' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, WL_Img_Win_hr01) == 0x000028, "Member 'FFoodWidgetInfo::WL_Img_Win_hr01' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, Txt_FoodName) == 0x000030, "Member 'FFoodWidgetInfo::Txt_FoodName' has a wrong offset!");
static_assert(offsetof(FFoodWidgetInfo, EnterAnim) == 0x000038, "Member 'FFoodWidgetInfo::EnterAnim' has a wrong offset!");

// ScriptStruct AT.DemoInfoBase
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDemoInfoBase
{
public:
	class FName                                   DemoName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDEMO_TYPE                                    Type;                                              // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDEMO_TIMING_TYPE                             Timing;                                            // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDemoInfoBase) == 0x000008, "Wrong alignment on FDemoInfoBase");
static_assert(sizeof(FDemoInfoBase) == 0x000010, "Wrong size on FDemoInfoBase");
static_assert(offsetof(FDemoInfoBase, DemoName) == 0x000000, "Member 'FDemoInfoBase::DemoName' has a wrong offset!");
static_assert(offsetof(FDemoInfoBase, Type) == 0x000008, "Member 'FDemoInfoBase::Type' has a wrong offset!");
static_assert(offsetof(FDemoInfoBase, Timing) == 0x000009, "Member 'FDemoInfoBase::Timing' has a wrong offset!");

// ScriptStruct AT.PlayingDemoInfo
// 0x0008 (0x0018 - 0x0010)
struct FPlayingDemoInfo final : public FDemoInfoBase
{
public:
	bool                                          bActive;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayingDemoInfo) == 0x000008, "Wrong alignment on FPlayingDemoInfo");
static_assert(sizeof(FPlayingDemoInfo) == 0x000018, "Wrong size on FPlayingDemoInfo");
static_assert(offsetof(FPlayingDemoInfo, bActive) == 0x000010, "Member 'FPlayingDemoInfo::bActive' has a wrong offset!");

// ScriptStruct AT.RecipeInfo
// 0x0020 (0x0020 - 0x0000)
struct FRecipeInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             CookingMenuTex;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecipeInfo) == 0x000008, "Wrong alignment on FRecipeInfo");
static_assert(sizeof(FRecipeInfo) == 0x000020, "Wrong size on FRecipeInfo");
static_assert(offsetof(FRecipeInfo, CookingMenuTex) == 0x000010, "Member 'FRecipeInfo::CookingMenuTex' has a wrong offset!");

// ScriptStruct AT.DamagePopPlayInfo
// 0x0038 (0x0038 - 0x0000)
struct FDamagePopPlayInfo final
{
public:
	bool                                          bIsPlayer;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageValue;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DrawOffset;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraOut;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitPos;                                            // 0x0014(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDAMAGE_TYPE                                  DamageType;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              DrawScale;                                         // 0x0024(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawAngleDegree;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AAT_Character>           DamageTarget;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamagePopPlayInfo) == 0x000004, "Wrong alignment on FDamagePopPlayInfo");
static_assert(sizeof(FDamagePopPlayInfo) == 0x000038, "Wrong size on FDamagePopPlayInfo");
static_assert(offsetof(FDamagePopPlayInfo, bIsPlayer) == 0x000000, "Member 'FDamagePopPlayInfo::bIsPlayer' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, DamageValue) == 0x000004, "Member 'FDamagePopPlayInfo::DamageValue' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, DrawOffset) == 0x000008, "Member 'FDamagePopPlayInfo::DrawOffset' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, bCameraOut) == 0x000010, "Member 'FDamagePopPlayInfo::bCameraOut' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, HitPos) == 0x000014, "Member 'FDamagePopPlayInfo::HitPos' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, DamageType) == 0x000020, "Member 'FDamagePopPlayInfo::DamageType' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, DrawScale) == 0x000024, "Member 'FDamagePopPlayInfo::DrawScale' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, DrawAngleDegree) == 0x00002C, "Member 'FDamagePopPlayInfo::DrawAngleDegree' has a wrong offset!");
static_assert(offsetof(FDamagePopPlayInfo, DamageTarget) == 0x000030, "Member 'FDamagePopPlayInfo::DamageTarget' has a wrong offset!");

// ScriptStruct AT.CookingEffectMessageData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCookingEffectMessageData final
{
public:
	class FName                                   MessageId;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECookingEffectValueType                       ValueType;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Value;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingEffectMessageData) == 0x000008, "Wrong alignment on FCookingEffectMessageData");
static_assert(sizeof(FCookingEffectMessageData) == 0x000018, "Wrong size on FCookingEffectMessageData");
static_assert(offsetof(FCookingEffectMessageData, MessageId) == 0x000000, "Member 'FCookingEffectMessageData::MessageId' has a wrong offset!");
static_assert(offsetof(FCookingEffectMessageData, ValueType) == 0x000008, "Member 'FCookingEffectMessageData::ValueType' has a wrong offset!");
static_assert(offsetof(FCookingEffectMessageData, Value) == 0x000010, "Member 'FCookingEffectMessageData::Value' has a wrong offset!");

// ScriptStruct AT.CookingEffectOverWrite
// 0x0050 (0x0058 - 0x0008)
struct FCookingEffectOverWrite final : public FTableRowBase
{
public:
	class FName                                   DlcId;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCookingEffectMessageData              MessageData1;                                      // 0x0010(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCookingEffectMessageData              MessageData2;                                      // 0x0028(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FCookingEffectMessageData              MessageData3;                                      // 0x0040(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingEffectOverWrite) == 0x000008, "Wrong alignment on FCookingEffectOverWrite");
static_assert(sizeof(FCookingEffectOverWrite) == 0x000058, "Wrong size on FCookingEffectOverWrite");
static_assert(offsetof(FCookingEffectOverWrite, DlcId) == 0x000008, "Member 'FCookingEffectOverWrite::DlcId' has a wrong offset!");
static_assert(offsetof(FCookingEffectOverWrite, MessageData1) == 0x000010, "Member 'FCookingEffectOverWrite::MessageData1' has a wrong offset!");
static_assert(offsetof(FCookingEffectOverWrite, MessageData2) == 0x000028, "Member 'FCookingEffectOverWrite::MessageData2' has a wrong offset!");
static_assert(offsetof(FCookingEffectOverWrite, MessageData3) == 0x000040, "Member 'FCookingEffectOverWrite::MessageData3' has a wrong offset!");

// ScriptStruct AT.DroneCommanderMapLegendInsertParam
// 0x0018 (0x0020 - 0x0008)
struct FDroneCommanderMapLegendInsertParam final : public FTableRowBase
{
public:
	class FName                                   ProgressStart;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressEnd;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVisible;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDroneCommanderMapLegendInsertParam) == 0x000008, "Wrong alignment on FDroneCommanderMapLegendInsertParam");
static_assert(sizeof(FDroneCommanderMapLegendInsertParam) == 0x000020, "Wrong size on FDroneCommanderMapLegendInsertParam");
static_assert(offsetof(FDroneCommanderMapLegendInsertParam, ProgressStart) == 0x000008, "Member 'FDroneCommanderMapLegendInsertParam::ProgressStart' has a wrong offset!");
static_assert(offsetof(FDroneCommanderMapLegendInsertParam, ProgressEnd) == 0x000010, "Member 'FDroneCommanderMapLegendInsertParam::ProgressEnd' has a wrong offset!");
static_assert(offsetof(FDroneCommanderMapLegendInsertParam, bVisible) == 0x000018, "Member 'FDroneCommanderMapLegendInsertParam::bVisible' has a wrong offset!");

// ScriptStruct AT.TopMenuPortraitSelectionParam
// 0x0028 (0x0030 - 0x0008)
struct FTopMenuPortraitSelectionParam final : public FTableRowBase
{
public:
	class FName                                   QuestId;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImagePath;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FadeTexturePath;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTopMenuPortraitSelectionParam) == 0x000008, "Wrong alignment on FTopMenuPortraitSelectionParam");
static_assert(sizeof(FTopMenuPortraitSelectionParam) == 0x000030, "Wrong size on FTopMenuPortraitSelectionParam");
static_assert(offsetof(FTopMenuPortraitSelectionParam, QuestId) == 0x000008, "Member 'FTopMenuPortraitSelectionParam::QuestId' has a wrong offset!");
static_assert(offsetof(FTopMenuPortraitSelectionParam, ImagePath) == 0x000010, "Member 'FTopMenuPortraitSelectionParam::ImagePath' has a wrong offset!");
static_assert(offsetof(FTopMenuPortraitSelectionParam, FadeTexturePath) == 0x000020, "Member 'FTopMenuPortraitSelectionParam::FadeTexturePath' has a wrong offset!");

// ScriptStruct AT.ATCookingBuff
// 0x0008 (0x0008 - 0x0000)
struct FATCookingBuff final
{
public:
	EATCookingBuffType                            BuffType;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCookingBuff) == 0x000004, "Wrong alignment on FATCookingBuff");
static_assert(sizeof(FATCookingBuff) == 0x000008, "Wrong size on FATCookingBuff");
static_assert(offsetof(FATCookingBuff, BuffType) == 0x000000, "Member 'FATCookingBuff::BuffType' has a wrong offset!");
static_assert(offsetof(FATCookingBuff, Rate) == 0x000004, "Member 'FATCookingBuff::Rate' has a wrong offset!");

// ScriptStruct AT.MaxLevelReleaseCharacter
// 0x0008 (0x0010 - 0x0008)
struct FMaxLevelReleaseCharacter final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMaxLevelReleaseCharacter) == 0x000008, "Wrong alignment on FMaxLevelReleaseCharacter");
static_assert(sizeof(FMaxLevelReleaseCharacter) == 0x000010, "Wrong size on FMaxLevelReleaseCharacter");
static_assert(offsetof(FMaxLevelReleaseCharacter, CharacterType) == 0x000008, "Member 'FMaxLevelReleaseCharacter::CharacterType' has a wrong offset!");

// ScriptStruct AT.EnemyGaugeNumInfo
// 0x0008 (0x0010 - 0x0008)
struct FEnemyGaugeNumInfo final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GaugeNum;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyGaugeNumInfo) == 0x000008, "Wrong alignment on FEnemyGaugeNumInfo");
static_assert(sizeof(FEnemyGaugeNumInfo) == 0x000010, "Wrong size on FEnemyGaugeNumInfo");
static_assert(offsetof(FEnemyGaugeNumInfo, Type) == 0x000008, "Member 'FEnemyGaugeNumInfo::Type' has a wrong offset!");
static_assert(offsetof(FEnemyGaugeNumInfo, GaugeNum) == 0x00000C, "Member 'FEnemyGaugeNumInfo::GaugeNum' has a wrong offset!");

// ScriptStruct AT.Credit
// 0x0030 (0x0038 - 0x0008)
struct FCredit final : public FTableRowBase
{
public:
	class FString                                 Category;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Post;                                              // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCredit) == 0x000008, "Wrong alignment on FCredit");
static_assert(sizeof(FCredit) == 0x000038, "Wrong size on FCredit");
static_assert(offsetof(FCredit, Category) == 0x000008, "Member 'FCredit::Category' has a wrong offset!");
static_assert(offsetof(FCredit, Post) == 0x000018, "Member 'FCredit::Post' has a wrong offset!");
static_assert(offsetof(FCredit, Name) == 0x000028, "Member 'FCredit::Name' has a wrong offset!");

// ScriptStruct AT.LinkBonusVoiceProgress
// 0x0060 (0x0068 - 0x0008)
struct FLinkBonusVoiceProgress final : public FTableRowBase
{
public:
	class FName                                   LinkBonusID;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressID;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_1;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_2;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_3;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_4;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_5;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_6;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_7;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_8;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_9;                                           // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId_10;                                          // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLinkBonusVoiceProgress) == 0x000008, "Wrong alignment on FLinkBonusVoiceProgress");
static_assert(sizeof(FLinkBonusVoiceProgress) == 0x000068, "Wrong size on FLinkBonusVoiceProgress");
static_assert(offsetof(FLinkBonusVoiceProgress, LinkBonusID) == 0x000008, "Member 'FLinkBonusVoiceProgress::LinkBonusID' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, ProgressID) == 0x000010, "Member 'FLinkBonusVoiceProgress::ProgressID' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_1) == 0x000018, "Member 'FLinkBonusVoiceProgress::MsgId_1' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_2) == 0x000020, "Member 'FLinkBonusVoiceProgress::MsgId_2' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_3) == 0x000028, "Member 'FLinkBonusVoiceProgress::MsgId_3' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_4) == 0x000030, "Member 'FLinkBonusVoiceProgress::MsgId_4' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_5) == 0x000038, "Member 'FLinkBonusVoiceProgress::MsgId_5' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_6) == 0x000040, "Member 'FLinkBonusVoiceProgress::MsgId_6' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_7) == 0x000048, "Member 'FLinkBonusVoiceProgress::MsgId_7' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_8) == 0x000050, "Member 'FLinkBonusVoiceProgress::MsgId_8' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_9) == 0x000058, "Member 'FLinkBonusVoiceProgress::MsgId_9' has a wrong offset!");
static_assert(offsetof(FLinkBonusVoiceProgress, MsgId_10) == 0x000060, "Member 'FLinkBonusVoiceProgress::MsgId_10' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateDebriInfo
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FTerrainDecorateDebriInfo final
{
public:
	uint8                                         Pad_0[0xC8];                                       // 0x0000(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainDecorateDebriInfo) == 0x000008, "Wrong alignment on FTerrainDecorateDebriInfo");
static_assert(sizeof(FTerrainDecorateDebriInfo) == 0x0000C8, "Wrong size on FTerrainDecorateDebriInfo");

// ScriptStruct AT.EncounterEnemyTableRow
// 0x0030 (0x0038 - 0x0008)
struct FEncounterEnemyTableRow final : public FTableRowBase
{
public:
	class FName                                   LandPartyName;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate_Land;                                         // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SeaPartyName;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate_Sea;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkyPartyName;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate_Sky;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterEnemyTableRow) == 0x000008, "Wrong alignment on FEncounterEnemyTableRow");
static_assert(sizeof(FEncounterEnemyTableRow) == 0x000038, "Wrong size on FEncounterEnemyTableRow");
static_assert(offsetof(FEncounterEnemyTableRow, LandPartyName) == 0x000008, "Member 'FEncounterEnemyTableRow::LandPartyName' has a wrong offset!");
static_assert(offsetof(FEncounterEnemyTableRow, Rate_Land) == 0x000010, "Member 'FEncounterEnemyTableRow::Rate_Land' has a wrong offset!");
static_assert(offsetof(FEncounterEnemyTableRow, SeaPartyName) == 0x000018, "Member 'FEncounterEnemyTableRow::SeaPartyName' has a wrong offset!");
static_assert(offsetof(FEncounterEnemyTableRow, Rate_Sea) == 0x000020, "Member 'FEncounterEnemyTableRow::Rate_Sea' has a wrong offset!");
static_assert(offsetof(FEncounterEnemyTableRow, SkyPartyName) == 0x000028, "Member 'FEncounterEnemyTableRow::SkyPartyName' has a wrong offset!");
static_assert(offsetof(FEncounterEnemyTableRow, Rate_Sky) == 0x000030, "Member 'FEncounterEnemyTableRow::Rate_Sky' has a wrong offset!");

// ScriptStruct AT.DLC6WorldMapMaterialInfo
// 0x0020 (0x0028 - 0x0008)
struct FDLC6WorldMapMaterialInfo final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSubQuestId;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC6WorldMapMaterialInfo) == 0x000008, "Wrong alignment on FDLC6WorldMapMaterialInfo");
static_assert(sizeof(FDLC6WorldMapMaterialInfo) == 0x000028, "Wrong size on FDLC6WorldMapMaterialInfo");
static_assert(offsetof(FDLC6WorldMapMaterialInfo, ItemId) == 0x000008, "Member 'FDLC6WorldMapMaterialInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FDLC6WorldMapMaterialInfo, AreaName) == 0x000010, "Member 'FDLC6WorldMapMaterialInfo::AreaName' has a wrong offset!");
static_assert(offsetof(FDLC6WorldMapMaterialInfo, StartSubQuestId) == 0x000018, "Member 'FDLC6WorldMapMaterialInfo::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC6WorldMapMaterialInfo, EndSubQuestId) == 0x000020, "Member 'FDLC6WorldMapMaterialInfo::EndSubQuestId' has a wrong offset!");

// ScriptStruct AT.ATWearEffectColor
// 0x0010 (0x0010 - 0x0000)
struct FATWearEffectColor final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Multi;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWearEffectColor) == 0x000004, "Wrong alignment on FATWearEffectColor");
static_assert(sizeof(FATWearEffectColor) == 0x000010, "Wrong size on FATWearEffectColor");
static_assert(offsetof(FATWearEffectColor, R) == 0x000000, "Member 'FATWearEffectColor::R' has a wrong offset!");
static_assert(offsetof(FATWearEffectColor, G) == 0x000004, "Member 'FATWearEffectColor::G' has a wrong offset!");
static_assert(offsetof(FATWearEffectColor, B) == 0x000008, "Member 'FATWearEffectColor::B' has a wrong offset!");
static_assert(offsetof(FATWearEffectColor, Multi) == 0x00000C, "Member 'FATWearEffectColor::Multi' has a wrong offset!");

// ScriptStruct AT.ATFresnelColor
// 0x0014 (0x0014 - 0x0000)
struct FATFresnelColor final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Influence;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATFresnelColor) == 0x000004, "Wrong alignment on FATFresnelColor");
static_assert(sizeof(FATFresnelColor) == 0x000014, "Wrong size on FATFresnelColor");
static_assert(offsetof(FATFresnelColor, R) == 0x000000, "Member 'FATFresnelColor::R' has a wrong offset!");
static_assert(offsetof(FATFresnelColor, G) == 0x000004, "Member 'FATFresnelColor::G' has a wrong offset!");
static_assert(offsetof(FATFresnelColor, B) == 0x000008, "Member 'FATFresnelColor::B' has a wrong offset!");
static_assert(offsetof(FATFresnelColor, Influence) == 0x00000C, "Member 'FATFresnelColor::Influence' has a wrong offset!");
static_assert(offsetof(FATFresnelColor, Power) == 0x000010, "Member 'FATFresnelColor::Power' has a wrong offset!");

// ScriptStruct AT.ATOutlineColor
// 0x000C (0x000C - 0x0000)
struct FATOutlineColor final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATOutlineColor) == 0x000004, "Wrong alignment on FATOutlineColor");
static_assert(sizeof(FATOutlineColor) == 0x00000C, "Wrong size on FATOutlineColor");
static_assert(offsetof(FATOutlineColor, R) == 0x000000, "Member 'FATOutlineColor::R' has a wrong offset!");
static_assert(offsetof(FATOutlineColor, G) == 0x000004, "Member 'FATOutlineColor::G' has a wrong offset!");
static_assert(offsetof(FATOutlineColor, B) == 0x000008, "Member 'FATOutlineColor::B' has a wrong offset!");

// ScriptStruct AT.ATWearEffectColorTable
// 0x0040 (0x0048 - 0x0008)
struct FATWearEffectColorTable final : public FTableRowBase
{
public:
	struct FATWearEffectColor                     BaseColor;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FATWearEffectColor                     SubColor;                                          // 0x0018(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FATFresnelColor                        FresnelColor;                                      // 0x0028(0x0014)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FATOutlineColor                        OutlineColor;                                      // 0x003C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWearEffectColorTable) == 0x000008, "Wrong alignment on FATWearEffectColorTable");
static_assert(sizeof(FATWearEffectColorTable) == 0x000048, "Wrong size on FATWearEffectColorTable");
static_assert(offsetof(FATWearEffectColorTable, BaseColor) == 0x000008, "Member 'FATWearEffectColorTable::BaseColor' has a wrong offset!");
static_assert(offsetof(FATWearEffectColorTable, SubColor) == 0x000018, "Member 'FATWearEffectColorTable::SubColor' has a wrong offset!");
static_assert(offsetof(FATWearEffectColorTable, FresnelColor) == 0x000028, "Member 'FATWearEffectColorTable::FresnelColor' has a wrong offset!");
static_assert(offsetof(FATWearEffectColorTable, OutlineColor) == 0x00003C, "Member 'FATWearEffectColorTable::OutlineColor' has a wrong offset!");

// ScriptStruct AT.DLC5WorldMapMaterialInfo
// 0x0020 (0x0028 - 0x0008)
struct FDLC5WorldMapMaterialInfo final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSubQuestId;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC5WorldMapMaterialInfo) == 0x000008, "Wrong alignment on FDLC5WorldMapMaterialInfo");
static_assert(sizeof(FDLC5WorldMapMaterialInfo) == 0x000028, "Wrong size on FDLC5WorldMapMaterialInfo");
static_assert(offsetof(FDLC5WorldMapMaterialInfo, ItemId) == 0x000008, "Member 'FDLC5WorldMapMaterialInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FDLC5WorldMapMaterialInfo, AreaName) == 0x000010, "Member 'FDLC5WorldMapMaterialInfo::AreaName' has a wrong offset!");
static_assert(offsetof(FDLC5WorldMapMaterialInfo, StartSubQuestId) == 0x000018, "Member 'FDLC5WorldMapMaterialInfo::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC5WorldMapMaterialInfo, EndSubQuestId) == 0x000020, "Member 'FDLC5WorldMapMaterialInfo::EndSubQuestId' has a wrong offset!");

// ScriptStruct AT.EventParam
// 0x0108 (0x0108 - 0x0000)
struct alignas(0x08) FEventParam final
{
public:
	uint8                                         Pad_0[0x108];                                      // 0x0000(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventParam) == 0x000008, "Wrong alignment on FEventParam");
static_assert(sizeof(FEventParam) == 0x000108, "Wrong size on FEventParam");

// ScriptStruct AT.DLC3WorldMapMaterialInfo
// 0x0020 (0x0028 - 0x0008)
struct FDLC3WorldMapMaterialInfo final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartSubQuestId;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC3WorldMapMaterialInfo) == 0x000008, "Wrong alignment on FDLC3WorldMapMaterialInfo");
static_assert(sizeof(FDLC3WorldMapMaterialInfo) == 0x000028, "Wrong size on FDLC3WorldMapMaterialInfo");
static_assert(offsetof(FDLC3WorldMapMaterialInfo, ItemId) == 0x000008, "Member 'FDLC3WorldMapMaterialInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FDLC3WorldMapMaterialInfo, AreaName) == 0x000010, "Member 'FDLC3WorldMapMaterialInfo::AreaName' has a wrong offset!");
static_assert(offsetof(FDLC3WorldMapMaterialInfo, StartSubQuestId) == 0x000018, "Member 'FDLC3WorldMapMaterialInfo::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC3WorldMapMaterialInfo, EndSubQuestId) == 0x000020, "Member 'FDLC3WorldMapMaterialInfo::EndSubQuestId' has a wrong offset!");

// ScriptStruct AT.WorldMapMaterialInfo
// 0x0018 (0x0020 - 0x0008)
struct FWorldMapMaterialInfo final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartEpisode;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartChapter;                                      // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartPart;                                         // 0x001A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndEpisode;                                        // 0x001B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndChapter;                                        // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndPart;                                           // 0x001D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldMapMaterialInfo) == 0x000008, "Wrong alignment on FWorldMapMaterialInfo");
static_assert(sizeof(FWorldMapMaterialInfo) == 0x000020, "Wrong size on FWorldMapMaterialInfo");
static_assert(offsetof(FWorldMapMaterialInfo, ItemId) == 0x000008, "Member 'FWorldMapMaterialInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, AreaName) == 0x000010, "Member 'FWorldMapMaterialInfo::AreaName' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, StartEpisode) == 0x000018, "Member 'FWorldMapMaterialInfo::StartEpisode' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, StartChapter) == 0x000019, "Member 'FWorldMapMaterialInfo::StartChapter' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, StartPart) == 0x00001A, "Member 'FWorldMapMaterialInfo::StartPart' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, EndEpisode) == 0x00001B, "Member 'FWorldMapMaterialInfo::EndEpisode' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, EndChapter) == 0x00001C, "Member 'FWorldMapMaterialInfo::EndChapter' has a wrong offset!");
static_assert(offsetof(FWorldMapMaterialInfo, EndPart) == 0x00001D, "Member 'FWorldMapMaterialInfo::EndPart' has a wrong offset!");

// ScriptStruct AT.DLC5WorldMapActiveParamRow
// 0x0018 (0x0020 - 0x0008)
struct FDLC5WorldMapActiveParamRow final : public FTableRowBase
{
public:
	EWorldStageId                                 StageId;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSubQuestId;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC5WorldMapActiveParamRow) == 0x000008, "Wrong alignment on FDLC5WorldMapActiveParamRow");
static_assert(sizeof(FDLC5WorldMapActiveParamRow) == 0x000020, "Wrong size on FDLC5WorldMapActiveParamRow");
static_assert(offsetof(FDLC5WorldMapActiveParamRow, StageId) == 0x000008, "Member 'FDLC5WorldMapActiveParamRow::StageId' has a wrong offset!");
static_assert(offsetof(FDLC5WorldMapActiveParamRow, StartSubQuestId) == 0x000010, "Member 'FDLC5WorldMapActiveParamRow::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC5WorldMapActiveParamRow, EndSubQuestId) == 0x000018, "Member 'FDLC5WorldMapActiveParamRow::EndSubQuestId' has a wrong offset!");

// ScriptStruct AT.WishInfoParam
// 0x0078 (0x0080 - 0x0008)
struct FWishInfoParam final : public FTableRowBase
{
public:
	int32                                         WishInfoId;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWishType                                     WishType;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           UniqueIdList;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 WishTextId;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WishResultTextId;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWishCountType                                WishCountType;                                     // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WishDetail;                                        // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WishReleaseQuestId;                                // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReleasPhaseNo;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WishHideQuestId;                                   // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WishHidePhaseNo;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WishReleaseItemId;                                 // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWishInfoParam) == 0x000008, "Wrong alignment on FWishInfoParam");
static_assert(sizeof(FWishInfoParam) == 0x000080, "Wrong size on FWishInfoParam");
static_assert(offsetof(FWishInfoParam, WishInfoId) == 0x000008, "Member 'FWishInfoParam::WishInfoId' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishType) == 0x00000C, "Member 'FWishInfoParam::WishType' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, UniqueIdList) == 0x000010, "Member 'FWishInfoParam::UniqueIdList' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishTextId) == 0x000020, "Member 'FWishInfoParam::WishTextId' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishResultTextId) == 0x000030, "Member 'FWishInfoParam::WishResultTextId' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishCountType) == 0x000040, "Member 'FWishInfoParam::WishCountType' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishDetail) == 0x000048, "Member 'FWishInfoParam::WishDetail' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishReleaseQuestId) == 0x000058, "Member 'FWishInfoParam::WishReleaseQuestId' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, ReleasPhaseNo) == 0x000060, "Member 'FWishInfoParam::ReleasPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishHideQuestId) == 0x000068, "Member 'FWishInfoParam::WishHideQuestId' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishHidePhaseNo) == 0x000070, "Member 'FWishInfoParam::WishHidePhaseNo' has a wrong offset!");
static_assert(offsetof(FWishInfoParam, WishReleaseItemId) == 0x000078, "Member 'FWishInfoParam::WishReleaseItemId' has a wrong offset!");

// ScriptStruct AT.DLC3WorldMapActiveParamRow
// 0x0018 (0x0020 - 0x0008)
struct FDLC3WorldMapActiveParamRow final : public FTableRowBase
{
public:
	EWorldStageId                                 StageId;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSubQuestId;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC3WorldMapActiveParamRow) == 0x000008, "Wrong alignment on FDLC3WorldMapActiveParamRow");
static_assert(sizeof(FDLC3WorldMapActiveParamRow) == 0x000020, "Wrong size on FDLC3WorldMapActiveParamRow");
static_assert(offsetof(FDLC3WorldMapActiveParamRow, StageId) == 0x000008, "Member 'FDLC3WorldMapActiveParamRow::StageId' has a wrong offset!");
static_assert(offsetof(FDLC3WorldMapActiveParamRow, StartSubQuestId) == 0x000010, "Member 'FDLC3WorldMapActiveParamRow::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC3WorldMapActiveParamRow, EndSubQuestId) == 0x000018, "Member 'FDLC3WorldMapActiveParamRow::EndSubQuestId' has a wrong offset!");

// ScriptStruct AT.ContentReleaseCondition
// 0x0028 (0x0030 - 0x0008)
struct FContentReleaseCondition final : public FTableRowBase
{
public:
	TArray<class FName>                           PhaseIds;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          Releasable;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Comment;                                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FContentReleaseCondition) == 0x000008, "Wrong alignment on FContentReleaseCondition");
static_assert(sizeof(FContentReleaseCondition) == 0x000030, "Wrong size on FContentReleaseCondition");
static_assert(offsetof(FContentReleaseCondition, PhaseIds) == 0x000008, "Member 'FContentReleaseCondition::PhaseIds' has a wrong offset!");
static_assert(offsetof(FContentReleaseCondition, Releasable) == 0x000018, "Member 'FContentReleaseCondition::Releasable' has a wrong offset!");
static_assert(offsetof(FContentReleaseCondition, Comment) == 0x000020, "Member 'FContentReleaseCondition::Comment' has a wrong offset!");

// ScriptStruct AT.QuestCostumeOverride
// 0x0028 (0x0030 - 0x0008)
struct FQuestCostumeOverride final : public FTableRowBase
{
public:
	class FName                                   UniqueId;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProgressID;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TriggerId;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestCostumeOverride) == 0x000008, "Wrong alignment on FQuestCostumeOverride");
static_assert(sizeof(FQuestCostumeOverride) == 0x000030, "Wrong size on FQuestCostumeOverride");
static_assert(offsetof(FQuestCostumeOverride, UniqueId) == 0x000008, "Member 'FQuestCostumeOverride::UniqueId' has a wrong offset!");
static_assert(offsetof(FQuestCostumeOverride, FormID) == 0x000010, "Member 'FQuestCostumeOverride::FormID' has a wrong offset!");
static_assert(offsetof(FQuestCostumeOverride, VariationId) == 0x000011, "Member 'FQuestCostumeOverride::VariationId' has a wrong offset!");
static_assert(offsetof(FQuestCostumeOverride, ProgressID) == 0x000018, "Member 'FQuestCostumeOverride::ProgressID' has a wrong offset!");
static_assert(offsetof(FQuestCostumeOverride, AreaName) == 0x000020, "Member 'FQuestCostumeOverride::AreaName' has a wrong offset!");
static_assert(offsetof(FQuestCostumeOverride, TriggerId) == 0x000028, "Member 'FQuestCostumeOverride::TriggerId' has a wrong offset!");

// ScriptStruct AT.WorldMapActiveParamRow
// 0x0008 (0x0010 - 0x0008)
struct FWorldMapActiveParamRow final : public FTableRowBase
{
public:
	EWorldStageId                                 StageId;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartEpisode;                                      // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartChapter;                                      // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartPart;                                         // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndEpisode;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndChapter;                                        // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EndPart;                                           // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsIconChange;                                      // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldMapActiveParamRow) == 0x000008, "Wrong alignment on FWorldMapActiveParamRow");
static_assert(sizeof(FWorldMapActiveParamRow) == 0x000010, "Wrong size on FWorldMapActiveParamRow");
static_assert(offsetof(FWorldMapActiveParamRow, StageId) == 0x000008, "Member 'FWorldMapActiveParamRow::StageId' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, StartEpisode) == 0x000009, "Member 'FWorldMapActiveParamRow::StartEpisode' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, StartChapter) == 0x00000A, "Member 'FWorldMapActiveParamRow::StartChapter' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, StartPart) == 0x00000B, "Member 'FWorldMapActiveParamRow::StartPart' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, EndEpisode) == 0x00000C, "Member 'FWorldMapActiveParamRow::EndEpisode' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, EndChapter) == 0x00000D, "Member 'FWorldMapActiveParamRow::EndChapter' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, EndPart) == 0x00000E, "Member 'FWorldMapActiveParamRow::EndPart' has a wrong offset!");
static_assert(offsetof(FWorldMapActiveParamRow, IsIconChange) == 0x00000F, "Member 'FWorldMapActiveParamRow::IsIconChange' has a wrong offset!");

// ScriptStruct AT.ToogleExecutionParam
// 0x0020 (0x0028 - 0x0008)
struct FToogleExecutionParam final : public FTableRowBase
{
public:
	class FString                                 NameFilter;                                        // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FolderFilter;                                      // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FToogleExecutionParam) == 0x000008, "Wrong alignment on FToogleExecutionParam");
static_assert(sizeof(FToogleExecutionParam) == 0x000028, "Wrong size on FToogleExecutionParam");
static_assert(offsetof(FToogleExecutionParam, NameFilter) == 0x000008, "Member 'FToogleExecutionParam::NameFilter' has a wrong offset!");
static_assert(offsetof(FToogleExecutionParam, FolderFilter) == 0x000018, "Member 'FToogleExecutionParam::FolderFilter' has a wrong offset!");

// ScriptStruct AT.KeyGuideItem
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FKeyGuideItem final
{
public:
	class FName                                   Note;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BtnTxtId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OperationTxtId;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EKeyGuideCondition                            Condition;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKeyGuideItem) == 0x000008, "Wrong alignment on FKeyGuideItem");
static_assert(sizeof(FKeyGuideItem) == 0x000020, "Wrong size on FKeyGuideItem");
static_assert(offsetof(FKeyGuideItem, Note) == 0x000000, "Member 'FKeyGuideItem::Note' has a wrong offset!");
static_assert(offsetof(FKeyGuideItem, BtnTxtId) == 0x000008, "Member 'FKeyGuideItem::BtnTxtId' has a wrong offset!");
static_assert(offsetof(FKeyGuideItem, OperationTxtId) == 0x000010, "Member 'FKeyGuideItem::OperationTxtId' has a wrong offset!");
static_assert(offsetof(FKeyGuideItem, Condition) == 0x000018, "Member 'FKeyGuideItem::Condition' has a wrong offset!");

// ScriptStruct AT.KeyGuideListParam
// 0x0010 (0x0018 - 0x0008)
struct FKeyGuideListParam final : public FTableRowBase
{
public:
	TArray<struct FKeyGuideItem>                  GuideList;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKeyGuideListParam) == 0x000008, "Wrong alignment on FKeyGuideListParam");
static_assert(sizeof(FKeyGuideListParam) == 0x000018, "Wrong size on FKeyGuideListParam");
static_assert(offsetof(FKeyGuideListParam, GuideList) == 0x000008, "Member 'FKeyGuideListParam::GuideList' has a wrong offset!");

// ScriptStruct AT.ObserverCondition
// 0x0040 (0x0040 - 0x0000)
struct FObserverCondition final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TriggerId;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ConditionFlags;                                    // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CommandId;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinished;                                         // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledTrigger;                                   // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecute;                                          // 0x003A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObserverCondition) == 0x000008, "Wrong alignment on FObserverCondition");
static_assert(sizeof(FObserverCondition) == 0x000040, "Wrong size on FObserverCondition");
static_assert(offsetof(FObserverCondition, ID) == 0x000000, "Member 'FObserverCondition::ID' has a wrong offset!");
static_assert(offsetof(FObserverCondition, TriggerId) == 0x000010, "Member 'FObserverCondition::TriggerId' has a wrong offset!");
static_assert(offsetof(FObserverCondition, Distance) == 0x000020, "Member 'FObserverCondition::Distance' has a wrong offset!");
static_assert(offsetof(FObserverCondition, ConditionFlags) == 0x000024, "Member 'FObserverCondition::ConditionFlags' has a wrong offset!");
static_assert(offsetof(FObserverCondition, CommandId) == 0x000028, "Member 'FObserverCondition::CommandId' has a wrong offset!");
static_assert(offsetof(FObserverCondition, bFinished) == 0x000038, "Member 'FObserverCondition::bFinished' has a wrong offset!");
static_assert(offsetof(FObserverCondition, bEnabledTrigger) == 0x000039, "Member 'FObserverCondition::bEnabledTrigger' has a wrong offset!");
static_assert(offsetof(FObserverCondition, bExecute) == 0x00003A, "Member 'FObserverCondition::bExecute' has a wrong offset!");

// ScriptStruct AT.DisplayParam
// 0x0008 (0x0010 - 0x0008)
struct FDisplayParam final : public FTableRowBase
{
public:
	int32                                         Width;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisplayParam) == 0x000008, "Wrong alignment on FDisplayParam");
static_assert(sizeof(FDisplayParam) == 0x000010, "Wrong size on FDisplayParam");
static_assert(offsetof(FDisplayParam, Width) == 0x000008, "Member 'FDisplayParam::Width' has a wrong offset!");
static_assert(offsetof(FDisplayParam, Height) == 0x00000C, "Member 'FDisplayParam::Height' has a wrong offset!");

// ScriptStruct AT.BannedSkillProgressParam
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FBannedSkillProgressParam final
{
public:
	class FName                                   QuestId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannedSkillProgressParam) == 0x000008, "Wrong alignment on FBannedSkillProgressParam");
static_assert(sizeof(FBannedSkillProgressParam) == 0x000008, "Wrong size on FBannedSkillProgressParam");
static_assert(offsetof(FBannedSkillProgressParam, QuestId) == 0x000000, "Member 'FBannedSkillProgressParam::QuestId' has a wrong offset!");

// ScriptStruct AT.BannedSkillTimeParam
// 0x0010 (0x0010 - 0x0000)
struct FBannedSkillTimeParam final
{
public:
	struct FBannedSkillProgressParam              Start;                                             // 0x0000(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FBannedSkillProgressParam              End;                                               // 0x0008(0x0008)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannedSkillTimeParam) == 0x000008, "Wrong alignment on FBannedSkillTimeParam");
static_assert(sizeof(FBannedSkillTimeParam) == 0x000010, "Wrong size on FBannedSkillTimeParam");
static_assert(offsetof(FBannedSkillTimeParam, Start) == 0x000000, "Member 'FBannedSkillTimeParam::Start' has a wrong offset!");
static_assert(offsetof(FBannedSkillTimeParam, End) == 0x000008, "Member 'FBannedSkillTimeParam::End' has a wrong offset!");

// ScriptStruct AT.BannedSkillParam
// 0x0028 (0x0030 - 0x0008)
struct FBannedSkillParam final : public FTableRowBase
{
public:
	class FString                                 Discription;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPassive;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FBannedSkillTimeParam                  Period;                                            // 0x0020(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBannedSkillParam) == 0x000008, "Wrong alignment on FBannedSkillParam");
static_assert(sizeof(FBannedSkillParam) == 0x000030, "Wrong size on FBannedSkillParam");
static_assert(offsetof(FBannedSkillParam, Discription) == 0x000008, "Member 'FBannedSkillParam::Discription' has a wrong offset!");
static_assert(offsetof(FBannedSkillParam, IsPassive) == 0x000018, "Member 'FBannedSkillParam::IsPassive' has a wrong offset!");
static_assert(offsetof(FBannedSkillParam, CharacterType) == 0x000019, "Member 'FBannedSkillParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FBannedSkillParam, Period) == 0x000020, "Member 'FBannedSkillParam::Period' has a wrong offset!");

// ScriptStruct AT.MiniGameQuizSaveInfo
// 0x0001 (0x0001 - 0x0000)
struct FMiniGameQuizSaveInfo final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniGameQuizSaveInfo) == 0x000001, "Wrong alignment on FMiniGameQuizSaveInfo");
static_assert(sizeof(FMiniGameQuizSaveInfo) == 0x000001, "Wrong size on FMiniGameQuizSaveInfo");

// ScriptStruct AT.ReferenceToFishGameCharaAnimationAssetInstance
// 0x00A0 (0x00A0 - 0x0000)
struct FReferenceToFishGameCharaAnimationAssetInstance final
{
public:
	class UAnimMontage*                           FishingStart;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingStart_Rod;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingAction;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingAction_Rod;                                 // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingQTE1;                                       // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingQTE1_Rod;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingQTE2;                                       // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingQTE2_Rod;                                   // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingMiss;                                       // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingMiss_Rod;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingLoop;                                       // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingLoop_Rod;                                   // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingResultStart;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingResultLoop;                                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingBait;                                       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingFaceSweat;                                  // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingHit;                                        // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingHit_Rod;                                    // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingStart2;                                     // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FishingStart2_Rod;                                 // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToFishGameCharaAnimationAssetInstance) == 0x000008, "Wrong alignment on FReferenceToFishGameCharaAnimationAssetInstance");
static_assert(sizeof(FReferenceToFishGameCharaAnimationAssetInstance) == 0x0000A0, "Wrong size on FReferenceToFishGameCharaAnimationAssetInstance");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingStart) == 0x000000, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingStart' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingStart_Rod) == 0x000008, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingStart_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingAction) == 0x000010, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingAction' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingAction_Rod) == 0x000018, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingAction_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingQTE1) == 0x000020, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingQTE1' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingQTE1_Rod) == 0x000028, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingQTE1_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingQTE2) == 0x000030, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingQTE2' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingQTE2_Rod) == 0x000038, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingQTE2_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingMiss) == 0x000040, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingMiss' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingMiss_Rod) == 0x000048, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingMiss_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingLoop) == 0x000050, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingLoop' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingLoop_Rod) == 0x000058, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingLoop_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingResultStart) == 0x000060, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingResultStart' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingResultLoop) == 0x000068, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingResultLoop' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingBait) == 0x000070, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingBait' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingFaceSweat) == 0x000078, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingFaceSweat' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingHit) == 0x000080, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingHit' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingHit_Rod) == 0x000088, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingHit_Rod' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingStart2) == 0x000090, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingStart2' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameCharaAnimationAssetInstance, FishingStart2_Rod) == 0x000098, "Member 'FReferenceToFishGameCharaAnimationAssetInstance::FishingStart2_Rod' has a wrong offset!");

// ScriptStruct AT.SkillDataTable
// 0x0060 (0x0068 - 0x0008)
struct FSkillDataTable final : public FTableRowBase
{
public:
	class FString                                 Discription;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Cost;                                              // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillAttribute                               SkillAttribute;                                    // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillActionType                              SkillType;                                         // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddBreakTime;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageId;                                         // 0x0028(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SkillTextureID;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAuraStrength                                 AuraStrengthID;                                    // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AuraWait;                                          // 0x004C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkillAssistCoolTime;                               // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelDamage[0x4];                                  // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLearnTraining;                                    // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ComboCancel;                                       // 0x0065(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAerialSkillBranchType                        AerialBranchType;                                  // 0x0066(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillDataTable) == 0x000008, "Wrong alignment on FSkillDataTable");
static_assert(sizeof(FSkillDataTable) == 0x000068, "Wrong size on FSkillDataTable");
static_assert(offsetof(FSkillDataTable, Discription) == 0x000008, "Member 'FSkillDataTable::Discription' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, Rarity) == 0x000018, "Member 'FSkillDataTable::Rarity' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, Cost) == 0x00001C, "Member 'FSkillDataTable::Cost' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, SkillAttribute) == 0x000020, "Member 'FSkillDataTable::SkillAttribute' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, SkillType) == 0x000021, "Member 'FSkillDataTable::SkillType' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, AddBreakTime) == 0x000024, "Member 'FSkillDataTable::AddBreakTime' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, MessageId) == 0x000028, "Member 'FSkillDataTable::MessageId' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, SkillTextureID) == 0x000038, "Member 'FSkillDataTable::SkillTextureID' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, AuraStrengthID) == 0x000048, "Member 'FSkillDataTable::AuraStrengthID' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, AuraWait) == 0x00004C, "Member 'FSkillDataTable::AuraWait' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, SkillAssistCoolTime) == 0x000050, "Member 'FSkillDataTable::SkillAssistCoolTime' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, LevelDamage) == 0x000054, "Member 'FSkillDataTable::LevelDamage' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, bLearnTraining) == 0x000064, "Member 'FSkillDataTable::bLearnTraining' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, ComboCancel) == 0x000065, "Member 'FSkillDataTable::ComboCancel' has a wrong offset!");
static_assert(offsetof(FSkillDataTable, AerialBranchType) == 0x000066, "Member 'FSkillDataTable::AerialBranchType' has a wrong offset!");

// ScriptStruct AT.PartyMember
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FPartyMember final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartyMember) == 0x000008, "Wrong alignment on FPartyMember");
static_assert(sizeof(FPartyMember) == 0x000028, "Wrong size on FPartyMember");

// ScriptStruct AT.LandMarkVisibleParam
// 0x0028 (0x0030 - 0x0008)
struct FLandMarkVisibleParam final : public FTableRowBase
{
public:
	ELandmarkIconType                             Type;                                              // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartProgress;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMainPhaseNo;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndProgress;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndMainPhaseNo;                                    // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLandMarkVisibleParam) == 0x000008, "Wrong alignment on FLandMarkVisibleParam");
static_assert(sizeof(FLandMarkVisibleParam) == 0x000030, "Wrong size on FLandMarkVisibleParam");
static_assert(offsetof(FLandMarkVisibleParam, Type) == 0x000008, "Member 'FLandMarkVisibleParam::Type' has a wrong offset!");
static_assert(offsetof(FLandMarkVisibleParam, StartProgress) == 0x000010, "Member 'FLandMarkVisibleParam::StartProgress' has a wrong offset!");
static_assert(offsetof(FLandMarkVisibleParam, StartMainPhaseNo) == 0x000018, "Member 'FLandMarkVisibleParam::StartMainPhaseNo' has a wrong offset!");
static_assert(offsetof(FLandMarkVisibleParam, EndProgress) == 0x000020, "Member 'FLandMarkVisibleParam::EndProgress' has a wrong offset!");
static_assert(offsetof(FLandMarkVisibleParam, EndMainPhaseNo) == 0x000028, "Member 'FLandMarkVisibleParam::EndMainPhaseNo' has a wrong offset!");

// ScriptStruct AT.ReferenceToBattleGroupAIAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToBattleGroupAIAssetInstance final
{
public:
	TSubclassOf<class UBattleGroupAIInfo>         GroupInfo;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToBattleGroupAIAssetInstance) == 0x000008, "Wrong alignment on FReferenceToBattleGroupAIAssetInstance");
static_assert(sizeof(FReferenceToBattleGroupAIAssetInstance) == 0x000008, "Wrong size on FReferenceToBattleGroupAIAssetInstance");
static_assert(offsetof(FReferenceToBattleGroupAIAssetInstance, GroupInfo) == 0x000000, "Member 'FReferenceToBattleGroupAIAssetInstance::GroupInfo' has a wrong offset!");

// ScriptStruct AT.CookingSequenceLevelName
// 0x0018 (0x0020 - 0x0008)
struct FCookingSequenceLevelName final : public FTableRowBase
{
public:
	class FName                                   C001SequenceLevelName;                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   C002CSequenceLevelName;                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   C002DSequenceLevelName;                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingSequenceLevelName) == 0x000008, "Wrong alignment on FCookingSequenceLevelName");
static_assert(sizeof(FCookingSequenceLevelName) == 0x000020, "Wrong size on FCookingSequenceLevelName");
static_assert(offsetof(FCookingSequenceLevelName, C001SequenceLevelName) == 0x000008, "Member 'FCookingSequenceLevelName::C001SequenceLevelName' has a wrong offset!");
static_assert(offsetof(FCookingSequenceLevelName, C002CSequenceLevelName) == 0x000010, "Member 'FCookingSequenceLevelName::C002CSequenceLevelName' has a wrong offset!");
static_assert(offsetof(FCookingSequenceLevelName, C002DSequenceLevelName) == 0x000018, "Member 'FCookingSequenceLevelName::C002DSequenceLevelName' has a wrong offset!");

// ScriptStruct AT.AreaChangeTrainingRewardParam
// 0x0028 (0x0030 - 0x0008)
struct FAreaChangeTrainingRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardItem01;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum01;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum02;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum03;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRewardItemForFirstTimeOnly01;                     // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRewardItemForFirstTimeOnly02;                     // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRewardItemForFirstTimeOnly03;                     // 0x002E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaChangeTrainingRewardParam) == 0x000008, "Wrong alignment on FAreaChangeTrainingRewardParam");
static_assert(sizeof(FAreaChangeTrainingRewardParam) == 0x000030, "Wrong size on FAreaChangeTrainingRewardParam");
static_assert(offsetof(FAreaChangeTrainingRewardParam, RewardItem01) == 0x000008, "Member 'FAreaChangeTrainingRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, RewardItem02) == 0x000010, "Member 'FAreaChangeTrainingRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, RewardItem03) == 0x000018, "Member 'FAreaChangeTrainingRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, RewardItemNum01) == 0x000020, "Member 'FAreaChangeTrainingRewardParam::RewardItemNum01' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, RewardItemNum02) == 0x000024, "Member 'FAreaChangeTrainingRewardParam::RewardItemNum02' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, RewardItemNum03) == 0x000028, "Member 'FAreaChangeTrainingRewardParam::RewardItemNum03' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, bRewardItemForFirstTimeOnly01) == 0x00002C, "Member 'FAreaChangeTrainingRewardParam::bRewardItemForFirstTimeOnly01' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, bRewardItemForFirstTimeOnly02) == 0x00002D, "Member 'FAreaChangeTrainingRewardParam::bRewardItemForFirstTimeOnly02' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingRewardParam, bRewardItemForFirstTimeOnly03) == 0x00002E, "Member 'FAreaChangeTrainingRewardParam::bRewardItemForFirstTimeOnly03' has a wrong offset!");

// ScriptStruct AT.AreaChangeTrainingParam
// 0x0088 (0x0090 - 0x0008)
struct FAreaChangeTrainingParam final : public FTableRowBase
{
public:
	int32                                         TrainingID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengingConditionTrainingId;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItemID;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExterminationBattleIDs;                            // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleMessageId;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestId;                                           // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MoveAreaName;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharacterName;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConditionalItems;                               // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ChangeCharacterNotifyMessageID;                    // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFadeInAfterAreaChange;                      // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAreaChangeTrainingParam) == 0x000008, "Wrong alignment on FAreaChangeTrainingParam");
static_assert(sizeof(FAreaChangeTrainingParam) == 0x000090, "Wrong size on FAreaChangeTrainingParam");
static_assert(offsetof(FAreaChangeTrainingParam, TrainingID) == 0x000008, "Member 'FAreaChangeTrainingParam::TrainingID' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, ChallengingConditionTrainingId) == 0x00000C, "Member 'FAreaChangeTrainingParam::ChallengingConditionTrainingId' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, RewardItemID) == 0x000010, "Member 'FAreaChangeTrainingParam::RewardItemID' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, EventBattleID) == 0x000018, "Member 'FAreaChangeTrainingParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, ExterminationBattleIDs) == 0x000020, "Member 'FAreaChangeTrainingParam::ExterminationBattleIDs' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, Recommendedlevel) == 0x000030, "Member 'FAreaChangeTrainingParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, TitleMessageId) == 0x000038, "Member 'FAreaChangeTrainingParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, QuestId) == 0x000048, "Member 'FAreaChangeTrainingParam::QuestId' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, MoveAreaName) == 0x000050, "Member 'FAreaChangeTrainingParam::MoveAreaName' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, CharacterType) == 0x000058, "Member 'FAreaChangeTrainingParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, CharacterName) == 0x000060, "Member 'FAreaChangeTrainingParam::CharacterName' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, bIsConditionalItems) == 0x000070, "Member 'FAreaChangeTrainingParam::bIsConditionalItems' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, ChangeCharacterNotifyMessageID) == 0x000078, "Member 'FAreaChangeTrainingParam::ChangeCharacterNotifyMessageID' has a wrong offset!");
static_assert(offsetof(FAreaChangeTrainingParam, bShouldFadeInAfterAreaChange) == 0x000088, "Member 'FAreaChangeTrainingParam::bShouldFadeInAfterAreaChange' has a wrong offset!");

// ScriptStruct AT.CmnMenuListParam
// 0x0068 (0x0068 - 0x0000)
struct FCmnMenuListParam final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               ItemType;                                          // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_CATEGORY_TYPE                      CategoryIconType;                                  // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemDetail;                                        // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemFlavor;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WhereToGet;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SellPrice;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0064(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNumDisp;                                        // 0x0065(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0066(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_67[0x1];                                       // 0x0067(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnMenuListParam) == 0x000008, "Wrong alignment on FCmnMenuListParam");
static_assert(sizeof(FCmnMenuListParam) == 0x000068, "Wrong size on FCmnMenuListParam");
static_assert(offsetof(FCmnMenuListParam, ItemId) == 0x000000, "Member 'FCmnMenuListParam::ItemId' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, Rarity) == 0x000008, "Member 'FCmnMenuListParam::Rarity' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, ItemType) == 0x00000C, "Member 'FCmnMenuListParam::ItemType' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, CategoryIconType) == 0x00000D, "Member 'FCmnMenuListParam::CategoryIconType' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, ItemName) == 0x000010, "Member 'FCmnMenuListParam::ItemName' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, ItemDetail) == 0x000020, "Member 'FCmnMenuListParam::ItemDetail' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, ItemFlavor) == 0x000030, "Member 'FCmnMenuListParam::ItemFlavor' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, WhereToGet) == 0x000040, "Member 'FCmnMenuListParam::WhereToGet' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, SellPrice) == 0x000050, "Member 'FCmnMenuListParam::SellPrice' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, ItemNum) == 0x000060, "Member 'FCmnMenuListParam::ItemNum' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, bIsNew) == 0x000064, "Member 'FCmnMenuListParam::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, bIsNumDisp) == 0x000065, "Member 'FCmnMenuListParam::bIsNumDisp' has a wrong offset!");
static_assert(offsetof(FCmnMenuListParam, bIsActive) == 0x000066, "Member 'FCmnMenuListParam::bIsActive' has a wrong offset!");

// ScriptStruct AT.RaceGameLoadLevelName
// 0x0010 (0x0018 - 0x0008)
struct FRaceGameLoadLevelName final : public FTableRowBase
{
public:
	class FName                                   AirCarLoadLevelName;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TwinFootLoadLevelName;                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRaceGameLoadLevelName) == 0x000008, "Wrong alignment on FRaceGameLoadLevelName");
static_assert(sizeof(FRaceGameLoadLevelName) == 0x000018, "Wrong size on FRaceGameLoadLevelName");
static_assert(offsetof(FRaceGameLoadLevelName, AirCarLoadLevelName) == 0x000008, "Member 'FRaceGameLoadLevelName::AirCarLoadLevelName' has a wrong offset!");
static_assert(offsetof(FRaceGameLoadLevelName, TwinFootLoadLevelName) == 0x000010, "Member 'FRaceGameLoadLevelName::TwinFootLoadLevelName' has a wrong offset!");

// ScriptStruct AT.CrowdTrainingRewardParam
// 0x0028 (0x0030 - 0x0008)
struct FCrowdTrainingRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardItem01;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum01;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum02;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum03;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCrowdTrainingRewardParam) == 0x000008, "Wrong alignment on FCrowdTrainingRewardParam");
static_assert(sizeof(FCrowdTrainingRewardParam) == 0x000030, "Wrong size on FCrowdTrainingRewardParam");
static_assert(offsetof(FCrowdTrainingRewardParam, RewardItem01) == 0x000008, "Member 'FCrowdTrainingRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingRewardParam, RewardItem02) == 0x000010, "Member 'FCrowdTrainingRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingRewardParam, RewardItem03) == 0x000018, "Member 'FCrowdTrainingRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingRewardParam, RewardItemNum01) == 0x000020, "Member 'FCrowdTrainingRewardParam::RewardItemNum01' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingRewardParam, RewardItemNum02) == 0x000024, "Member 'FCrowdTrainingRewardParam::RewardItemNum02' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingRewardParam, RewardItemNum03) == 0x000028, "Member 'FCrowdTrainingRewardParam::RewardItemNum03' has a wrong offset!");

// ScriptStruct AT.CollectionNavigation
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x08) FCollectionNavigation final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionNavigation) == 0x000008, "Wrong alignment on FCollectionNavigation");
static_assert(sizeof(FCollectionNavigation) == 0x000030, "Wrong size on FCollectionNavigation");

// ScriptStruct AT.CrowdTrainingParam
// 0x0030 (0x0038 - 0x0008)
struct FCrowdTrainingParam final : public FTableRowBase
{
public:
	int32                                         TrainingID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengingConditionTrainingId;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItemID;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleMessageId;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrowdTrainingParam) == 0x000008, "Wrong alignment on FCrowdTrainingParam");
static_assert(sizeof(FCrowdTrainingParam) == 0x000038, "Wrong size on FCrowdTrainingParam");
static_assert(offsetof(FCrowdTrainingParam, TrainingID) == 0x000008, "Member 'FCrowdTrainingParam::TrainingID' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingParam, ChallengingConditionTrainingId) == 0x00000C, "Member 'FCrowdTrainingParam::ChallengingConditionTrainingId' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingParam, RewardItemID) == 0x000010, "Member 'FCrowdTrainingParam::RewardItemID' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingParam, EventBattleID) == 0x000018, "Member 'FCrowdTrainingParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingParam, Recommendedlevel) == 0x000020, "Member 'FCrowdTrainingParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FCrowdTrainingParam, TitleMessageId) == 0x000028, "Member 'FCrowdTrainingParam::TitleMessageId' has a wrong offset!");

// ScriptStruct AT.ATCharacterDataTable
// 0x0100 (0x0108 - 0x0008)
struct FATCharacterDataTable final : public FTableRowBase
{
public:
	bool                                          PlayerCharacter;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SupportCharacter;                                  // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MotCode;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DLC;                                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERacialType                                   RacialType;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveIndex;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortIndex;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UniqueId;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESummonCondition                              SummonCondition_01;                                // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SummonCharacterID_01;                              // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_01;                       // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_01;                            // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_02;                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_02;                              // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_02;                       // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_02;                            // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_03;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_03;                              // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_03;                       // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_03;                            // 0x0089(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_04;                                // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_04;                              // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_04;                       // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_04;                            // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x2];                                       // 0x00A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_05;                                // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_05;                              // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_05;                       // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_05;                            // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x2];                                       // 0x00BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_06;                                // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_06;                              // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_06;                       // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_06;                            // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x2];                                       // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_07;                                // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_07;                              // 0x00D8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_07;                       // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_07;                            // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EA[0x2];                                       // 0x00EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ESummonCondition                              SummonCondition_08;                                // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummonCharacterID_08;                              // 0x00F0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterVariation_08;                       // 0x0100(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SummonCharacterForm_08;                            // 0x0101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATCharacterDataTable) == 0x000008, "Wrong alignment on FATCharacterDataTable");
static_assert(sizeof(FATCharacterDataTable) == 0x000108, "Wrong size on FATCharacterDataTable");
static_assert(offsetof(FATCharacterDataTable, PlayerCharacter) == 0x000008, "Member 'FATCharacterDataTable::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SupportCharacter) == 0x000009, "Member 'FATCharacterDataTable::SupportCharacter' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, Height) == 0x00000C, "Member 'FATCharacterDataTable::Height' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, Width) == 0x000010, "Member 'FATCharacterDataTable::Width' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, MotCode) == 0x000018, "Member 'FATCharacterDataTable::MotCode' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, DLC) == 0x000020, "Member 'FATCharacterDataTable::DLC' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, RacialType) == 0x000024, "Member 'FATCharacterDataTable::RacialType' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SaveIndex) == 0x000028, "Member 'FATCharacterDataTable::SaveIndex' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SortIndex) == 0x00002C, "Member 'FATCharacterDataTable::SortIndex' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, Level) == 0x000030, "Member 'FATCharacterDataTable::Level' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, UniqueId) == 0x000038, "Member 'FATCharacterDataTable::UniqueId' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_01) == 0x000040, "Member 'FATCharacterDataTable::SummonCondition_01' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_01) == 0x000048, "Member 'FATCharacterDataTable::SummonCharacterID_01' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_01) == 0x000058, "Member 'FATCharacterDataTable::SummonCharacterVariation_01' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_01) == 0x000059, "Member 'FATCharacterDataTable::SummonCharacterForm_01' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_02) == 0x00005C, "Member 'FATCharacterDataTable::SummonCondition_02' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_02) == 0x000060, "Member 'FATCharacterDataTable::SummonCharacterID_02' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_02) == 0x000070, "Member 'FATCharacterDataTable::SummonCharacterVariation_02' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_02) == 0x000071, "Member 'FATCharacterDataTable::SummonCharacterForm_02' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_03) == 0x000074, "Member 'FATCharacterDataTable::SummonCondition_03' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_03) == 0x000078, "Member 'FATCharacterDataTable::SummonCharacterID_03' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_03) == 0x000088, "Member 'FATCharacterDataTable::SummonCharacterVariation_03' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_03) == 0x000089, "Member 'FATCharacterDataTable::SummonCharacterForm_03' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_04) == 0x00008C, "Member 'FATCharacterDataTable::SummonCondition_04' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_04) == 0x000090, "Member 'FATCharacterDataTable::SummonCharacterID_04' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_04) == 0x0000A0, "Member 'FATCharacterDataTable::SummonCharacterVariation_04' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_04) == 0x0000A1, "Member 'FATCharacterDataTable::SummonCharacterForm_04' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_05) == 0x0000A4, "Member 'FATCharacterDataTable::SummonCondition_05' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_05) == 0x0000A8, "Member 'FATCharacterDataTable::SummonCharacterID_05' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_05) == 0x0000B8, "Member 'FATCharacterDataTable::SummonCharacterVariation_05' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_05) == 0x0000B9, "Member 'FATCharacterDataTable::SummonCharacterForm_05' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_06) == 0x0000BC, "Member 'FATCharacterDataTable::SummonCondition_06' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_06) == 0x0000C0, "Member 'FATCharacterDataTable::SummonCharacterID_06' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_06) == 0x0000D0, "Member 'FATCharacterDataTable::SummonCharacterVariation_06' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_06) == 0x0000D1, "Member 'FATCharacterDataTable::SummonCharacterForm_06' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_07) == 0x0000D4, "Member 'FATCharacterDataTable::SummonCondition_07' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_07) == 0x0000D8, "Member 'FATCharacterDataTable::SummonCharacterID_07' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_07) == 0x0000E8, "Member 'FATCharacterDataTable::SummonCharacterVariation_07' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_07) == 0x0000E9, "Member 'FATCharacterDataTable::SummonCharacterForm_07' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCondition_08) == 0x0000EC, "Member 'FATCharacterDataTable::SummonCondition_08' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterID_08) == 0x0000F0, "Member 'FATCharacterDataTable::SummonCharacterID_08' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterVariation_08) == 0x000100, "Member 'FATCharacterDataTable::SummonCharacterVariation_08' has a wrong offset!");
static_assert(offsetof(FATCharacterDataTable, SummonCharacterForm_08) == 0x000101, "Member 'FATCharacterDataTable::SummonCharacterForm_08' has a wrong offset!");

// ScriptStruct AT.ExperienceBonus
// 0x000C (0x000C - 0x0000)
struct FExperienceBonus final
{
public:
	float                                         ExperienceRate_S;                                  // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExperienceRate_A;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExperienceRate_B;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExperienceBonus) == 0x000004, "Wrong alignment on FExperienceBonus");
static_assert(sizeof(FExperienceBonus) == 0x00000C, "Wrong size on FExperienceBonus");
static_assert(offsetof(FExperienceBonus, ExperienceRate_S) == 0x000000, "Member 'FExperienceBonus::ExperienceRate_S' has a wrong offset!");
static_assert(offsetof(FExperienceBonus, ExperienceRate_A) == 0x000004, "Member 'FExperienceBonus::ExperienceRate_A' has a wrong offset!");
static_assert(offsetof(FExperienceBonus, ExperienceRate_B) == 0x000008, "Member 'FExperienceBonus::ExperienceRate_B' has a wrong offset!");

// ScriptStruct AT.ChallengeFreezerFRewardParam
// 0x0028 (0x0030 - 0x0008)
struct FChallengeFreezerFRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardItem01;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum01;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum02;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum03;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeFreezerFRewardParam) == 0x000008, "Wrong alignment on FChallengeFreezerFRewardParam");
static_assert(sizeof(FChallengeFreezerFRewardParam) == 0x000030, "Wrong size on FChallengeFreezerFRewardParam");
static_assert(offsetof(FChallengeFreezerFRewardParam, RewardItem01) == 0x000008, "Member 'FChallengeFreezerFRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFRewardParam, RewardItem02) == 0x000010, "Member 'FChallengeFreezerFRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFRewardParam, RewardItem03) == 0x000018, "Member 'FChallengeFreezerFRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFRewardParam, RewardItemNum01) == 0x000020, "Member 'FChallengeFreezerFRewardParam::RewardItemNum01' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFRewardParam, RewardItemNum02) == 0x000024, "Member 'FChallengeFreezerFRewardParam::RewardItemNum02' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFRewardParam, RewardItemNum03) == 0x000028, "Member 'FChallengeFreezerFRewardParam::RewardItemNum03' has a wrong offset!");

// ScriptStruct AT.ChallengeFreezerFParam
// 0x0058 (0x0060 - 0x0008)
struct FChallengeFreezerFParam final : public FTableRowBase
{
public:
	int32                                         TrainingID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengingConditionID;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChallengeFreezerFRewardID;                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleMessageId;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummaryMessageID;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BattleConfirmMessageID;                            // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRepeatedPlay;                                     // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayOnlyPlayer;                                // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeFreezerFParam) == 0x000008, "Wrong alignment on FChallengeFreezerFParam");
static_assert(sizeof(FChallengeFreezerFParam) == 0x000060, "Wrong size on FChallengeFreezerFParam");
static_assert(offsetof(FChallengeFreezerFParam, TrainingID) == 0x000008, "Member 'FChallengeFreezerFParam::TrainingID' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, ChallengingConditionID) == 0x00000C, "Member 'FChallengeFreezerFParam::ChallengingConditionID' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, ChallengeFreezerFRewardID) == 0x000010, "Member 'FChallengeFreezerFParam::ChallengeFreezerFRewardID' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, EventBattleID) == 0x000018, "Member 'FChallengeFreezerFParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, Recommendedlevel) == 0x000020, "Member 'FChallengeFreezerFParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, TitleMessageId) == 0x000028, "Member 'FChallengeFreezerFParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, SummaryMessageID) == 0x000038, "Member 'FChallengeFreezerFParam::SummaryMessageID' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, BattleConfirmMessageID) == 0x000048, "Member 'FChallengeFreezerFParam::BattleConfirmMessageID' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, bRepeatedPlay) == 0x000058, "Member 'FChallengeFreezerFParam::bRepeatedPlay' has a wrong offset!");
static_assert(offsetof(FChallengeFreezerFParam, bDisplayOnlyPlayer) == 0x000059, "Member 'FChallengeFreezerFParam::bDisplayOnlyPlayer' has a wrong offset!");

// ScriptStruct AT.ChallengeBeerusRewardParam
// 0x0028 (0x0030 - 0x0008)
struct FChallengeBeerusRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardItem01;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum01;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum02;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum03;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeBeerusRewardParam) == 0x000008, "Wrong alignment on FChallengeBeerusRewardParam");
static_assert(sizeof(FChallengeBeerusRewardParam) == 0x000030, "Wrong size on FChallengeBeerusRewardParam");
static_assert(offsetof(FChallengeBeerusRewardParam, RewardItem01) == 0x000008, "Member 'FChallengeBeerusRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusRewardParam, RewardItem02) == 0x000010, "Member 'FChallengeBeerusRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusRewardParam, RewardItem03) == 0x000018, "Member 'FChallengeBeerusRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusRewardParam, RewardItemNum01) == 0x000020, "Member 'FChallengeBeerusRewardParam::RewardItemNum01' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusRewardParam, RewardItemNum02) == 0x000024, "Member 'FChallengeBeerusRewardParam::RewardItemNum02' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusRewardParam, RewardItemNum03) == 0x000028, "Member 'FChallengeBeerusRewardParam::RewardItemNum03' has a wrong offset!");

// ScriptStruct AT.PassiveSkillSlotReleaseConditionsTable
// 0x0020 (0x0028 - 0x0008)
struct FPassiveSkillSlotReleaseConditionsTable final : public FTableRowBase
{
public:
	class FName                                   OpenQuest;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MessageId;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveSkillSlotReleaseConditionsTable) == 0x000008, "Wrong alignment on FPassiveSkillSlotReleaseConditionsTable");
static_assert(sizeof(FPassiveSkillSlotReleaseConditionsTable) == 0x000028, "Wrong size on FPassiveSkillSlotReleaseConditionsTable");
static_assert(offsetof(FPassiveSkillSlotReleaseConditionsTable, OpenQuest) == 0x000008, "Member 'FPassiveSkillSlotReleaseConditionsTable::OpenQuest' has a wrong offset!");
static_assert(offsetof(FPassiveSkillSlotReleaseConditionsTable, CharacterLevel) == 0x000010, "Member 'FPassiveSkillSlotReleaseConditionsTable::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FPassiveSkillSlotReleaseConditionsTable, MessageId) == 0x000018, "Member 'FPassiveSkillSlotReleaseConditionsTable::MessageId' has a wrong offset!");

// ScriptStruct AT.ChallengeBeerusParam
// 0x0050 (0x0058 - 0x0008)
struct FChallengeBeerusParam final : public FTableRowBase
{
public:
	int32                                         TrainingID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ChallengeBeerusRewardID;                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleMessageId;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummaryMessageID;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DlcId;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeBeerusParam) == 0x000008, "Wrong alignment on FChallengeBeerusParam");
static_assert(sizeof(FChallengeBeerusParam) == 0x000058, "Wrong size on FChallengeBeerusParam");
static_assert(offsetof(FChallengeBeerusParam, TrainingID) == 0x000008, "Member 'FChallengeBeerusParam::TrainingID' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, ChallengeBeerusRewardID) == 0x000010, "Member 'FChallengeBeerusParam::ChallengeBeerusRewardID' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, EventBattleID) == 0x000018, "Member 'FChallengeBeerusParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, Recommendedlevel) == 0x000020, "Member 'FChallengeBeerusParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, TitleMessageId) == 0x000028, "Member 'FChallengeBeerusParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, SummaryMessageID) == 0x000038, "Member 'FChallengeBeerusParam::SummaryMessageID' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, CharacterType) == 0x000048, "Member 'FChallengeBeerusParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FChallengeBeerusParam, DlcId) == 0x000050, "Member 'FChallengeBeerusParam::DlcId' has a wrong offset!");

// ScriptStruct AT.ATSaveOption
// 0x0270 (0x0270 - 0x0000)
struct FATSaveOption final
{
public:
	struct FATSaveSystemOption                    SystemOption;                                      // 0x0000(0x026C)(NoDestructor, NativeAccessSpecifierPublic)
	EOptionDifficulty                             Difficulty;                                        // 0x026C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATSaveOption) == 0x000004, "Wrong alignment on FATSaveOption");
static_assert(sizeof(FATSaveOption) == 0x000270, "Wrong size on FATSaveOption");
static_assert(offsetof(FATSaveOption, SystemOption) == 0x000000, "Member 'FATSaveOption::SystemOption' has a wrong offset!");
static_assert(offsetof(FATSaveOption, Difficulty) == 0x00026C, "Member 'FATSaveOption::Difficulty' has a wrong offset!");

// ScriptStruct AT.SuperTrainingRewardParam
// 0x0028 (0x0030 - 0x0008)
struct FSuperTrainingRewardParam final : public FTableRowBase
{
public:
	class FName                                   RewardItem01;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem02;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem03;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum01;                                   // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum02;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum03;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSuperTrainingRewardParam) == 0x000008, "Wrong alignment on FSuperTrainingRewardParam");
static_assert(sizeof(FSuperTrainingRewardParam) == 0x000030, "Wrong size on FSuperTrainingRewardParam");
static_assert(offsetof(FSuperTrainingRewardParam, RewardItem01) == 0x000008, "Member 'FSuperTrainingRewardParam::RewardItem01' has a wrong offset!");
static_assert(offsetof(FSuperTrainingRewardParam, RewardItem02) == 0x000010, "Member 'FSuperTrainingRewardParam::RewardItem02' has a wrong offset!");
static_assert(offsetof(FSuperTrainingRewardParam, RewardItem03) == 0x000018, "Member 'FSuperTrainingRewardParam::RewardItem03' has a wrong offset!");
static_assert(offsetof(FSuperTrainingRewardParam, RewardItemNum01) == 0x000020, "Member 'FSuperTrainingRewardParam::RewardItemNum01' has a wrong offset!");
static_assert(offsetof(FSuperTrainingRewardParam, RewardItemNum02) == 0x000024, "Member 'FSuperTrainingRewardParam::RewardItemNum02' has a wrong offset!");
static_assert(offsetof(FSuperTrainingRewardParam, RewardItemNum03) == 0x000028, "Member 'FSuperTrainingRewardParam::RewardItemNum03' has a wrong offset!");

// ScriptStruct AT.SuperTrainingParam
// 0x0030 (0x0038 - 0x0008)
struct FSuperTrainingParam final : public FTableRowBase
{
public:
	int32                                         TrainingID;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengingConditionTrainingId;                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItemID;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TitleMessageId;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSuperTrainingParam) == 0x000008, "Wrong alignment on FSuperTrainingParam");
static_assert(sizeof(FSuperTrainingParam) == 0x000038, "Wrong size on FSuperTrainingParam");
static_assert(offsetof(FSuperTrainingParam, TrainingID) == 0x000008, "Member 'FSuperTrainingParam::TrainingID' has a wrong offset!");
static_assert(offsetof(FSuperTrainingParam, ChallengingConditionTrainingId) == 0x00000C, "Member 'FSuperTrainingParam::ChallengingConditionTrainingId' has a wrong offset!");
static_assert(offsetof(FSuperTrainingParam, RewardItemID) == 0x000010, "Member 'FSuperTrainingParam::RewardItemID' has a wrong offset!");
static_assert(offsetof(FSuperTrainingParam, EventBattleID) == 0x000018, "Member 'FSuperTrainingParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FSuperTrainingParam, Recommendedlevel) == 0x000020, "Member 'FSuperTrainingParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FSuperTrainingParam, TitleMessageId) == 0x000028, "Member 'FSuperTrainingParam::TitleMessageId' has a wrong offset!");

// ScriptStruct AT.AddExpOverwriteCharacterTypeInfo
// 0x0002 (0x0002 - 0x0000)
struct FAddExpOverwriteCharacterTypeInfo final
{
public:
	ECHARACTER_TYPE                               CurrentAddExpPlayerCharacter;                      // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               OverwriteAddExpPlayerCharacter;                    // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddExpOverwriteCharacterTypeInfo) == 0x000001, "Wrong alignment on FAddExpOverwriteCharacterTypeInfo");
static_assert(sizeof(FAddExpOverwriteCharacterTypeInfo) == 0x000002, "Wrong size on FAddExpOverwriteCharacterTypeInfo");
static_assert(offsetof(FAddExpOverwriteCharacterTypeInfo, CurrentAddExpPlayerCharacter) == 0x000000, "Member 'FAddExpOverwriteCharacterTypeInfo::CurrentAddExpPlayerCharacter' has a wrong offset!");
static_assert(offsetof(FAddExpOverwriteCharacterTypeInfo, OverwriteAddExpPlayerCharacter) == 0x000001, "Member 'FAddExpOverwriteCharacterTypeInfo::OverwriteAddExpPlayerCharacter' has a wrong offset!");

// ScriptStruct AT.SimulationBattleParam
// 0x0040 (0x0048 - 0x0008)
struct FSimulationBattleParam final : public FTableRowBase
{
public:
	int32                                         SimulationID;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChallengingConditionSimulatorId;                   // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardItem;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfDefeatedEnemies;                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleMessageId;                                    // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SummaryMessageID;                                  // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimulationBattleParam) == 0x000008, "Wrong alignment on FSimulationBattleParam");
static_assert(sizeof(FSimulationBattleParam) == 0x000048, "Wrong size on FSimulationBattleParam");
static_assert(offsetof(FSimulationBattleParam, SimulationID) == 0x000008, "Member 'FSimulationBattleParam::SimulationID' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, ChallengingConditionSimulatorId) == 0x00000C, "Member 'FSimulationBattleParam::ChallengingConditionSimulatorId' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, RewardItem) == 0x000010, "Member 'FSimulationBattleParam::RewardItem' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, EventBattleID) == 0x000018, "Member 'FSimulationBattleParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, Recommendedlevel) == 0x000020, "Member 'FSimulationBattleParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, NumberOfDefeatedEnemies) == 0x000024, "Member 'FSimulationBattleParam::NumberOfDefeatedEnemies' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, TitleMessageId) == 0x000028, "Member 'FSimulationBattleParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FSimulationBattleParam, SummaryMessageID) == 0x000038, "Member 'FSimulationBattleParam::SummaryMessageID' has a wrong offset!");

// ScriptStruct AT.TrainingBattleParam
// 0x0058 (0x0060 - 0x0008)
struct FTrainingBattleParam final : public FTableRowBase
{
public:
	EFilteredCharacterType                        Character;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ChallengeLevel;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GetItem1;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemAmount1;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GetItem2;                                          // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemAmount2;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GetSuperPassive;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventBattleID;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEndContent;                                     // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TrainingEndContentID;                              // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UnlockEndContentID;                                // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnlockStringID;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpecificStringID;                                  // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainingBattleParam) == 0x000008, "Wrong alignment on FTrainingBattleParam");
static_assert(sizeof(FTrainingBattleParam) == 0x000060, "Wrong size on FTrainingBattleParam");
static_assert(offsetof(FTrainingBattleParam, Character) == 0x000008, "Member 'FTrainingBattleParam::Character' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, ChallengeLevel) == 0x00000C, "Member 'FTrainingBattleParam::ChallengeLevel' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, GetItem1) == 0x000010, "Member 'FTrainingBattleParam::GetItem1' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, ItemAmount1) == 0x000018, "Member 'FTrainingBattleParam::ItemAmount1' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, GetItem2) == 0x000020, "Member 'FTrainingBattleParam::GetItem2' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, ItemAmount2) == 0x000028, "Member 'FTrainingBattleParam::ItemAmount2' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, GetSuperPassive) == 0x000030, "Member 'FTrainingBattleParam::GetSuperPassive' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, EventBattleID) == 0x000038, "Member 'FTrainingBattleParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, Recommendedlevel) == 0x000040, "Member 'FTrainingBattleParam::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, bIsEndContent) == 0x000044, "Member 'FTrainingBattleParam::bIsEndContent' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, TrainingEndContentID) == 0x000048, "Member 'FTrainingBattleParam::TrainingEndContentID' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, UnlockEndContentID) == 0x00004C, "Member 'FTrainingBattleParam::UnlockEndContentID' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, UnlockStringID) == 0x000050, "Member 'FTrainingBattleParam::UnlockStringID' has a wrong offset!");
static_assert(offsetof(FTrainingBattleParam, SpecificStringID) == 0x000058, "Member 'FTrainingBattleParam::SpecificStringID' has a wrong offset!");

// ScriptStruct AT.SkillLearningItemTable
// 0x0008 (0x0010 - 0x0008)
struct FSkillLearningItemTable final : public FTableRowBase
{
public:
	class FName                                   LearnedSkillID;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillLearningItemTable) == 0x000008, "Wrong alignment on FSkillLearningItemTable");
static_assert(sizeof(FSkillLearningItemTable) == 0x000010, "Wrong size on FSkillLearningItemTable");
static_assert(offsetof(FSkillLearningItemTable, LearnedSkillID) == 0x000008, "Member 'FSkillLearningItemTable::LearnedSkillID' has a wrong offset!");

// ScriptStruct AT.SerializeMiniQuestParam
// 0x0010 (0x0018 - 0x0008)
struct FSerializeMiniQuestParam final : public FTableRowBase
{
public:
	class FName                                   CharacterName;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaID;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSerializeMiniQuestParam) == 0x000008, "Wrong alignment on FSerializeMiniQuestParam");
static_assert(sizeof(FSerializeMiniQuestParam) == 0x000018, "Wrong size on FSerializeMiniQuestParam");
static_assert(offsetof(FSerializeMiniQuestParam, CharacterName) == 0x000008, "Member 'FSerializeMiniQuestParam::CharacterName' has a wrong offset!");
static_assert(offsetof(FSerializeMiniQuestParam, AreaID) == 0x000010, "Member 'FSerializeMiniQuestParam::AreaID' has a wrong offset!");

// ScriptStruct AT.AT_UICursorParam
// 0x0010 (0x0010 - 0x0000)
struct FAT_UICursorParam final
{
public:
	class UImage*                                 Instanse;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               DynamicMat;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAT_UICursorParam) == 0x000008, "Wrong alignment on FAT_UICursorParam");
static_assert(sizeof(FAT_UICursorParam) == 0x000010, "Wrong size on FAT_UICursorParam");
static_assert(offsetof(FAT_UICursorParam, Instanse) == 0x000000, "Member 'FAT_UICursorParam::Instanse' has a wrong offset!");
static_assert(offsetof(FAT_UICursorParam, DynamicMat) == 0x000008, "Member 'FAT_UICursorParam::DynamicMat' has a wrong offset!");

// ScriptStruct AT.TrainingRemodelingParam
// 0x0060 (0x0068 - 0x0008)
struct FTrainingRemodelingParam final : public FTableRowBase
{
public:
	int32                                         RemodelingLevel;                                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RemodelingTitle;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RemodelingDetail;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZenyConditions;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DmedalAmount;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemConditions1;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionsAmount1;                                 // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemConditions2;                                   // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionsAmount2;                                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemConditions3;                                   // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConditionsAmount3;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrainingRemodelingParam) == 0x000008, "Wrong alignment on FTrainingRemodelingParam");
static_assert(sizeof(FTrainingRemodelingParam) == 0x000068, "Wrong size on FTrainingRemodelingParam");
static_assert(offsetof(FTrainingRemodelingParam, RemodelingLevel) == 0x000008, "Member 'FTrainingRemodelingParam::RemodelingLevel' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, RemodelingTitle) == 0x000010, "Member 'FTrainingRemodelingParam::RemodelingTitle' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, RemodelingDetail) == 0x000020, "Member 'FTrainingRemodelingParam::RemodelingDetail' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ZenyConditions) == 0x000030, "Member 'FTrainingRemodelingParam::ZenyConditions' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, DmedalAmount) == 0x000034, "Member 'FTrainingRemodelingParam::DmedalAmount' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ItemConditions1) == 0x000038, "Member 'FTrainingRemodelingParam::ItemConditions1' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ConditionsAmount1) == 0x000040, "Member 'FTrainingRemodelingParam::ConditionsAmount1' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ItemConditions2) == 0x000048, "Member 'FTrainingRemodelingParam::ItemConditions2' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ConditionsAmount2) == 0x000050, "Member 'FTrainingRemodelingParam::ConditionsAmount2' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ItemConditions3) == 0x000058, "Member 'FTrainingRemodelingParam::ItemConditions3' has a wrong offset!");
static_assert(offsetof(FTrainingRemodelingParam, ConditionsAmount3) == 0x000060, "Member 'FTrainingRemodelingParam::ConditionsAmount3' has a wrong offset!");

// ScriptStruct AT.TrainingConditionDataParam
// 0x0028 (0x0028 - 0x0000)
struct FTrainingConditionDataParam final
{
public:
	ETrainingDataConditionType                    Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Value;                                             // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageId;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTrainingConditionDataParam) == 0x000008, "Wrong alignment on FTrainingConditionDataParam");
static_assert(sizeof(FTrainingConditionDataParam) == 0x000028, "Wrong size on FTrainingConditionDataParam");
static_assert(offsetof(FTrainingConditionDataParam, Type) == 0x000000, "Member 'FTrainingConditionDataParam::Type' has a wrong offset!");
static_assert(offsetof(FTrainingConditionDataParam, Value) == 0x000008, "Member 'FTrainingConditionDataParam::Value' has a wrong offset!");
static_assert(offsetof(FTrainingConditionDataParam, MessageId) == 0x000018, "Member 'FTrainingConditionDataParam::MessageId' has a wrong offset!");

// ScriptStruct AT.TrainingDataParam
// 0x0028 (0x0030 - 0x0008)
struct FTrainingDataParam final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SkillId;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FTrainingConditionDataParam>    LearningCondition;                                 // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrainingDataParam) == 0x000008, "Wrong alignment on FTrainingDataParam");
static_assert(sizeof(FTrainingDataParam) == 0x000030, "Wrong size on FTrainingDataParam");
static_assert(offsetof(FTrainingDataParam, CharacterType) == 0x000008, "Member 'FTrainingDataParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FTrainingDataParam, SkillId) == 0x000010, "Member 'FTrainingDataParam::SkillId' has a wrong offset!");
static_assert(offsetof(FTrainingDataParam, LearningCondition) == 0x000018, "Member 'FTrainingDataParam::LearningCondition' has a wrong offset!");
static_assert(offsetof(FTrainingDataParam, Recommendedlevel) == 0x000028, "Member 'FTrainingDataParam::Recommendedlevel' has a wrong offset!");

// ScriptStruct AT.LoadingCrossTalkAsset
// 0x0038 (0x0038 - 0x0000)
struct FLoadingCrossTalkAsset final
{
public:
	TSoftObjectPtr<class UDataTable>              ConditionDataTable;                                // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UDataTable>>      EventDataTableArray;                               // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingCrossTalkAsset) == 0x000008, "Wrong alignment on FLoadingCrossTalkAsset");
static_assert(sizeof(FLoadingCrossTalkAsset) == 0x000038, "Wrong size on FLoadingCrossTalkAsset");
static_assert(offsetof(FLoadingCrossTalkAsset, ConditionDataTable) == 0x000000, "Member 'FLoadingCrossTalkAsset::ConditionDataTable' has a wrong offset!");
static_assert(offsetof(FLoadingCrossTalkAsset, EventDataTableArray) == 0x000028, "Member 'FLoadingCrossTalkAsset::EventDataTableArray' has a wrong offset!");

// ScriptStruct AT.ATStarScaleFinishAreaTable
// 0x0010 (0x0018 - 0x0008)
struct FATStarScaleFinishAreaTable final : public FTableRowBase
{
public:
	class FString                                 StarLevelName;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATStarScaleFinishAreaTable) == 0x000008, "Wrong alignment on FATStarScaleFinishAreaTable");
static_assert(sizeof(FATStarScaleFinishAreaTable) == 0x000018, "Wrong size on FATStarScaleFinishAreaTable");
static_assert(offsetof(FATStarScaleFinishAreaTable, StarLevelName) == 0x000008, "Member 'FATStarScaleFinishAreaTable::StarLevelName' has a wrong offset!");

// ScriptStruct AT.TrainingEventBattleExtendedParam
// 0x0010 (0x0018 - 0x0008)
struct FTrainingEventBattleExtendedParam final : public FTableRowBase
{
public:
	class FName                                   EventBattleID;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               PlayerCharacter;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter1;                                 // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter2;                                 // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTrainingEventBattleExtendedParam) == 0x000008, "Wrong alignment on FTrainingEventBattleExtendedParam");
static_assert(sizeof(FTrainingEventBattleExtendedParam) == 0x000018, "Wrong size on FTrainingEventBattleExtendedParam");
static_assert(offsetof(FTrainingEventBattleExtendedParam, EventBattleID) == 0x000008, "Member 'FTrainingEventBattleExtendedParam::EventBattleID' has a wrong offset!");
static_assert(offsetof(FTrainingEventBattleExtendedParam, PlayerCharacter) == 0x000010, "Member 'FTrainingEventBattleExtendedParam::PlayerCharacter' has a wrong offset!");
static_assert(offsetof(FTrainingEventBattleExtendedParam, SupportCharacter1) == 0x000011, "Member 'FTrainingEventBattleExtendedParam::SupportCharacter1' has a wrong offset!");
static_assert(offsetof(FTrainingEventBattleExtendedParam, SupportCharacter2) == 0x000012, "Member 'FTrainingEventBattleExtendedParam::SupportCharacter2' has a wrong offset!");

// ScriptStruct AT.LoadingEventBattlePostProcessEffectAsset
// 0x0078 (0x0078 - 0x0000)
struct FLoadingEventBattlePostProcessEffectAsset final
{
public:
	TSoftObjectPtr<class UParticleSystem>         ATPostProcessEffectCmnHologram_NoiseEffect;        // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               ATPostProcessEffectCmnHologram_Material;           // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               ATPostEffectCmnSkillAquisition_Material;           // 0x0050(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingEventBattlePostProcessEffectAsset) == 0x000008, "Wrong alignment on FLoadingEventBattlePostProcessEffectAsset");
static_assert(sizeof(FLoadingEventBattlePostProcessEffectAsset) == 0x000078, "Wrong size on FLoadingEventBattlePostProcessEffectAsset");
static_assert(offsetof(FLoadingEventBattlePostProcessEffectAsset, ATPostProcessEffectCmnHologram_NoiseEffect) == 0x000000, "Member 'FLoadingEventBattlePostProcessEffectAsset::ATPostProcessEffectCmnHologram_NoiseEffect' has a wrong offset!");
static_assert(offsetof(FLoadingEventBattlePostProcessEffectAsset, ATPostProcessEffectCmnHologram_Material) == 0x000028, "Member 'FLoadingEventBattlePostProcessEffectAsset::ATPostProcessEffectCmnHologram_Material' has a wrong offset!");
static_assert(offsetof(FLoadingEventBattlePostProcessEffectAsset, ATPostEffectCmnSkillAquisition_Material) == 0x000050, "Member 'FLoadingEventBattlePostProcessEffectAsset::ATPostEffectCmnSkillAquisition_Material' has a wrong offset!");

// ScriptStruct AT.ItemTableChip
// 0x0020 (0x0060 - 0x0040)
struct FItemTableChip final : public FItemInfoParam
{
public:
	EItemChipType                                 Type;                                              // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CostMemory;                                        // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Jump;                                              // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Battery;                                           // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rader;                                             // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Efficiency;                                        // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Discoverability;                                   // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTableChip) == 0x000008, "Wrong alignment on FItemTableChip");
static_assert(sizeof(FItemTableChip) == 0x000060, "Wrong size on FItemTableChip");
static_assert(offsetof(FItemTableChip, Type) == 0x000040, "Member 'FItemTableChip::Type' has a wrong offset!");
static_assert(offsetof(FItemTableChip, CostMemory) == 0x000044, "Member 'FItemTableChip::CostMemory' has a wrong offset!");
static_assert(offsetof(FItemTableChip, Speed) == 0x000048, "Member 'FItemTableChip::Speed' has a wrong offset!");
static_assert(offsetof(FItemTableChip, Jump) == 0x00004C, "Member 'FItemTableChip::Jump' has a wrong offset!");
static_assert(offsetof(FItemTableChip, Battery) == 0x000050, "Member 'FItemTableChip::Battery' has a wrong offset!");
static_assert(offsetof(FItemTableChip, Rader) == 0x000054, "Member 'FItemTableChip::Rader' has a wrong offset!");
static_assert(offsetof(FItemTableChip, Efficiency) == 0x000058, "Member 'FItemTableChip::Efficiency' has a wrong offset!");
static_assert(offsetof(FItemTableChip, Discoverability) == 0x00005C, "Member 'FItemTableChip::Discoverability' has a wrong offset!");

// ScriptStruct AT.CharacterDetailParam
// 0x0050 (0x0058 - 0x0008)
struct FCharacterDetailParam final : public FTableRowBase
{
public:
	int32                                         ModelMasterId;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NameId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BirthDateId;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RaceId;                                            // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OccupationId;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FavoriteRides;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DebutId;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CVId;                                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DetailId;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Episode;                                           // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterDetailParam) == 0x000008, "Wrong alignment on FCharacterDetailParam");
static_assert(sizeof(FCharacterDetailParam) == 0x000058, "Wrong size on FCharacterDetailParam");
static_assert(offsetof(FCharacterDetailParam, ModelMasterId) == 0x000008, "Member 'FCharacterDetailParam::ModelMasterId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, NameId) == 0x000010, "Member 'FCharacterDetailParam::NameId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, BirthDateId) == 0x000018, "Member 'FCharacterDetailParam::BirthDateId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, RaceId) == 0x000020, "Member 'FCharacterDetailParam::RaceId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, OccupationId) == 0x000028, "Member 'FCharacterDetailParam::OccupationId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, FavoriteRides) == 0x000030, "Member 'FCharacterDetailParam::FavoriteRides' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, DebutId) == 0x000038, "Member 'FCharacterDetailParam::DebutId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, CVId) == 0x000040, "Member 'FCharacterDetailParam::CVId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, DetailId) == 0x000048, "Member 'FCharacterDetailParam::DetailId' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, Chapter) == 0x000050, "Member 'FCharacterDetailParam::Chapter' has a wrong offset!");
static_assert(offsetof(FCharacterDetailParam, Episode) == 0x000054, "Member 'FCharacterDetailParam::Episode' has a wrong offset!");

// ScriptStruct AT.WishLotteryParam
// 0x0018 (0x0020 - 0x0008)
struct FWishLotteryParam final : public FTableRowBase
{
public:
	int32                                         ItemGroupId;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWishLotteryParam) == 0x000008, "Wrong alignment on FWishLotteryParam");
static_assert(sizeof(FWishLotteryParam) == 0x000020, "Wrong size on FWishLotteryParam");
static_assert(offsetof(FWishLotteryParam, ItemGroupId) == 0x000008, "Member 'FWishLotteryParam::ItemGroupId' has a wrong offset!");
static_assert(offsetof(FWishLotteryParam, ItemName) == 0x000010, "Member 'FWishLotteryParam::ItemName' has a wrong offset!");
static_assert(offsetof(FWishLotteryParam, Count) == 0x000018, "Member 'FWishLotteryParam::Count' has a wrong offset!");

// ScriptStruct AT.ReferenceToBaseballGameCommonAssetInstance
// 0x01D8 (0x01D8 - 0x0000)
struct FReferenceToBaseballGameCommonAssetInstance final
{
public:
	class USkeletalMesh*                          BallMesh;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          BatMesh;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          GroveMesh;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          StraightBallAnimSequence;                          // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          CurveBallAnimSequence;                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          ForkBallAnimSequence;                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          KnuckleBallAnimSequence;                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          SpiralBallAnimSequence;                            // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          WaveBallAnimSequence;                              // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitR01_01ST_Montage;                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitR01_02LP_Montage;                              // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowR01_01ST_Montage;                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowR01_02LP_Montage;                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowR01_03ED_Montage;                             // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitR01_L_01ST_Montage;                             // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitR01_L_02LP_Montage;                             // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitR01_R_01ST_Montage;                             // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           HitR01_R_02LP_Montage;                             // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitR01_01ST_Aura_Montage;                         // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitR01_02LP_Aura_Montage;                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitR01_02LP_NoLoop_Aura_Montage;                  // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowR01_01ST_Aura_Montage;                        // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowR01_02LP_Aura_Montage;                        // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ThrowR01_03ED_Aura_Montage;                        // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Wait01_Montage;                                    // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwingWait_Montage;                                 // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwingMiss_Montage;                                 // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swing01_01ST_Montage;                              // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swing01_02LP_Montage;                              // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swing01_03ED_Montage;                              // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Wait01_Aura_Montage;                               // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwingWait_Aura_Montage;                            // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SwingMiss_Aura_Montage;                            // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swing01_01ST_Aura_Montage;                         // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swing01_02LP_Aura_Montage;                         // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Swing01_03ED_Aura_Montage;                         // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Result_Montage;                                    // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BallAuraBlueS_Particle;                            // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BallAuraBlueL_Particle;                            // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BallAuraRedS_Particle;                             // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        BallAuraRedL_Particle;                             // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Hit_Particle;                                      // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitDist_Particle;                                  // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Radiation_Particle;                                // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ConstantDataTable;                                 // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             PitcherDataTable;                                  // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BallDataTable;                                     // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BallTypeDataTable;                                 // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HitTimingDataTable;                                // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CameraDataTable;                                   // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BattlePowerDataTable;                              // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CutinDataTable;                                    // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MobPresetDataTable;                                // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Mob_Man_Reaction01;                                // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Mob_Man_Reaction02;                                // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Mob_Man_Reaction03;                                // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Mob_Woman_Reaction01;                              // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Mob_Woman_Reaction02;                              // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Mob_Kid_Reaction01;                                // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToBaseballGameCommonAssetInstance) == 0x000008, "Wrong alignment on FReferenceToBaseballGameCommonAssetInstance");
static_assert(sizeof(FReferenceToBaseballGameCommonAssetInstance) == 0x0001D8, "Wrong size on FReferenceToBaseballGameCommonAssetInstance");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallMesh) == 0x000000, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BatMesh) == 0x000008, "Member 'FReferenceToBaseballGameCommonAssetInstance::BatMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, GroveMesh) == 0x000010, "Member 'FReferenceToBaseballGameCommonAssetInstance::GroveMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, StraightBallAnimSequence) == 0x000018, "Member 'FReferenceToBaseballGameCommonAssetInstance::StraightBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, CurveBallAnimSequence) == 0x000020, "Member 'FReferenceToBaseballGameCommonAssetInstance::CurveBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ForkBallAnimSequence) == 0x000028, "Member 'FReferenceToBaseballGameCommonAssetInstance::ForkBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, KnuckleBallAnimSequence) == 0x000030, "Member 'FReferenceToBaseballGameCommonAssetInstance::KnuckleBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, SpiralBallAnimSequence) == 0x000038, "Member 'FReferenceToBaseballGameCommonAssetInstance::SpiralBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, WaveBallAnimSequence) == 0x000040, "Member 'FReferenceToBaseballGameCommonAssetInstance::WaveBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, WaitR01_01ST_Montage) == 0x000048, "Member 'FReferenceToBaseballGameCommonAssetInstance::WaitR01_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, WaitR01_02LP_Montage) == 0x000050, "Member 'FReferenceToBaseballGameCommonAssetInstance::WaitR01_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ThrowR01_01ST_Montage) == 0x000058, "Member 'FReferenceToBaseballGameCommonAssetInstance::ThrowR01_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ThrowR01_02LP_Montage) == 0x000060, "Member 'FReferenceToBaseballGameCommonAssetInstance::ThrowR01_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ThrowR01_03ED_Montage) == 0x000068, "Member 'FReferenceToBaseballGameCommonAssetInstance::ThrowR01_03ED_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, HitR01_L_01ST_Montage) == 0x000070, "Member 'FReferenceToBaseballGameCommonAssetInstance::HitR01_L_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, HitR01_L_02LP_Montage) == 0x000078, "Member 'FReferenceToBaseballGameCommonAssetInstance::HitR01_L_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, HitR01_R_01ST_Montage) == 0x000080, "Member 'FReferenceToBaseballGameCommonAssetInstance::HitR01_R_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, HitR01_R_02LP_Montage) == 0x000088, "Member 'FReferenceToBaseballGameCommonAssetInstance::HitR01_R_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, WaitR01_01ST_Aura_Montage) == 0x000090, "Member 'FReferenceToBaseballGameCommonAssetInstance::WaitR01_01ST_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, WaitR01_02LP_Aura_Montage) == 0x000098, "Member 'FReferenceToBaseballGameCommonAssetInstance::WaitR01_02LP_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, WaitR01_02LP_NoLoop_Aura_Montage) == 0x0000A0, "Member 'FReferenceToBaseballGameCommonAssetInstance::WaitR01_02LP_NoLoop_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ThrowR01_01ST_Aura_Montage) == 0x0000A8, "Member 'FReferenceToBaseballGameCommonAssetInstance::ThrowR01_01ST_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ThrowR01_02LP_Aura_Montage) == 0x0000B0, "Member 'FReferenceToBaseballGameCommonAssetInstance::ThrowR01_02LP_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ThrowR01_03ED_Aura_Montage) == 0x0000B8, "Member 'FReferenceToBaseballGameCommonAssetInstance::ThrowR01_03ED_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Wait01_Montage) == 0x0000C0, "Member 'FReferenceToBaseballGameCommonAssetInstance::Wait01_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, SwingWait_Montage) == 0x0000C8, "Member 'FReferenceToBaseballGameCommonAssetInstance::SwingWait_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, SwingMiss_Montage) == 0x0000D0, "Member 'FReferenceToBaseballGameCommonAssetInstance::SwingMiss_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Swing01_01ST_Montage) == 0x0000D8, "Member 'FReferenceToBaseballGameCommonAssetInstance::Swing01_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Swing01_02LP_Montage) == 0x0000E0, "Member 'FReferenceToBaseballGameCommonAssetInstance::Swing01_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Swing01_03ED_Montage) == 0x0000E8, "Member 'FReferenceToBaseballGameCommonAssetInstance::Swing01_03ED_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Wait01_Aura_Montage) == 0x0000F0, "Member 'FReferenceToBaseballGameCommonAssetInstance::Wait01_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, SwingWait_Aura_Montage) == 0x0000F8, "Member 'FReferenceToBaseballGameCommonAssetInstance::SwingWait_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, SwingMiss_Aura_Montage) == 0x000100, "Member 'FReferenceToBaseballGameCommonAssetInstance::SwingMiss_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Swing01_01ST_Aura_Montage) == 0x000108, "Member 'FReferenceToBaseballGameCommonAssetInstance::Swing01_01ST_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Swing01_02LP_Aura_Montage) == 0x000110, "Member 'FReferenceToBaseballGameCommonAssetInstance::Swing01_02LP_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Swing01_03ED_Aura_Montage) == 0x000118, "Member 'FReferenceToBaseballGameCommonAssetInstance::Swing01_03ED_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Result_Montage) == 0x000120, "Member 'FReferenceToBaseballGameCommonAssetInstance::Result_Montage' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallAuraBlueS_Particle) == 0x000128, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallAuraBlueS_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallAuraBlueL_Particle) == 0x000130, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallAuraBlueL_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallAuraRedS_Particle) == 0x000138, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallAuraRedS_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallAuraRedL_Particle) == 0x000140, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallAuraRedL_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Hit_Particle) == 0x000148, "Member 'FReferenceToBaseballGameCommonAssetInstance::Hit_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, HitDist_Particle) == 0x000150, "Member 'FReferenceToBaseballGameCommonAssetInstance::HitDist_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Radiation_Particle) == 0x000158, "Member 'FReferenceToBaseballGameCommonAssetInstance::Radiation_Particle' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, ConstantDataTable) == 0x000160, "Member 'FReferenceToBaseballGameCommonAssetInstance::ConstantDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, PitcherDataTable) == 0x000168, "Member 'FReferenceToBaseballGameCommonAssetInstance::PitcherDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallDataTable) == 0x000170, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BallTypeDataTable) == 0x000178, "Member 'FReferenceToBaseballGameCommonAssetInstance::BallTypeDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, HitTimingDataTable) == 0x000180, "Member 'FReferenceToBaseballGameCommonAssetInstance::HitTimingDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, CameraDataTable) == 0x000188, "Member 'FReferenceToBaseballGameCommonAssetInstance::CameraDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, BattlePowerDataTable) == 0x000190, "Member 'FReferenceToBaseballGameCommonAssetInstance::BattlePowerDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, CutinDataTable) == 0x000198, "Member 'FReferenceToBaseballGameCommonAssetInstance::CutinDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, MobPresetDataTable) == 0x0001A0, "Member 'FReferenceToBaseballGameCommonAssetInstance::MobPresetDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Mob_Man_Reaction01) == 0x0001A8, "Member 'FReferenceToBaseballGameCommonAssetInstance::Mob_Man_Reaction01' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Mob_Man_Reaction02) == 0x0001B0, "Member 'FReferenceToBaseballGameCommonAssetInstance::Mob_Man_Reaction02' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Mob_Man_Reaction03) == 0x0001B8, "Member 'FReferenceToBaseballGameCommonAssetInstance::Mob_Man_Reaction03' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Mob_Woman_Reaction01) == 0x0001C0, "Member 'FReferenceToBaseballGameCommonAssetInstance::Mob_Woman_Reaction01' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Mob_Woman_Reaction02) == 0x0001C8, "Member 'FReferenceToBaseballGameCommonAssetInstance::Mob_Woman_Reaction02' has a wrong offset!");
static_assert(offsetof(FReferenceToBaseballGameCommonAssetInstance, Mob_Kid_Reaction01) == 0x0001D0, "Member 'FReferenceToBaseballGameCommonAssetInstance::Mob_Kid_Reaction01' has a wrong offset!");

// ScriptStruct AT.SkillMontageInfo
// 0x00C8 (0x00C8 - 0x0000)
struct FSkillMontageInfo final
{
public:
	class UAnimMontage*                           WaitMontage;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitLoopTime;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitLoopTimeHeatUpCancel;                          // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          WaitCancelNotPlayer;                               // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackMontage;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopTime;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopTimeSupportRatio;                        // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackLoopNum;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackLoopDistance;                                // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackEndTime;                                     // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackCutinMontage;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkillMontageFormChangeCutinInfo> FormChangeCutinInfo;                               // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AttackCutinTargetMontage;                          // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttackCutinTargetMontageID;                        // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UAnimMontage*>        AttackCutinTargetMontagePrivate;                   // 0x0060(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          AttackCutinAdjustDestructObject;                   // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AttackFizzleFlag;                                  // 0x00B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AttackFizzleMontage;                               // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroundMontage;                                    // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkipEndState;                                      // 0x00C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x6];                                       // 0x00C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillMontageInfo) == 0x000008, "Wrong alignment on FSkillMontageInfo");
static_assert(sizeof(FSkillMontageInfo) == 0x0000C8, "Wrong size on FSkillMontageInfo");
static_assert(offsetof(FSkillMontageInfo, WaitMontage) == 0x000000, "Member 'FSkillMontageInfo::WaitMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, WaitLoopTime) == 0x000008, "Member 'FSkillMontageInfo::WaitLoopTime' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, WaitLoopTimeHeatUpCancel) == 0x00000C, "Member 'FSkillMontageInfo::WaitLoopTimeHeatUpCancel' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, WaitCancelNotPlayer) == 0x000010, "Member 'FSkillMontageInfo::WaitCancelNotPlayer' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackMontage) == 0x000018, "Member 'FSkillMontageInfo::AttackMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackLoopTime) == 0x000020, "Member 'FSkillMontageInfo::AttackLoopTime' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackLoopTimeSupportRatio) == 0x000024, "Member 'FSkillMontageInfo::AttackLoopTimeSupportRatio' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackLoopNum) == 0x000028, "Member 'FSkillMontageInfo::AttackLoopNum' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackLoopDistance) == 0x00002C, "Member 'FSkillMontageInfo::AttackLoopDistance' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackEndTime) == 0x000030, "Member 'FSkillMontageInfo::AttackEndTime' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackCutinMontage) == 0x000038, "Member 'FSkillMontageInfo::AttackCutinMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, FormChangeCutinInfo) == 0x000040, "Member 'FSkillMontageInfo::FormChangeCutinInfo' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackCutinTargetMontage) == 0x000050, "Member 'FSkillMontageInfo::AttackCutinTargetMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackCutinTargetMontageID) == 0x000058, "Member 'FSkillMontageInfo::AttackCutinTargetMontageID' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackCutinTargetMontagePrivate) == 0x000060, "Member 'FSkillMontageInfo::AttackCutinTargetMontagePrivate' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackCutinAdjustDestructObject) == 0x0000B0, "Member 'FSkillMontageInfo::AttackCutinAdjustDestructObject' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackFizzleFlag) == 0x0000B1, "Member 'FSkillMontageInfo::AttackFizzleFlag' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, AttackFizzleMontage) == 0x0000B8, "Member 'FSkillMontageInfo::AttackFizzleMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, bGroundMontage) == 0x0000C0, "Member 'FSkillMontageInfo::bGroundMontage' has a wrong offset!");
static_assert(offsetof(FSkillMontageInfo, SkipEndState) == 0x0000C1, "Member 'FSkillMontageInfo::SkipEndState' has a wrong offset!");

// ScriptStruct AT.ActGroundBattleChargeHeatParticle
// 0x0010 (0x0010 - 0x0000)
struct FActGroundBattleChargeHeatParticle final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActGroundBattleChargeHeatParticle) == 0x000008, "Wrong alignment on FActGroundBattleChargeHeatParticle");
static_assert(sizeof(FActGroundBattleChargeHeatParticle) == 0x000010, "Wrong size on FActGroundBattleChargeHeatParticle");
static_assert(offsetof(FActGroundBattleChargeHeatParticle, FormChangeID) == 0x000000, "Member 'FActGroundBattleChargeHeatParticle::FormChangeID' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatParticle, Particle) == 0x000008, "Member 'FActGroundBattleChargeHeatParticle::Particle' has a wrong offset!");

// ScriptStruct AT.ATMeshAttachObject
// 0x0040 (0x0040 - 0x0000)
struct FATMeshAttachObject final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachName;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Offset;                                            // 0x0010(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATMeshAttachObject) == 0x000010, "Wrong alignment on FATMeshAttachObject");
static_assert(sizeof(FATMeshAttachObject) == 0x000040, "Wrong size on FATMeshAttachObject");
static_assert(offsetof(FATMeshAttachObject, Mesh) == 0x000000, "Member 'FATMeshAttachObject::Mesh' has a wrong offset!");
static_assert(offsetof(FATMeshAttachObject, AttachName) == 0x000008, "Member 'FATMeshAttachObject::AttachName' has a wrong offset!");
static_assert(offsetof(FATMeshAttachObject, Offset) == 0x000010, "Member 'FATMeshAttachObject::Offset' has a wrong offset!");

// ScriptStruct AT.NPCPoseSet
// 0x0018 (0x0018 - 0x0000)
struct FNPCPoseSet final
{
public:
	class UAnimationAsset*                        M_Animation;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FATMeshAttachObject>            M_AttachObjects;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNPCPoseSet) == 0x000008, "Wrong alignment on FNPCPoseSet");
static_assert(sizeof(FNPCPoseSet) == 0x000018, "Wrong size on FNPCPoseSet");
static_assert(offsetof(FNPCPoseSet, M_Animation) == 0x000000, "Member 'FNPCPoseSet::M_Animation' has a wrong offset!");
static_assert(offsetof(FNPCPoseSet, M_AttachObjects) == 0x000008, "Member 'FNPCPoseSet::M_AttachObjects' has a wrong offset!");

// ScriptStruct AT.WishLotteryGroupParam
// 0x0030 (0x0038 - 0x0008)
struct FWishLotteryGroupParam final : public FTableRowBase
{
public:
	EWishType                                     WishType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartQuestId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemGroupId;                                       // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWishLotteryGroupParam) == 0x000008, "Wrong alignment on FWishLotteryGroupParam");
static_assert(sizeof(FWishLotteryGroupParam) == 0x000038, "Wrong size on FWishLotteryGroupParam");
static_assert(offsetof(FWishLotteryGroupParam, WishType) == 0x000008, "Member 'FWishLotteryGroupParam::WishType' has a wrong offset!");
static_assert(offsetof(FWishLotteryGroupParam, StartQuestId) == 0x000010, "Member 'FWishLotteryGroupParam::StartQuestId' has a wrong offset!");
static_assert(offsetof(FWishLotteryGroupParam, StartPhaseNo) == 0x000018, "Member 'FWishLotteryGroupParam::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishLotteryGroupParam, EndQuestId) == 0x000020, "Member 'FWishLotteryGroupParam::EndQuestId' has a wrong offset!");
static_assert(offsetof(FWishLotteryGroupParam, EndPhaseNo) == 0x000028, "Member 'FWishLotteryGroupParam::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishLotteryGroupParam, Weight) == 0x00002C, "Member 'FWishLotteryGroupParam::Weight' has a wrong offset!");
static_assert(offsetof(FWishLotteryGroupParam, ItemGroupId) == 0x000030, "Member 'FWishLotteryGroupParam::ItemGroupId' has a wrong offset!");

// ScriptStruct AT.LongBlowoffChaseMontageInfo
// 0x0018 (0x0018 - 0x0000)
struct FLongBlowoffChaseMontageInfo final
{
public:
	class UAnimMontage*                           MontageMove;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveEndDist;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageAttack;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLongBlowoffChaseMontageInfo) == 0x000008, "Wrong alignment on FLongBlowoffChaseMontageInfo");
static_assert(sizeof(FLongBlowoffChaseMontageInfo) == 0x000018, "Wrong size on FLongBlowoffChaseMontageInfo");
static_assert(offsetof(FLongBlowoffChaseMontageInfo, MontageMove) == 0x000000, "Member 'FLongBlowoffChaseMontageInfo::MontageMove' has a wrong offset!");
static_assert(offsetof(FLongBlowoffChaseMontageInfo, MoveTime) == 0x000008, "Member 'FLongBlowoffChaseMontageInfo::MoveTime' has a wrong offset!");
static_assert(offsetof(FLongBlowoffChaseMontageInfo, MoveEndDist) == 0x00000C, "Member 'FLongBlowoffChaseMontageInfo::MoveEndDist' has a wrong offset!");
static_assert(offsetof(FLongBlowoffChaseMontageInfo, MontageAttack) == 0x000010, "Member 'FLongBlowoffChaseMontageInfo::MontageAttack' has a wrong offset!");

// ScriptStruct AT.WishLotteryCountParam
// 0x0030 (0x0038 - 0x0008)
struct FWishLotteryCountParam final : public FTableRowBase
{
public:
	EWishType                                     WishType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartQuestId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Weight;                                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWishLotteryCountParam) == 0x000008, "Wrong alignment on FWishLotteryCountParam");
static_assert(sizeof(FWishLotteryCountParam) == 0x000038, "Wrong size on FWishLotteryCountParam");
static_assert(offsetof(FWishLotteryCountParam, WishType) == 0x000008, "Member 'FWishLotteryCountParam::WishType' has a wrong offset!");
static_assert(offsetof(FWishLotteryCountParam, StartQuestId) == 0x000010, "Member 'FWishLotteryCountParam::StartQuestId' has a wrong offset!");
static_assert(offsetof(FWishLotteryCountParam, StartPhaseNo) == 0x000018, "Member 'FWishLotteryCountParam::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishLotteryCountParam, EndQuestId) == 0x000020, "Member 'FWishLotteryCountParam::EndQuestId' has a wrong offset!");
static_assert(offsetof(FWishLotteryCountParam, EndPhaseNo) == 0x000028, "Member 'FWishLotteryCountParam::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishLotteryCountParam, Weight) == 0x00002C, "Member 'FWishLotteryCountParam::Weight' has a wrong offset!");
static_assert(offsetof(FWishLotteryCountParam, Count) == 0x000030, "Member 'FWishLotteryCountParam::Count' has a wrong offset!");

// ScriptStruct AT.AddZOrbCount
// 0x0008 (0x0008 - 0x0000)
struct FAddZOrbCount final
{
public:
	EZOrbItemType                                 ZOrbItemType;                                      // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AddCount;                                          // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddZOrbCount) == 0x000004, "Wrong alignment on FAddZOrbCount");
static_assert(sizeof(FAddZOrbCount) == 0x000008, "Wrong size on FAddZOrbCount");
static_assert(offsetof(FAddZOrbCount, ZOrbItemType) == 0x000000, "Member 'FAddZOrbCount::ZOrbItemType' has a wrong offset!");
static_assert(offsetof(FAddZOrbCount, AddCount) == 0x000004, "Member 'FAddZOrbCount::AddCount' has a wrong offset!");

// ScriptStruct AT.WishAddParam
// 0x0038 (0x0040 - 0x0008)
struct FWishAddParam final : public FTableRowBase
{
public:
	EWishType                                     WishType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartQuestId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddCount;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAddZOrbCount>                  AddZOrbCount;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWishAddParam) == 0x000008, "Wrong alignment on FWishAddParam");
static_assert(sizeof(FWishAddParam) == 0x000040, "Wrong size on FWishAddParam");
static_assert(offsetof(FWishAddParam, WishType) == 0x000008, "Member 'FWishAddParam::WishType' has a wrong offset!");
static_assert(offsetof(FWishAddParam, StartQuestId) == 0x000010, "Member 'FWishAddParam::StartQuestId' has a wrong offset!");
static_assert(offsetof(FWishAddParam, StartPhaseNo) == 0x000018, "Member 'FWishAddParam::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishAddParam, EndQuestId) == 0x000020, "Member 'FWishAddParam::EndQuestId' has a wrong offset!");
static_assert(offsetof(FWishAddParam, EndPhaseNo) == 0x000028, "Member 'FWishAddParam::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FWishAddParam, AddCount) == 0x00002C, "Member 'FWishAddParam::AddCount' has a wrong offset!");
static_assert(offsetof(FWishAddParam, AddZOrbCount) == 0x000030, "Member 'FWishAddParam::AddZOrbCount' has a wrong offset!");

// ScriptStruct AT.QuestPair
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FQuestPair final
{
public:
	class FName                                   QuestId;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseNo;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestPair) == 0x000008, "Wrong alignment on FQuestPair");
static_assert(sizeof(FQuestPair) == 0x000010, "Wrong size on FQuestPair");
static_assert(offsetof(FQuestPair, QuestId) == 0x000000, "Member 'FQuestPair::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestPair, PhaseNo) == 0x000008, "Member 'FQuestPair::PhaseNo' has a wrong offset!");

// ScriptStruct AT.ReferenceToGBCharacterAssetInstance
// 0x0060 (0x0060 - 0x0000)
struct FReferenceToGBCharacterAssetInstance final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          MeshMobNear;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UAnimMontage*>        AnimationMap;                                      // 0x0010(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToGBCharacterAssetInstance) == 0x000008, "Wrong alignment on FReferenceToGBCharacterAssetInstance");
static_assert(sizeof(FReferenceToGBCharacterAssetInstance) == 0x000060, "Wrong size on FReferenceToGBCharacterAssetInstance");
static_assert(offsetof(FReferenceToGBCharacterAssetInstance, Mesh) == 0x000000, "Member 'FReferenceToGBCharacterAssetInstance::Mesh' has a wrong offset!");
static_assert(offsetof(FReferenceToGBCharacterAssetInstance, MeshMobNear) == 0x000008, "Member 'FReferenceToGBCharacterAssetInstance::MeshMobNear' has a wrong offset!");
static_assert(offsetof(FReferenceToGBCharacterAssetInstance, AnimationMap) == 0x000010, "Member 'FReferenceToGBCharacterAssetInstance::AnimationMap' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateEffectColorMultiByArea
// 0x0048 (0x0048 - 0x0000)
struct FTerrainDecorateEffectColorMultiByArea final
{
public:
	TSoftObjectPtr<class UMaterialParameterCollection> UseParameterCollection;                            // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           ParameterCollectionInstance;                       // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           MultiplyColor;                                     // 0x0030(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainDecorateEffectColorMultiByArea) == 0x000008, "Wrong alignment on FTerrainDecorateEffectColorMultiByArea");
static_assert(sizeof(FTerrainDecorateEffectColorMultiByArea) == 0x000048, "Wrong size on FTerrainDecorateEffectColorMultiByArea");
static_assert(offsetof(FTerrainDecorateEffectColorMultiByArea, UseParameterCollection) == 0x000000, "Member 'FTerrainDecorateEffectColorMultiByArea::UseParameterCollection' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateEffectColorMultiByArea, ParameterCollectionInstance) == 0x000028, "Member 'FTerrainDecorateEffectColorMultiByArea::ParameterCollectionInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateEffectColorMultiByArea, MultiplyColor) == 0x000030, "Member 'FTerrainDecorateEffectColorMultiByArea::MultiplyColor' has a wrong offset!");

// ScriptStruct AT.CaptureFacialTypeParam
// 0x0008 (0x0010 - 0x0008)
struct FCaptureFacialTypeParam final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ValiationId;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFacialType                                   FacialType;                                        // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaptureFacialTypeParam) == 0x000008, "Wrong alignment on FCaptureFacialTypeParam");
static_assert(sizeof(FCaptureFacialTypeParam) == 0x000010, "Wrong size on FCaptureFacialTypeParam");
static_assert(offsetof(FCaptureFacialTypeParam, CharacterType) == 0x000008, "Member 'FCaptureFacialTypeParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FCaptureFacialTypeParam, ValiationId) == 0x000009, "Member 'FCaptureFacialTypeParam::ValiationId' has a wrong offset!");
static_assert(offsetof(FCaptureFacialTypeParam, FormID) == 0x00000A, "Member 'FCaptureFacialTypeParam::FormID' has a wrong offset!");
static_assert(offsetof(FCaptureFacialTypeParam, FacialType) == 0x00000B, "Member 'FCaptureFacialTypeParam::FacialType' has a wrong offset!");

// ScriptStruct AT.LoadingEventBattleMobAsset
// 0x0078 (0x0078 - 0x0000)
struct FLoadingEventBattleMobAsset final
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         Animation;                                         // 0x0050(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingEventBattleMobAsset) == 0x000008, "Wrong alignment on FLoadingEventBattleMobAsset");
static_assert(sizeof(FLoadingEventBattleMobAsset) == 0x000078, "Wrong size on FLoadingEventBattleMobAsset");
static_assert(offsetof(FLoadingEventBattleMobAsset, StaticMesh) == 0x000000, "Member 'FLoadingEventBattleMobAsset::StaticMesh' has a wrong offset!");
static_assert(offsetof(FLoadingEventBattleMobAsset, SkeletalMesh) == 0x000028, "Member 'FLoadingEventBattleMobAsset::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FLoadingEventBattleMobAsset, Animation) == 0x000050, "Member 'FLoadingEventBattleMobAsset::Animation' has a wrong offset!");

// ScriptStruct AT.CaptureModelParam
// 0x0068 (0x0070 - 0x0008)
struct FCaptureModelParam final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AnimationId;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FacialId;                                          // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FacialPath;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             CameraTransform;                                   // 0x0040(0x0030)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCaptureModelParam) == 0x000010, "Wrong alignment on FCaptureModelParam");
static_assert(sizeof(FCaptureModelParam) == 0x000070, "Wrong size on FCaptureModelParam");
static_assert(offsetof(FCaptureModelParam, CharacterType) == 0x000008, "Member 'FCaptureModelParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FCaptureModelParam, VariationId) == 0x000009, "Member 'FCaptureModelParam::VariationId' has a wrong offset!");
static_assert(offsetof(FCaptureModelParam, FormID) == 0x00000A, "Member 'FCaptureModelParam::FormID' has a wrong offset!");
static_assert(offsetof(FCaptureModelParam, AnimationId) == 0x000010, "Member 'FCaptureModelParam::AnimationId' has a wrong offset!");
static_assert(offsetof(FCaptureModelParam, FacialId) == 0x000020, "Member 'FCaptureModelParam::FacialId' has a wrong offset!");
static_assert(offsetof(FCaptureModelParam, FacialPath) == 0x000030, "Member 'FCaptureModelParam::FacialPath' has a wrong offset!");
static_assert(offsetof(FCaptureModelParam, CameraTransform) == 0x000040, "Member 'FCaptureModelParam::CameraTransform' has a wrong offset!");

// ScriptStruct AT.MinigameBaseballRewardParam
// 0x0028 (0x0030 - 0x0008)
struct FMinigameBaseballRewardParam final : public FTableRowBase
{
public:
	uint32                                        CReward;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CRewardGroup;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniGameBaseballClearType                    CClearType;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CClear;                                            // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CRewardItem;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CRewardCount;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinigameBaseballRewardParam) == 0x000008, "Wrong alignment on FMinigameBaseballRewardParam");
static_assert(sizeof(FMinigameBaseballRewardParam) == 0x000030, "Wrong size on FMinigameBaseballRewardParam");
static_assert(offsetof(FMinigameBaseballRewardParam, CReward) == 0x000008, "Member 'FMinigameBaseballRewardParam::CReward' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballRewardParam, CRewardGroup) == 0x000010, "Member 'FMinigameBaseballRewardParam::CRewardGroup' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballRewardParam, CClearType) == 0x000018, "Member 'FMinigameBaseballRewardParam::CClearType' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballRewardParam, CClear) == 0x00001C, "Member 'FMinigameBaseballRewardParam::CClear' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballRewardParam, CRewardItem) == 0x000020, "Member 'FMinigameBaseballRewardParam::CRewardItem' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballRewardParam, CRewardCount) == 0x000028, "Member 'FMinigameBaseballRewardParam::CRewardCount' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballRewardParam, bLoop) == 0x00002C, "Member 'FMinigameBaseballRewardParam::bLoop' has a wrong offset!");

// ScriptStruct AT.AttackRangeParam
// 0x000C (0x000C - 0x0000)
struct FAttackRangeParam final
{
public:
	float                                         HPParsent;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackEffectScaleUpSpeed;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAttackRangeParam) == 0x000004, "Wrong alignment on FAttackRangeParam");
static_assert(sizeof(FAttackRangeParam) == 0x00000C, "Wrong size on FAttackRangeParam");
static_assert(offsetof(FAttackRangeParam, HPParsent) == 0x000000, "Member 'FAttackRangeParam::HPParsent' has a wrong offset!");
static_assert(offsetof(FAttackRangeParam, Power) == 0x000004, "Member 'FAttackRangeParam::Power' has a wrong offset!");
static_assert(offsetof(FAttackRangeParam, AttackEffectScaleUpSpeed) == 0x000008, "Member 'FAttackRangeParam::AttackEffectScaleUpSpeed' has a wrong offset!");

// ScriptStruct AT.QuestImageParameterSet
// 0x0018 (0x0020 - 0x0008)
struct FQuestImageParameterSet final : public FTableRowBase
{
public:
	TArray<class FName>                           QuestImageIds;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   LoadProgressId;                                    // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestImageParameterSet) == 0x000008, "Wrong alignment on FQuestImageParameterSet");
static_assert(sizeof(FQuestImageParameterSet) == 0x000020, "Wrong size on FQuestImageParameterSet");
static_assert(offsetof(FQuestImageParameterSet, QuestImageIds) == 0x000008, "Member 'FQuestImageParameterSet::QuestImageIds' has a wrong offset!");
static_assert(offsetof(FQuestImageParameterSet, LoadProgressId) == 0x000018, "Member 'FQuestImageParameterSet::LoadProgressId' has a wrong offset!");

// ScriptStruct AT.AssaultMontageInfo
// 0x0010 (0x0010 - 0x0000)
struct FAssaultMontageInfo final
{
public:
	class UAnimMontage*                           MontageAttack;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MontageDamageID;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAssaultMontageInfo) == 0x000008, "Wrong alignment on FAssaultMontageInfo");
static_assert(sizeof(FAssaultMontageInfo) == 0x000010, "Wrong size on FAssaultMontageInfo");
static_assert(offsetof(FAssaultMontageInfo, MontageAttack) == 0x000000, "Member 'FAssaultMontageInfo::MontageAttack' has a wrong offset!");
static_assert(offsetof(FAssaultMontageInfo, MontageDamageID) == 0x000008, "Member 'FAssaultMontageInfo::MontageDamageID' has a wrong offset!");

// ScriptStruct AT.MinigameBaseballLocalRankingParam
// 0x0020 (0x0028 - 0x0008)
struct FMinigameBaseballLocalRankingParam final : public FTableRowBase
{
public:
	uint32                                        CRecordNum;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CRecordName;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBaseballGameDifficulty                       CRecordCourse;                                     // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        CNpcRecord;                                        // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinigameBaseballLocalRankingParam) == 0x000008, "Wrong alignment on FMinigameBaseballLocalRankingParam");
static_assert(sizeof(FMinigameBaseballLocalRankingParam) == 0x000028, "Wrong size on FMinigameBaseballLocalRankingParam");
static_assert(offsetof(FMinigameBaseballLocalRankingParam, CRecordNum) == 0x000008, "Member 'FMinigameBaseballLocalRankingParam::CRecordNum' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballLocalRankingParam, CRecordName) == 0x000010, "Member 'FMinigameBaseballLocalRankingParam::CRecordName' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballLocalRankingParam, CRecordCourse) == 0x000020, "Member 'FMinigameBaseballLocalRankingParam::CRecordCourse' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballLocalRankingParam, CNpcRecord) == 0x000024, "Member 'FMinigameBaseballLocalRankingParam::CNpcRecord' has a wrong offset!");

// ScriptStruct AT.HiddenTarget
// 0x0010 (0x0010 - 0x0000)
struct FHiddenTarget final
{
public:
	TArray<class FName>                           HiddenActors;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiddenTarget) == 0x000008, "Wrong alignment on FHiddenTarget");
static_assert(sizeof(FHiddenTarget) == 0x000010, "Wrong size on FHiddenTarget");
static_assert(offsetof(FHiddenTarget, HiddenActors) == 0x000000, "Member 'FHiddenTarget::HiddenActors' has a wrong offset!");

// ScriptStruct AT.BattleGroupAIPhaseTable
// 0x0020 (0x0028 - 0x0008)
struct FBattleGroupAIPhaseTable final : public FTableRowBase
{
public:
	int32                                         Phase;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType1;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue1;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType2;                                    // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue2;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType3;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue3;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleGroupAIPhaseTable) == 0x000008, "Wrong alignment on FBattleGroupAIPhaseTable");
static_assert(sizeof(FBattleGroupAIPhaseTable) == 0x000028, "Wrong size on FBattleGroupAIPhaseTable");
static_assert(offsetof(FBattleGroupAIPhaseTable, Phase) == 0x000008, "Member 'FBattleGroupAIPhaseTable::Phase' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIPhaseTable, ConditionType1) == 0x00000C, "Member 'FBattleGroupAIPhaseTable::ConditionType1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIPhaseTable, ConditionValue1) == 0x000010, "Member 'FBattleGroupAIPhaseTable::ConditionValue1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIPhaseTable, ConditionType2) == 0x000014, "Member 'FBattleGroupAIPhaseTable::ConditionType2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIPhaseTable, ConditionValue2) == 0x000018, "Member 'FBattleGroupAIPhaseTable::ConditionValue2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIPhaseTable, ConditionType3) == 0x00001C, "Member 'FBattleGroupAIPhaseTable::ConditionType3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIPhaseTable, ConditionValue3) == 0x000020, "Member 'FBattleGroupAIPhaseTable::ConditionValue3' has a wrong offset!");

// ScriptStruct AT.MinigameBaseballDifficultyParam
// 0x0020 (0x0028 - 0x0008)
struct FMinigameBaseballDifficultyParam final : public FTableRowBase
{
public:
	EBaseballGameDifficulty                       CCourse;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CChara;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CMoney;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        CHomerunKm;                                        // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CRewardGroup;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinigameBaseballDifficultyParam) == 0x000008, "Wrong alignment on FMinigameBaseballDifficultyParam");
static_assert(sizeof(FMinigameBaseballDifficultyParam) == 0x000028, "Wrong size on FMinigameBaseballDifficultyParam");
static_assert(offsetof(FMinigameBaseballDifficultyParam, CCourse) == 0x000008, "Member 'FMinigameBaseballDifficultyParam::CCourse' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballDifficultyParam, CChara) == 0x000010, "Member 'FMinigameBaseballDifficultyParam::CChara' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballDifficultyParam, CMoney) == 0x000018, "Member 'FMinigameBaseballDifficultyParam::CMoney' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballDifficultyParam, CHomerunKm) == 0x00001C, "Member 'FMinigameBaseballDifficultyParam::CHomerunKm' has a wrong offset!");
static_assert(offsetof(FMinigameBaseballDifficultyParam, CRewardGroup) == 0x000020, "Member 'FMinigameBaseballDifficultyParam::CRewardGroup' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupLinkList
// 0x0058 (0x0058 - 0x0000)
struct FGameWindowSetupLinkList final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             LinkID[0x6];                                       // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupLinkList) == 0x000008, "Wrong alignment on FGameWindowSetupLinkList");
static_assert(sizeof(FGameWindowSetupLinkList) == 0x000058, "Wrong size on FGameWindowSetupLinkList");
static_assert(offsetof(FGameWindowSetupLinkList, LinkID) == 0x000018, "Member 'FGameWindowSetupLinkList::LinkID' has a wrong offset!");

// ScriptStruct AT.CustomColorInfo
// 0x0040 (0x0040 - 0x0000)
struct FCustomColorInfo final
{
public:
	struct FLinearColor                           ColorA;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorB;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorG;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ColorR;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCustomColorInfo) == 0x000004, "Wrong alignment on FCustomColorInfo");
static_assert(sizeof(FCustomColorInfo) == 0x000040, "Wrong size on FCustomColorInfo");
static_assert(offsetof(FCustomColorInfo, ColorA) == 0x000000, "Member 'FCustomColorInfo::ColorA' has a wrong offset!");
static_assert(offsetof(FCustomColorInfo, ColorB) == 0x000010, "Member 'FCustomColorInfo::ColorB' has a wrong offset!");
static_assert(offsetof(FCustomColorInfo, ColorG) == 0x000020, "Member 'FCustomColorInfo::ColorG' has a wrong offset!");
static_assert(offsetof(FCustomColorInfo, ColorR) == 0x000030, "Member 'FCustomColorInfo::ColorR' has a wrong offset!");

// ScriptStruct AT.NpcParts
// 0x0090 (0x0090 - 0x0000)
struct FNpcParts final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcParts                                     Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CustomColorSet;                                    // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomColorInfo                       CustomColor;                                       // 0x002C(0x0040)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x006C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Rotation;                                          // 0x0078(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MeshAttachPoint;                                   // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcParts) == 0x000008, "Wrong alignment on FNpcParts");
static_assert(sizeof(FNpcParts) == 0x000090, "Wrong size on FNpcParts");
static_assert(offsetof(FNpcParts, Mesh) == 0x000000, "Member 'FNpcParts::Mesh' has a wrong offset!");
static_assert(offsetof(FNpcParts, Type) == 0x000028, "Member 'FNpcParts::Type' has a wrong offset!");
static_assert(offsetof(FNpcParts, CustomColorSet) == 0x000029, "Member 'FNpcParts::CustomColorSet' has a wrong offset!");
static_assert(offsetof(FNpcParts, CustomColor) == 0x00002C, "Member 'FNpcParts::CustomColor' has a wrong offset!");
static_assert(offsetof(FNpcParts, Offset) == 0x00006C, "Member 'FNpcParts::Offset' has a wrong offset!");
static_assert(offsetof(FNpcParts, Rotation) == 0x000078, "Member 'FNpcParts::Rotation' has a wrong offset!");
static_assert(offsetof(FNpcParts, MeshAttachPoint) == 0x000088, "Member 'FNpcParts::MeshAttachPoint' has a wrong offset!");

// ScriptStruct AT.MinigameRaceLocalRankingParam
// 0x0040 (0x0048 - 0x0008)
struct FMinigameRaceLocalRankingParam final : public FTableRowBase
{
public:
	int32                                         CRecordNum;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CRecordName;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CCourseArea;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniGameRaceMode                             CRaceType;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CRecordCount;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinigameRaceLocalRankingParam) == 0x000008, "Wrong alignment on FMinigameRaceLocalRankingParam");
static_assert(sizeof(FMinigameRaceLocalRankingParam) == 0x000048, "Wrong size on FMinigameRaceLocalRankingParam");
static_assert(offsetof(FMinigameRaceLocalRankingParam, CRecordNum) == 0x000008, "Member 'FMinigameRaceLocalRankingParam::CRecordNum' has a wrong offset!");
static_assert(offsetof(FMinigameRaceLocalRankingParam, CRecordName) == 0x000010, "Member 'FMinigameRaceLocalRankingParam::CRecordName' has a wrong offset!");
static_assert(offsetof(FMinigameRaceLocalRankingParam, CCourseArea) == 0x000020, "Member 'FMinigameRaceLocalRankingParam::CCourseArea' has a wrong offset!");
static_assert(offsetof(FMinigameRaceLocalRankingParam, CRaceType) == 0x000028, "Member 'FMinigameRaceLocalRankingParam::CRaceType' has a wrong offset!");
static_assert(offsetof(FMinigameRaceLocalRankingParam, CRecordCount) == 0x000030, "Member 'FMinigameRaceLocalRankingParam::CRecordCount' has a wrong offset!");

// ScriptStruct AT.MinigameRaceRewardsParam
// 0x0038 (0x0040 - 0x0008)
struct FMinigameRaceRewardsParam final : public FTableRowBase
{
public:
	uint32                                        CReward;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CRewardGroup;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniGameRaceClearType                        CClearType;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CClearNum;                                         // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CClearTime;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CRewardItem;                                       // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CRewardCount;                                      // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinigameRaceRewardsParam) == 0x000008, "Wrong alignment on FMinigameRaceRewardsParam");
static_assert(sizeof(FMinigameRaceRewardsParam) == 0x000040, "Wrong size on FMinigameRaceRewardsParam");
static_assert(offsetof(FMinigameRaceRewardsParam, CReward) == 0x000008, "Member 'FMinigameRaceRewardsParam::CReward' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, CRewardGroup) == 0x000010, "Member 'FMinigameRaceRewardsParam::CRewardGroup' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, CClearType) == 0x000018, "Member 'FMinigameRaceRewardsParam::CClearType' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, CClearNum) == 0x00001C, "Member 'FMinigameRaceRewardsParam::CClearNum' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, CClearTime) == 0x000020, "Member 'FMinigameRaceRewardsParam::CClearTime' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, CRewardItem) == 0x000030, "Member 'FMinigameRaceRewardsParam::CRewardItem' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, CRewardCount) == 0x000038, "Member 'FMinigameRaceRewardsParam::CRewardCount' has a wrong offset!");
static_assert(offsetof(FMinigameRaceRewardsParam, bLoop) == 0x00003C, "Member 'FMinigameRaceRewardsParam::bLoop' has a wrong offset!");

// ScriptStruct AT.UIXlistCustom00Param
// 0x0030 (0x0030 - 0x0000)
struct FUIXlistCustom00Param final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               ItemType;                                          // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUIXlistCustom00Param) == 0x000008, "Wrong alignment on FUIXlistCustom00Param");
static_assert(sizeof(FUIXlistCustom00Param) == 0x000030, "Wrong size on FUIXlistCustom00Param");
static_assert(offsetof(FUIXlistCustom00Param, bActive) == 0x000000, "Member 'FUIXlistCustom00Param::bActive' has a wrong offset!");
static_assert(offsetof(FUIXlistCustom00Param, ItemId) == 0x000008, "Member 'FUIXlistCustom00Param::ItemId' has a wrong offset!");
static_assert(offsetof(FUIXlistCustom00Param, ItemType) == 0x000010, "Member 'FUIXlistCustom00Param::ItemType' has a wrong offset!");
static_assert(offsetof(FUIXlistCustom00Param, ItemName) == 0x000018, "Member 'FUIXlistCustom00Param::ItemName' has a wrong offset!");
static_assert(offsetof(FUIXlistCustom00Param, Rarity) == 0x000028, "Member 'FUIXlistCustom00Param::Rarity' has a wrong offset!");

// ScriptStruct AT.MinigameRaceCourseParam
// 0x0030 (0x0038 - 0x0008)
struct FMinigameRaceCourseParam final : public FTableRowBase
{
public:
	class FName                                   CAreaName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMiniGameRaceMode                             CRaceType;                                         // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CCheckPoint;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CCheckPointTime;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CRewardGroup;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CCost;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMinigameRaceCourseParam) == 0x000008, "Wrong alignment on FMinigameRaceCourseParam");
static_assert(sizeof(FMinigameRaceCourseParam) == 0x000038, "Wrong size on FMinigameRaceCourseParam");
static_assert(offsetof(FMinigameRaceCourseParam, CAreaName) == 0x000008, "Member 'FMinigameRaceCourseParam::CAreaName' has a wrong offset!");
static_assert(offsetof(FMinigameRaceCourseParam, CRaceType) == 0x000010, "Member 'FMinigameRaceCourseParam::CRaceType' has a wrong offset!");
static_assert(offsetof(FMinigameRaceCourseParam, CCheckPoint) == 0x000014, "Member 'FMinigameRaceCourseParam::CCheckPoint' has a wrong offset!");
static_assert(offsetof(FMinigameRaceCourseParam, CCheckPointTime) == 0x000018, "Member 'FMinigameRaceCourseParam::CCheckPointTime' has a wrong offset!");
static_assert(offsetof(FMinigameRaceCourseParam, CRewardGroup) == 0x000028, "Member 'FMinigameRaceCourseParam::CRewardGroup' has a wrong offset!");
static_assert(offsetof(FMinigameRaceCourseParam, CCost) == 0x000030, "Member 'FMinigameRaceCourseParam::CCost' has a wrong offset!");

// ScriptStruct AT.OptionParam
// 0x0060 (0x0068 - 0x0008)
struct FOptionParam final : public FTableRowBase
{
public:
	class FName                                   CategoryId;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MsgId;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HelpMsgId;                                         // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOptionItemType                               Type;                                              // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Value0;                                            // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value1;                                            // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value2;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value3;                                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value4;                                            // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value5;                                            // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value6;                                            // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value7;                                            // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionParam) == 0x000008, "Wrong alignment on FOptionParam");
static_assert(sizeof(FOptionParam) == 0x000068, "Wrong size on FOptionParam");
static_assert(offsetof(FOptionParam, CategoryId) == 0x000008, "Member 'FOptionParam::CategoryId' has a wrong offset!");
static_assert(offsetof(FOptionParam, MsgId) == 0x000010, "Member 'FOptionParam::MsgId' has a wrong offset!");
static_assert(offsetof(FOptionParam, HelpMsgId) == 0x000018, "Member 'FOptionParam::HelpMsgId' has a wrong offset!");
static_assert(offsetof(FOptionParam, Type) == 0x000020, "Member 'FOptionParam::Type' has a wrong offset!");
static_assert(offsetof(FOptionParam, IsLoop) == 0x000021, "Member 'FOptionParam::IsLoop' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value0) == 0x000028, "Member 'FOptionParam::Value0' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value1) == 0x000030, "Member 'FOptionParam::Value1' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value2) == 0x000038, "Member 'FOptionParam::Value2' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value3) == 0x000040, "Member 'FOptionParam::Value3' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value4) == 0x000048, "Member 'FOptionParam::Value4' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value5) == 0x000050, "Member 'FOptionParam::Value5' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value6) == 0x000058, "Member 'FOptionParam::Value6' has a wrong offset!");
static_assert(offsetof(FOptionParam, Value7) == 0x000060, "Member 'FOptionParam::Value7' has a wrong offset!");

// ScriptStruct AT.BattleGroupAIBehaviorTable
// 0x0228 (0x0230 - 0x0008)
struct FBattleGroupAIBehaviorTable final : public FTableRowBase
{
public:
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecastTime;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIPhaseCondition                       PhaseConditionType;                                // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhaseConditionValue;                               // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType1;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue1;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType2;                                    // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue2;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType3;                                    // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue3;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableCheckProbability;                            // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableCheckTimer;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BehaviorCharacter1;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum1;                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType1;                                     // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue1;                                    // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType1;                             // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue1;                            // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime1;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter2;                                // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum2;                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType2;                                     // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue2;                                    // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType2;                             // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue2;                            // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime2;                                 // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter3;                                // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum3;                             // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType3;                                     // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8D[0x3];                                       // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue3;                                    // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType3;                             // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue3;                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime3;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter4;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum4;                             // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType4;                                     // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue4;                                    // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType4;                             // 0x00B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B5[0x3];                                       // 0x00B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue4;                            // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime4;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter5;                                // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum5;                             // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType5;                                     // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue5;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType5;                             // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue5;                            // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime5;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter6;                                // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum6;                             // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType6;                                     // 0x00EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED[0x3];                                       // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue6;                                    // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType6;                             // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue6;                            // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime6;                                 // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter7;                                // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum7;                             // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType7;                                     // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue7;                                    // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType7;                             // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue7;                            // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime7;                                 // 0x011C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter8;                                // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum8;                             // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType8;                                     // 0x012C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12D[0x3];                                      // 0x012D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue8;                                    // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType8;                             // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue8;                            // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime8;                                 // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter9;                                // 0x0140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum9;                             // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType9;                                     // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue9;                                    // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType9;                             // 0x0154(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_155[0x3];                                      // 0x0155(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue9;                            // 0x0158(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime9;                                 // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter10;                               // 0x0160(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum10;                            // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType10;                                    // 0x016C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D[0x3];                                      // 0x016D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue10;                                   // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType10;                            // 0x0174(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_175[0x3];                                      // 0x0175(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue10;                           // 0x0178(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime10;                                // 0x017C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter11;                               // 0x0180(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum11;                            // 0x0188(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType11;                                    // 0x018C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18D[0x3];                                      // 0x018D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue11;                                   // 0x0190(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType11;                            // 0x0194(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_195[0x3];                                      // 0x0195(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue11;                           // 0x0198(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime11;                                // 0x019C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter12;                               // 0x01A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum12;                            // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType12;                                    // 0x01AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AD[0x3];                                      // 0x01AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue12;                                   // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType12;                            // 0x01B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B5[0x3];                                      // 0x01B5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue12;                           // 0x01B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime12;                                // 0x01BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter13;                               // 0x01C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum13;                            // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType13;                                    // 0x01CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CD[0x3];                                      // 0x01CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue13;                                   // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType13;                            // 0x01D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D5[0x3];                                      // 0x01D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue13;                           // 0x01D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime13;                                // 0x01DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter14;                               // 0x01E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum14;                            // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType14;                                    // 0x01EC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1ED[0x3];                                      // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue14;                                   // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType14;                            // 0x01F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F5[0x3];                                      // 0x01F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue14;                           // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime14;                                // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BehaviorCharacter15;                               // 0x0200(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BehaviorCharacterNum15;                            // 0x0208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType15;                                    // 0x020C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D[0x3];                                      // 0x020D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue15;                                   // 0x0210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType15;                            // 0x0214(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215[0x3];                                      // 0x0215(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue15;                           // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime15;                                // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UniqueId;                                          // 0x0220(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleGroupAIBehaviorTable) == 0x000008, "Wrong alignment on FBattleGroupAIBehaviorTable");
static_assert(sizeof(FBattleGroupAIBehaviorTable) == 0x000230, "Wrong size on FBattleGroupAIBehaviorTable");
static_assert(offsetof(FBattleGroupAIBehaviorTable, Priority) == 0x000008, "Member 'FBattleGroupAIBehaviorTable::Priority' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, Probability) == 0x00000C, "Member 'FBattleGroupAIBehaviorTable::Probability' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, RecastTime) == 0x000010, "Member 'FBattleGroupAIBehaviorTable::RecastTime' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, PhaseConditionType) == 0x000014, "Member 'FBattleGroupAIBehaviorTable::PhaseConditionType' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, PhaseConditionValue) == 0x000018, "Member 'FBattleGroupAIBehaviorTable::PhaseConditionValue' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, ConditionType1) == 0x00001C, "Member 'FBattleGroupAIBehaviorTable::ConditionType1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, ConditionValue1) == 0x000020, "Member 'FBattleGroupAIBehaviorTable::ConditionValue1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, ConditionType2) == 0x000024, "Member 'FBattleGroupAIBehaviorTable::ConditionType2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, ConditionValue2) == 0x000028, "Member 'FBattleGroupAIBehaviorTable::ConditionValue2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, ConditionType3) == 0x00002C, "Member 'FBattleGroupAIBehaviorTable::ConditionType3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, ConditionValue3) == 0x000030, "Member 'FBattleGroupAIBehaviorTable::ConditionValue3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, EnableCheckProbability) == 0x000034, "Member 'FBattleGroupAIBehaviorTable::EnableCheckProbability' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, EnableCheckTimer) == 0x000038, "Member 'FBattleGroupAIBehaviorTable::EnableCheckTimer' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter1) == 0x000040, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum1) == 0x000048, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType1) == 0x00004C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue1) == 0x000050, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType1) == 0x000054, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue1) == 0x000058, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime1) == 0x00005C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter2) == 0x000060, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum2) == 0x000068, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType2) == 0x00006C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue2) == 0x000070, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType2) == 0x000074, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue2) == 0x000078, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime2) == 0x00007C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter3) == 0x000080, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum3) == 0x000088, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType3) == 0x00008C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue3) == 0x000090, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType3) == 0x000094, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue3) == 0x000098, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime3) == 0x00009C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter4) == 0x0000A0, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum4) == 0x0000A8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType4) == 0x0000AC, "Member 'FBattleGroupAIBehaviorTable::BehaviorType4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue4) == 0x0000B0, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType4) == 0x0000B4, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue4) == 0x0000B8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime4) == 0x0000BC, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter5) == 0x0000C0, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum5) == 0x0000C8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType5) == 0x0000CC, "Member 'FBattleGroupAIBehaviorTable::BehaviorType5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue5) == 0x0000D0, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType5) == 0x0000D4, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue5) == 0x0000D8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime5) == 0x0000DC, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter6) == 0x0000E0, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum6) == 0x0000E8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType6) == 0x0000EC, "Member 'FBattleGroupAIBehaviorTable::BehaviorType6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue6) == 0x0000F0, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType6) == 0x0000F4, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue6) == 0x0000F8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime6) == 0x0000FC, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime6' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter7) == 0x000100, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum7) == 0x000108, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType7) == 0x00010C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue7) == 0x000110, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType7) == 0x000114, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue7) == 0x000118, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime7) == 0x00011C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime7' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter8) == 0x000120, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum8) == 0x000128, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType8) == 0x00012C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue8) == 0x000130, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType8) == 0x000134, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue8) == 0x000138, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime8) == 0x00013C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime8' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter9) == 0x000140, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum9) == 0x000148, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType9) == 0x00014C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue9) == 0x000150, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType9) == 0x000154, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue9) == 0x000158, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime9) == 0x00015C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime9' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter10) == 0x000160, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum10) == 0x000168, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType10) == 0x00016C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue10) == 0x000170, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType10) == 0x000174, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue10) == 0x000178, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime10) == 0x00017C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime10' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter11) == 0x000180, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum11) == 0x000188, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType11) == 0x00018C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue11) == 0x000190, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType11) == 0x000194, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue11) == 0x000198, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime11) == 0x00019C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime11' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter12) == 0x0001A0, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum12) == 0x0001A8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType12) == 0x0001AC, "Member 'FBattleGroupAIBehaviorTable::BehaviorType12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue12) == 0x0001B0, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType12) == 0x0001B4, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue12) == 0x0001B8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime12) == 0x0001BC, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime12' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter13) == 0x0001C0, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum13) == 0x0001C8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType13) == 0x0001CC, "Member 'FBattleGroupAIBehaviorTable::BehaviorType13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue13) == 0x0001D0, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType13) == 0x0001D4, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue13) == 0x0001D8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime13) == 0x0001DC, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime13' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter14) == 0x0001E0, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum14) == 0x0001E8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType14) == 0x0001EC, "Member 'FBattleGroupAIBehaviorTable::BehaviorType14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue14) == 0x0001F0, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType14) == 0x0001F4, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue14) == 0x0001F8, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime14) == 0x0001FC, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime14' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacter15) == 0x000200, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacter15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCharacterNum15) == 0x000208, "Member 'FBattleGroupAIBehaviorTable::BehaviorCharacterNum15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorType15) == 0x00020C, "Member 'FBattleGroupAIBehaviorTable::BehaviorType15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorValue15) == 0x000210, "Member 'FBattleGroupAIBehaviorTable::BehaviorValue15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteType15) == 0x000214, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteType15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorCompleteValue15) == 0x000218, "Member 'FBattleGroupAIBehaviorTable::BehaviorCompleteValue15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, BehaviorWaitTime15) == 0x00021C, "Member 'FBattleGroupAIBehaviorTable::BehaviorWaitTime15' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBehaviorTable, UniqueId) == 0x000220, "Member 'FBattleGroupAIBehaviorTable::UniqueId' has a wrong offset!");

// ScriptStruct AT.AnimalData
// 0x0020 (0x0028 - 0x0008)
struct FAnimalData final : public FTableRowBase
{
public:
	class FString                                 Name;                                              // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EventCategory;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReSartTime;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReSartCount;                                       // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimalData) == 0x000008, "Wrong alignment on FAnimalData");
static_assert(sizeof(FAnimalData) == 0x000028, "Wrong size on FAnimalData");
static_assert(offsetof(FAnimalData, Name) == 0x000008, "Member 'FAnimalData::Name' has a wrong offset!");
static_assert(offsetof(FAnimalData, EventCategory) == 0x000018, "Member 'FAnimalData::EventCategory' has a wrong offset!");
static_assert(offsetof(FAnimalData, ReSartTime) == 0x000020, "Member 'FAnimalData::ReSartTime' has a wrong offset!");
static_assert(offsetof(FAnimalData, ReSartCount) == 0x000024, "Member 'FAnimalData::ReSartCount' has a wrong offset!");

// ScriptStruct AT.EnemyHpGaugeOneBar
// 0x0010 (0x0018 - 0x0008)
struct FEnemyHpGaugeOneBar final : public FTableRowBase
{
public:
	int32                                         Episode;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Part;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OneBarValue;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyHpGaugeOneBar) == 0x000008, "Wrong alignment on FEnemyHpGaugeOneBar");
static_assert(sizeof(FEnemyHpGaugeOneBar) == 0x000018, "Wrong size on FEnemyHpGaugeOneBar");
static_assert(offsetof(FEnemyHpGaugeOneBar, Episode) == 0x000008, "Member 'FEnemyHpGaugeOneBar::Episode' has a wrong offset!");
static_assert(offsetof(FEnemyHpGaugeOneBar, Chapter) == 0x00000C, "Member 'FEnemyHpGaugeOneBar::Chapter' has a wrong offset!");
static_assert(offsetof(FEnemyHpGaugeOneBar, Part) == 0x000010, "Member 'FEnemyHpGaugeOneBar::Part' has a wrong offset!");
static_assert(offsetof(FEnemyHpGaugeOneBar, OneBarValue) == 0x000014, "Member 'FEnemyHpGaugeOneBar::OneBarValue' has a wrong offset!");

// ScriptStruct AT.TipsParam
// 0x0078 (0x0080 - 0x0008)
struct FTipsParam final : public FTableRowBase
{
public:
	class FName                                   NextTipsId;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dlc3TipsId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dlc4TipsId;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dlc5TipsId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Dlc6TipsId;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CategoryMsgId;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TitleMsgId;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PageMsgId;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextMsgId;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ImageId;                                           // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MovieId;                                           // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveId;                                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultUnlock;                                    // 0x0064(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DlcId;                                             // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LinkTipsIds;                                       // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTipsParam) == 0x000008, "Wrong alignment on FTipsParam");
static_assert(sizeof(FTipsParam) == 0x000080, "Wrong size on FTipsParam");
static_assert(offsetof(FTipsParam, NextTipsId) == 0x000008, "Member 'FTipsParam::NextTipsId' has a wrong offset!");
static_assert(offsetof(FTipsParam, Dlc3TipsId) == 0x000010, "Member 'FTipsParam::Dlc3TipsId' has a wrong offset!");
static_assert(offsetof(FTipsParam, Dlc4TipsId) == 0x000018, "Member 'FTipsParam::Dlc4TipsId' has a wrong offset!");
static_assert(offsetof(FTipsParam, Dlc5TipsId) == 0x000020, "Member 'FTipsParam::Dlc5TipsId' has a wrong offset!");
static_assert(offsetof(FTipsParam, Dlc6TipsId) == 0x000028, "Member 'FTipsParam::Dlc6TipsId' has a wrong offset!");
static_assert(offsetof(FTipsParam, CategoryMsgId) == 0x000030, "Member 'FTipsParam::CategoryMsgId' has a wrong offset!");
static_assert(offsetof(FTipsParam, TitleMsgId) == 0x000038, "Member 'FTipsParam::TitleMsgId' has a wrong offset!");
static_assert(offsetof(FTipsParam, PageMsgId) == 0x000040, "Member 'FTipsParam::PageMsgId' has a wrong offset!");
static_assert(offsetof(FTipsParam, TextMsgId) == 0x000048, "Member 'FTipsParam::TextMsgId' has a wrong offset!");
static_assert(offsetof(FTipsParam, ImageId) == 0x000050, "Member 'FTipsParam::ImageId' has a wrong offset!");
static_assert(offsetof(FTipsParam, MovieId) == 0x000058, "Member 'FTipsParam::MovieId' has a wrong offset!");
static_assert(offsetof(FTipsParam, SaveId) == 0x000060, "Member 'FTipsParam::SaveId' has a wrong offset!");
static_assert(offsetof(FTipsParam, bDefaultUnlock) == 0x000064, "Member 'FTipsParam::bDefaultUnlock' has a wrong offset!");
static_assert(offsetof(FTipsParam, DlcId) == 0x000068, "Member 'FTipsParam::DlcId' has a wrong offset!");
static_assert(offsetof(FTipsParam, LinkTipsIds) == 0x000070, "Member 'FTipsParam::LinkTipsIds' has a wrong offset!");

// ScriptStruct AT.UiMapParam
// 0x00A0 (0x00A8 - 0x0008)
struct FUiMapParam final : public FTableRowBase
{
public:
	class FName                                   JName;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_UI_MAP_TYPE                                 MapType;                                           // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FieldAreaName;                                     // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TownAreaName_1;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TownAreaName_2;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TownAreaName_3;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LandmarkNameList;                                  // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AirRoadWidgetName;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaNameMessageId;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaLocationNameMessageId;                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LeftUp;                                            // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RightDown;                                         // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TexturePath;                                       // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              TextureOffset;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartProgress;                                     // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartMainPhaseNo;                                  // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndProgress;                                       // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndMainPhaseNo;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUiMapParam) == 0x000008, "Wrong alignment on FUiMapParam");
static_assert(sizeof(FUiMapParam) == 0x0000A8, "Wrong size on FUiMapParam");
static_assert(offsetof(FUiMapParam, JName) == 0x000008, "Member 'FUiMapParam::JName' has a wrong offset!");
static_assert(offsetof(FUiMapParam, AreaName) == 0x000010, "Member 'FUiMapParam::AreaName' has a wrong offset!");
static_assert(offsetof(FUiMapParam, MapType) == 0x000018, "Member 'FUiMapParam::MapType' has a wrong offset!");
static_assert(offsetof(FUiMapParam, FieldAreaName) == 0x000020, "Member 'FUiMapParam::FieldAreaName' has a wrong offset!");
static_assert(offsetof(FUiMapParam, TownAreaName_1) == 0x000028, "Member 'FUiMapParam::TownAreaName_1' has a wrong offset!");
static_assert(offsetof(FUiMapParam, TownAreaName_2) == 0x000030, "Member 'FUiMapParam::TownAreaName_2' has a wrong offset!");
static_assert(offsetof(FUiMapParam, TownAreaName_3) == 0x000038, "Member 'FUiMapParam::TownAreaName_3' has a wrong offset!");
static_assert(offsetof(FUiMapParam, LandmarkNameList) == 0x000040, "Member 'FUiMapParam::LandmarkNameList' has a wrong offset!");
static_assert(offsetof(FUiMapParam, AirRoadWidgetName) == 0x000050, "Member 'FUiMapParam::AirRoadWidgetName' has a wrong offset!");
static_assert(offsetof(FUiMapParam, AreaNameMessageId) == 0x000058, "Member 'FUiMapParam::AreaNameMessageId' has a wrong offset!");
static_assert(offsetof(FUiMapParam, AreaLocationNameMessageId) == 0x000060, "Member 'FUiMapParam::AreaLocationNameMessageId' has a wrong offset!");
static_assert(offsetof(FUiMapParam, LeftUp) == 0x000068, "Member 'FUiMapParam::LeftUp' has a wrong offset!");
static_assert(offsetof(FUiMapParam, RightDown) == 0x000070, "Member 'FUiMapParam::RightDown' has a wrong offset!");
static_assert(offsetof(FUiMapParam, TexturePath) == 0x000078, "Member 'FUiMapParam::TexturePath' has a wrong offset!");
static_assert(offsetof(FUiMapParam, TextureOffset) == 0x000080, "Member 'FUiMapParam::TextureOffset' has a wrong offset!");
static_assert(offsetof(FUiMapParam, StartProgress) == 0x000088, "Member 'FUiMapParam::StartProgress' has a wrong offset!");
static_assert(offsetof(FUiMapParam, StartMainPhaseNo) == 0x000090, "Member 'FUiMapParam::StartMainPhaseNo' has a wrong offset!");
static_assert(offsetof(FUiMapParam, EndProgress) == 0x000098, "Member 'FUiMapParam::EndProgress' has a wrong offset!");
static_assert(offsetof(FUiMapParam, EndMainPhaseNo) == 0x0000A0, "Member 'FUiMapParam::EndMainPhaseNo' has a wrong offset!");

// ScriptStruct AT.ComponentActiveInfo
// 0x0008 (0x0010 - 0x0008)
struct FComponentActiveInfo final : public FTableRowBase
{
public:
	bool                                          Active;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Invisible;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Deactive;                                          // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutScreen;                                         // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FComponentActiveInfo) == 0x000008, "Wrong alignment on FComponentActiveInfo");
static_assert(sizeof(FComponentActiveInfo) == 0x000010, "Wrong size on FComponentActiveInfo");
static_assert(offsetof(FComponentActiveInfo, Active) == 0x000008, "Member 'FComponentActiveInfo::Active' has a wrong offset!");
static_assert(offsetof(FComponentActiveInfo, Invisible) == 0x000009, "Member 'FComponentActiveInfo::Invisible' has a wrong offset!");
static_assert(offsetof(FComponentActiveInfo, Deactive) == 0x00000A, "Member 'FComponentActiveInfo::Deactive' has a wrong offset!");
static_assert(offsetof(FComponentActiveInfo, OutScreen) == 0x00000B, "Member 'FComponentActiveInfo::OutScreen' has a wrong offset!");

// ScriptStruct AT.BattleAIBehaviorTable
// 0x0180 (0x0188 - 0x0008)
struct FBattleAIBehaviorTable final : public FTableRowBase
{
public:
	int32                                         Priority;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecastTime;                                        // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGroupAI;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIPhaseCondition                       PhaseConditionType;                                // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhaseConditionValue;                               // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAITargetSituation                      TargetSituation;                                   // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            ConditionType1;                                    // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue1;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            ConditionType2;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue2;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            ConditionType3;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue3;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableCheckProbability;                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnableCheckTimer;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType1;                                     // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue1;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType1;                             // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue1;                            // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime1;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType2;                                     // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue2;                                    // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType2;                             // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue2;                            // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime2;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType3;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue3;                                    // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType3;                             // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue3;                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime3;                                 // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType4;                                     // 0x007C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue4;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType4;                             // 0x0084(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue4;                            // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime4;                                 // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType5;                                     // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue5;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType5;                             // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue5;                            // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime5;                                 // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType6;                                     // 0x00A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue6;                                    // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType6;                             // 0x00AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AD[0x3];                                       // 0x00AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue6;                            // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime6;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType7;                                     // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue7;                                    // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType7;                             // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue7;                            // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime7;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType8;                                     // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD[0x3];                                       // 0x00CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue8;                                    // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType8;                             // 0x00D4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D5[0x3];                                       // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue8;                            // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime8;                                 // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType9;                                     // 0x00E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue9;                                    // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType9;                             // 0x00E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue9;                            // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime9;                                 // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType10;                                    // 0x00F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue10;                                   // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType10;                            // 0x00FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FD[0x3];                                       // 0x00FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue10;                           // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime10;                                // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType11;                                    // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue11;                                   // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType11;                            // 0x0110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x3];                                      // 0x0111(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue11;                           // 0x0114(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime11;                                // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType12;                                    // 0x011C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11D[0x3];                                      // 0x011D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue12;                                   // 0x0120(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType12;                            // 0x0124(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_125[0x3];                                      // 0x0125(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue12;                           // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime12;                                // 0x012C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType13;                                    // 0x0130(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_131[0x3];                                      // 0x0131(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue13;                                   // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType13;                            // 0x0138(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue13;                           // 0x013C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime13;                                // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType14;                                    // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_145[0x3];                                      // 0x0145(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue14;                                   // 0x0148(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType14;                            // 0x014C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14D[0x3];                                      // 0x014D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue14;                           // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime14;                                // 0x0154(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAIBehavior                             BehaviorType15;                                    // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorValue15;                                   // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            BehaviorCompleteType15;                            // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BehaviorCompleteValue15;                           // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BehaviorWaitTime15;                                // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InterruptGroup;                                    // 0x016C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CanInterruptGroup;                                 // 0x0170(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UniqueId;                                          // 0x0178(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleAIBehaviorTable) == 0x000008, "Wrong alignment on FBattleAIBehaviorTable");
static_assert(sizeof(FBattleAIBehaviorTable) == 0x000188, "Wrong size on FBattleAIBehaviorTable");
static_assert(offsetof(FBattleAIBehaviorTable, Priority) == 0x000008, "Member 'FBattleAIBehaviorTable::Priority' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, Probability) == 0x00000C, "Member 'FBattleAIBehaviorTable::Probability' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, RecastTime) == 0x000010, "Member 'FBattleAIBehaviorTable::RecastTime' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, WaitTime) == 0x000014, "Member 'FBattleAIBehaviorTable::WaitTime' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, EnableGroupAI) == 0x000018, "Member 'FBattleAIBehaviorTable::EnableGroupAI' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, PhaseConditionType) == 0x000019, "Member 'FBattleAIBehaviorTable::PhaseConditionType' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, PhaseConditionValue) == 0x00001C, "Member 'FBattleAIBehaviorTable::PhaseConditionValue' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, TargetSituation) == 0x000020, "Member 'FBattleAIBehaviorTable::TargetSituation' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, ConditionType1) == 0x000021, "Member 'FBattleAIBehaviorTable::ConditionType1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, ConditionValue1) == 0x000024, "Member 'FBattleAIBehaviorTable::ConditionValue1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, ConditionType2) == 0x000028, "Member 'FBattleAIBehaviorTable::ConditionType2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, ConditionValue2) == 0x00002C, "Member 'FBattleAIBehaviorTable::ConditionValue2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, ConditionType3) == 0x000030, "Member 'FBattleAIBehaviorTable::ConditionType3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, ConditionValue3) == 0x000034, "Member 'FBattleAIBehaviorTable::ConditionValue3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, EnableCheckProbability) == 0x000038, "Member 'FBattleAIBehaviorTable::EnableCheckProbability' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, EnableCheckTimer) == 0x00003C, "Member 'FBattleAIBehaviorTable::EnableCheckTimer' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType1) == 0x000040, "Member 'FBattleAIBehaviorTable::BehaviorType1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue1) == 0x000044, "Member 'FBattleAIBehaviorTable::BehaviorValue1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType1) == 0x000048, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue1) == 0x00004C, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime1) == 0x000050, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime1' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType2) == 0x000054, "Member 'FBattleAIBehaviorTable::BehaviorType2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue2) == 0x000058, "Member 'FBattleAIBehaviorTable::BehaviorValue2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType2) == 0x00005C, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue2) == 0x000060, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime2) == 0x000064, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime2' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType3) == 0x000068, "Member 'FBattleAIBehaviorTable::BehaviorType3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue3) == 0x00006C, "Member 'FBattleAIBehaviorTable::BehaviorValue3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType3) == 0x000070, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue3) == 0x000074, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime3) == 0x000078, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime3' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType4) == 0x00007C, "Member 'FBattleAIBehaviorTable::BehaviorType4' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue4) == 0x000080, "Member 'FBattleAIBehaviorTable::BehaviorValue4' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType4) == 0x000084, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType4' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue4) == 0x000088, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue4' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime4) == 0x00008C, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime4' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType5) == 0x000090, "Member 'FBattleAIBehaviorTable::BehaviorType5' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue5) == 0x000094, "Member 'FBattleAIBehaviorTable::BehaviorValue5' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType5) == 0x000098, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType5' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue5) == 0x00009C, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue5' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime5) == 0x0000A0, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime5' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType6) == 0x0000A4, "Member 'FBattleAIBehaviorTable::BehaviorType6' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue6) == 0x0000A8, "Member 'FBattleAIBehaviorTable::BehaviorValue6' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType6) == 0x0000AC, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType6' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue6) == 0x0000B0, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue6' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime6) == 0x0000B4, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime6' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType7) == 0x0000B8, "Member 'FBattleAIBehaviorTable::BehaviorType7' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue7) == 0x0000BC, "Member 'FBattleAIBehaviorTable::BehaviorValue7' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType7) == 0x0000C0, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType7' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue7) == 0x0000C4, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue7' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime7) == 0x0000C8, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime7' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType8) == 0x0000CC, "Member 'FBattleAIBehaviorTable::BehaviorType8' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue8) == 0x0000D0, "Member 'FBattleAIBehaviorTable::BehaviorValue8' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType8) == 0x0000D4, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType8' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue8) == 0x0000D8, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue8' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime8) == 0x0000DC, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime8' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType9) == 0x0000E0, "Member 'FBattleAIBehaviorTable::BehaviorType9' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue9) == 0x0000E4, "Member 'FBattleAIBehaviorTable::BehaviorValue9' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType9) == 0x0000E8, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType9' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue9) == 0x0000EC, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue9' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime9) == 0x0000F0, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime9' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType10) == 0x0000F4, "Member 'FBattleAIBehaviorTable::BehaviorType10' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue10) == 0x0000F8, "Member 'FBattleAIBehaviorTable::BehaviorValue10' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType10) == 0x0000FC, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType10' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue10) == 0x000100, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue10' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime10) == 0x000104, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime10' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType11) == 0x000108, "Member 'FBattleAIBehaviorTable::BehaviorType11' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue11) == 0x00010C, "Member 'FBattleAIBehaviorTable::BehaviorValue11' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType11) == 0x000110, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType11' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue11) == 0x000114, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue11' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime11) == 0x000118, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime11' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType12) == 0x00011C, "Member 'FBattleAIBehaviorTable::BehaviorType12' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue12) == 0x000120, "Member 'FBattleAIBehaviorTable::BehaviorValue12' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType12) == 0x000124, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType12' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue12) == 0x000128, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue12' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime12) == 0x00012C, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime12' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType13) == 0x000130, "Member 'FBattleAIBehaviorTable::BehaviorType13' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue13) == 0x000134, "Member 'FBattleAIBehaviorTable::BehaviorValue13' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType13) == 0x000138, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType13' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue13) == 0x00013C, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue13' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime13) == 0x000140, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime13' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType14) == 0x000144, "Member 'FBattleAIBehaviorTable::BehaviorType14' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue14) == 0x000148, "Member 'FBattleAIBehaviorTable::BehaviorValue14' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType14) == 0x00014C, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType14' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue14) == 0x000150, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue14' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime14) == 0x000154, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime14' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorType15) == 0x000158, "Member 'FBattleAIBehaviorTable::BehaviorType15' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorValue15) == 0x00015C, "Member 'FBattleAIBehaviorTable::BehaviorValue15' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteType15) == 0x000160, "Member 'FBattleAIBehaviorTable::BehaviorCompleteType15' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorCompleteValue15) == 0x000164, "Member 'FBattleAIBehaviorTable::BehaviorCompleteValue15' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, BehaviorWaitTime15) == 0x000168, "Member 'FBattleAIBehaviorTable::BehaviorWaitTime15' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, InterruptGroup) == 0x00016C, "Member 'FBattleAIBehaviorTable::InterruptGroup' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, CanInterruptGroup) == 0x000170, "Member 'FBattleAIBehaviorTable::CanInterruptGroup' has a wrong offset!");
static_assert(offsetof(FBattleAIBehaviorTable, UniqueId) == 0x000178, "Member 'FBattleAIBehaviorTable::UniqueId' has a wrong offset!");

// ScriptStruct AT.DlcMenuItem
// 0x00E0 (0x00E0 - 0x0000)
struct FDlcMenuItem final
{
public:
	class FName                                   CommonId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Summary;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Image_Path;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_Id;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_dlc_Id;                                     // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_dlc2_Id;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_dlc3_Id;                                    // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_DLC4_Id;                                    // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_DLC5_Id;                                    // 0x0088(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_DLC6_Id;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_FirstNotice_Id;                             // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Dialog_unusable_Id;                                // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Details_Id;                                        // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestId;                                           // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDlcMenuItem) == 0x000008, "Wrong alignment on FDlcMenuItem");
static_assert(sizeof(FDlcMenuItem) == 0x0000E0, "Wrong size on FDlcMenuItem");
static_assert(offsetof(FDlcMenuItem, CommonId) == 0x000000, "Member 'FDlcMenuItem::CommonId' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Summary) == 0x000008, "Member 'FDlcMenuItem::Summary' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Image_Path) == 0x000018, "Member 'FDlcMenuItem::Image_Path' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Title) == 0x000028, "Member 'FDlcMenuItem::Title' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_Id) == 0x000038, "Member 'FDlcMenuItem::Dialog_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_dlc_Id) == 0x000048, "Member 'FDlcMenuItem::Dialog_dlc_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_dlc2_Id) == 0x000058, "Member 'FDlcMenuItem::Dialog_dlc2_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_dlc3_Id) == 0x000068, "Member 'FDlcMenuItem::Dialog_dlc3_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_DLC4_Id) == 0x000078, "Member 'FDlcMenuItem::Dialog_DLC4_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_DLC5_Id) == 0x000088, "Member 'FDlcMenuItem::Dialog_DLC5_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_DLC6_Id) == 0x000098, "Member 'FDlcMenuItem::Dialog_DLC6_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_FirstNotice_Id) == 0x0000A8, "Member 'FDlcMenuItem::Dialog_FirstNotice_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Dialog_unusable_Id) == 0x0000B8, "Member 'FDlcMenuItem::Dialog_unusable_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, Details_Id) == 0x0000C8, "Member 'FDlcMenuItem::Details_Id' has a wrong offset!");
static_assert(offsetof(FDlcMenuItem, QuestId) == 0x0000D8, "Member 'FDlcMenuItem::QuestId' has a wrong offset!");

// ScriptStruct AT.CurrencyBasedCustomShopMessagesParam
// 0x00D8 (0x00E0 - 0x0008)
struct FCurrencyBasedCustomShopMessagesParam final : public FTableRowBase
{
public:
	ESHOP_MONEY_CURRENCY_TYPE                     CurrencyType;                                      // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 BuyHeader;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SellHeader;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PriceColumnHeader;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PurchaseCountColumnHeader;                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SaleCountColumnHeader;                             // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionCostTotalMessage;                       // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PurchaseInputLabelMessage;                         // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SaleInputLabelMessage;                             // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PurchaseConfirmDialogMessage;                      // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SaleConfirmDialogMessage;                          // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InsufficientFundsForPurchaseDialogMessage;         // 0x00B0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TooMuchFundsAfterSaleDialogMessage;                // 0x00C0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TransactionImpossibleDialogMessage;                // 0x00D0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCurrencyBasedCustomShopMessagesParam) == 0x000008, "Wrong alignment on FCurrencyBasedCustomShopMessagesParam");
static_assert(sizeof(FCurrencyBasedCustomShopMessagesParam) == 0x0000E0, "Wrong size on FCurrencyBasedCustomShopMessagesParam");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, CurrencyType) == 0x000008, "Member 'FCurrencyBasedCustomShopMessagesParam::CurrencyType' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, BuyHeader) == 0x000010, "Member 'FCurrencyBasedCustomShopMessagesParam::BuyHeader' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, SellHeader) == 0x000020, "Member 'FCurrencyBasedCustomShopMessagesParam::SellHeader' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, PriceColumnHeader) == 0x000030, "Member 'FCurrencyBasedCustomShopMessagesParam::PriceColumnHeader' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, PurchaseCountColumnHeader) == 0x000040, "Member 'FCurrencyBasedCustomShopMessagesParam::PurchaseCountColumnHeader' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, SaleCountColumnHeader) == 0x000050, "Member 'FCurrencyBasedCustomShopMessagesParam::SaleCountColumnHeader' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, TransactionCostTotalMessage) == 0x000060, "Member 'FCurrencyBasedCustomShopMessagesParam::TransactionCostTotalMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, PurchaseInputLabelMessage) == 0x000070, "Member 'FCurrencyBasedCustomShopMessagesParam::PurchaseInputLabelMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, SaleInputLabelMessage) == 0x000080, "Member 'FCurrencyBasedCustomShopMessagesParam::SaleInputLabelMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, PurchaseConfirmDialogMessage) == 0x000090, "Member 'FCurrencyBasedCustomShopMessagesParam::PurchaseConfirmDialogMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, SaleConfirmDialogMessage) == 0x0000A0, "Member 'FCurrencyBasedCustomShopMessagesParam::SaleConfirmDialogMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, InsufficientFundsForPurchaseDialogMessage) == 0x0000B0, "Member 'FCurrencyBasedCustomShopMessagesParam::InsufficientFundsForPurchaseDialogMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, TooMuchFundsAfterSaleDialogMessage) == 0x0000C0, "Member 'FCurrencyBasedCustomShopMessagesParam::TooMuchFundsAfterSaleDialogMessage' has a wrong offset!");
static_assert(offsetof(FCurrencyBasedCustomShopMessagesParam, TransactionImpossibleDialogMessage) == 0x0000D0, "Member 'FCurrencyBasedCustomShopMessagesParam::TransactionImpossibleDialogMessage' has a wrong offset!");

// ScriptStruct AT.ATDataAssetGBResultInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetGBResultInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            PlayerAnimB;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetGBResultInfo) == 0x000008, "Wrong alignment on FATDataAssetGBResultInfo");
static_assert(sizeof(FATDataAssetGBResultInfo) == 0x000030, "Wrong size on FATDataAssetGBResultInfo");
static_assert(offsetof(FATDataAssetGBResultInfo, MasterId) == 0x000000, "Member 'FATDataAssetGBResultInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetGBResultInfo, PlayerAnimB) == 0x000008, "Member 'FATDataAssetGBResultInfo::PlayerAnimB' has a wrong offset!");

// ScriptStruct AT.MobParameterInfo
// 0x0018 (0x0018 - 0x0000)
struct FMobParameterInfo final
{
public:
	float                                         WalkingSpeed;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingSpeed_RandHigh;                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingSpeed_RandLow;                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunningSpeed;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunningSpeed_RandHigh;                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunningSpeed_RandLow;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMobParameterInfo) == 0x000004, "Wrong alignment on FMobParameterInfo");
static_assert(sizeof(FMobParameterInfo) == 0x000018, "Wrong size on FMobParameterInfo");
static_assert(offsetof(FMobParameterInfo, WalkingSpeed) == 0x000000, "Member 'FMobParameterInfo::WalkingSpeed' has a wrong offset!");
static_assert(offsetof(FMobParameterInfo, WalkingSpeed_RandHigh) == 0x000004, "Member 'FMobParameterInfo::WalkingSpeed_RandHigh' has a wrong offset!");
static_assert(offsetof(FMobParameterInfo, WalkingSpeed_RandLow) == 0x000008, "Member 'FMobParameterInfo::WalkingSpeed_RandLow' has a wrong offset!");
static_assert(offsetof(FMobParameterInfo, RunningSpeed) == 0x00000C, "Member 'FMobParameterInfo::RunningSpeed' has a wrong offset!");
static_assert(offsetof(FMobParameterInfo, RunningSpeed_RandHigh) == 0x000010, "Member 'FMobParameterInfo::RunningSpeed_RandHigh' has a wrong offset!");
static_assert(offsetof(FMobParameterInfo, RunningSpeed_RandLow) == 0x000014, "Member 'FMobParameterInfo::RunningSpeed_RandLow' has a wrong offset!");

// ScriptStruct AT.SetTownMobParameter
// 0x0020 (0x0028 - 0x0008)
struct FSetTownMobParameter final : public FTableRowBase
{
public:
	ENpcMobType                                   MobType;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMobParameterInfo                      Parameter;                                         // 0x000C(0x0018)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSetTownMobParameter) == 0x000008, "Wrong alignment on FSetTownMobParameter");
static_assert(sizeof(FSetTownMobParameter) == 0x000028, "Wrong size on FSetTownMobParameter");
static_assert(offsetof(FSetTownMobParameter, MobType) == 0x000008, "Member 'FSetTownMobParameter::MobType' has a wrong offset!");
static_assert(offsetof(FSetTownMobParameter, Parameter) == 0x00000C, "Member 'FSetTownMobParameter::Parameter' has a wrong offset!");

// ScriptStruct AT.BattlePowerTextData
// 0x0028 (0x0028 - 0x0000)
struct FBattlePowerTextData final
{
public:
	int64                                         MinValue;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int64                                         MaxValue;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LinearColor;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseEffect;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattlePowerTextData) == 0x000008, "Wrong alignment on FBattlePowerTextData");
static_assert(sizeof(FBattlePowerTextData) == 0x000028, "Wrong size on FBattlePowerTextData");
static_assert(offsetof(FBattlePowerTextData, MinValue) == 0x000000, "Member 'FBattlePowerTextData::MinValue' has a wrong offset!");
static_assert(offsetof(FBattlePowerTextData, MaxValue) == 0x000008, "Member 'FBattlePowerTextData::MaxValue' has a wrong offset!");
static_assert(offsetof(FBattlePowerTextData, LinearColor) == 0x000010, "Member 'FBattlePowerTextData::LinearColor' has a wrong offset!");
static_assert(offsetof(FBattlePowerTextData, bUseEffect) == 0x000020, "Member 'FBattlePowerTextData::bUseEffect' has a wrong offset!");

// ScriptStruct AT.QuestNotifyCondition
// 0x0018 (0x0020 - 0x0008)
struct FQuestNotifyCondition final : public FTableRowBase
{
public:
	ENotyfyConditionCategory                      Category;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProgressStartId;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressEndId;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestNotifyCondition) == 0x000008, "Wrong alignment on FQuestNotifyCondition");
static_assert(sizeof(FQuestNotifyCondition) == 0x000020, "Wrong size on FQuestNotifyCondition");
static_assert(offsetof(FQuestNotifyCondition, Category) == 0x000008, "Member 'FQuestNotifyCondition::Category' has a wrong offset!");
static_assert(offsetof(FQuestNotifyCondition, ProgressStartId) == 0x000010, "Member 'FQuestNotifyCondition::ProgressStartId' has a wrong offset!");
static_assert(offsetof(FQuestNotifyCondition, ProgressEndId) == 0x000018, "Member 'FQuestNotifyCondition::ProgressEndId' has a wrong offset!");

// ScriptStruct AT.ReferenceToCookDemoAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToCookDemoAssetInstance final
{
public:
	TSubclassOf<class ALevelSequenceActor>        Sequencer;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToCookDemoAssetInstance) == 0x000008, "Wrong alignment on FReferenceToCookDemoAssetInstance");
static_assert(sizeof(FReferenceToCookDemoAssetInstance) == 0x000008, "Wrong size on FReferenceToCookDemoAssetInstance");
static_assert(offsetof(FReferenceToCookDemoAssetInstance, Sequencer) == 0x000000, "Member 'FReferenceToCookDemoAssetInstance::Sequencer' has a wrong offset!");

// ScriptStruct AT.WalkingMobTalk
// 0x0018 (0x0020 - 0x0008)
struct FWalkingMobTalk final : public FTableRowBase
{
public:
	class FName                                   QuestPhase;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StringID;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWalkingMobTalk) == 0x000008, "Wrong alignment on FWalkingMobTalk");
static_assert(sizeof(FWalkingMobTalk) == 0x000020, "Wrong size on FWalkingMobTalk");
static_assert(offsetof(FWalkingMobTalk, QuestPhase) == 0x000008, "Member 'FWalkingMobTalk::QuestPhase' has a wrong offset!");
static_assert(offsetof(FWalkingMobTalk, StringID) == 0x000010, "Member 'FWalkingMobTalk::StringID' has a wrong offset!");

// ScriptStruct AT.SkillTreeDataTable
// 0x0098 (0x00A0 - 0x0008)
struct FSkillTreeDataTable final : public FTableRowBase
{
public:
	class FString                                 Discription;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Character;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Skill;                                             // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillLevel;                                        // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OpenSkillTree1;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenSkillTree2;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenSkillTree3;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenQuest;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VisibleQuestId;                                    // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharacterLevel;                                    // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QuestConditionMessageOverride;                     // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cost;                                              // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostBlue;                                          // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostGreen;                                         // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostRainbow;                                       // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostWhite;                                         // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostPureWhite;                                     // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DlcId;                                             // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveNo;                                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillTreeDataTable) == 0x000008, "Wrong alignment on FSkillTreeDataTable");
static_assert(sizeof(FSkillTreeDataTable) == 0x0000A0, "Wrong size on FSkillTreeDataTable");
static_assert(offsetof(FSkillTreeDataTable, Discription) == 0x000008, "Member 'FSkillTreeDataTable::Discription' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, Character) == 0x000018, "Member 'FSkillTreeDataTable::Character' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, Skill) == 0x000020, "Member 'FSkillTreeDataTable::Skill' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, SkillLevel) == 0x000028, "Member 'FSkillTreeDataTable::SkillLevel' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, OpenSkillTree1) == 0x000030, "Member 'FSkillTreeDataTable::OpenSkillTree1' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, OpenSkillTree2) == 0x000038, "Member 'FSkillTreeDataTable::OpenSkillTree2' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, OpenSkillTree3) == 0x000040, "Member 'FSkillTreeDataTable::OpenSkillTree3' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, OpenQuest) == 0x000048, "Member 'FSkillTreeDataTable::OpenQuest' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, VisibleQuestId) == 0x000050, "Member 'FSkillTreeDataTable::VisibleQuestId' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, CharacterLevel) == 0x000058, "Member 'FSkillTreeDataTable::CharacterLevel' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, QuestConditionMessageOverride) == 0x000060, "Member 'FSkillTreeDataTable::QuestConditionMessageOverride' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, Cost) == 0x000070, "Member 'FSkillTreeDataTable::Cost' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, CostBlue) == 0x000074, "Member 'FSkillTreeDataTable::CostBlue' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, CostGreen) == 0x000078, "Member 'FSkillTreeDataTable::CostGreen' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, CostRainbow) == 0x00007C, "Member 'FSkillTreeDataTable::CostRainbow' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, CostWhite) == 0x000080, "Member 'FSkillTreeDataTable::CostWhite' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, CostPureWhite) == 0x000084, "Member 'FSkillTreeDataTable::CostPureWhite' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, Rarity) == 0x000088, "Member 'FSkillTreeDataTable::Rarity' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, DlcId) == 0x000090, "Member 'FSkillTreeDataTable::DlcId' has a wrong offset!");
static_assert(offsetof(FSkillTreeDataTable, SaveNo) == 0x000098, "Member 'FSkillTreeDataTable::SaveNo' has a wrong offset!");

// ScriptStruct AT.DoorEventArgment
// 0x0004 (0x0004 - 0x0000)
struct alignas(0x04) FDoorEventArgment final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDoorEventArgment) == 0x000004, "Wrong alignment on FDoorEventArgment");
static_assert(sizeof(FDoorEventArgment) == 0x000004, "Wrong size on FDoorEventArgment");

// ScriptStruct AT.ItemTradeUpdatableCondition
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FItemTradeUpdatableCondition final
{
public:
	class FName                                   DisableProgressIdBegin;                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisablePhaseIdBegin;                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableProgressIdEnd;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisablePhaseIdEnd;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTradeUpdatableCondition) == 0x000008, "Wrong alignment on FItemTradeUpdatableCondition");
static_assert(sizeof(FItemTradeUpdatableCondition) == 0x000020, "Wrong size on FItemTradeUpdatableCondition");
static_assert(offsetof(FItemTradeUpdatableCondition, DisableProgressIdBegin) == 0x000000, "Member 'FItemTradeUpdatableCondition::DisableProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FItemTradeUpdatableCondition, DisablePhaseIdBegin) == 0x000008, "Member 'FItemTradeUpdatableCondition::DisablePhaseIdBegin' has a wrong offset!");
static_assert(offsetof(FItemTradeUpdatableCondition, DisableProgressIdEnd) == 0x000010, "Member 'FItemTradeUpdatableCondition::DisableProgressIdEnd' has a wrong offset!");
static_assert(offsetof(FItemTradeUpdatableCondition, DisablePhaseIdEnd) == 0x000018, "Member 'FItemTradeUpdatableCondition::DisablePhaseIdEnd' has a wrong offset!");

// ScriptStruct AT.NpcVariety_Fly
// 0x0018 (0x0018 - 0x0000)
struct FNpcVariety_Fly final
{
public:
	float                                         FlySpeedHigh;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySpeedLow;                                       // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAngleYawHigh;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAngleYawLow;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAnglePitchHigh;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAnglePitchLow;                                  // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcVariety_Fly) == 0x000004, "Wrong alignment on FNpcVariety_Fly");
static_assert(sizeof(FNpcVariety_Fly) == 0x000018, "Wrong size on FNpcVariety_Fly");
static_assert(offsetof(FNpcVariety_Fly, FlySpeedHigh) == 0x000000, "Member 'FNpcVariety_Fly::FlySpeedHigh' has a wrong offset!");
static_assert(offsetof(FNpcVariety_Fly, FlySpeedLow) == 0x000004, "Member 'FNpcVariety_Fly::FlySpeedLow' has a wrong offset!");
static_assert(offsetof(FNpcVariety_Fly, FlyAngleYawHigh) == 0x000008, "Member 'FNpcVariety_Fly::FlyAngleYawHigh' has a wrong offset!");
static_assert(offsetof(FNpcVariety_Fly, FlyAngleYawLow) == 0x00000C, "Member 'FNpcVariety_Fly::FlyAngleYawLow' has a wrong offset!");
static_assert(offsetof(FNpcVariety_Fly, FlyAnglePitchHigh) == 0x000010, "Member 'FNpcVariety_Fly::FlyAnglePitchHigh' has a wrong offset!");
static_assert(offsetof(FNpcVariety_Fly, FlyAnglePitchLow) == 0x000014, "Member 'FNpcVariety_Fly::FlyAnglePitchLow' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupBgmInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FGameWindowSetupBgmInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupBgmInfo) == 0x000008, "Wrong alignment on FGameWindowSetupBgmInfo");
static_assert(sizeof(FGameWindowSetupBgmInfo) == 0x000018, "Wrong size on FGameWindowSetupBgmInfo");

// ScriptStruct AT.GameWindowSetupBannedSkillList
// 0x0018 (0x0018 - 0x0000)
struct FGameWindowSetupBannedSkillList final
{
public:
	class UTexture2D*                             CharTex;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupBannedSkillList) == 0x000008, "Wrong alignment on FGameWindowSetupBannedSkillList");
static_assert(sizeof(FGameWindowSetupBannedSkillList) == 0x000018, "Wrong size on FGameWindowSetupBannedSkillList");
static_assert(offsetof(FGameWindowSetupBannedSkillList, CharTex) == 0x000000, "Member 'FGameWindowSetupBannedSkillList::CharTex' has a wrong offset!");

// ScriptStruct AT.ATDataAssetRaceGameCommonInfo
// 0x0028 (0x0028 - 0x0000)
struct FATDataAssetRaceGameCommonInfo final
{
public:
	TSoftObjectPtr<class UDataTable>              RaceGameDataTable;                                 // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetRaceGameCommonInfo) == 0x000008, "Wrong alignment on FATDataAssetRaceGameCommonInfo");
static_assert(sizeof(FATDataAssetRaceGameCommonInfo) == 0x000028, "Wrong size on FATDataAssetRaceGameCommonInfo");
static_assert(offsetof(FATDataAssetRaceGameCommonInfo, RaceGameDataTable) == 0x000000, "Member 'FATDataAssetRaceGameCommonInfo::RaceGameDataTable' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupBuffInfo
// 0x0020 (0x0020 - 0x0000)
struct FGameWindowSetupBuffInfo final
{
public:
	E_STATE_ICON_TYPE                             StateIconType;                                     // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 StateName;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeBuffValue;                                   // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterBuffValue;                                    // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameWindowSetupBuffInfo) == 0x000008, "Wrong alignment on FGameWindowSetupBuffInfo");
static_assert(sizeof(FGameWindowSetupBuffInfo) == 0x000020, "Wrong size on FGameWindowSetupBuffInfo");
static_assert(offsetof(FGameWindowSetupBuffInfo, StateIconType) == 0x000000, "Member 'FGameWindowSetupBuffInfo::StateIconType' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupBuffInfo, StateName) == 0x000008, "Member 'FGameWindowSetupBuffInfo::StateName' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupBuffInfo, BeforeBuffValue) == 0x000018, "Member 'FGameWindowSetupBuffInfo::BeforeBuffValue' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupBuffInfo, AfterBuffValue) == 0x00001C, "Member 'FGameWindowSetupBuffInfo::AfterBuffValue' has a wrong offset!");

// ScriptStruct AT.CooperationTalkInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCooperationTalkInfo final
{
public:
	class FName                                   TalkID;                                            // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCooperationTalkInfo) == 0x000008, "Wrong alignment on FCooperationTalkInfo");
static_assert(sizeof(FCooperationTalkInfo) == 0x000010, "Wrong size on FCooperationTalkInfo");
static_assert(offsetof(FCooperationTalkInfo, TalkID) == 0x000000, "Member 'FCooperationTalkInfo::TalkID' has a wrong offset!");
static_assert(offsetof(FCooperationTalkInfo, Duration) == 0x000008, "Member 'FCooperationTalkInfo::Duration' has a wrong offset!");

// ScriptStruct AT.MemberTalkInfo
// 0x0018 (0x0018 - 0x0000)
struct FMemberTalkInfo final
{
public:
	ECHARACTER_TYPE                               Character;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCooperationTalkInfo                   Info;                                              // 0x0008(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMemberTalkInfo) == 0x000008, "Wrong alignment on FMemberTalkInfo");
static_assert(sizeof(FMemberTalkInfo) == 0x000018, "Wrong size on FMemberTalkInfo");
static_assert(offsetof(FMemberTalkInfo, Character) == 0x000000, "Member 'FMemberTalkInfo::Character' has a wrong offset!");
static_assert(offsetof(FMemberTalkInfo, Info) == 0x000008, "Member 'FMemberTalkInfo::Info' has a wrong offset!");

// ScriptStruct AT.ExclusiveTalkInfo
// 0x0040 (0x0040 - 0x0000)
struct FExclusiveTalkInfo final
{
public:
	struct FCooperationTalkInfo                   OwnerInfo;                                         // 0x0000(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FMemberTalkInfo                        MemberTalkInfo[0x2];                               // 0x0010(0x0018)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExclusiveTalkInfo) == 0x000008, "Wrong alignment on FExclusiveTalkInfo");
static_assert(sizeof(FExclusiveTalkInfo) == 0x000040, "Wrong size on FExclusiveTalkInfo");
static_assert(offsetof(FExclusiveTalkInfo, OwnerInfo) == 0x000000, "Member 'FExclusiveTalkInfo::OwnerInfo' has a wrong offset!");
static_assert(offsetof(FExclusiveTalkInfo, MemberTalkInfo) == 0x000010, "Member 'FExclusiveTalkInfo::MemberTalkInfo' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupComuEmbInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FGameWindowSetupComuEmbInfo final
{
public:
	class FName                                   SoulEmId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameWindowSetupComuEmbInfo) == 0x000008, "Wrong alignment on FGameWindowSetupComuEmbInfo");
static_assert(sizeof(FGameWindowSetupComuEmbInfo) == 0x000008, "Wrong size on FGameWindowSetupComuEmbInfo");
static_assert(offsetof(FGameWindowSetupComuEmbInfo, SoulEmId) == 0x000000, "Member 'FGameWindowSetupComuEmbInfo::SoulEmId' has a wrong offset!");

// ScriptStruct AT.ReferenceToMiniGameAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToMiniGameAssetInstance final
{
public:
	TSubclassOf<class UCFUIUserWidget>            UserWidgetClass;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToMiniGameAssetInstance) == 0x000008, "Wrong alignment on FReferenceToMiniGameAssetInstance");
static_assert(sizeof(FReferenceToMiniGameAssetInstance) == 0x000008, "Wrong size on FReferenceToMiniGameAssetInstance");
static_assert(offsetof(FReferenceToMiniGameAssetInstance, UserWidgetClass) == 0x000000, "Member 'FReferenceToMiniGameAssetInstance::UserWidgetClass' has a wrong offset!");

// ScriptStruct AT.FishProbabilityInfo
// 0x0010 (0x0018 - 0x0008)
struct FFishProbabilityInfo final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFishProbabilityInfo) == 0x000008, "Wrong alignment on FFishProbabilityInfo");
static_assert(sizeof(FFishProbabilityInfo) == 0x000018, "Wrong size on FFishProbabilityInfo");
static_assert(offsetof(FFishProbabilityInfo, ItemId) == 0x000008, "Member 'FFishProbabilityInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FFishProbabilityInfo, Probability) == 0x000010, "Member 'FFishProbabilityInfo::Probability' has a wrong offset!");

// ScriptStruct AT.ReferenceToBattleDemoSceneAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToBattleDemoSceneAssetInstance final
{
public:
	class ULevelSequence*                         Sequencer;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToBattleDemoSceneAssetInstance) == 0x000008, "Wrong alignment on FReferenceToBattleDemoSceneAssetInstance");
static_assert(sizeof(FReferenceToBattleDemoSceneAssetInstance) == 0x000008, "Wrong size on FReferenceToBattleDemoSceneAssetInstance");
static_assert(offsetof(FReferenceToBattleDemoSceneAssetInstance, Sequencer) == 0x000000, "Member 'FReferenceToBattleDemoSceneAssetInstance::Sequencer' has a wrong offset!");

// ScriptStruct AT.MissionProgressSet
// 0x0950 (0x0950 - 0x0000)
struct FMissionProgressSet final
{
public:
	struct FMissionProgress                       Progress[0x63];                                    // 0x0000(0x0018)(NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CurrentPhaseNo;                                    // 0x0948(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_94C[0x4];                                      // 0x094C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionProgressSet) == 0x000008, "Wrong alignment on FMissionProgressSet");
static_assert(sizeof(FMissionProgressSet) == 0x000950, "Wrong size on FMissionProgressSet");
static_assert(offsetof(FMissionProgressSet, Progress) == 0x000000, "Member 'FMissionProgressSet::Progress' has a wrong offset!");
static_assert(offsetof(FMissionProgressSet, CurrentPhaseNo) == 0x000948, "Member 'FMissionProgressSet::CurrentPhaseNo' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupTextMenuInfo
// 0x0010 (0x0010 - 0x0000)
struct FGameWindowSetupTextMenuInfo final
{
public:
	class FString                                 MenuName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameWindowSetupTextMenuInfo) == 0x000008, "Wrong alignment on FGameWindowSetupTextMenuInfo");
static_assert(sizeof(FGameWindowSetupTextMenuInfo) == 0x000010, "Wrong size on FGameWindowSetupTextMenuInfo");
static_assert(offsetof(FGameWindowSetupTextMenuInfo, MenuName) == 0x000000, "Member 'FGameWindowSetupTextMenuInfo::MenuName' has a wrong offset!");

// ScriptStruct AT.LoadingMiniGameAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingMiniGameAsset final
{
public:
	TSoftClassPtr<class UClass>                   UserWidgetClass;                                   // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingMiniGameAsset) == 0x000008, "Wrong alignment on FLoadingMiniGameAsset");
static_assert(sizeof(FLoadingMiniGameAsset) == 0x000028, "Wrong size on FLoadingMiniGameAsset");
static_assert(offsetof(FLoadingMiniGameAsset, UserWidgetClass) == 0x000000, "Member 'FLoadingMiniGameAsset::UserWidgetClass' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupCheckInfo
// 0x0038 (0x0038 - 0x0000)
struct FGameWindowSetupCheckInfo final
{
public:
	bool                                          ItemChecked;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ItemReceived;                                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemCondition;                                     // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               ItemIconType;                                      // 0x002C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemRarity;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupCheckInfo) == 0x000008, "Wrong alignment on FGameWindowSetupCheckInfo");
static_assert(sizeof(FGameWindowSetupCheckInfo) == 0x000038, "Wrong size on FGameWindowSetupCheckInfo");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemChecked) == 0x000000, "Member 'FGameWindowSetupCheckInfo::ItemChecked' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemReceived) == 0x000001, "Member 'FGameWindowSetupCheckInfo::ItemReceived' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemCondition) == 0x000008, "Member 'FGameWindowSetupCheckInfo::ItemCondition' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemName) == 0x000018, "Member 'FGameWindowSetupCheckInfo::ItemName' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemNum) == 0x000028, "Member 'FGameWindowSetupCheckInfo::ItemNum' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemIconType) == 0x00002C, "Member 'FGameWindowSetupCheckInfo::ItemIconType' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupCheckInfo, ItemRarity) == 0x000030, "Member 'FGameWindowSetupCheckInfo::ItemRarity' has a wrong offset!");

// ScriptStruct AT.ATDataAssetMiniGameMobAnimationInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetMiniGameMobAnimationInfo final
{
public:
	ENpcMobType                                   MobTypeId;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimationBP;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetMiniGameMobAnimationInfo) == 0x000008, "Wrong alignment on FATDataAssetMiniGameMobAnimationInfo");
static_assert(sizeof(FATDataAssetMiniGameMobAnimationInfo) == 0x000030, "Wrong size on FATDataAssetMiniGameMobAnimationInfo");
static_assert(offsetof(FATDataAssetMiniGameMobAnimationInfo, MobTypeId) == 0x000000, "Member 'FATDataAssetMiniGameMobAnimationInfo::MobTypeId' has a wrong offset!");
static_assert(offsetof(FATDataAssetMiniGameMobAnimationInfo, AnimationBP) == 0x000008, "Member 'FATDataAssetMiniGameMobAnimationInfo::AnimationBP' has a wrong offset!");

// ScriptStruct AT.GameWindowSetupSelectItemInfo
// 0x0030 (0x0030 - 0x0000)
struct FGameWindowSetupSelectItemInfo final
{
public:
	class FString                                 ItemName;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemDetail;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_ICON_TYPE                               ItemIconType;                                      // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ItemRarity;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGameWindowSetupSelectItemInfo) == 0x000008, "Wrong alignment on FGameWindowSetupSelectItemInfo");
static_assert(sizeof(FGameWindowSetupSelectItemInfo) == 0x000030, "Wrong size on FGameWindowSetupSelectItemInfo");
static_assert(offsetof(FGameWindowSetupSelectItemInfo, ItemName) == 0x000000, "Member 'FGameWindowSetupSelectItemInfo::ItemName' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupSelectItemInfo, ItemDetail) == 0x000010, "Member 'FGameWindowSetupSelectItemInfo::ItemDetail' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupSelectItemInfo, ItemNum) == 0x000020, "Member 'FGameWindowSetupSelectItemInfo::ItemNum' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupSelectItemInfo, ItemIconType) == 0x000024, "Member 'FGameWindowSetupSelectItemInfo::ItemIconType' has a wrong offset!");
static_assert(offsetof(FGameWindowSetupSelectItemInfo, ItemRarity) == 0x000028, "Member 'FGameWindowSetupSelectItemInfo::ItemRarity' has a wrong offset!");

// ScriptStruct AT.LoadingFishGameCharaAnimationAsset
// 0x0320 (0x0320 - 0x0000)
struct alignas(0x08) FLoadingFishGameCharaAnimationAsset final
{
public:
	uint8                                         Pad_0[0x320];                                      // 0x0000(0x0320)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingFishGameCharaAnimationAsset) == 0x000008, "Wrong alignment on FLoadingFishGameCharaAnimationAsset");
static_assert(sizeof(FLoadingFishGameCharaAnimationAsset) == 0x000320, "Wrong size on FLoadingFishGameCharaAnimationAsset");

// ScriptStruct AT.ATLoadingFacialAsset
// 0x0030 (0x0030 - 0x0000)
struct FATLoadingFacialAsset final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Parts;                                             // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATLoadingFacialAsset) == 0x000008, "Wrong alignment on FATLoadingFacialAsset");
static_assert(sizeof(FATLoadingFacialAsset) == 0x000030, "Wrong size on FATLoadingFacialAsset");
static_assert(offsetof(FATLoadingFacialAsset, MasterId) == 0x000000, "Member 'FATLoadingFacialAsset::MasterId' has a wrong offset!");
static_assert(offsetof(FATLoadingFacialAsset, Parts) == 0x000008, "Member 'FATLoadingFacialAsset::Parts' has a wrong offset!");

// ScriptStruct AT.MiniGameRaceSaveDetails
// 0x0030 (0x0030 - 0x0000)
struct FMiniGameRaceSaveDetails final
{
public:
	class FString                                 CharacterName;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              BestTime;                                          // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              LastPlayTime;                                      // 0x0018(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewRecord;                                      // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayCount;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayStartCount;                                    // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ViewResultCount;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniGameRaceSaveDetails) == 0x000008, "Wrong alignment on FMiniGameRaceSaveDetails");
static_assert(sizeof(FMiniGameRaceSaveDetails) == 0x000030, "Wrong size on FMiniGameRaceSaveDetails");
static_assert(offsetof(FMiniGameRaceSaveDetails, CharacterName) == 0x000000, "Member 'FMiniGameRaceSaveDetails::CharacterName' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveDetails, BestTime) == 0x000010, "Member 'FMiniGameRaceSaveDetails::BestTime' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveDetails, LastPlayTime) == 0x000018, "Member 'FMiniGameRaceSaveDetails::LastPlayTime' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveDetails, bIsNewRecord) == 0x000020, "Member 'FMiniGameRaceSaveDetails::bIsNewRecord' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveDetails, PlayCount) == 0x000024, "Member 'FMiniGameRaceSaveDetails::PlayCount' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveDetails, PlayStartCount) == 0x000028, "Member 'FMiniGameRaceSaveDetails::PlayStartCount' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveDetails, ViewResultCount) == 0x00002C, "Member 'FMiniGameRaceSaveDetails::ViewResultCount' has a wrong offset!");

// ScriptStruct AT.ProgressCheckQuestInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FProgressCheckQuestInfo final
{
public:
	class FName                                   Quest_id;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Progress_id;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProgressCheckQuestInfo) == 0x000008, "Wrong alignment on FProgressCheckQuestInfo");
static_assert(sizeof(FProgressCheckQuestInfo) == 0x000010, "Wrong size on FProgressCheckQuestInfo");
static_assert(offsetof(FProgressCheckQuestInfo, Quest_id) == 0x000000, "Member 'FProgressCheckQuestInfo::Quest_id' has a wrong offset!");
static_assert(offsetof(FProgressCheckQuestInfo, Progress_id) == 0x000008, "Member 'FProgressCheckQuestInfo::Progress_id' has a wrong offset!");

// ScriptStruct AT.QuestDataTableStore
// 0x0380 (0x0380 - 0x0000)
struct FQuestDataTableStore final
{
public:
	class UDataTable*                             QuestDataTable;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestDemoDataTable;                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestItemDataTable;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestLiveTalkDataTable;                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestRewardDataTable;                              // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestRewardSetDataTable;                           // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestRewardExpCondition;                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestIdHashMapDataTable;                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestInstanceMapDataTable;                         // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestCommunityDataTable;                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestItemListWindowDataTable;                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestHuntingConditionDataTable;                    // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestDefeatEnemiesSet;                             // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestBlurParameter;                                // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestRewardPhaseCondition;                         // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestPartyCondition;                               // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestPartyOrganizeCondition;                       // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestPartyOrganizeCondition_DLC2;                  // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestPartyOrganizeConditionSet;                    // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CharacterPriority;                                 // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             StartingBoostBlockList;                            // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestWishCondition;                                // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestImageParameter;                               // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestImageParameterSet;                            // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestImageAssetsReference;                         // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestDistanceObserverParameter;                    // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestNotificationParameter;                        // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestNotifyCondition;                              // 0x00D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestInsertParam;                                  // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TalkPhaseCondition;                                // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             FishingPhaseCondition;                             // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CharacterTypeProgressSet;                          // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MinigamePhaseCondition;                            // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestDirectionCoordinateParameter;                 // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MessagePhaseParameter;                             // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             WindowClosedPhaseCondition;                        // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             NpcTalkEventParameter;                             // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestFormChangeDisableParam;                       // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BonfireActivateCondition;                          // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BonfireFacialTable;                                // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             BonfireAnimationTable;                             // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestRetryCondition;                            // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestBGMParameter;                                 // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestCameraShake;                                  // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             CharacterAbsenceParam;                             // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SerializeMiniQuestListTable;                       // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TalkParticleTable;                                 // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MapParam;                                          // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ConditionalSimpleTalkSet;                          // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             NeedCharacterSubQuestTable;                        // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestStartUITable;                              // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestStartMontageTable;                         // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestStartMontageTable_DLC4;                    // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestStartMontageTable_DLC5;                    // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestStartMontageTable_DLC6;                    // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             SubQuestStartCondition;                            // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ContentReleaseCondition;                           // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ArrivalPhaseCondition;                             // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestRetryCondition;                               // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             ConsecutiveQuestSet;                               // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestEventBattleSequence;                          // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestEventRestoreCondition;                        // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestPhaseAutoSaveRestriction;                     // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestFutureVisionParam;                            // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             MobProgressParam;                                  // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestTalkBuyItemTable;                             // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestTalkBuyItemTableDLC6;                         // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             QuestTalkExchangeItemTable;                        // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TitleCallIdDataTable;                              // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UDataTable*>          QuestPhaseParams;                                  // 0x0228(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FProgressCheckQuestInfo>        QuestIds;                                          // 0x0278(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FProgressCheckQuestInfo>        MainQuestIds;                                      // 0x0288(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FProgressCheckQuestInfo>        SubQuestIds;                                       // 0x0298(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UDataTable*                             TalkParticleTable_DLC4;                            // 0x02A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TalkParticleTable_DLC5;                            // 0x02B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             TalkParticleTable_DLC6;                            // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C0[0xC0];                                     // 0x02C0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestDataTableStore) == 0x000008, "Wrong alignment on FQuestDataTableStore");
static_assert(sizeof(FQuestDataTableStore) == 0x000380, "Wrong size on FQuestDataTableStore");
static_assert(offsetof(FQuestDataTableStore, QuestDataTable) == 0x000000, "Member 'FQuestDataTableStore::QuestDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestDemoDataTable) == 0x000008, "Member 'FQuestDataTableStore::QuestDemoDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestItemDataTable) == 0x000010, "Member 'FQuestDataTableStore::QuestItemDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestLiveTalkDataTable) == 0x000018, "Member 'FQuestDataTableStore::QuestLiveTalkDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestRewardDataTable) == 0x000020, "Member 'FQuestDataTableStore::QuestRewardDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestRewardSetDataTable) == 0x000028, "Member 'FQuestDataTableStore::QuestRewardSetDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestRewardExpCondition) == 0x000030, "Member 'FQuestDataTableStore::QuestRewardExpCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestIdHashMapDataTable) == 0x000038, "Member 'FQuestDataTableStore::QuestIdHashMapDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestInstanceMapDataTable) == 0x000040, "Member 'FQuestDataTableStore::QuestInstanceMapDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestCommunityDataTable) == 0x000048, "Member 'FQuestDataTableStore::QuestCommunityDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestItemListWindowDataTable) == 0x000050, "Member 'FQuestDataTableStore::QuestItemListWindowDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestHuntingConditionDataTable) == 0x000058, "Member 'FQuestDataTableStore::QuestHuntingConditionDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestDefeatEnemiesSet) == 0x000060, "Member 'FQuestDataTableStore::QuestDefeatEnemiesSet' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestBlurParameter) == 0x000068, "Member 'FQuestDataTableStore::QuestBlurParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestRewardPhaseCondition) == 0x000070, "Member 'FQuestDataTableStore::QuestRewardPhaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestPartyCondition) == 0x000078, "Member 'FQuestDataTableStore::QuestPartyCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestPartyOrganizeCondition) == 0x000080, "Member 'FQuestDataTableStore::QuestPartyOrganizeCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestPartyOrganizeCondition_DLC2) == 0x000088, "Member 'FQuestDataTableStore::QuestPartyOrganizeCondition_DLC2' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestPartyOrganizeConditionSet) == 0x000090, "Member 'FQuestDataTableStore::QuestPartyOrganizeConditionSet' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, CharacterPriority) == 0x000098, "Member 'FQuestDataTableStore::CharacterPriority' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, StartingBoostBlockList) == 0x0000A0, "Member 'FQuestDataTableStore::StartingBoostBlockList' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestWishCondition) == 0x0000A8, "Member 'FQuestDataTableStore::QuestWishCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestImageParameter) == 0x0000B0, "Member 'FQuestDataTableStore::QuestImageParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestImageParameterSet) == 0x0000B8, "Member 'FQuestDataTableStore::QuestImageParameterSet' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestImageAssetsReference) == 0x0000C0, "Member 'FQuestDataTableStore::QuestImageAssetsReference' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestDistanceObserverParameter) == 0x0000C8, "Member 'FQuestDataTableStore::QuestDistanceObserverParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestNotificationParameter) == 0x0000D0, "Member 'FQuestDataTableStore::QuestNotificationParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestNotifyCondition) == 0x0000D8, "Member 'FQuestDataTableStore::QuestNotifyCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestInsertParam) == 0x0000E0, "Member 'FQuestDataTableStore::QuestInsertParam' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, TalkPhaseCondition) == 0x0000E8, "Member 'FQuestDataTableStore::TalkPhaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, FishingPhaseCondition) == 0x0000F0, "Member 'FQuestDataTableStore::FishingPhaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, CharacterTypeProgressSet) == 0x0000F8, "Member 'FQuestDataTableStore::CharacterTypeProgressSet' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, MinigamePhaseCondition) == 0x000100, "Member 'FQuestDataTableStore::MinigamePhaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestDirectionCoordinateParameter) == 0x000108, "Member 'FQuestDataTableStore::QuestDirectionCoordinateParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, MessagePhaseParameter) == 0x000110, "Member 'FQuestDataTableStore::MessagePhaseParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, WindowClosedPhaseCondition) == 0x000118, "Member 'FQuestDataTableStore::WindowClosedPhaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, NpcTalkEventParameter) == 0x000120, "Member 'FQuestDataTableStore::NpcTalkEventParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestFormChangeDisableParam) == 0x000128, "Member 'FQuestDataTableStore::QuestFormChangeDisableParam' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, BonfireActivateCondition) == 0x000130, "Member 'FQuestDataTableStore::BonfireActivateCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, BonfireFacialTable) == 0x000138, "Member 'FQuestDataTableStore::BonfireFacialTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, BonfireAnimationTable) == 0x000140, "Member 'FQuestDataTableStore::BonfireAnimationTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestRetryCondition) == 0x000148, "Member 'FQuestDataTableStore::SubQuestRetryCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestBGMParameter) == 0x000150, "Member 'FQuestDataTableStore::QuestBGMParameter' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestCameraShake) == 0x000158, "Member 'FQuestDataTableStore::QuestCameraShake' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, CharacterAbsenceParam) == 0x000160, "Member 'FQuestDataTableStore::CharacterAbsenceParam' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SerializeMiniQuestListTable) == 0x000168, "Member 'FQuestDataTableStore::SerializeMiniQuestListTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, TalkParticleTable) == 0x000170, "Member 'FQuestDataTableStore::TalkParticleTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, MapParam) == 0x000178, "Member 'FQuestDataTableStore::MapParam' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, ConditionalSimpleTalkSet) == 0x000180, "Member 'FQuestDataTableStore::ConditionalSimpleTalkSet' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, NeedCharacterSubQuestTable) == 0x000188, "Member 'FQuestDataTableStore::NeedCharacterSubQuestTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestStartUITable) == 0x000190, "Member 'FQuestDataTableStore::SubQuestStartUITable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestStartMontageTable) == 0x000198, "Member 'FQuestDataTableStore::SubQuestStartMontageTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestStartMontageTable_DLC4) == 0x0001A0, "Member 'FQuestDataTableStore::SubQuestStartMontageTable_DLC4' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestStartMontageTable_DLC5) == 0x0001A8, "Member 'FQuestDataTableStore::SubQuestStartMontageTable_DLC5' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestStartMontageTable_DLC6) == 0x0001B0, "Member 'FQuestDataTableStore::SubQuestStartMontageTable_DLC6' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestStartCondition) == 0x0001B8, "Member 'FQuestDataTableStore::SubQuestStartCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, ContentReleaseCondition) == 0x0001C0, "Member 'FQuestDataTableStore::ContentReleaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, ArrivalPhaseCondition) == 0x0001C8, "Member 'FQuestDataTableStore::ArrivalPhaseCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestRetryCondition) == 0x0001D0, "Member 'FQuestDataTableStore::QuestRetryCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, ConsecutiveQuestSet) == 0x0001D8, "Member 'FQuestDataTableStore::ConsecutiveQuestSet' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestEventBattleSequence) == 0x0001E0, "Member 'FQuestDataTableStore::QuestEventBattleSequence' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestEventRestoreCondition) == 0x0001E8, "Member 'FQuestDataTableStore::QuestEventRestoreCondition' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestPhaseAutoSaveRestriction) == 0x0001F0, "Member 'FQuestDataTableStore::QuestPhaseAutoSaveRestriction' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestFutureVisionParam) == 0x0001F8, "Member 'FQuestDataTableStore::QuestFutureVisionParam' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, MobProgressParam) == 0x000200, "Member 'FQuestDataTableStore::MobProgressParam' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestTalkBuyItemTable) == 0x000208, "Member 'FQuestDataTableStore::QuestTalkBuyItemTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestTalkBuyItemTableDLC6) == 0x000210, "Member 'FQuestDataTableStore::QuestTalkBuyItemTableDLC6' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestTalkExchangeItemTable) == 0x000218, "Member 'FQuestDataTableStore::QuestTalkExchangeItemTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, TitleCallIdDataTable) == 0x000220, "Member 'FQuestDataTableStore::TitleCallIdDataTable' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestPhaseParams) == 0x000228, "Member 'FQuestDataTableStore::QuestPhaseParams' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, QuestIds) == 0x000278, "Member 'FQuestDataTableStore::QuestIds' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, MainQuestIds) == 0x000288, "Member 'FQuestDataTableStore::MainQuestIds' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, SubQuestIds) == 0x000298, "Member 'FQuestDataTableStore::SubQuestIds' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, TalkParticleTable_DLC4) == 0x0002A8, "Member 'FQuestDataTableStore::TalkParticleTable_DLC4' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, TalkParticleTable_DLC5) == 0x0002B0, "Member 'FQuestDataTableStore::TalkParticleTable_DLC5' has a wrong offset!");
static_assert(offsetof(FQuestDataTableStore, TalkParticleTable_DLC6) == 0x0002B8, "Member 'FQuestDataTableStore::TalkParticleTable_DLC6' has a wrong offset!");

// ScriptStruct AT.ExtendZCompworksAreaNav
// 0x0028 (0x0030 - 0x0008)
struct FExtendZCompworksAreaNav final : public FTableRowBase
{
public:
	class FName                                   ZCompworksId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAreaIndex>                            AreaIndices;                                       // 0x0010(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SublevelId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Exclude;                                           // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtendZCompworksAreaNav) == 0x000008, "Wrong alignment on FExtendZCompworksAreaNav");
static_assert(sizeof(FExtendZCompworksAreaNav) == 0x000030, "Wrong size on FExtendZCompworksAreaNav");
static_assert(offsetof(FExtendZCompworksAreaNav, ZCompworksId) == 0x000008, "Member 'FExtendZCompworksAreaNav::ZCompworksId' has a wrong offset!");
static_assert(offsetof(FExtendZCompworksAreaNav, AreaIndices) == 0x000010, "Member 'FExtendZCompworksAreaNav::AreaIndices' has a wrong offset!");
static_assert(offsetof(FExtendZCompworksAreaNav, SublevelId) == 0x000020, "Member 'FExtendZCompworksAreaNav::SublevelId' has a wrong offset!");
static_assert(offsetof(FExtendZCompworksAreaNav, Exclude) == 0x000028, "Member 'FExtendZCompworksAreaNav::Exclude' has a wrong offset!");

// ScriptStruct AT.Anim2DParam_F
// 0x0008 (0x0010 - 0x0008)
struct FAnim2DParam_F final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IconScale;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnim2DParam_F) == 0x000008, "Wrong alignment on FAnim2DParam_F");
static_assert(sizeof(FAnim2DParam_F) == 0x000010, "Wrong size on FAnim2DParam_F");
static_assert(offsetof(FAnim2DParam_F, Value) == 0x000008, "Member 'FAnim2DParam_F::Value' has a wrong offset!");
static_assert(offsetof(FAnim2DParam_F, IconScale) == 0x00000C, "Member 'FAnim2DParam_F::IconScale' has a wrong offset!");

// ScriptStruct AT.EnemyGageParam
// 0x0018 (0x0020 - 0x0008)
struct FEnemyGageParam final : public FTableRowBase
{
public:
	float                                         Hight;                                             // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DataName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyGageParam) == 0x000008, "Wrong alignment on FEnemyGageParam");
static_assert(sizeof(FEnemyGageParam) == 0x000020, "Wrong size on FEnemyGageParam");
static_assert(offsetof(FEnemyGageParam, Hight) == 0x000008, "Member 'FEnemyGageParam::Hight' has a wrong offset!");
static_assert(offsetof(FEnemyGageParam, DataName) == 0x000010, "Member 'FEnemyGageParam::DataName' has a wrong offset!");

// ScriptStruct AT.MessageInfoTbl
// 0x01A0 (0x01A8 - 0x0008)
struct FMessageInfoTbl final : public FTableRowBase
{
public:
	class FString                                 Speaker_jpn;                                       // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_jpn;                                       // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_eng;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_eng;                                       // 0x0038(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_fre;                                       // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_fre;                                       // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_ita;                                       // 0x0068(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_ita;                                       // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_ger;                                       // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_ger;                                       // 0x0098(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_spa;                                       // 0x00A8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_spa;                                       // 0x00B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_rus;                                       // 0x00C8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_rus;                                       // 0x00D8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_por;                                       // 0x00E8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_por;                                       // 0x00F8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_pol;                                       // 0x0108(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_pol;                                       // 0x0118(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_chi;                                       // 0x0128(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_chi;                                       // 0x0138(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_arae;                                      // 0x0148(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_arae;                                      // 0x0158(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_esmx;                                      // 0x0168(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_esmx;                                      // 0x0178(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Speaker_kokr;                                      // 0x0188(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_kokr;                                      // 0x0198(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMessageInfoTbl) == 0x000008, "Wrong alignment on FMessageInfoTbl");
static_assert(sizeof(FMessageInfoTbl) == 0x0001A8, "Wrong size on FMessageInfoTbl");
static_assert(offsetof(FMessageInfoTbl, Speaker_jpn) == 0x000008, "Member 'FMessageInfoTbl::Speaker_jpn' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_jpn) == 0x000018, "Member 'FMessageInfoTbl::Message_jpn' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_eng) == 0x000028, "Member 'FMessageInfoTbl::Speaker_eng' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_eng) == 0x000038, "Member 'FMessageInfoTbl::Message_eng' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_fre) == 0x000048, "Member 'FMessageInfoTbl::Speaker_fre' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_fre) == 0x000058, "Member 'FMessageInfoTbl::Message_fre' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_ita) == 0x000068, "Member 'FMessageInfoTbl::Speaker_ita' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_ita) == 0x000078, "Member 'FMessageInfoTbl::Message_ita' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_ger) == 0x000088, "Member 'FMessageInfoTbl::Speaker_ger' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_ger) == 0x000098, "Member 'FMessageInfoTbl::Message_ger' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_spa) == 0x0000A8, "Member 'FMessageInfoTbl::Speaker_spa' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_spa) == 0x0000B8, "Member 'FMessageInfoTbl::Message_spa' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_rus) == 0x0000C8, "Member 'FMessageInfoTbl::Speaker_rus' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_rus) == 0x0000D8, "Member 'FMessageInfoTbl::Message_rus' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_por) == 0x0000E8, "Member 'FMessageInfoTbl::Speaker_por' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_por) == 0x0000F8, "Member 'FMessageInfoTbl::Message_por' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_pol) == 0x000108, "Member 'FMessageInfoTbl::Speaker_pol' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_pol) == 0x000118, "Member 'FMessageInfoTbl::Message_pol' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_chi) == 0x000128, "Member 'FMessageInfoTbl::Speaker_chi' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_chi) == 0x000138, "Member 'FMessageInfoTbl::Message_chi' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_arae) == 0x000148, "Member 'FMessageInfoTbl::Speaker_arae' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_arae) == 0x000158, "Member 'FMessageInfoTbl::Message_arae' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_esmx) == 0x000168, "Member 'FMessageInfoTbl::Speaker_esmx' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_esmx) == 0x000178, "Member 'FMessageInfoTbl::Message_esmx' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Speaker_kokr) == 0x000188, "Member 'FMessageInfoTbl::Speaker_kokr' has a wrong offset!");
static_assert(offsetof(FMessageInfoTbl, Message_kokr) == 0x000198, "Member 'FMessageInfoTbl::Message_kokr' has a wrong offset!");

// ScriptStruct AT.DamageInfo
// 0x0054 (0x0054 - 0x0000)
struct alignas(0x04) FDamageInfo final
{
public:
	uint8                                         Pad_0[0x54];                                       // 0x0000(0x0054)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageInfo) == 0x000004, "Wrong alignment on FDamageInfo");
static_assert(sizeof(FDamageInfo) == 0x000054, "Wrong size on FDamageInfo");

// ScriptStruct AT.ATDataTableSoundDemo
// 0x0028 (0x0030 - 0x0008)
struct FATDataTableSoundDemo final : public FTableRowBase
{
public:
	TSoftObjectPtr<class USoundAtomCueSheet>      CueSheet;                                          // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataTableSoundDemo) == 0x000008, "Wrong alignment on FATDataTableSoundDemo");
static_assert(sizeof(FATDataTableSoundDemo) == 0x000030, "Wrong size on FATDataTableSoundDemo");
static_assert(offsetof(FATDataTableSoundDemo, CueSheet) == 0x000008, "Member 'FATDataTableSoundDemo::CueSheet' has a wrong offset!");

// ScriptStruct AT.CameraTableRow
// 0x0030 (0x0038 - 0x0008)
struct FCameraTableRow final : public FTableRowBase
{
public:
	float                                         FOV;                                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetLength;                                      // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetZ;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitPitch;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitYaw;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotSpeed;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstAngleRange;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRange;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchRangeOffset;                                  // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrustumDistance;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeightOffset;                                // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VariationBlendSpeed;                               // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraTableRow) == 0x000008, "Wrong alignment on FCameraTableRow");
static_assert(sizeof(FCameraTableRow) == 0x000038, "Wrong size on FCameraTableRow");
static_assert(offsetof(FCameraTableRow, FOV) == 0x000008, "Member 'FCameraTableRow::FOV' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, TargetLength) == 0x00000C, "Member 'FCameraTableRow::TargetLength' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, OffsetZ) == 0x000010, "Member 'FCameraTableRow::OffsetZ' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, LimitPitch) == 0x000014, "Member 'FCameraTableRow::LimitPitch' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, LimitYaw) == 0x000018, "Member 'FCameraTableRow::LimitYaw' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, RotSpeed) == 0x00001C, "Member 'FCameraTableRow::RotSpeed' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, FirstAngleRange) == 0x000020, "Member 'FCameraTableRow::FirstAngleRange' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, AngleRange) == 0x000024, "Member 'FCameraTableRow::AngleRange' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, PitchRangeOffset) == 0x000028, "Member 'FCameraTableRow::PitchRangeOffset' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, FrustumDistance) == 0x00002C, "Member 'FCameraTableRow::FrustumDistance' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, TargetHeightOffset) == 0x000030, "Member 'FCameraTableRow::TargetHeightOffset' has a wrong offset!");
static_assert(offsetof(FCameraTableRow, VariationBlendSpeed) == 0x000034, "Member 'FCameraTableRow::VariationBlendSpeed' has a wrong offset!");

// ScriptStruct AT.DlcElementRow
// 0x0070 (0x0078 - 0x0008)
struct FDlcElementRow final : public FTableRowBase
{
public:
	class FName                                   CommonId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDlcElementType                               ElementType;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LocalId;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberToGive;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        PatchVersion;                                      // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EnableNoticeMessageId;                             // 0x0028(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisableNoticeMessageId;                            // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoadedRevocation;                               // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TelopMessage;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DialogMessage;                                     // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortNo;                                            // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDlcElementRow) == 0x000008, "Wrong alignment on FDlcElementRow");
static_assert(sizeof(FDlcElementRow) == 0x000078, "Wrong size on FDlcElementRow");
static_assert(offsetof(FDlcElementRow, CommonId) == 0x000008, "Member 'FDlcElementRow::CommonId' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, ElementType) == 0x000010, "Member 'FDlcElementRow::ElementType' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, LocalId) == 0x000018, "Member 'FDlcElementRow::LocalId' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, NumberToGive) == 0x000020, "Member 'FDlcElementRow::NumberToGive' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, PatchVersion) == 0x000024, "Member 'FDlcElementRow::PatchVersion' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, EnableNoticeMessageId) == 0x000028, "Member 'FDlcElementRow::EnableNoticeMessageId' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, DisableNoticeMessageId) == 0x000038, "Member 'FDlcElementRow::DisableNoticeMessageId' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, bIsLoadedRevocation) == 0x000048, "Member 'FDlcElementRow::bIsLoadedRevocation' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, TelopMessage) == 0x000050, "Member 'FDlcElementRow::TelopMessage' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, DialogMessage) == 0x000060, "Member 'FDlcElementRow::DialogMessage' has a wrong offset!");
static_assert(offsetof(FDlcElementRow, SortNo) == 0x000070, "Member 'FDlcElementRow::SortNo' has a wrong offset!");

// ScriptStruct AT.EncounterEnemyInfo
// 0x0030 (0x0030 - 0x0000)
struct alignas(0x04) FEncounterEnemyInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterEnemyInfo) == 0x000004, "Wrong alignment on FEncounterEnemyInfo");
static_assert(sizeof(FEncounterEnemyInfo) == 0x000030, "Wrong size on FEncounterEnemyInfo");

// ScriptStruct AT.MultiEncounterEnemyInfo
// 0x0010 (0x0010 - 0x0000)
struct FMultiEncounterEnemyInfo final
{
public:
	TArray<struct FEncounterEnemyInfo>            EncountInfo;                                       // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiEncounterEnemyInfo) == 0x000008, "Wrong alignment on FMultiEncounterEnemyInfo");
static_assert(sizeof(FMultiEncounterEnemyInfo) == 0x000010, "Wrong size on FMultiEncounterEnemyInfo");
static_assert(offsetof(FMultiEncounterEnemyInfo, EncountInfo) == 0x000000, "Member 'FMultiEncounterEnemyInfo::EncountInfo' has a wrong offset!");

// ScriptStruct AT.TimeOrbAppearanceParam
// 0x0008 (0x0010 - 0x0008)
struct FTimeOrbAppearanceParam final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaIndex;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Limit;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimeOrbAppearanceParam) == 0x000008, "Wrong alignment on FTimeOrbAppearanceParam");
static_assert(sizeof(FTimeOrbAppearanceParam) == 0x000010, "Wrong size on FTimeOrbAppearanceParam");
static_assert(offsetof(FTimeOrbAppearanceParam, AreaIndex) == 0x000008, "Member 'FTimeOrbAppearanceParam::AreaIndex' has a wrong offset!");
static_assert(offsetof(FTimeOrbAppearanceParam, Limit) == 0x00000C, "Member 'FTimeOrbAppearanceParam::Limit' has a wrong offset!");

// ScriptStruct AT.ATDataAssetRaceGameInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetRaceGameInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Result_Montage;                                    // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetRaceGameInfo) == 0x000008, "Wrong alignment on FATDataAssetRaceGameInfo");
static_assert(sizeof(FATDataAssetRaceGameInfo) == 0x000030, "Wrong size on FATDataAssetRaceGameInfo");
static_assert(offsetof(FATDataAssetRaceGameInfo, MasterId) == 0x000000, "Member 'FATDataAssetRaceGameInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetRaceGameInfo, Result_Montage) == 0x000008, "Member 'FATDataAssetRaceGameInfo::Result_Montage' has a wrong offset!");

// ScriptStruct AT.ATDragonBallSpawnPointInfo
// 0x0028 (0x0030 - 0x0008)
struct FATDragonBallSpawnPointInfo final : public FTableRowBase
{
public:
	class FName                                   PointName;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SpawnGroup;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldStageId                                 WorldMapLocation;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IgnorePoint;                                       // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDragonBallSpawnPointInfo) == 0x000008, "Wrong alignment on FATDragonBallSpawnPointInfo");
static_assert(sizeof(FATDragonBallSpawnPointInfo) == 0x000030, "Wrong size on FATDragonBallSpawnPointInfo");
static_assert(offsetof(FATDragonBallSpawnPointInfo, PointName) == 0x000008, "Member 'FATDragonBallSpawnPointInfo::PointName' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnPointInfo, SpawnGroup) == 0x000010, "Member 'FATDragonBallSpawnPointInfo::SpawnGroup' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnPointInfo, WorldMapLocation) == 0x000018, "Member 'FATDragonBallSpawnPointInfo::WorldMapLocation' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnPointInfo, IgnorePoint) == 0x000020, "Member 'FATDragonBallSpawnPointInfo::IgnorePoint' has a wrong offset!");

// ScriptStruct AT.ATDataAssetEventBattlePostProcessEffectInfo
// 0x0078 (0x0078 - 0x0000)
struct FATDataAssetEventBattlePostProcessEffectInfo final
{
public:
	TSoftObjectPtr<class UParticleSystem>         ATPostProcessEffectCmnHologram_NoiseEffect;        // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               ATPostProcessEffectCmnHologram_Material;           // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterial>               ATPostEffectCmnSkillAquisition_Material;           // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetEventBattlePostProcessEffectInfo) == 0x000008, "Wrong alignment on FATDataAssetEventBattlePostProcessEffectInfo");
static_assert(sizeof(FATDataAssetEventBattlePostProcessEffectInfo) == 0x000078, "Wrong size on FATDataAssetEventBattlePostProcessEffectInfo");
static_assert(offsetof(FATDataAssetEventBattlePostProcessEffectInfo, ATPostProcessEffectCmnHologram_NoiseEffect) == 0x000000, "Member 'FATDataAssetEventBattlePostProcessEffectInfo::ATPostProcessEffectCmnHologram_NoiseEffect' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattlePostProcessEffectInfo, ATPostProcessEffectCmnHologram_Material) == 0x000028, "Member 'FATDataAssetEventBattlePostProcessEffectInfo::ATPostProcessEffectCmnHologram_Material' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattlePostProcessEffectInfo, ATPostEffectCmnSkillAquisition_Material) == 0x000050, "Member 'FATDataAssetEventBattlePostProcessEffectInfo::ATPostEffectCmnSkillAquisition_Material' has a wrong offset!");

// ScriptStruct AT.CollectionPersonalIDTable
// 0x0008 (0x0010 - 0x0008)
struct FCollectionPersonalIDTable final : public FTableRowBase
{
public:
	class FName                                   PersonalID;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionPersonalIDTable) == 0x000008, "Wrong alignment on FCollectionPersonalIDTable");
static_assert(sizeof(FCollectionPersonalIDTable) == 0x000010, "Wrong size on FCollectionPersonalIDTable");
static_assert(offsetof(FCollectionPersonalIDTable, PersonalID) == 0x000008, "Member 'FCollectionPersonalIDTable::PersonalID' has a wrong offset!");

// ScriptStruct AT.EncounterInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FEncounterInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterInfo) == 0x000008, "Wrong alignment on FEncounterInfo");
static_assert(sizeof(FEncounterInfo) == 0x000038, "Wrong size on FEncounterInfo");

// ScriptStruct AT.EncounterDBInfo
// 0x0010 (0x0010 - 0x0000)
struct FEncounterDBInfo final
{
public:
	TArray<struct FEncounterInfo>                 EncounterDBInfo;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEncounterDBInfo) == 0x000008, "Wrong alignment on FEncounterDBInfo");
static_assert(sizeof(FEncounterDBInfo) == 0x000010, "Wrong size on FEncounterDBInfo");
static_assert(offsetof(FEncounterDBInfo, EncounterDBInfo) == 0x000000, "Member 'FEncounterDBInfo::EncounterDBInfo' has a wrong offset!");

// ScriptStruct AT.CookingDemoChangeFormParam
// 0x0008 (0x0010 - 0x0008)
struct FCookingDemoChangeFormParam final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InVariation;                                       // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         InForm;                                            // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutVariation;                                      // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OutForm;                                           // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCookingDemoChangeFormParam) == 0x000008, "Wrong alignment on FCookingDemoChangeFormParam");
static_assert(sizeof(FCookingDemoChangeFormParam) == 0x000010, "Wrong size on FCookingDemoChangeFormParam");
static_assert(offsetof(FCookingDemoChangeFormParam, CharacterType) == 0x000008, "Member 'FCookingDemoChangeFormParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FCookingDemoChangeFormParam, InVariation) == 0x000009, "Member 'FCookingDemoChangeFormParam::InVariation' has a wrong offset!");
static_assert(offsetof(FCookingDemoChangeFormParam, InForm) == 0x00000A, "Member 'FCookingDemoChangeFormParam::InForm' has a wrong offset!");
static_assert(offsetof(FCookingDemoChangeFormParam, OutVariation) == 0x00000B, "Member 'FCookingDemoChangeFormParam::OutVariation' has a wrong offset!");
static_assert(offsetof(FCookingDemoChangeFormParam, OutForm) == 0x00000C, "Member 'FCookingDemoChangeFormParam::OutForm' has a wrong offset!");

// ScriptStruct AT.MineralSpawnConfirmedData
// 0x0008 (0x0008 - 0x0000)
struct FMineralSpawnConfirmedData final
{
public:
	EITEM_ID                                      ItemId;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Num;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMineralSpawnConfirmedData) == 0x000004, "Wrong alignment on FMineralSpawnConfirmedData");
static_assert(sizeof(FMineralSpawnConfirmedData) == 0x000008, "Wrong size on FMineralSpawnConfirmedData");
static_assert(offsetof(FMineralSpawnConfirmedData, ItemId) == 0x000000, "Member 'FMineralSpawnConfirmedData::ItemId' has a wrong offset!");
static_assert(offsetof(FMineralSpawnConfirmedData, Num) == 0x000004, "Member 'FMineralSpawnConfirmedData::Num' has a wrong offset!");

// ScriptStruct AT.BattleDirectionInfo
// 0x0024 (0x0024 - 0x0000)
struct alignas(0x04) FBattleDirectionInfo final
{
public:
	uint8                                         Pad_0[0x24];                                       // 0x0000(0x0024)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleDirectionInfo) == 0x000004, "Wrong alignment on FBattleDirectionInfo");
static_assert(sizeof(FBattleDirectionInfo) == 0x000024, "Wrong size on FBattleDirectionInfo");

// ScriptStruct AT.MultiBattleDirectionInfo
// 0x0010 (0x0010 - 0x0000)
struct FMultiBattleDirectionInfo final
{
public:
	TArray<struct FBattleDirectionInfo>           battleEncountInfo;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMultiBattleDirectionInfo) == 0x000008, "Wrong alignment on FMultiBattleDirectionInfo");
static_assert(sizeof(FMultiBattleDirectionInfo) == 0x000010, "Wrong size on FMultiBattleDirectionInfo");
static_assert(offsetof(FMultiBattleDirectionInfo, battleEncountInfo) == 0x000000, "Member 'FMultiBattleDirectionInfo::battleEncountInfo' has a wrong offset!");

// ScriptStruct AT.MiniMapInfo
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FMiniMapInfo final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMiniMapInfo) == 0x000008, "Wrong alignment on FMiniMapInfo");
static_assert(sizeof(FMiniMapInfo) == 0x000060, "Wrong size on FMiniMapInfo");

// ScriptStruct AT.SkillChainComboHudInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x04) FSkillChainComboHudInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillChainComboHudInfo) == 0x000004, "Wrong alignment on FSkillChainComboHudInfo");
static_assert(sizeof(FSkillChainComboHudInfo) == 0x000020, "Wrong size on FSkillChainComboHudInfo");

// ScriptStruct AT.EnemyInfo
// 0x0450 (0x0450 - 0x0000)
struct alignas(0x08) FEnemyInfo final
{
public:
	uint8                                         Pad_0[0x450];                                      // 0x0000(0x0450)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyInfo) == 0x000008, "Wrong alignment on FEnemyInfo");
static_assert(sizeof(FEnemyInfo) == 0x000450, "Wrong size on FEnemyInfo");

// ScriptStruct AT.ATDataAssetNpcMobAnimationInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetNpcMobAnimationInfo final
{
public:
	ENpcMobType                                   MobTypeId;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   AnimationBP;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetNpcMobAnimationInfo) == 0x000008, "Wrong alignment on FATDataAssetNpcMobAnimationInfo");
static_assert(sizeof(FATDataAssetNpcMobAnimationInfo) == 0x000030, "Wrong size on FATDataAssetNpcMobAnimationInfo");
static_assert(offsetof(FATDataAssetNpcMobAnimationInfo, MobTypeId) == 0x000000, "Member 'FATDataAssetNpcMobAnimationInfo::MobTypeId' has a wrong offset!");
static_assert(offsetof(FATDataAssetNpcMobAnimationInfo, AnimationBP) == 0x000008, "Member 'FATDataAssetNpcMobAnimationInfo::AnimationBP' has a wrong offset!");

// ScriptStruct AT.MissionParameter
// 0x0030 (0x0038 - 0x0008)
struct FMissionParameter final : public FTableRowBase
{
public:
	class FName                                   DescriptionId;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CommunityType;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionType                                  MissionType;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MissionPhaseGroupId;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestIdRequired;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         QuestPhaseNoRequired;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionUpdateType                            MissionUpdateType;                                 // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMissionOwnerType                             MissionOwnerType;                                  // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionParameter) == 0x000008, "Wrong alignment on FMissionParameter");
static_assert(sizeof(FMissionParameter) == 0x000038, "Wrong size on FMissionParameter");
static_assert(offsetof(FMissionParameter, DescriptionId) == 0x000008, "Member 'FMissionParameter::DescriptionId' has a wrong offset!");
static_assert(offsetof(FMissionParameter, CommunityType) == 0x000010, "Member 'FMissionParameter::CommunityType' has a wrong offset!");
static_assert(offsetof(FMissionParameter, MissionType) == 0x000018, "Member 'FMissionParameter::MissionType' has a wrong offset!");
static_assert(offsetof(FMissionParameter, MissionPhaseGroupId) == 0x000020, "Member 'FMissionParameter::MissionPhaseGroupId' has a wrong offset!");
static_assert(offsetof(FMissionParameter, QuestIdRequired) == 0x000028, "Member 'FMissionParameter::QuestIdRequired' has a wrong offset!");
static_assert(offsetof(FMissionParameter, QuestPhaseNoRequired) == 0x000030, "Member 'FMissionParameter::QuestPhaseNoRequired' has a wrong offset!");
static_assert(offsetof(FMissionParameter, MissionUpdateType) == 0x000034, "Member 'FMissionParameter::MissionUpdateType' has a wrong offset!");
static_assert(offsetof(FMissionParameter, MissionOwnerType) == 0x000035, "Member 'FMissionParameter::MissionOwnerType' has a wrong offset!");

// ScriptStruct AT.Condition
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FCondition final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCondition) == 0x000004, "Wrong alignment on FCondition");
static_assert(sizeof(FCondition) == 0x00001C, "Wrong size on FCondition");

// ScriptStruct AT.LoadingCharacterAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingCharacterAsset final
{
public:
	TSoftClassPtr<class UClass>                   Character;                                         // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingCharacterAsset) == 0x000008, "Wrong alignment on FLoadingCharacterAsset");
static_assert(sizeof(FLoadingCharacterAsset) == 0x000028, "Wrong size on FLoadingCharacterAsset");
static_assert(offsetof(FLoadingCharacterAsset, Character) == 0x000000, "Member 'FLoadingCharacterAsset::Character' has a wrong offset!");

// ScriptStruct AT.ExtendProgressMap
// 0x0010 (0x0018 - 0x0008)
struct FExtendProgressMap final : public FTableRowBase
{
public:
	int32                                         OrderNo;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Part;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Character;                                         // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter1;                                 // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter2;                                 // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtendProgressMap) == 0x000008, "Wrong alignment on FExtendProgressMap");
static_assert(sizeof(FExtendProgressMap) == 0x000018, "Wrong size on FExtendProgressMap");
static_assert(offsetof(FExtendProgressMap, OrderNo) == 0x000008, "Member 'FExtendProgressMap::OrderNo' has a wrong offset!");
static_assert(offsetof(FExtendProgressMap, Chapter) == 0x00000C, "Member 'FExtendProgressMap::Chapter' has a wrong offset!");
static_assert(offsetof(FExtendProgressMap, Part) == 0x000010, "Member 'FExtendProgressMap::Part' has a wrong offset!");
static_assert(offsetof(FExtendProgressMap, Character) == 0x000014, "Member 'FExtendProgressMap::Character' has a wrong offset!");
static_assert(offsetof(FExtendProgressMap, SupportCharacter1) == 0x000015, "Member 'FExtendProgressMap::SupportCharacter1' has a wrong offset!");
static_assert(offsetof(FExtendProgressMap, SupportCharacter2) == 0x000016, "Member 'FExtendProgressMap::SupportCharacter2' has a wrong offset!");

// ScriptStruct AT.AtrociousEnemyParamTable
// 0x0018 (0x0020 - 0x0008)
struct FAtrociousEnemyParamTable final : public FTableRowBase
{
public:
	float                                         SpawnRateUpdateDist;                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInitRate;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnUpRate;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousEnemyWaitTime;                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousEnemyRetryTime;                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoopCoolTime;                                      // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtrociousEnemyParamTable) == 0x000008, "Wrong alignment on FAtrociousEnemyParamTable");
static_assert(sizeof(FAtrociousEnemyParamTable) == 0x000020, "Wrong size on FAtrociousEnemyParamTable");
static_assert(offsetof(FAtrociousEnemyParamTable, SpawnRateUpdateDist) == 0x000008, "Member 'FAtrociousEnemyParamTable::SpawnRateUpdateDist' has a wrong offset!");
static_assert(offsetof(FAtrociousEnemyParamTable, SpawnInitRate) == 0x00000C, "Member 'FAtrociousEnemyParamTable::SpawnInitRate' has a wrong offset!");
static_assert(offsetof(FAtrociousEnemyParamTable, SpawnUpRate) == 0x000010, "Member 'FAtrociousEnemyParamTable::SpawnUpRate' has a wrong offset!");
static_assert(offsetof(FAtrociousEnemyParamTable, AtrociousEnemyWaitTime) == 0x000014, "Member 'FAtrociousEnemyParamTable::AtrociousEnemyWaitTime' has a wrong offset!");
static_assert(offsetof(FAtrociousEnemyParamTable, AtrociousEnemyRetryTime) == 0x000018, "Member 'FAtrociousEnemyParamTable::AtrociousEnemyRetryTime' has a wrong offset!");
static_assert(offsetof(FAtrociousEnemyParamTable, LoopCoolTime) == 0x00001C, "Member 'FAtrociousEnemyParamTable::LoopCoolTime' has a wrong offset!");

// ScriptStruct AT.ReferenceToCharacterActionAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToCharacterActionAssetInstance final
{
public:
	TSubclassOf<class UCharacterActionClassTable> CharacterAction;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToCharacterActionAssetInstance) == 0x000008, "Wrong alignment on FReferenceToCharacterActionAssetInstance");
static_assert(sizeof(FReferenceToCharacterActionAssetInstance) == 0x000008, "Wrong size on FReferenceToCharacterActionAssetInstance");
static_assert(offsetof(FReferenceToCharacterActionAssetInstance, CharacterAction) == 0x000000, "Member 'FReferenceToCharacterActionAssetInstance::CharacterAction' has a wrong offset!");

// ScriptStruct AT.PlayerInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x04) FPlayerInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerInfo) == 0x000004, "Wrong alignment on FPlayerInfo");
static_assert(sizeof(FPlayerInfo) == 0x000038, "Wrong size on FPlayerInfo");

// ScriptStruct AT.DBHaveCharInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDBHaveCharInfo final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDBHaveCharInfo) == 0x000008, "Wrong alignment on FDBHaveCharInfo");
static_assert(sizeof(FDBHaveCharInfo) == 0x000010, "Wrong size on FDBHaveCharInfo");

// ScriptStruct AT.SkillTreeImpLogInfo
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSkillTreeImpLogInfo final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillTreeImpLogInfo) == 0x000008, "Wrong alignment on FSkillTreeImpLogInfo");
static_assert(sizeof(FSkillTreeImpLogInfo) == 0x000038, "Wrong size on FSkillTreeImpLogInfo");

// ScriptStruct AT.ReferenceToNpcMeshInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToNpcMeshInstance final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToNpcMeshInstance) == 0x000008, "Wrong alignment on FReferenceToNpcMeshInstance");
static_assert(sizeof(FReferenceToNpcMeshInstance) == 0x000008, "Wrong size on FReferenceToNpcMeshInstance");
static_assert(offsetof(FReferenceToNpcMeshInstance, Mesh) == 0x000000, "Member 'FReferenceToNpcMeshInstance::Mesh' has a wrong offset!");

// ScriptStruct AT.AuraSearchRadialBlurParam
// 0x0018 (0x0020 - 0x0008)
struct FAuraSearchRadialBlurParam final : public FTableRowBase
{
public:
	float                                         Alpha;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurAmount;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mid;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAddAmount;                                    // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAddAmount;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuraSearchRadialBlurParam) == 0x000008, "Wrong alignment on FAuraSearchRadialBlurParam");
static_assert(sizeof(FAuraSearchRadialBlurParam) == 0x000020, "Wrong size on FAuraSearchRadialBlurParam");
static_assert(offsetof(FAuraSearchRadialBlurParam, Alpha) == 0x000008, "Member 'FAuraSearchRadialBlurParam::Alpha' has a wrong offset!");
static_assert(offsetof(FAuraSearchRadialBlurParam, BlurAmount) == 0x00000C, "Member 'FAuraSearchRadialBlurParam::BlurAmount' has a wrong offset!");
static_assert(offsetof(FAuraSearchRadialBlurParam, Mid) == 0x000010, "Member 'FAuraSearchRadialBlurParam::Mid' has a wrong offset!");
static_assert(offsetof(FAuraSearchRadialBlurParam, StartAddAmount) == 0x000014, "Member 'FAuraSearchRadialBlurParam::StartAddAmount' has a wrong offset!");
static_assert(offsetof(FAuraSearchRadialBlurParam, EndAddAmount) == 0x000018, "Member 'FAuraSearchRadialBlurParam::EndAddAmount' has a wrong offset!");

// ScriptStruct AT.ATDataAssetCharacterInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetCharacterInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   CharacterClass;                                    // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetCharacterInfo) == 0x000008, "Wrong alignment on FATDataAssetCharacterInfo");
static_assert(sizeof(FATDataAssetCharacterInfo) == 0x000030, "Wrong size on FATDataAssetCharacterInfo");
static_assert(offsetof(FATDataAssetCharacterInfo, MasterId) == 0x000000, "Member 'FATDataAssetCharacterInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetCharacterInfo, CharacterClass) == 0x000008, "Member 'FATDataAssetCharacterInfo::CharacterClass' has a wrong offset!");

// ScriptStruct AT.MissionProgressUserData
// 0x0050 (0x0050 - 0x0000)
struct FMissionProgressUserData final
{
public:
	TMap<class FName, struct FMissionProgressSet> MissionProgressMap;                                // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionProgressUserData) == 0x000008, "Wrong alignment on FMissionProgressUserData");
static_assert(sizeof(FMissionProgressUserData) == 0x000050, "Wrong size on FMissionProgressUserData");
static_assert(offsetof(FMissionProgressUserData, MissionProgressMap) == 0x000000, "Member 'FMissionProgressUserData::MissionProgressMap' has a wrong offset!");

// ScriptStruct AT.LevelUpLogItem
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLevelUpLogItem final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLevelUpLogItem) == 0x000008, "Wrong alignment on FLevelUpLogItem");
static_assert(sizeof(FLevelUpLogItem) == 0x000010, "Wrong size on FLevelUpLogItem");

// ScriptStruct AT.ItemTableBento
// 0x0020 (0x0060 - 0x0040)
struct FItemTableBento final : public FItemInfoParam
{
public:
	class FName                                   EffectGroupId;                                     // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoostId;                                           // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESpecialBentoType                             SpecialType;                                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpecialEffectValue1;                               // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEffectValue2;                               // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpecialEffectValue3;                               // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTableBento) == 0x000008, "Wrong alignment on FItemTableBento");
static_assert(sizeof(FItemTableBento) == 0x000060, "Wrong size on FItemTableBento");
static_assert(offsetof(FItemTableBento, EffectGroupId) == 0x000040, "Member 'FItemTableBento::EffectGroupId' has a wrong offset!");
static_assert(offsetof(FItemTableBento, BoostId) == 0x000048, "Member 'FItemTableBento::BoostId' has a wrong offset!");
static_assert(offsetof(FItemTableBento, SpecialType) == 0x000050, "Member 'FItemTableBento::SpecialType' has a wrong offset!");
static_assert(offsetof(FItemTableBento, SpecialEffectValue1) == 0x000054, "Member 'FItemTableBento::SpecialEffectValue1' has a wrong offset!");
static_assert(offsetof(FItemTableBento, SpecialEffectValue2) == 0x000058, "Member 'FItemTableBento::SpecialEffectValue2' has a wrong offset!");
static_assert(offsetof(FItemTableBento, SpecialEffectValue3) == 0x00005C, "Member 'FItemTableBento::SpecialEffectValue3' has a wrong offset!");

// ScriptStruct AT.InfoLogInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FInfoLogInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInfoLogInfo) == 0x000008, "Wrong alignment on FInfoLogInfo");
static_assert(sizeof(FInfoLogInfo) == 0x000020, "Wrong size on FInfoLogInfo");

// ScriptStruct AT.ReferenceToNpcAnimBPInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToNpcAnimBPInstance final
{
public:
	TSubclassOf<class UAnimInstance>              AnimBP;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToNpcAnimBPInstance) == 0x000008, "Wrong alignment on FReferenceToNpcAnimBPInstance");
static_assert(sizeof(FReferenceToNpcAnimBPInstance) == 0x000008, "Wrong size on FReferenceToNpcAnimBPInstance");
static_assert(offsetof(FReferenceToNpcAnimBPInstance, AnimBP) == 0x000000, "Member 'FReferenceToNpcAnimBPInstance::AnimBP' has a wrong offset!");

// ScriptStruct AT.IntVector4_AT
// 0x0010 (0x0010 - 0x0000)
struct FIntVector4_AT final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Z;                                                 // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         W;                                                 // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIntVector4_AT) == 0x000004, "Wrong alignment on FIntVector4_AT");
static_assert(sizeof(FIntVector4_AT) == 0x000010, "Wrong size on FIntVector4_AT");
static_assert(offsetof(FIntVector4_AT, X) == 0x000000, "Member 'FIntVector4_AT::X' has a wrong offset!");
static_assert(offsetof(FIntVector4_AT, Y) == 0x000004, "Member 'FIntVector4_AT::Y' has a wrong offset!");
static_assert(offsetof(FIntVector4_AT, Z) == 0x000008, "Member 'FIntVector4_AT::Z' has a wrong offset!");
static_assert(offsetof(FIntVector4_AT, W) == 0x00000C, "Member 'FIntVector4_AT::W' has a wrong offset!");

// ScriptStruct AT.DirtyData
// 0x00B8 (0x00B8 - 0x0000)
struct alignas(0x08) FDirtyData final
{
public:
	struct FIntVector4_AT                         Offset;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0xA0];                                      // 0x0010(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Height;                                            // 0x00B0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirtyData) == 0x000008, "Wrong alignment on FDirtyData");
static_assert(sizeof(FDirtyData) == 0x0000B8, "Wrong size on FDirtyData");
static_assert(offsetof(FDirtyData, Offset) == 0x000000, "Member 'FDirtyData::Offset' has a wrong offset!");
static_assert(offsetof(FDirtyData, Height) == 0x0000B0, "Member 'FDirtyData::Height' has a wrong offset!");

// ScriptStruct AT.ReferenceToCharacterAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToCharacterAssetInstance final
{
public:
	TSubclassOf<class AAT_CharacterBase>          Character;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToCharacterAssetInstance) == 0x000008, "Wrong alignment on FReferenceToCharacterAssetInstance");
static_assert(sizeof(FReferenceToCharacterAssetInstance) == 0x000008, "Wrong size on FReferenceToCharacterAssetInstance");
static_assert(offsetof(FReferenceToCharacterAssetInstance, Character) == 0x000000, "Member 'FReferenceToCharacterAssetInstance::Character' has a wrong offset!");

// ScriptStruct AT.InfoLog02Info
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FInfoLog02Info final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInfoLog02Info) == 0x000008, "Wrong alignment on FInfoLog02Info");
static_assert(sizeof(FInfoLog02Info) == 0x000018, "Wrong size on FInfoLog02Info");

// ScriptStruct AT.InfoLogBar02InfoDesc
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FInfoLogBar02InfoDesc final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInfoLogBar02InfoDesc) == 0x000008, "Wrong alignment on FInfoLogBar02InfoDesc");
static_assert(sizeof(FInfoLogBar02InfoDesc) == 0x000018, "Wrong size on FInfoLogBar02InfoDesc");

// ScriptStruct AT.ItemInventoryDefault
// 0x0008 (0x0010 - 0x0008)
struct FItemInventoryDefault final : public FTableRowBase
{
public:
	int32                                         ItemNum;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemInventoryDefault) == 0x000008, "Wrong alignment on FItemInventoryDefault");
static_assert(sizeof(FItemInventoryDefault) == 0x000010, "Wrong size on FItemInventoryDefault");
static_assert(offsetof(FItemInventoryDefault, ItemNum) == 0x000008, "Member 'FItemInventoryDefault::ItemNum' has a wrong offset!");

// ScriptStruct AT.LipSyncParam
// 0x0008 (0x0010 - 0x0008)
struct FLipSyncParam final : public FTableRowBase
{
public:
	float                                         LipSyncOneCharacterTime;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLipSyncParam) == 0x000008, "Wrong alignment on FLipSyncParam");
static_assert(sizeof(FLipSyncParam) == 0x000010, "Wrong size on FLipSyncParam");
static_assert(offsetof(FLipSyncParam, LipSyncOneCharacterTime) == 0x000008, "Member 'FLipSyncParam::LipSyncOneCharacterTime' has a wrong offset!");

// ScriptStruct AT.InfoZOrbLogInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FInfoZOrbLogInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInfoZOrbLogInfo) == 0x000004, "Wrong alignment on FInfoZOrbLogInfo");
static_assert(sizeof(FInfoZOrbLogInfo) == 0x000008, "Wrong size on FInfoZOrbLogInfo");

// ScriptStruct AT.BlinkIconData
// 0x0010 (0x0010 - 0x0000)
struct FBlinkIconData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAT_MapIconSwitchBase*                  MapIcon;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlinkIconData) == 0x000008, "Wrong alignment on FBlinkIconData");
static_assert(sizeof(FBlinkIconData) == 0x000010, "Wrong size on FBlinkIconData");
static_assert(offsetof(FBlinkIconData, MapIcon) == 0x000008, "Member 'FBlinkIconData::MapIcon' has a wrong offset!");

// ScriptStruct AT.IconBlinker
// 0x0020 (0x0020 - 0x0000)
struct FIconBlinker final
{
public:
	TArray<struct FBlinkIconData>                 blinkList;                                         // 0x0000(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIconBlinker) == 0x000008, "Wrong alignment on FIconBlinker");
static_assert(sizeof(FIconBlinker) == 0x000020, "Wrong size on FIconBlinker");
static_assert(offsetof(FIconBlinker, blinkList) == 0x000000, "Member 'FIconBlinker::blinkList' has a wrong offset!");

// ScriptStruct AT.RushShotOffsetParam
// 0x001C (0x001C - 0x0000)
struct FRushShotOffsetParam final
{
public:
	struct FVector2D                              TargetOffset;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOffsetZ;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandRadius;                                        // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandWeight;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRushShotOffsetParam) == 0x000004, "Wrong alignment on FRushShotOffsetParam");
static_assert(sizeof(FRushShotOffsetParam) == 0x00001C, "Wrong size on FRushShotOffsetParam");
static_assert(offsetof(FRushShotOffsetParam, TargetOffset) == 0x000000, "Member 'FRushShotOffsetParam::TargetOffset' has a wrong offset!");
static_assert(offsetof(FRushShotOffsetParam, TargetOffsetZ) == 0x000008, "Member 'FRushShotOffsetParam::TargetOffsetZ' has a wrong offset!");
static_assert(offsetof(FRushShotOffsetParam, RandRadius) == 0x00000C, "Member 'FRushShotOffsetParam::RandRadius' has a wrong offset!");
static_assert(offsetof(FRushShotOffsetParam, RandWeight) == 0x000018, "Member 'FRushShotOffsetParam::RandWeight' has a wrong offset!");

// ScriptStruct AT.UISkillTreeLayoutIdTbl
// 0x0008 (0x0010 - 0x0008)
struct FUISkillTreeLayoutIdTbl final : public FTableRowBase
{
public:
	class FName                                   SkillId;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUISkillTreeLayoutIdTbl) == 0x000008, "Wrong alignment on FUISkillTreeLayoutIdTbl");
static_assert(sizeof(FUISkillTreeLayoutIdTbl) == 0x000010, "Wrong size on FUISkillTreeLayoutIdTbl");
static_assert(offsetof(FUISkillTreeLayoutIdTbl, SkillId) == 0x000008, "Member 'FUISkillTreeLayoutIdTbl::SkillId' has a wrong offset!");

// ScriptStruct AT.OptionData
// 0x0008 (0x0008 - 0x0000)
struct FOptionData final
{
public:
	ELanguageType                                 LangType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      bgm_code;                                          // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlBattleVoice_ID                             Voice_code;                                        // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Voice_chara;                                       // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlBattleVoice_ID                             Voice_code_demo;                                   // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Voice_chara_demo;                                  // 0x0005(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlBattleVoice_ID                             Voice_code_controller;                             // 0x0006(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Voice_chara_controller;                            // 0x0007(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionData) == 0x000001, "Wrong alignment on FOptionData");
static_assert(sizeof(FOptionData) == 0x000008, "Wrong size on FOptionData");
static_assert(offsetof(FOptionData, LangType) == 0x000000, "Member 'FOptionData::LangType' has a wrong offset!");
static_assert(offsetof(FOptionData, bgm_code) == 0x000001, "Member 'FOptionData::bgm_code' has a wrong offset!");
static_assert(offsetof(FOptionData, Voice_code) == 0x000002, "Member 'FOptionData::Voice_code' has a wrong offset!");
static_assert(offsetof(FOptionData, Voice_chara) == 0x000003, "Member 'FOptionData::Voice_chara' has a wrong offset!");
static_assert(offsetof(FOptionData, Voice_code_demo) == 0x000004, "Member 'FOptionData::Voice_code_demo' has a wrong offset!");
static_assert(offsetof(FOptionData, Voice_chara_demo) == 0x000005, "Member 'FOptionData::Voice_chara_demo' has a wrong offset!");
static_assert(offsetof(FOptionData, Voice_code_controller) == 0x000006, "Member 'FOptionData::Voice_code_controller' has a wrong offset!");
static_assert(offsetof(FOptionData, Voice_chara_controller) == 0x000007, "Member 'FOptionData::Voice_chara_controller' has a wrong offset!");

// ScriptStruct AT.LoadingNpcAnimBP
// 0x0028 (0x0028 - 0x0000)
struct FLoadingNpcAnimBP final
{
public:
	TSoftClassPtr<class UClass>                   AnimBP;                                            // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingNpcAnimBP) == 0x000008, "Wrong alignment on FLoadingNpcAnimBP");
static_assert(sizeof(FLoadingNpcAnimBP) == 0x000028, "Wrong size on FLoadingNpcAnimBP");
static_assert(offsetof(FLoadingNpcAnimBP, AnimBP) == 0x000000, "Member 'FLoadingNpcAnimBP::AnimBP' has a wrong offset!");

// ScriptStruct AT.GhostMeshInfo
// 0x0010 (0x0010 - 0x0000)
struct FGhostMeshInfo final
{
public:
	TArray<class USkeletalMesh*>                  SkeletalMeshs;                                     // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGhostMeshInfo) == 0x000008, "Wrong alignment on FGhostMeshInfo");
static_assert(sizeof(FGhostMeshInfo) == 0x000010, "Wrong size on FGhostMeshInfo");
static_assert(offsetof(FGhostMeshInfo, SkeletalMeshs) == 0x000000, "Member 'FGhostMeshInfo::SkeletalMeshs' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFormMeshInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetFormMeshInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PartsClass;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFormMeshInfo) == 0x000008, "Wrong alignment on FATDataAssetFormMeshInfo");
static_assert(sizeof(FATDataAssetFormMeshInfo) == 0x000030, "Wrong size on FATDataAssetFormMeshInfo");
static_assert(offsetof(FATDataAssetFormMeshInfo, MasterId) == 0x000000, "Member 'FATDataAssetFormMeshInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetFormMeshInfo, PartsClass) == 0x000008, "Member 'FATDataAssetFormMeshInfo::PartsClass' has a wrong offset!");

// ScriptStruct AT.WorldMapIconData
// 0x0010 (0x0010 - 0x0000)
struct FWorldMapIconData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ResoucePtr;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWorldMapIconData) == 0x000008, "Wrong alignment on FWorldMapIconData");
static_assert(sizeof(FWorldMapIconData) == 0x000010, "Wrong size on FWorldMapIconData");
static_assert(offsetof(FWorldMapIconData, ResoucePtr) == 0x000008, "Member 'FWorldMapIconData::ResoucePtr' has a wrong offset!");

// ScriptStruct AT.ATDataAssetParticleInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetParticleInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         ParticleClass;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetParticleInfo) == 0x000008, "Wrong alignment on FATDataAssetParticleInfo");
static_assert(sizeof(FATDataAssetParticleInfo) == 0x000030, "Wrong size on FATDataAssetParticleInfo");
static_assert(offsetof(FATDataAssetParticleInfo, MasterId) == 0x000000, "Member 'FATDataAssetParticleInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetParticleInfo, ParticleClass) == 0x000008, "Member 'FATDataAssetParticleInfo::ParticleClass' has a wrong offset!");

// ScriptStruct AT.LoadingCharacterActionAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingCharacterActionAsset final
{
public:
	TSoftClassPtr<class UClass>                   CharacterAction;                                   // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingCharacterActionAsset) == 0x000008, "Wrong alignment on FLoadingCharacterActionAsset");
static_assert(sizeof(FLoadingCharacterActionAsset) == 0x000028, "Wrong size on FLoadingCharacterActionAsset");
static_assert(offsetof(FLoadingCharacterActionAsset, CharacterAction) == 0x000000, "Member 'FLoadingCharacterActionAsset::CharacterAction' has a wrong offset!");

// ScriptStruct AT.SkillAnimInfo
// 0x0010 (0x0010 - 0x0000)
struct FSkillAnimInfo final
{
public:
	class UAnimMontage*                           WaitMontage;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitLoopTime;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillAnimInfo) == 0x000008, "Wrong alignment on FSkillAnimInfo");
static_assert(sizeof(FSkillAnimInfo) == 0x000010, "Wrong size on FSkillAnimInfo");
static_assert(offsetof(FSkillAnimInfo, WaitMontage) == 0x000000, "Member 'FSkillAnimInfo::WaitMontage' has a wrong offset!");
static_assert(offsetof(FSkillAnimInfo, WaitLoopTime) == 0x000008, "Member 'FSkillAnimInfo::WaitLoopTime' has a wrong offset!");

// ScriptStruct AT.CharacterDamageComponentTickFunction
// 0x0028 (0x0080 - 0x0058)
struct FCharacterDamageComponentTickFunction final : public FActorComponentTickFunction
{
public:
	uint8                                         Pad_58[0x28];                                      // 0x0058(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterDamageComponentTickFunction) == 0x000008, "Wrong alignment on FCharacterDamageComponentTickFunction");
static_assert(sizeof(FCharacterDamageComponentTickFunction) == 0x000080, "Wrong size on FCharacterDamageComponentTickFunction");

// ScriptStruct AT.WorldMapsSymbol
// 0x0020 (0x0020 - 0x0000)
struct FWorldMapsSymbol final
{
public:
	class UCanvasPanelSlot*                       BaseSlot;                                          // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAT_UIMapWorldIcon*                     MapIcon;                                           // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldMapsSymbol) == 0x000008, "Wrong alignment on FWorldMapsSymbol");
static_assert(sizeof(FWorldMapsSymbol) == 0x000020, "Wrong size on FWorldMapsSymbol");
static_assert(offsetof(FWorldMapsSymbol, BaseSlot) == 0x000000, "Member 'FWorldMapsSymbol::BaseSlot' has a wrong offset!");
static_assert(offsetof(FWorldMapsSymbol, MapIcon) == 0x000008, "Member 'FWorldMapsSymbol::MapIcon' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamDlc
// 0x0008 (0x0028 - 0x0020)
struct FZCompworksParamDlc : public FZCompworksParamBase
{
public:
	class FName                                   RequireDlcId;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksParamDlc) == 0x000008, "Wrong alignment on FZCompworksParamDlc");
static_assert(sizeof(FZCompworksParamDlc) == 0x000028, "Wrong size on FZCompworksParamDlc");
static_assert(offsetof(FZCompworksParamDlc, RequireDlcId) == 0x000020, "Member 'FZCompworksParamDlc::RequireDlcId' has a wrong offset!");

// ScriptStruct AT.CmnMenuBar03Param
// 0x0060 (0x0060 - 0x0000)
struct FCmnMenuBar03Param final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KeyHelpId;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KeyBindId;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CachedValue;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionValue;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         OptionList;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEdit;                                           // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMin;                                            // 0x0053(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMax;                                            // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoop;                                           // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOption;                                         // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVolume;                                         // 0x0057(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPopUp;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisplay;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNumber;                                         // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKeyBind;                                        // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConfirm;                                        // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBgmSel;                                         // 0x005D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnMenuBar03Param) == 0x000008, "Wrong alignment on FCmnMenuBar03Param");
static_assert(sizeof(FCmnMenuBar03Param) == 0x000060, "Wrong size on FCmnMenuBar03Param");
static_assert(offsetof(FCmnMenuBar03Param, ItemId) == 0x000000, "Member 'FCmnMenuBar03Param::ItemId' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, KeyHelpId) == 0x000008, "Member 'FCmnMenuBar03Param::KeyHelpId' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, KeyBindId) == 0x000018, "Member 'FCmnMenuBar03Param::KeyBindId' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, ItemName) == 0x000020, "Member 'FCmnMenuBar03Param::ItemName' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, DefaultValue) == 0x000030, "Member 'FCmnMenuBar03Param::DefaultValue' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, CachedValue) == 0x000034, "Member 'FCmnMenuBar03Param::CachedValue' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, OptionValue) == 0x000038, "Member 'FCmnMenuBar03Param::OptionValue' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, OptionList) == 0x000040, "Member 'FCmnMenuBar03Param::OptionList' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsNew) == 0x000050, "Member 'FCmnMenuBar03Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsActive) == 0x000051, "Member 'FCmnMenuBar03Param::bIsActive' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsEdit) == 0x000052, "Member 'FCmnMenuBar03Param::bIsEdit' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsMin) == 0x000053, "Member 'FCmnMenuBar03Param::bIsMin' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsMax) == 0x000054, "Member 'FCmnMenuBar03Param::bIsMax' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsLoop) == 0x000055, "Member 'FCmnMenuBar03Param::bIsLoop' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsOption) == 0x000056, "Member 'FCmnMenuBar03Param::bIsOption' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsVolume) == 0x000057, "Member 'FCmnMenuBar03Param::bIsVolume' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsPopUp) == 0x000058, "Member 'FCmnMenuBar03Param::bIsPopUp' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsDisplay) == 0x000059, "Member 'FCmnMenuBar03Param::bIsDisplay' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsNumber) == 0x00005A, "Member 'FCmnMenuBar03Param::bIsNumber' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsKeyBind) == 0x00005B, "Member 'FCmnMenuBar03Param::bIsKeyBind' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsConfirm) == 0x00005C, "Member 'FCmnMenuBar03Param::bIsConfirm' has a wrong offset!");
static_assert(offsetof(FCmnMenuBar03Param, bIsBgmSel) == 0x00005D, "Member 'FCmnMenuBar03Param::bIsBgmSel' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataModelUnique
// 0x0050 (0x0078 - 0x0028)
struct FZCompworksUIDataModelUnique final : public FZCompworksUIDataModel
{
public:
	class FName                                   UniqueId;                                          // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x0031(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AnimationPath;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RefAnimationPath;                                  // 0x0040(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FacialPath;                                        // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        RefFacialPath;                                     // 0x0060(0x0018)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataModelUnique) == 0x000008, "Wrong alignment on FZCompworksUIDataModelUnique");
static_assert(sizeof(FZCompworksUIDataModelUnique) == 0x000078, "Wrong size on FZCompworksUIDataModelUnique");
static_assert(offsetof(FZCompworksUIDataModelUnique, UniqueId) == 0x000028, "Member 'FZCompworksUIDataModelUnique::UniqueId' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelUnique, VariationId) == 0x000030, "Member 'FZCompworksUIDataModelUnique::VariationId' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelUnique, FormID) == 0x000031, "Member 'FZCompworksUIDataModelUnique::FormID' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelUnique, AnimationPath) == 0x000038, "Member 'FZCompworksUIDataModelUnique::AnimationPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelUnique, RefAnimationPath) == 0x000040, "Member 'FZCompworksUIDataModelUnique::RefAnimationPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelUnique, FacialPath) == 0x000058, "Member 'FZCompworksUIDataModelUnique::FacialPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelUnique, RefFacialPath) == 0x000060, "Member 'FZCompworksUIDataModelUnique::RefFacialPath' has a wrong offset!");

// ScriptStruct AT.CmnWishMenuList00Param
// 0x0020 (0x0020 - 0x0000)
struct FCmnWishMenuList00Param final
{
public:
	int32                                         WishInfoId;                                        // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 WishName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheak;                                          // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsClear;                                          // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLoop;                                           // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnWishMenuList00Param) == 0x000008, "Wrong alignment on FCmnWishMenuList00Param");
static_assert(sizeof(FCmnWishMenuList00Param) == 0x000020, "Wrong size on FCmnWishMenuList00Param");
static_assert(offsetof(FCmnWishMenuList00Param, WishInfoId) == 0x000000, "Member 'FCmnWishMenuList00Param::WishInfoId' has a wrong offset!");
static_assert(offsetof(FCmnWishMenuList00Param, WishName) == 0x000008, "Member 'FCmnWishMenuList00Param::WishName' has a wrong offset!");
static_assert(offsetof(FCmnWishMenuList00Param, bIsNew) == 0x000018, "Member 'FCmnWishMenuList00Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnWishMenuList00Param, bIsActive) == 0x000019, "Member 'FCmnWishMenuList00Param::bIsActive' has a wrong offset!");
static_assert(offsetof(FCmnWishMenuList00Param, bIsCheak) == 0x00001A, "Member 'FCmnWishMenuList00Param::bIsCheak' has a wrong offset!");
static_assert(offsetof(FCmnWishMenuList00Param, bIsClear) == 0x00001B, "Member 'FCmnWishMenuList00Param::bIsClear' has a wrong offset!");
static_assert(offsetof(FCmnWishMenuList00Param, bIsLoop) == 0x00001C, "Member 'FCmnWishMenuList00Param::bIsLoop' has a wrong offset!");

// ScriptStruct AT.SubQuestStartUITableRow
// 0x0010 (0x0018 - 0x0008)
struct FSubQuestStartUITableRow final : public FTableRowBase
{
public:
	class FName                                   ClientName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConfirmationMessageId;                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubQuestStartUITableRow) == 0x000008, "Wrong alignment on FSubQuestStartUITableRow");
static_assert(sizeof(FSubQuestStartUITableRow) == 0x000018, "Wrong size on FSubQuestStartUITableRow");
static_assert(offsetof(FSubQuestStartUITableRow, ClientName) == 0x000008, "Member 'FSubQuestStartUITableRow::ClientName' has a wrong offset!");
static_assert(offsetof(FSubQuestStartUITableRow, ConfirmationMessageId) == 0x000010, "Member 'FSubQuestStartUITableRow::ConfirmationMessageId' has a wrong offset!");

// ScriptStruct AT.ReferenceToRaceGameCommonAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToRaceGameCommonAssetInstance final
{
public:
	class UDataTable*                             RaceGameDataTable;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToRaceGameCommonAssetInstance) == 0x000008, "Wrong alignment on FReferenceToRaceGameCommonAssetInstance");
static_assert(sizeof(FReferenceToRaceGameCommonAssetInstance) == 0x000008, "Wrong size on FReferenceToRaceGameCommonAssetInstance");
static_assert(offsetof(FReferenceToRaceGameCommonAssetInstance, RaceGameDataTable) == 0x000000, "Member 'FReferenceToRaceGameCommonAssetInstance::RaceGameDataTable' has a wrong offset!");

// ScriptStruct AT.BattleGroupAICharacters
// 0x0010 (0x0010 - 0x0000)
struct FBattleGroupAICharacters final
{
public:
	TArray<ECHARACTER_TYPE>                       Characters;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleGroupAICharacters) == 0x000008, "Wrong alignment on FBattleGroupAICharacters");
static_assert(sizeof(FBattleGroupAICharacters) == 0x000010, "Wrong size on FBattleGroupAICharacters");
static_assert(offsetof(FBattleGroupAICharacters, Characters) == 0x000000, "Member 'FBattleGroupAICharacters::Characters' has a wrong offset!");

// ScriptStruct AT.PushAnimElem
// 0x0010 (0x0010 - 0x0000)
struct FPushAnimElem final
{
public:
	class UWidgetAnimation*                       Animation;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPushAnimElem) == 0x000008, "Wrong alignment on FPushAnimElem");
static_assert(sizeof(FPushAnimElem) == 0x000010, "Wrong size on FPushAnimElem");
static_assert(offsetof(FPushAnimElem, Animation) == 0x000000, "Member 'FPushAnimElem::Animation' has a wrong offset!");

// ScriptStruct AT.CmnMenuList03Param
// 0x0020 (0x0020 - 0x0000)
struct FCmnMenuList03Param final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCmnMenuList03Param) == 0x000008, "Wrong alignment on FCmnMenuList03Param");
static_assert(sizeof(FCmnMenuList03Param) == 0x000020, "Wrong size on FCmnMenuList03Param");
static_assert(offsetof(FCmnMenuList03Param, ItemId) == 0x000000, "Member 'FCmnMenuList03Param::ItemId' has a wrong offset!");
static_assert(offsetof(FCmnMenuList03Param, ItemName) == 0x000008, "Member 'FCmnMenuList03Param::ItemName' has a wrong offset!");
static_assert(offsetof(FCmnMenuList03Param, bIsNew) == 0x000018, "Member 'FCmnMenuList03Param::bIsNew' has a wrong offset!");
static_assert(offsetof(FCmnMenuList03Param, bIsActive) == 0x000019, "Member 'FCmnMenuList03Param::bIsActive' has a wrong offset!");

// ScriptStruct AT.AtrociousConditonInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAtrociousConditonInfo final
{
public:
	class FName                                   EnemyPartyID;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnemyKillCount;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EncountEventName;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtrociousConditonInfo) == 0x000008, "Wrong alignment on FAtrociousConditonInfo");
static_assert(sizeof(FAtrociousConditonInfo) == 0x000018, "Wrong size on FAtrociousConditonInfo");
static_assert(offsetof(FAtrociousConditonInfo, EnemyPartyID) == 0x000000, "Member 'FAtrociousConditonInfo::EnemyPartyID' has a wrong offset!");
static_assert(offsetof(FAtrociousConditonInfo, EnemyKillCount) == 0x000008, "Member 'FAtrociousConditonInfo::EnemyKillCount' has a wrong offset!");
static_assert(offsetof(FAtrociousConditonInfo, EncountEventName) == 0x000010, "Member 'FAtrociousConditonInfo::EncountEventName' has a wrong offset!");

// ScriptStruct AT.AtrociousConditionParamTable
// 0x0030 (0x0038 - 0x0008)
struct FAtrociousConditionParamTable final : public FTableRowBase
{
public:
	TArray<struct FAtrociousConditonInfo>         AtrociousConditonInfo;                             // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AreaID;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UnlockEnemyPartyID;                                // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditonPhaseID;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnQuestID;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAtrociousConditionParamTable) == 0x000008, "Wrong alignment on FAtrociousConditionParamTable");
static_assert(sizeof(FAtrociousConditionParamTable) == 0x000038, "Wrong size on FAtrociousConditionParamTable");
static_assert(offsetof(FAtrociousConditionParamTable, AtrociousConditonInfo) == 0x000008, "Member 'FAtrociousConditionParamTable::AtrociousConditonInfo' has a wrong offset!");
static_assert(offsetof(FAtrociousConditionParamTable, AreaID) == 0x000018, "Member 'FAtrociousConditionParamTable::AreaID' has a wrong offset!");
static_assert(offsetof(FAtrociousConditionParamTable, UnlockEnemyPartyID) == 0x000020, "Member 'FAtrociousConditionParamTable::UnlockEnemyPartyID' has a wrong offset!");
static_assert(offsetof(FAtrociousConditionParamTable, ConditonPhaseID) == 0x000028, "Member 'FAtrociousConditionParamTable::ConditonPhaseID' has a wrong offset!");
static_assert(offsetof(FAtrociousConditionParamTable, ReturnQuestID) == 0x000030, "Member 'FAtrociousConditionParamTable::ReturnQuestID' has a wrong offset!");

// ScriptStruct AT.MenuData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FMenuData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMenuData) == 0x000008, "Wrong alignment on FMenuData");
static_assert(sizeof(FMenuData) == 0x000018, "Wrong size on FMenuData");

// ScriptStruct AT.DLC6ScalingTownMiniMapIconParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDLC6ScalingTownMiniMapIconParam final
{
public:
	EMapIcon                                      MapIcon;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TownName;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLC6ScalingTownMiniMapIconParam) == 0x000008, "Wrong alignment on FDLC6ScalingTownMiniMapIconParam");
static_assert(sizeof(FDLC6ScalingTownMiniMapIconParam) == 0x000018, "Wrong size on FDLC6ScalingTownMiniMapIconParam");
static_assert(offsetof(FDLC6ScalingTownMiniMapIconParam, MapIcon) == 0x000000, "Member 'FDLC6ScalingTownMiniMapIconParam::MapIcon' has a wrong offset!");
static_assert(offsetof(FDLC6ScalingTownMiniMapIconParam, TownName) == 0x000008, "Member 'FDLC6ScalingTownMiniMapIconParam::TownName' has a wrong offset!");
static_assert(offsetof(FDLC6ScalingTownMiniMapIconParam, Scale) == 0x000010, "Member 'FDLC6ScalingTownMiniMapIconParam::Scale' has a wrong offset!");

// ScriptStruct AT.ReferenceToGroupBattleAssetInstance
// 0x00D0 (0x00D0 - 0x0000)
struct FReferenceToGroupBattleAssetInstance final
{
public:
	TArray<class USkeletalMesh*>                  FarMobMeshes;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SZCDummyAnim;                                      // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SZCDummyMesh;                                      // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   SZCDamageAnim;                                     // 0x0020(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UCameraAnim*                            SZCCameraAnim;                                     // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SZCOverKillTable;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             SZCOverKillTable2p;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ZOverthrowverKillTableLevel1;                      // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ZOverthrowverKillTableLevel2;                      // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ZOverthrowverKillTableLevel3;                      // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ZOverthrowverKillTableLevel1_DLC5;                 // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ZOverthrowverKillTableLevel2_DLC5;                 // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ZOverthrowverKillTableLevel3_DLC5;                 // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class UParticleSystem*>     AuraParticleMap;                                   // 0x0078(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             GroupBattleReinforceParameterTable;                // 0x00C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToGroupBattleAssetInstance) == 0x000008, "Wrong alignment on FReferenceToGroupBattleAssetInstance");
static_assert(sizeof(FReferenceToGroupBattleAssetInstance) == 0x0000D0, "Wrong size on FReferenceToGroupBattleAssetInstance");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, FarMobMeshes) == 0x000000, "Member 'FReferenceToGroupBattleAssetInstance::FarMobMeshes' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, SZCDummyAnim) == 0x000010, "Member 'FReferenceToGroupBattleAssetInstance::SZCDummyAnim' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, SZCDummyMesh) == 0x000018, "Member 'FReferenceToGroupBattleAssetInstance::SZCDummyMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, SZCDamageAnim) == 0x000020, "Member 'FReferenceToGroupBattleAssetInstance::SZCDamageAnim' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, SZCCameraAnim) == 0x000030, "Member 'FReferenceToGroupBattleAssetInstance::SZCCameraAnim' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, SZCOverKillTable) == 0x000038, "Member 'FReferenceToGroupBattleAssetInstance::SZCOverKillTable' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, SZCOverKillTable2p) == 0x000040, "Member 'FReferenceToGroupBattleAssetInstance::SZCOverKillTable2p' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, ZOverthrowverKillTableLevel1) == 0x000048, "Member 'FReferenceToGroupBattleAssetInstance::ZOverthrowverKillTableLevel1' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, ZOverthrowverKillTableLevel2) == 0x000050, "Member 'FReferenceToGroupBattleAssetInstance::ZOverthrowverKillTableLevel2' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, ZOverthrowverKillTableLevel3) == 0x000058, "Member 'FReferenceToGroupBattleAssetInstance::ZOverthrowverKillTableLevel3' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, ZOverthrowverKillTableLevel1_DLC5) == 0x000060, "Member 'FReferenceToGroupBattleAssetInstance::ZOverthrowverKillTableLevel1_DLC5' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, ZOverthrowverKillTableLevel2_DLC5) == 0x000068, "Member 'FReferenceToGroupBattleAssetInstance::ZOverthrowverKillTableLevel2_DLC5' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, ZOverthrowverKillTableLevel3_DLC5) == 0x000070, "Member 'FReferenceToGroupBattleAssetInstance::ZOverthrowverKillTableLevel3_DLC5' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, AuraParticleMap) == 0x000078, "Member 'FReferenceToGroupBattleAssetInstance::AuraParticleMap' has a wrong offset!");
static_assert(offsetof(FReferenceToGroupBattleAssetInstance, GroupBattleReinforceParameterTable) == 0x0000C8, "Member 'FReferenceToGroupBattleAssetInstance::GroupBattleReinforceParameterTable' has a wrong offset!");

// ScriptStruct AT.FlamethrowerParameter
// 0x0014 (0x0014 - 0x0000)
struct FFlamethrowerParameter final
{
public:
	int32                                         RandWeight;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFlamethrowerAngle                            RotationPattern;                                   // 0x0004(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DirInterp;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMoveTime;                                     // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleTime;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlamethrowerParameter) == 0x000004, "Wrong alignment on FFlamethrowerParameter");
static_assert(sizeof(FFlamethrowerParameter) == 0x000014, "Wrong size on FFlamethrowerParameter");
static_assert(offsetof(FFlamethrowerParameter, RandWeight) == 0x000000, "Member 'FFlamethrowerParameter::RandWeight' has a wrong offset!");
static_assert(offsetof(FFlamethrowerParameter, RotationPattern) == 0x000004, "Member 'FFlamethrowerParameter::RotationPattern' has a wrong offset!");
static_assert(offsetof(FFlamethrowerParameter, DirInterp) == 0x000008, "Member 'FFlamethrowerParameter::DirInterp' has a wrong offset!");
static_assert(offsetof(FFlamethrowerParameter, StartMoveTime) == 0x00000C, "Member 'FFlamethrowerParameter::StartMoveTime' has a wrong offset!");
static_assert(offsetof(FFlamethrowerParameter, AngleTime) == 0x000010, "Member 'FFlamethrowerParameter::AngleTime' has a wrong offset!");

// ScriptStruct AT.FishModelData
// 0x0040 (0x0040 - 0x0000)
struct FFishModelData final
{
public:
	class UAnimMontage*                           FishMontage[0x5];                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 AnimBP;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMeshAry[0x2];                              // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishModelData) == 0x000008, "Wrong alignment on FFishModelData");
static_assert(sizeof(FFishModelData) == 0x000040, "Wrong size on FFishModelData");
static_assert(offsetof(FFishModelData, FishMontage) == 0x000000, "Member 'FFishModelData::FishMontage' has a wrong offset!");
static_assert(offsetof(FFishModelData, AnimBP) == 0x000028, "Member 'FFishModelData::AnimBP' has a wrong offset!");
static_assert(offsetof(FFishModelData, SkeletalMeshAry) == 0x000030, "Member 'FFishModelData::SkeletalMeshAry' has a wrong offset!");

// ScriptStruct AT.UIShopCustomColorParam
// 0x0030 (0x0030 - 0x0000)
struct FUIShopCustomColorParam final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TexId;                                             // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0020(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIShopCustomColorParam) == 0x000008, "Wrong alignment on FUIShopCustomColorParam");
static_assert(sizeof(FUIShopCustomColorParam) == 0x000030, "Wrong size on FUIShopCustomColorParam");
static_assert(offsetof(FUIShopCustomColorParam, bActive) == 0x000000, "Member 'FUIShopCustomColorParam::bActive' has a wrong offset!");
static_assert(offsetof(FUIShopCustomColorParam, TexId) == 0x000004, "Member 'FUIShopCustomColorParam::TexId' has a wrong offset!");
static_assert(offsetof(FUIShopCustomColorParam, ID) == 0x000008, "Member 'FUIShopCustomColorParam::ID' has a wrong offset!");
static_assert(offsetof(FUIShopCustomColorParam, Name) == 0x000010, "Member 'FUIShopCustomColorParam::Name' has a wrong offset!");
static_assert(offsetof(FUIShopCustomColorParam, Value) == 0x000020, "Member 'FUIShopCustomColorParam::Value' has a wrong offset!");

// ScriptStruct AT.LiveTalkParam
// 0x0018 (0x0018 - 0x0000)
struct FLiveTalkParam final
{
public:
	class FString                                 MesId;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DispTime;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETALK_TYPE                                    Type;                                              // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_MSG_FACE_ICON                               Icon;                                              // 0x0015(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLiveTalkParam) == 0x000008, "Wrong alignment on FLiveTalkParam");
static_assert(sizeof(FLiveTalkParam) == 0x000018, "Wrong size on FLiveTalkParam");
static_assert(offsetof(FLiveTalkParam, MesId) == 0x000000, "Member 'FLiveTalkParam::MesId' has a wrong offset!");
static_assert(offsetof(FLiveTalkParam, DispTime) == 0x000010, "Member 'FLiveTalkParam::DispTime' has a wrong offset!");
static_assert(offsetof(FLiveTalkParam, Type) == 0x000014, "Member 'FLiveTalkParam::Type' has a wrong offset!");
static_assert(offsetof(FLiveTalkParam, Icon) == 0x000015, "Member 'FLiveTalkParam::Icon' has a wrong offset!");

// ScriptStruct AT.LoadingBattleGroupAIAsset
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLoadingBattleGroupAIAsset final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingBattleGroupAIAsset) == 0x000008, "Wrong alignment on FLoadingBattleGroupAIAsset");
static_assert(sizeof(FLoadingBattleGroupAIAsset) == 0x000028, "Wrong size on FLoadingBattleGroupAIAsset");

// ScriptStruct AT.GaugeUpdateSpeedThresholdParam
// 0x0008 (0x0008 - 0x0000)
struct FGaugeUpdateSpeedThresholdParam final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateSeconds;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGaugeUpdateSpeedThresholdParam) == 0x000004, "Wrong alignment on FGaugeUpdateSpeedThresholdParam");
static_assert(sizeof(FGaugeUpdateSpeedThresholdParam) == 0x000008, "Wrong size on FGaugeUpdateSpeedThresholdParam");
static_assert(offsetof(FGaugeUpdateSpeedThresholdParam, Threshold) == 0x000000, "Member 'FGaugeUpdateSpeedThresholdParam::Threshold' has a wrong offset!");
static_assert(offsetof(FGaugeUpdateSpeedThresholdParam, UpdateSeconds) == 0x000004, "Member 'FGaugeUpdateSpeedThresholdParam::UpdateSeconds' has a wrong offset!");

// ScriptStruct AT.ATMeshParts
// 0x0010 (0x0010 - 0x0000)
struct FATMeshParts final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Texture;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATMeshParts) == 0x000008, "Wrong alignment on FATMeshParts");
static_assert(sizeof(FATMeshParts) == 0x000010, "Wrong size on FATMeshParts");
static_assert(offsetof(FATMeshParts, Mesh) == 0x000000, "Member 'FATMeshParts::Mesh' has a wrong offset!");
static_assert(offsetof(FATMeshParts, Texture) == 0x000008, "Member 'FATMeshParts::Texture' has a wrong offset!");

// ScriptStruct AT.CaptureSkillDetail
// 0x0048 (0x0048 - 0x0000)
struct FCaptureSkillDetail final
{
public:
	class UCanvasPanel*                           WL_Pnl_Sp;                                         // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Cap00;                                      // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Cap02;                                      // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Cap03;                                      // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Detail;                                     // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAT_UIIconClear*                        WL_Icon_Clear;                                     // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Img_Fade00;                                     // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Img_Fade01;                                     // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Img_Fade02;                                     // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FCaptureSkillDetail) == 0x000008, "Wrong alignment on FCaptureSkillDetail");
static_assert(sizeof(FCaptureSkillDetail) == 0x000048, "Wrong size on FCaptureSkillDetail");
static_assert(offsetof(FCaptureSkillDetail, WL_Pnl_Sp) == 0x000000, "Member 'FCaptureSkillDetail::WL_Pnl_Sp' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Txt_Cap00) == 0x000008, "Member 'FCaptureSkillDetail::WL_Txt_Cap00' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Txt_Cap02) == 0x000010, "Member 'FCaptureSkillDetail::WL_Txt_Cap02' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Txt_Cap03) == 0x000018, "Member 'FCaptureSkillDetail::WL_Txt_Cap03' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Txt_Detail) == 0x000020, "Member 'FCaptureSkillDetail::WL_Txt_Detail' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Icon_Clear) == 0x000028, "Member 'FCaptureSkillDetail::WL_Icon_Clear' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Img_Fade00) == 0x000030, "Member 'FCaptureSkillDetail::WL_Img_Fade00' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Img_Fade01) == 0x000038, "Member 'FCaptureSkillDetail::WL_Img_Fade01' has a wrong offset!");
static_assert(offsetof(FCaptureSkillDetail, WL_Img_Fade02) == 0x000040, "Member 'FCaptureSkillDetail::WL_Img_Fade02' has a wrong offset!");

// ScriptStruct AT.ATDataAssetSoundAutoPlayList
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetSoundAutoPlayList final
{
public:
	TSoftObjectPtr<class USoundAtomCueSheet>      DemoCueSheet;                                      // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDataAssetSoundAutoPlayList) == 0x000008, "Wrong alignment on FATDataAssetSoundAutoPlayList");
static_assert(sizeof(FATDataAssetSoundAutoPlayList) == 0x000030, "Wrong size on FATDataAssetSoundAutoPlayList");
static_assert(offsetof(FATDataAssetSoundAutoPlayList, DemoCueSheet) == 0x000000, "Member 'FATDataAssetSoundAutoPlayList::DemoCueSheet' has a wrong offset!");

// ScriptStruct AT.TrainingDetailTask
// 0x0070 (0x0070 - 0x0000)
struct FTrainingDetailTask final
{
public:
	class UCanvasPanel*                           WL_Pnl_Detail_Task;                                // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Task;                                       // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Detail_Task;                                // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Detail_Task01;                              // 0x0018(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Name_P;                                     // 0x0020(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Lv_E00;                                     // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Ins_Mask_Char_P;                                // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Name_E00;                                   // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Ins_Mask_Char_E;                                // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 WL_Img_Dmy_Charicon;                               // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Name_E01;                                   // 0x0050(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Lv_E01;                                     // 0x0058(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Name_E02;                                   // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCFUIXcmnMultiLineText*                 WL_Txt_Lv_E02;                                     // 0x0068(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FTrainingDetailTask) == 0x000008, "Wrong alignment on FTrainingDetailTask");
static_assert(sizeof(FTrainingDetailTask) == 0x000070, "Wrong size on FTrainingDetailTask");
static_assert(offsetof(FTrainingDetailTask, WL_Pnl_Detail_Task) == 0x000000, "Member 'FTrainingDetailTask::WL_Pnl_Detail_Task' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Task) == 0x000008, "Member 'FTrainingDetailTask::WL_Txt_Task' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Detail_Task) == 0x000010, "Member 'FTrainingDetailTask::WL_Txt_Detail_Task' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Detail_Task01) == 0x000018, "Member 'FTrainingDetailTask::WL_Txt_Detail_Task01' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Name_P) == 0x000020, "Member 'FTrainingDetailTask::WL_Txt_Name_P' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Lv_E00) == 0x000028, "Member 'FTrainingDetailTask::WL_Txt_Lv_E00' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Ins_Mask_Char_P) == 0x000030, "Member 'FTrainingDetailTask::WL_Ins_Mask_Char_P' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Name_E00) == 0x000038, "Member 'FTrainingDetailTask::WL_Txt_Name_E00' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Ins_Mask_Char_E) == 0x000040, "Member 'FTrainingDetailTask::WL_Ins_Mask_Char_E' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Img_Dmy_Charicon) == 0x000048, "Member 'FTrainingDetailTask::WL_Img_Dmy_Charicon' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Name_E01) == 0x000050, "Member 'FTrainingDetailTask::WL_Txt_Name_E01' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Lv_E01) == 0x000058, "Member 'FTrainingDetailTask::WL_Txt_Lv_E01' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Name_E02) == 0x000060, "Member 'FTrainingDetailTask::WL_Txt_Name_E02' has a wrong offset!");
static_assert(offsetof(FTrainingDetailTask, WL_Txt_Lv_E02) == 0x000068, "Member 'FTrainingDetailTask::WL_Txt_Lv_E02' has a wrong offset!");

// ScriptStruct AT.RidingStatus
// 0x0260 (0x0260 - 0x0000)
struct FRidingStatus final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemorySlot;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Jump;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Battery;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rader;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Efficiency;                                        // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Discoverability;                                   // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowExp;                                            // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextExp;                                           // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Color;                                             // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedMemory;                                        // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddSpeed;                                          // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddJump;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddBattery;                                        // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddRader;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddEfficiency;                                     // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AddDiscoverability;                                // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EquipItems[0x80];                                  // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BatteryNow;                                        // 0x024C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BatteryMax;                                        // 0x0250(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_254[0x4];                                      // 0x0254(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              UpdateTime;                                        // 0x0258(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRidingStatus) == 0x000008, "Wrong alignment on FRidingStatus");
static_assert(sizeof(FRidingStatus) == 0x000260, "Wrong size on FRidingStatus");
static_assert(offsetof(FRidingStatus, Level) == 0x000000, "Member 'FRidingStatus::Level' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Exp) == 0x000004, "Member 'FRidingStatus::Exp' has a wrong offset!");
static_assert(offsetof(FRidingStatus, MemorySlot) == 0x000008, "Member 'FRidingStatus::MemorySlot' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Speed) == 0x00000C, "Member 'FRidingStatus::Speed' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Jump) == 0x000010, "Member 'FRidingStatus::Jump' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Battery) == 0x000014, "Member 'FRidingStatus::Battery' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Rader) == 0x000018, "Member 'FRidingStatus::Rader' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Efficiency) == 0x00001C, "Member 'FRidingStatus::Efficiency' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Discoverability) == 0x000020, "Member 'FRidingStatus::Discoverability' has a wrong offset!");
static_assert(offsetof(FRidingStatus, NowExp) == 0x000024, "Member 'FRidingStatus::NowExp' has a wrong offset!");
static_assert(offsetof(FRidingStatus, NextExp) == 0x000028, "Member 'FRidingStatus::NextExp' has a wrong offset!");
static_assert(offsetof(FRidingStatus, Color) == 0x00002C, "Member 'FRidingStatus::Color' has a wrong offset!");
static_assert(offsetof(FRidingStatus, UsedMemory) == 0x000030, "Member 'FRidingStatus::UsedMemory' has a wrong offset!");
static_assert(offsetof(FRidingStatus, AddSpeed) == 0x000034, "Member 'FRidingStatus::AddSpeed' has a wrong offset!");
static_assert(offsetof(FRidingStatus, AddJump) == 0x000038, "Member 'FRidingStatus::AddJump' has a wrong offset!");
static_assert(offsetof(FRidingStatus, AddBattery) == 0x00003C, "Member 'FRidingStatus::AddBattery' has a wrong offset!");
static_assert(offsetof(FRidingStatus, AddRader) == 0x000040, "Member 'FRidingStatus::AddRader' has a wrong offset!");
static_assert(offsetof(FRidingStatus, AddEfficiency) == 0x000044, "Member 'FRidingStatus::AddEfficiency' has a wrong offset!");
static_assert(offsetof(FRidingStatus, AddDiscoverability) == 0x000048, "Member 'FRidingStatus::AddDiscoverability' has a wrong offset!");
static_assert(offsetof(FRidingStatus, EquipItems) == 0x00004C, "Member 'FRidingStatus::EquipItems' has a wrong offset!");
static_assert(offsetof(FRidingStatus, BatteryNow) == 0x00024C, "Member 'FRidingStatus::BatteryNow' has a wrong offset!");
static_assert(offsetof(FRidingStatus, BatteryMax) == 0x000250, "Member 'FRidingStatus::BatteryMax' has a wrong offset!");
static_assert(offsetof(FRidingStatus, UpdateTime) == 0x000258, "Member 'FRidingStatus::UpdateTime' has a wrong offset!");

// ScriptStruct AT.LoadingFishParticleEffAsset
// 0x0140 (0x0140 - 0x0000)
struct alignas(0x08) FLoadingFishParticleEffAsset final
{
public:
	uint8                                         Pad_0[0x140];                                      // 0x0000(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingFishParticleEffAsset) == 0x000008, "Wrong alignment on FLoadingFishParticleEffAsset");
static_assert(sizeof(FLoadingFishParticleEffAsset) == 0x000140, "Wrong size on FLoadingFishParticleEffAsset");

// ScriptStruct AT.BlowTargetPointInfo
// 0x0028 (0x0028 - 0x0000)
struct FBlowTargetPointInfo final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Dir;                                               // 0x0014(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBlowTargetPointInfo) == 0x000008, "Wrong alignment on FBlowTargetPointInfo");
static_assert(sizeof(FBlowTargetPointInfo) == 0x000028, "Wrong size on FBlowTargetPointInfo");
static_assert(offsetof(FBlowTargetPointInfo, Target) == 0x000000, "Member 'FBlowTargetPointInfo::Target' has a wrong offset!");
static_assert(offsetof(FBlowTargetPointInfo, Location) == 0x000008, "Member 'FBlowTargetPointInfo::Location' has a wrong offset!");
static_assert(offsetof(FBlowTargetPointInfo, Dir) == 0x000014, "Member 'FBlowTargetPointInfo::Dir' has a wrong offset!");
static_assert(offsetof(FBlowTargetPointInfo, Distance) == 0x000020, "Member 'FBlowTargetPointInfo::Distance' has a wrong offset!");

// ScriptStruct AT.CaptureParam
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x10) FCaptureParam final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaptureParam) == 0x000010, "Wrong alignment on FCaptureParam");
static_assert(sizeof(FCaptureParam) == 0x000060, "Wrong size on FCaptureParam");

// ScriptStruct AT.CaptureSets
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCaptureSets final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCaptureSets) == 0x000008, "Wrong alignment on FCaptureSets");
static_assert(sizeof(FCaptureSets) == 0x000010, "Wrong size on FCaptureSets");

// ScriptStruct AT.BarData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FBarData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBarData) == 0x000008, "Wrong alignment on FBarData");
static_assert(sizeof(FBarData) == 0x000028, "Wrong size on FBarData");

// ScriptStruct AT.StartpartyPartySelectData
// 0x00B0 (0x00B0 - 0x0000)
struct FStartpartyPartySelectData final
{
public:
	int32                                         CursorIndex;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ECHARACTER_TYPE, class UTexture2D*>      IconTextureList;                                   // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<ECHARACTER_TYPE, class FString>          NowLoadingPathList;                                // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartpartyPartySelectData) == 0x000008, "Wrong alignment on FStartpartyPartySelectData");
static_assert(sizeof(FStartpartyPartySelectData) == 0x0000B0, "Wrong size on FStartpartyPartySelectData");
static_assert(offsetof(FStartpartyPartySelectData, CursorIndex) == 0x000000, "Member 'FStartpartyPartySelectData::CursorIndex' has a wrong offset!");
static_assert(offsetof(FStartpartyPartySelectData, IconTextureList) == 0x000008, "Member 'FStartpartyPartySelectData::IconTextureList' has a wrong offset!");
static_assert(offsetof(FStartpartyPartySelectData, NowLoadingPathList) == 0x000058, "Member 'FStartpartyPartySelectData::NowLoadingPathList' has a wrong offset!");

// ScriptStruct AT.StartStatusBasicParam
// 0x00D0 (0x00D0 - 0x0000)
struct FStartStatusBasicParam final
{
public:
	EStartPartyBarEditMode                        Mode;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Charatype;                                         // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HpCurrentNum;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpMaxNum;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpCurrentNum;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpMaxNum;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfightingAttack;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InfightingDefense;                                 // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShootingAttack;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ShootingDefense;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Critical;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffLevel;                                         // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextExp;                                           // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextExpFull;                                       // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GiveExp;                                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffHpMaxNum;                                      // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffSpMaxNum;                                      // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffInfightingAttack;                              // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffInfightingDefense;                             // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffShootingAttack;                                // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffShootingDefense;                               // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffCritical;                                      // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESupportStyle                                 SupportStyle;                                      // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillAttribute                               SupportSkillAttr1;                                 // 0x0081(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SupportSkillName1;                                 // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity1;                                           // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillAttribute                               SupportSkillAttr2;                                 // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SupportSkillName2;                                 // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity2;                                           // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EStartPartyBarType                            Type;                                              // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpMaxNumBuff;                                      // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SpMaxNumBuff;                                      // 0x00BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InfightingAttackBuff;                              // 0x00BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InfightingDefenseBuff;                             // 0x00BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShootingAttackBuff;                                // 0x00BF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShootingDefenseBuff;                               // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CriticalBuff;                                      // 0x00C1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0x2];                                       // 0x00C2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DiffHpMaxNumBuff;                                  // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffSpMaxNumBuff;                                  // 0x00C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffInfightingAttackBuff;                          // 0x00C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffInfightingDefenseBuff;                         // 0x00CA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffShootingAttackBuff;                            // 0x00CB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffShootingDefenseBuff;                           // 0x00CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffCriticalBuff;                                  // 0x00CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DiffNextExpGive;                                   // 0x00CE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartStatusBasicParam) == 0x000008, "Wrong alignment on FStartStatusBasicParam");
static_assert(sizeof(FStartStatusBasicParam) == 0x0000D0, "Wrong size on FStartStatusBasicParam");
static_assert(offsetof(FStartStatusBasicParam, Mode) == 0x000000, "Member 'FStartStatusBasicParam::Mode' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Charatype) == 0x000004, "Member 'FStartStatusBasicParam::Charatype' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Icon) == 0x000008, "Member 'FStartStatusBasicParam::Icon' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Level) == 0x000010, "Member 'FStartStatusBasicParam::Level' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Name) == 0x000018, "Member 'FStartStatusBasicParam::Name' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, HpCurrentNum) == 0x000030, "Member 'FStartStatusBasicParam::HpCurrentNum' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, HpMaxNum) == 0x000034, "Member 'FStartStatusBasicParam::HpMaxNum' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SpCurrentNum) == 0x000038, "Member 'FStartStatusBasicParam::SpCurrentNum' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SpMaxNum) == 0x00003C, "Member 'FStartStatusBasicParam::SpMaxNum' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, InfightingAttack) == 0x000040, "Member 'FStartStatusBasicParam::InfightingAttack' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, InfightingDefense) == 0x000044, "Member 'FStartStatusBasicParam::InfightingDefense' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, ShootingAttack) == 0x000048, "Member 'FStartStatusBasicParam::ShootingAttack' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, ShootingDefense) == 0x00004C, "Member 'FStartStatusBasicParam::ShootingDefense' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Critical) == 0x000050, "Member 'FStartStatusBasicParam::Critical' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffLevel) == 0x000054, "Member 'FStartStatusBasicParam::DiffLevel' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, NextExp) == 0x000058, "Member 'FStartStatusBasicParam::NextExp' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, NextExpFull) == 0x00005C, "Member 'FStartStatusBasicParam::NextExpFull' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, GiveExp) == 0x000060, "Member 'FStartStatusBasicParam::GiveExp' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffHpMaxNum) == 0x000064, "Member 'FStartStatusBasicParam::DiffHpMaxNum' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffSpMaxNum) == 0x000068, "Member 'FStartStatusBasicParam::DiffSpMaxNum' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffInfightingAttack) == 0x00006C, "Member 'FStartStatusBasicParam::DiffInfightingAttack' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffInfightingDefense) == 0x000070, "Member 'FStartStatusBasicParam::DiffInfightingDefense' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffShootingAttack) == 0x000074, "Member 'FStartStatusBasicParam::DiffShootingAttack' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffShootingDefense) == 0x000078, "Member 'FStartStatusBasicParam::DiffShootingDefense' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffCritical) == 0x00007C, "Member 'FStartStatusBasicParam::DiffCritical' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SupportStyle) == 0x000080, "Member 'FStartStatusBasicParam::SupportStyle' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SupportSkillAttr1) == 0x000081, "Member 'FStartStatusBasicParam::SupportSkillAttr1' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SupportSkillName1) == 0x000088, "Member 'FStartStatusBasicParam::SupportSkillName1' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Rarity1) == 0x000098, "Member 'FStartStatusBasicParam::Rarity1' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SupportSkillAttr2) == 0x00009C, "Member 'FStartStatusBasicParam::SupportSkillAttr2' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SupportSkillName2) == 0x0000A0, "Member 'FStartStatusBasicParam::SupportSkillName2' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Rarity2) == 0x0000B0, "Member 'FStartStatusBasicParam::Rarity2' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, Type) == 0x0000B4, "Member 'FStartStatusBasicParam::Type' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, HpMaxNumBuff) == 0x0000B8, "Member 'FStartStatusBasicParam::HpMaxNumBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, SpMaxNumBuff) == 0x0000BC, "Member 'FStartStatusBasicParam::SpMaxNumBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, InfightingAttackBuff) == 0x0000BD, "Member 'FStartStatusBasicParam::InfightingAttackBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, InfightingDefenseBuff) == 0x0000BE, "Member 'FStartStatusBasicParam::InfightingDefenseBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, ShootingAttackBuff) == 0x0000BF, "Member 'FStartStatusBasicParam::ShootingAttackBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, ShootingDefenseBuff) == 0x0000C0, "Member 'FStartStatusBasicParam::ShootingDefenseBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, CriticalBuff) == 0x0000C1, "Member 'FStartStatusBasicParam::CriticalBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffHpMaxNumBuff) == 0x0000C4, "Member 'FStartStatusBasicParam::DiffHpMaxNumBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffSpMaxNumBuff) == 0x0000C8, "Member 'FStartStatusBasicParam::DiffSpMaxNumBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffInfightingAttackBuff) == 0x0000C9, "Member 'FStartStatusBasicParam::DiffInfightingAttackBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffInfightingDefenseBuff) == 0x0000CA, "Member 'FStartStatusBasicParam::DiffInfightingDefenseBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffShootingAttackBuff) == 0x0000CB, "Member 'FStartStatusBasicParam::DiffShootingAttackBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffShootingDefenseBuff) == 0x0000CC, "Member 'FStartStatusBasicParam::DiffShootingDefenseBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffCriticalBuff) == 0x0000CD, "Member 'FStartStatusBasicParam::DiffCriticalBuff' has a wrong offset!");
static_assert(offsetof(FStartStatusBasicParam, DiffNextExpGive) == 0x0000CE, "Member 'FStartStatusBasicParam::DiffNextExpGive' has a wrong offset!");

// ScriptStruct AT.DLC5ProgressAreaMoveList
// 0x0018 (0x0020 - 0x0008)
struct FDLC5ProgressAreaMoveList final : public FTableRowBase
{
public:
	class FName                                   StartSubQuestId;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATAreaMoveState                              AreaMoveState;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDLC5ProgressAreaMoveList) == 0x000008, "Wrong alignment on FDLC5ProgressAreaMoveList");
static_assert(sizeof(FDLC5ProgressAreaMoveList) == 0x000020, "Wrong size on FDLC5ProgressAreaMoveList");
static_assert(offsetof(FDLC5ProgressAreaMoveList, StartSubQuestId) == 0x000008, "Member 'FDLC5ProgressAreaMoveList::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC5ProgressAreaMoveList, EndSubQuestId) == 0x000010, "Member 'FDLC5ProgressAreaMoveList::EndSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC5ProgressAreaMoveList, AreaMoveState) == 0x000018, "Member 'FDLC5ProgressAreaMoveList::AreaMoveState' has a wrong offset!");

// ScriptStruct AT.StartStatusParam
// 0x00C0 (0x00C0 - 0x0000)
struct alignas(0x10) FStartStatusParam final
{
public:
	uint8                                         Pad_0[0xC0];                                       // 0x0000(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStartStatusParam) == 0x000010, "Wrong alignment on FStartStatusParam");
static_assert(sizeof(FStartStatusParam) == 0x0000C0, "Wrong size on FStartStatusParam");

// ScriptStruct AT.CharacterIconCodeList
// 0x0020 (0x0028 - 0x0008)
struct FCharacterIconCodeList final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CharNameMsgId;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_CHARACTER_NAME                              CharIconCodeType;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterIconCodeList) == 0x000008, "Wrong alignment on FCharacterIconCodeList");
static_assert(sizeof(FCharacterIconCodeList) == 0x000028, "Wrong size on FCharacterIconCodeList");
static_assert(offsetof(FCharacterIconCodeList, CharType) == 0x000008, "Member 'FCharacterIconCodeList::CharType' has a wrong offset!");
static_assert(offsetof(FCharacterIconCodeList, CharNameMsgId) == 0x000010, "Member 'FCharacterIconCodeList::CharNameMsgId' has a wrong offset!");
static_assert(offsetof(FCharacterIconCodeList, CharIconCodeType) == 0x000020, "Member 'FCharacterIconCodeList::CharIconCodeType' has a wrong offset!");

// ScriptStruct AT.CharaPositionAdjust
// 0x0038 (0x0038 - 0x0000)
struct FCharaPositionAdjust final
{
public:
	ECHARACTER_TYPE                               Charatype;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AdjustVec_Player;                                  // 0x0004(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustVec_Support1;                                // 0x0010(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustVec_Support2;                                // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AdjustVec_AccompanyChara;                          // 0x0028(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetHeight;                                      // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharaPositionAdjust) == 0x000004, "Wrong alignment on FCharaPositionAdjust");
static_assert(sizeof(FCharaPositionAdjust) == 0x000038, "Wrong size on FCharaPositionAdjust");
static_assert(offsetof(FCharaPositionAdjust, Charatype) == 0x000000, "Member 'FCharaPositionAdjust::Charatype' has a wrong offset!");
static_assert(offsetof(FCharaPositionAdjust, AdjustVec_Player) == 0x000004, "Member 'FCharaPositionAdjust::AdjustVec_Player' has a wrong offset!");
static_assert(offsetof(FCharaPositionAdjust, AdjustVec_Support1) == 0x000010, "Member 'FCharaPositionAdjust::AdjustVec_Support1' has a wrong offset!");
static_assert(offsetof(FCharaPositionAdjust, AdjustVec_Support2) == 0x00001C, "Member 'FCharaPositionAdjust::AdjustVec_Support2' has a wrong offset!");
static_assert(offsetof(FCharaPositionAdjust, AdjustVec_AccompanyChara) == 0x000028, "Member 'FCharaPositionAdjust::AdjustVec_AccompanyChara' has a wrong offset!");
static_assert(offsetof(FCharaPositionAdjust, OffsetHeight) == 0x000034, "Member 'FCharaPositionAdjust::OffsetHeight' has a wrong offset!");

// ScriptStruct AT.QuestIdHashMap
// 0x0018 (0x0020 - 0x0008)
struct FQuestIdHashMap final : public FTableRowBase
{
public:
	TArray<class FName>                           QuestIds;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ObjectiveStringId;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestIdHashMap) == 0x000008, "Wrong alignment on FQuestIdHashMap");
static_assert(sizeof(FQuestIdHashMap) == 0x000020, "Wrong size on FQuestIdHashMap");
static_assert(offsetof(FQuestIdHashMap, QuestIds) == 0x000008, "Member 'FQuestIdHashMap::QuestIds' has a wrong offset!");
static_assert(offsetof(FQuestIdHashMap, ObjectiveStringId) == 0x000018, "Member 'FQuestIdHashMap::ObjectiveStringId' has a wrong offset!");

// ScriptStruct AT.ATCharacterExpTable
// 0x0008 (0x0010 - 0x0008)
struct FATCharacterExpTable final : public FTableRowBase
{
public:
	int32                                         Next;                                              // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATCharacterExpTable) == 0x000008, "Wrong alignment on FATCharacterExpTable");
static_assert(sizeof(FATCharacterExpTable) == 0x000010, "Wrong size on FATCharacterExpTable");
static_assert(offsetof(FATCharacterExpTable, Next) == 0x000008, "Member 'FATCharacterExpTable::Next' has a wrong offset!");

// ScriptStruct AT.CharacterIconInfo
// 0x0030 (0x0038 - 0x0008)
struct FCharacterIconInfo final : public FTableRowBase
{
public:
	class FString                                 CharaCode;                                         // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ModelId;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateId;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FaceId;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Filename;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterIconInfo) == 0x000008, "Wrong alignment on FCharacterIconInfo");
static_assert(sizeof(FCharacterIconInfo) == 0x000038, "Wrong size on FCharacterIconInfo");
static_assert(offsetof(FCharacterIconInfo, CharaCode) == 0x000008, "Member 'FCharacterIconInfo::CharaCode' has a wrong offset!");
static_assert(offsetof(FCharacterIconInfo, ModelId) == 0x000018, "Member 'FCharacterIconInfo::ModelId' has a wrong offset!");
static_assert(offsetof(FCharacterIconInfo, StateId) == 0x00001C, "Member 'FCharacterIconInfo::StateId' has a wrong offset!");
static_assert(offsetof(FCharacterIconInfo, FaceId) == 0x000020, "Member 'FCharacterIconInfo::FaceId' has a wrong offset!");
static_assert(offsetof(FCharacterIconInfo, Filename) == 0x000028, "Member 'FCharacterIconInfo::Filename' has a wrong offset!");

// ScriptStruct AT.QuestCharacterFetcherCondition
// 0x0010 (0x0018 - 0x0008)
struct FQuestCharacterFetcherCondition final : public FTableRowBase
{
public:
	class FName                                   SourceQuestId;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DestinationQuestId;                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestCharacterFetcherCondition) == 0x000008, "Wrong alignment on FQuestCharacterFetcherCondition");
static_assert(sizeof(FQuestCharacterFetcherCondition) == 0x000018, "Wrong size on FQuestCharacterFetcherCondition");
static_assert(offsetof(FQuestCharacterFetcherCondition, SourceQuestId) == 0x000008, "Member 'FQuestCharacterFetcherCondition::SourceQuestId' has a wrong offset!");
static_assert(offsetof(FQuestCharacterFetcherCondition, DestinationQuestId) == 0x000010, "Member 'FQuestCharacterFetcherCondition::DestinationQuestId' has a wrong offset!");

// ScriptStruct AT.ScrollText
// 0x00A0 (0x00A0 - 0x0000)
struct FScrollText final
{
public:
	uint8                                         Pad_0[0x98];                                       // 0x0000(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UCFUIXcmnMultiLineText*                 Txt_Credit;                                        // 0x0098(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScrollText) == 0x000008, "Wrong alignment on FScrollText");
static_assert(sizeof(FScrollText) == 0x0000A0, "Wrong size on FScrollText");
static_assert(offsetof(FScrollText, Txt_Credit) == 0x000098, "Member 'FScrollText::Txt_Credit' has a wrong offset!");

// ScriptStruct AT.TextStyle
// 0x001C (0x001C - 0x0000)
struct FTextStyle final
{
public:
	struct FLinearColor                           Color;                                             // 0x0000(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FontSize;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontHeight;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTextStyle) == 0x000004, "Wrong alignment on FTextStyle");
static_assert(sizeof(FTextStyle) == 0x00001C, "Wrong size on FTextStyle");
static_assert(offsetof(FTextStyle, Color) == 0x000000, "Member 'FTextStyle::Color' has a wrong offset!");
static_assert(offsetof(FTextStyle, FontSize) == 0x000010, "Member 'FTextStyle::FontSize' has a wrong offset!");
static_assert(offsetof(FTextStyle, FontHeight) == 0x000014, "Member 'FTextStyle::FontHeight' has a wrong offset!");
static_assert(offsetof(FTextStyle, Height) == 0x000018, "Member 'FTextStyle::Height' has a wrong offset!");

// ScriptStruct AT.ATReferenceToFacialAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FATReferenceToFacialAssetInstance final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AATFacialParts>             Parts;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATReferenceToFacialAssetInstance) == 0x000008, "Wrong alignment on FATReferenceToFacialAssetInstance");
static_assert(sizeof(FATReferenceToFacialAssetInstance) == 0x000010, "Wrong size on FATReferenceToFacialAssetInstance");
static_assert(offsetof(FATReferenceToFacialAssetInstance, MasterId) == 0x000000, "Member 'FATReferenceToFacialAssetInstance::MasterId' has a wrong offset!");
static_assert(offsetof(FATReferenceToFacialAssetInstance, Parts) == 0x000008, "Member 'FATReferenceToFacialAssetInstance::Parts' has a wrong offset!");

// ScriptStruct AT.UIXcmnPlatBtnInfo
// 0x0038 (0x0038 - 0x0000)
struct FUIXcmnPlatBtnInfo final
{
public:
	uint8                                         Pad_0[0x30];                                       // 0x0000(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             TextureIns;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIXcmnPlatBtnInfo) == 0x000008, "Wrong alignment on FUIXcmnPlatBtnInfo");
static_assert(sizeof(FUIXcmnPlatBtnInfo) == 0x000038, "Wrong size on FUIXcmnPlatBtnInfo");
static_assert(offsetof(FUIXcmnPlatBtnInfo, TextureIns) == 0x000030, "Member 'FUIXcmnPlatBtnInfo::TextureIns' has a wrong offset!");

// ScriptStruct AT.UIXcmnPlatBtnTypeInfo
// 0x0040 (0x0040 - 0x0000)
struct FUIXcmnPlatBtnTypeInfo final
{
public:
	TArray<EATPlatBtnId>                          KeyIdsForPad;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   KeyConfigActionId;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DynamicAssignInputId;                              // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           DynamicAssignInputControllerId;                    // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EATPlatBtnId>                          KeyIds;                                            // 0x0030(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUIXcmnPlatBtnTypeInfo) == 0x000008, "Wrong alignment on FUIXcmnPlatBtnTypeInfo");
static_assert(sizeof(FUIXcmnPlatBtnTypeInfo) == 0x000040, "Wrong size on FUIXcmnPlatBtnTypeInfo");
static_assert(offsetof(FUIXcmnPlatBtnTypeInfo, KeyIdsForPad) == 0x000000, "Member 'FUIXcmnPlatBtnTypeInfo::KeyIdsForPad' has a wrong offset!");
static_assert(offsetof(FUIXcmnPlatBtnTypeInfo, KeyConfigActionId) == 0x000010, "Member 'FUIXcmnPlatBtnTypeInfo::KeyConfigActionId' has a wrong offset!");
static_assert(offsetof(FUIXcmnPlatBtnTypeInfo, DynamicAssignInputId) == 0x000018, "Member 'FUIXcmnPlatBtnTypeInfo::DynamicAssignInputId' has a wrong offset!");
static_assert(offsetof(FUIXcmnPlatBtnTypeInfo, DynamicAssignInputControllerId) == 0x000020, "Member 'FUIXcmnPlatBtnTypeInfo::DynamicAssignInputControllerId' has a wrong offset!");
static_assert(offsetof(FUIXcmnPlatBtnTypeInfo, KeyIds) == 0x000030, "Member 'FUIXcmnPlatBtnTypeInfo::KeyIds' has a wrong offset!");

// ScriptStruct AT.ReferenceToFishCurveParamAssetInstance
// 0x0018 (0x0018 - 0x0000)
struct FReferenceToFishCurveParamAssetInstance final
{
public:
	class UCurveFloat*                            SwimSpeedCurve;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TurnSpeedCurve;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DiscoverSpeedCurve;                                // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToFishCurveParamAssetInstance) == 0x000008, "Wrong alignment on FReferenceToFishCurveParamAssetInstance");
static_assert(sizeof(FReferenceToFishCurveParamAssetInstance) == 0x000018, "Wrong size on FReferenceToFishCurveParamAssetInstance");
static_assert(offsetof(FReferenceToFishCurveParamAssetInstance, SwimSpeedCurve) == 0x000000, "Member 'FReferenceToFishCurveParamAssetInstance::SwimSpeedCurve' has a wrong offset!");
static_assert(offsetof(FReferenceToFishCurveParamAssetInstance, TurnSpeedCurve) == 0x000008, "Member 'FReferenceToFishCurveParamAssetInstance::TurnSpeedCurve' has a wrong offset!");
static_assert(offsetof(FReferenceToFishCurveParamAssetInstance, DiscoverSpeedCurve) == 0x000010, "Member 'FReferenceToFishCurveParamAssetInstance::DiscoverSpeedCurve' has a wrong offset!");

// ScriptStruct AT.ZCWNavigation
// 0x0048 (0x0048 - 0x0000)
struct alignas(0x08) FZCWNavigation final
{
public:
	uint8                                         Pad_0[0x48];                                       // 0x0000(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCWNavigation) == 0x000008, "Wrong alignment on FZCWNavigation");
static_assert(sizeof(FZCWNavigation) == 0x000048, "Wrong size on FZCWNavigation");

// ScriptStruct AT.ATDataAssetCookingDemoCharacterResourceInfo
// 0x02D8 (0x02D8 - 0x0000)
struct FATDataAssetCookingDemoCharacterResourceInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reaction_Grade1_Motion;                            // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reaction_Grade2_Motion;                            // 0x0030(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reaction_Grade3_Motion;                            // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Seize_Motion;                                 // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick1_Motion;                                // 0x00A8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick2_Motion;                                // 0x00D0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick3_Motion;                                // 0x00F8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick4_Motion;                                // 0x0120(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Grasp_Motion;                                 // 0x0148(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade1_Motion;                               // 0x0170(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade2_Motion;                               // 0x0198(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade3_Motion;                               // 0x01C0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade1_LP_Motion;                            // 0x01E8(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade2_LP_Motion;                            // 0x0210(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade3_LP_Motion;                            // 0x0238(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Result_St_Motion;                                  // 0x0260(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Result_Lp_Motion;                                  // 0x0288(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           StartAttachmentMesh;                               // 0x02B0(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetCookingDemoCharacterResourceInfo) == 0x000008, "Wrong alignment on FATDataAssetCookingDemoCharacterResourceInfo");
static_assert(sizeof(FATDataAssetCookingDemoCharacterResourceInfo) == 0x0002D8, "Wrong size on FATDataAssetCookingDemoCharacterResourceInfo");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, MasterId) == 0x000000, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Reaction_Grade1_Motion) == 0x000008, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Reaction_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Reaction_Grade2_Motion) == 0x000030, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Reaction_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Reaction_Grade3_Motion) == 0x000058, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Reaction_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Meal_Seize_Motion) == 0x000080, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Meal_Seize_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Meal_Stick1_Motion) == 0x0000A8, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Meal_Stick1_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Meal_Stick2_Motion) == 0x0000D0, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Meal_Stick2_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Meal_Stick3_Motion) == 0x0000F8, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Meal_Stick3_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Meal_Stick4_Motion) == 0x000120, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Meal_Stick4_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Meal_Grasp_Motion) == 0x000148, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Meal_Grasp_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, After_Grade1_Motion) == 0x000170, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::After_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, After_Grade2_Motion) == 0x000198, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::After_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, After_Grade3_Motion) == 0x0001C0, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::After_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, After_Grade1_LP_Motion) == 0x0001E8, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::After_Grade1_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, After_Grade2_LP_Motion) == 0x000210, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::After_Grade2_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, After_Grade3_LP_Motion) == 0x000238, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::After_Grade3_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Result_St_Motion) == 0x000260, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Result_St_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, Result_Lp_Motion) == 0x000288, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::Result_Lp_Motion' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoCharacterResourceInfo, StartAttachmentMesh) == 0x0002B0, "Member 'FATDataAssetCookingDemoCharacterResourceInfo::StartAttachmentMesh' has a wrong offset!");

// ScriptStruct AT.ActChargeHeatParticle
// 0x0010 (0x0010 - 0x0000)
struct FActChargeHeatParticle final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActChargeHeatParticle) == 0x000008, "Wrong alignment on FActChargeHeatParticle");
static_assert(sizeof(FActChargeHeatParticle) == 0x000010, "Wrong size on FActChargeHeatParticle");
static_assert(offsetof(FActChargeHeatParticle, FormChangeID) == 0x000000, "Member 'FActChargeHeatParticle::FormChangeID' has a wrong offset!");
static_assert(offsetof(FActChargeHeatParticle, Particle) == 0x000008, "Member 'FActChargeHeatParticle::Particle' has a wrong offset!");

// ScriptStruct AT.DetailTableDevelop
// 0x0028 (0x0030 - 0x0008)
struct FDetailTableDevelop final : public FTableRowBase
{
public:
	class FName                                   TexImage;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRobot;                                           // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MemorySlot;                                        // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Jump;                                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Battery;                                           // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rader;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Efficiency;                                        // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Discoverability;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDetailTableDevelop) == 0x000008, "Wrong alignment on FDetailTableDevelop");
static_assert(sizeof(FDetailTableDevelop) == 0x000030, "Wrong size on FDetailTableDevelop");
static_assert(offsetof(FDetailTableDevelop, TexImage) == 0x000008, "Member 'FDetailTableDevelop::TexImage' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, IsRobot) == 0x000010, "Member 'FDetailTableDevelop::IsRobot' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, MemorySlot) == 0x000014, "Member 'FDetailTableDevelop::MemorySlot' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, Speed) == 0x000018, "Member 'FDetailTableDevelop::Speed' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, Jump) == 0x00001C, "Member 'FDetailTableDevelop::Jump' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, Battery) == 0x000020, "Member 'FDetailTableDevelop::Battery' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, Rader) == 0x000024, "Member 'FDetailTableDevelop::Rader' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, Efficiency) == 0x000028, "Member 'FDetailTableDevelop::Efficiency' has a wrong offset!");
static_assert(offsetof(FDetailTableDevelop, Discoverability) == 0x00002C, "Member 'FDetailTableDevelop::Discoverability' has a wrong offset!");

// ScriptStruct AT.ATAnimNotifyState_CharacterTargetAroundInfo
// 0x0018 (0x0018 - 0x0000)
struct FATAnimNotifyState_CharacterTargetAroundInfo final
{
public:
	float                                         AroundTime1;                                       // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundTime2;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundPitch;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundYawMin;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundYawMax;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseTargetDist;                                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATAnimNotifyState_CharacterTargetAroundInfo) == 0x000004, "Wrong alignment on FATAnimNotifyState_CharacterTargetAroundInfo");
static_assert(sizeof(FATAnimNotifyState_CharacterTargetAroundInfo) == 0x000018, "Wrong size on FATAnimNotifyState_CharacterTargetAroundInfo");
static_assert(offsetof(FATAnimNotifyState_CharacterTargetAroundInfo, AroundTime1) == 0x000000, "Member 'FATAnimNotifyState_CharacterTargetAroundInfo::AroundTime1' has a wrong offset!");
static_assert(offsetof(FATAnimNotifyState_CharacterTargetAroundInfo, AroundTime2) == 0x000004, "Member 'FATAnimNotifyState_CharacterTargetAroundInfo::AroundTime2' has a wrong offset!");
static_assert(offsetof(FATAnimNotifyState_CharacterTargetAroundInfo, AroundPitch) == 0x000008, "Member 'FATAnimNotifyState_CharacterTargetAroundInfo::AroundPitch' has a wrong offset!");
static_assert(offsetof(FATAnimNotifyState_CharacterTargetAroundInfo, AroundYawMin) == 0x00000C, "Member 'FATAnimNotifyState_CharacterTargetAroundInfo::AroundYawMin' has a wrong offset!");
static_assert(offsetof(FATAnimNotifyState_CharacterTargetAroundInfo, AroundYawMax) == 0x000010, "Member 'FATAnimNotifyState_CharacterTargetAroundInfo::AroundYawMax' has a wrong offset!");
static_assert(offsetof(FATAnimNotifyState_CharacterTargetAroundInfo, ChaseTargetDist) == 0x000014, "Member 'FATAnimNotifyState_CharacterTargetAroundInfo::ChaseTargetDist' has a wrong offset!");

// ScriptStruct AT.ActChargeHeatCutInfo
// 0x0038 (0x0038 - 0x0000)
struct FActChargeHeatCutInfo final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFade;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorParameter;                                    // 0x0014(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutStartDelayTime;                             // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInStartDelayTime;                              // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActChargeHeatCutInfo) == 0x000008, "Wrong alignment on FActChargeHeatCutInfo");
static_assert(sizeof(FActChargeHeatCutInfo) == 0x000038, "Wrong size on FActChargeHeatCutInfo");
static_assert(offsetof(FActChargeHeatCutInfo, FormChangeID) == 0x000000, "Member 'FActChargeHeatCutInfo::FormChangeID' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, Montage) == 0x000008, "Member 'FActChargeHeatCutInfo::Montage' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, EnableFade) == 0x000010, "Member 'FActChargeHeatCutInfo::EnableFade' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, ColorParameter) == 0x000014, "Member 'FActChargeHeatCutInfo::ColorParameter' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, FadeOutStartDelayTime) == 0x000024, "Member 'FActChargeHeatCutInfo::FadeOutStartDelayTime' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, FadeOutTime) == 0x000028, "Member 'FActChargeHeatCutInfo::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, FadeInStartDelayTime) == 0x00002C, "Member 'FActChargeHeatCutInfo::FadeInStartDelayTime' has a wrong offset!");
static_assert(offsetof(FActChargeHeatCutInfo, FadeInTime) == 0x000030, "Member 'FActChargeHeatCutInfo::FadeInTime' has a wrong offset!");

// ScriptStruct AT.PurgePhaseElement
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPurgePhaseElement final
{
public:
	class FName                                   StartQuestId;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPurgePhaseElement) == 0x000008, "Wrong alignment on FPurgePhaseElement");
static_assert(sizeof(FPurgePhaseElement) == 0x000020, "Wrong size on FPurgePhaseElement");
static_assert(offsetof(FPurgePhaseElement, StartQuestId) == 0x000000, "Member 'FPurgePhaseElement::StartQuestId' has a wrong offset!");
static_assert(offsetof(FPurgePhaseElement, StartPhaseNo) == 0x000008, "Member 'FPurgePhaseElement::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FPurgePhaseElement, EndQuestId) == 0x000010, "Member 'FPurgePhaseElement::EndQuestId' has a wrong offset!");
static_assert(offsetof(FPurgePhaseElement, EndPhaseNo) == 0x000018, "Member 'FPurgePhaseElement::EndPhaseNo' has a wrong offset!");

// ScriptStruct AT.FishingPhaseCondition
// 0x0058 (0x0060 - 0x0008)
struct FFishingPhaseCondition final : public FTableRowBase
{
public:
	TMap<class FName, int32>                      TargetFishes;                                      // 0x0008(0x0050)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   TargetAreaName;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishingPhaseCondition) == 0x000008, "Wrong alignment on FFishingPhaseCondition");
static_assert(sizeof(FFishingPhaseCondition) == 0x000060, "Wrong size on FFishingPhaseCondition");
static_assert(offsetof(FFishingPhaseCondition, TargetFishes) == 0x000008, "Member 'FFishingPhaseCondition::TargetFishes' has a wrong offset!");
static_assert(offsetof(FFishingPhaseCondition, TargetAreaName) == 0x000058, "Member 'FFishingPhaseCondition::TargetAreaName' has a wrong offset!");

// ScriptStruct AT.Cpl002MakoudanShotParam
// 0x0018 (0x0018 - 0x0000)
struct FCpl002MakoudanShotParam final
{
public:
	int32                                         Rate;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ShotDirectTable;                                   // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCpl002MakoudanShotParam) == 0x000008, "Wrong alignment on FCpl002MakoudanShotParam");
static_assert(sizeof(FCpl002MakoudanShotParam) == 0x000018, "Wrong size on FCpl002MakoudanShotParam");
static_assert(offsetof(FCpl002MakoudanShotParam, Rate) == 0x000000, "Member 'FCpl002MakoudanShotParam::Rate' has a wrong offset!");
static_assert(offsetof(FCpl002MakoudanShotParam, ShotDirectTable) == 0x000008, "Member 'FCpl002MakoudanShotParam::ShotDirectTable' has a wrong offset!");

// ScriptStruct AT.Cpl002MakoudanDirectionParam
// 0x0008 (0x0008 - 0x0000)
struct FCpl002MakoudanDirectionParam final
{
public:
	float                                         DirectAngleX;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DirectAngleY;                                      // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCpl002MakoudanDirectionParam) == 0x000004, "Wrong alignment on FCpl002MakoudanDirectionParam");
static_assert(sizeof(FCpl002MakoudanDirectionParam) == 0x000008, "Wrong size on FCpl002MakoudanDirectionParam");
static_assert(offsetof(FCpl002MakoudanDirectionParam, DirectAngleX) == 0x000000, "Member 'FCpl002MakoudanDirectionParam::DirectAngleX' has a wrong offset!");
static_assert(offsetof(FCpl002MakoudanDirectionParam, DirectAngleY) == 0x000004, "Member 'FCpl002MakoudanDirectionParam::DirectAngleY' has a wrong offset!");

// ScriptStruct AT.ATDamageEvent
// 0x0088 (0x0130 - 0x00A8)
struct FATDamageEvent final : public FPointDamageEvent
{
public:
	uint8                                         Pad_A8[0x88];                                      // 0x00A8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDamageEvent) == 0x000008, "Wrong alignment on FATDamageEvent");
static_assert(sizeof(FATDamageEvent) == 0x000130, "Wrong size on FATDamageEvent");

// ScriptStruct AT.ActCpl003ESkill007EffectSetting
// 0x0038 (0x0038 - 0x0000)
struct FActCpl003ESkill007EffectSetting final
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0008(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attached;                                          // 0x002C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FActCpl003ESkill007EffectSetting) == 0x000008, "Wrong alignment on FActCpl003ESkill007EffectSetting");
static_assert(sizeof(FActCpl003ESkill007EffectSetting) == 0x000038, "Wrong size on FActCpl003ESkill007EffectSetting");
static_assert(offsetof(FActCpl003ESkill007EffectSetting, PSTemplate) == 0x000000, "Member 'FActCpl003ESkill007EffectSetting::PSTemplate' has a wrong offset!");
static_assert(offsetof(FActCpl003ESkill007EffectSetting, LocationOffset) == 0x000008, "Member 'FActCpl003ESkill007EffectSetting::LocationOffset' has a wrong offset!");
static_assert(offsetof(FActCpl003ESkill007EffectSetting, RotationOffset) == 0x000014, "Member 'FActCpl003ESkill007EffectSetting::RotationOffset' has a wrong offset!");
static_assert(offsetof(FActCpl003ESkill007EffectSetting, Scale) == 0x000020, "Member 'FActCpl003ESkill007EffectSetting::Scale' has a wrong offset!");
static_assert(offsetof(FActCpl003ESkill007EffectSetting, Attached) == 0x00002C, "Member 'FActCpl003ESkill007EffectSetting::Attached' has a wrong offset!");
static_assert(offsetof(FActCpl003ESkill007EffectSetting, SocketName) == 0x000030, "Member 'FActCpl003ESkill007EffectSetting::SocketName' has a wrong offset!");

// ScriptStruct AT.ATProgressAreaMoveList
// 0x0018 (0x0020 - 0x0008)
struct FATProgressAreaMoveList final : public FTableRowBase
{
public:
	class FName                                   Progress_id;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Start_quest_phase_id;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATAreaMoveState                              Is_worldmap;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATRestrictMoveControlPreset                  Player_preset;                                     // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_restrict_radar;                                 // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATProgressAreaMoveList) == 0x000008, "Wrong alignment on FATProgressAreaMoveList");
static_assert(sizeof(FATProgressAreaMoveList) == 0x000020, "Wrong size on FATProgressAreaMoveList");
static_assert(offsetof(FATProgressAreaMoveList, Progress_id) == 0x000008, "Member 'FATProgressAreaMoveList::Progress_id' has a wrong offset!");
static_assert(offsetof(FATProgressAreaMoveList, Start_quest_phase_id) == 0x000010, "Member 'FATProgressAreaMoveList::Start_quest_phase_id' has a wrong offset!");
static_assert(offsetof(FATProgressAreaMoveList, Is_worldmap) == 0x000018, "Member 'FATProgressAreaMoveList::Is_worldmap' has a wrong offset!");
static_assert(offsetof(FATProgressAreaMoveList, Player_preset) == 0x000019, "Member 'FATProgressAreaMoveList::Player_preset' has a wrong offset!");
static_assert(offsetof(FATProgressAreaMoveList, Is_restrict_radar) == 0x00001A, "Member 'FATProgressAreaMoveList::Is_restrict_radar' has a wrong offset!");

// ScriptStruct AT.Cpl005DeathSlicerAroundProjectile
// 0x000C (0x000C - 0x0000)
struct FCpl005DeathSlicerAroundProjectile final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShiftAngle;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCpl005DeathSlicerAroundProjectile) == 0x000004, "Wrong alignment on FCpl005DeathSlicerAroundProjectile");
static_assert(sizeof(FCpl005DeathSlicerAroundProjectile) == 0x00000C, "Wrong size on FCpl005DeathSlicerAroundProjectile");
static_assert(offsetof(FCpl005DeathSlicerAroundProjectile, Time) == 0x000000, "Member 'FCpl005DeathSlicerAroundProjectile::Time' has a wrong offset!");
static_assert(offsetof(FCpl005DeathSlicerAroundProjectile, Angle) == 0x000004, "Member 'FCpl005DeathSlicerAroundProjectile::Angle' has a wrong offset!");
static_assert(offsetof(FCpl005DeathSlicerAroundProjectile, ShiftAngle) == 0x000008, "Member 'FCpl005DeathSlicerAroundProjectile::ShiftAngle' has a wrong offset!");

// ScriptStruct AT.SkillAttackInfo_GoldenEdge
// 0x0044 (0x0044 - 0x0000)
struct FSkillAttackInfo_GoldenEdge final
{
public:
	float                                         BombWaitTime;                                      // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombIntervalTime;                                  // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombIntervalDist;                                  // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombMinDist;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombMaxDist;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ShotRotationOffset;                                // 0x0014(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ShotVector;                                        // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ShotRotation;                                      // 0x002C(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         BombStep;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombTime;                                          // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BombDist;                                          // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillAttackInfo_GoldenEdge) == 0x000004, "Wrong alignment on FSkillAttackInfo_GoldenEdge");
static_assert(sizeof(FSkillAttackInfo_GoldenEdge) == 0x000044, "Wrong size on FSkillAttackInfo_GoldenEdge");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombWaitTime) == 0x000000, "Member 'FSkillAttackInfo_GoldenEdge::BombWaitTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombIntervalTime) == 0x000004, "Member 'FSkillAttackInfo_GoldenEdge::BombIntervalTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombIntervalDist) == 0x000008, "Member 'FSkillAttackInfo_GoldenEdge::BombIntervalDist' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombMinDist) == 0x00000C, "Member 'FSkillAttackInfo_GoldenEdge::BombMinDist' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombMaxDist) == 0x000010, "Member 'FSkillAttackInfo_GoldenEdge::BombMaxDist' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, ShotRotationOffset) == 0x000014, "Member 'FSkillAttackInfo_GoldenEdge::ShotRotationOffset' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, ShotVector) == 0x000020, "Member 'FSkillAttackInfo_GoldenEdge::ShotVector' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, ShotRotation) == 0x00002C, "Member 'FSkillAttackInfo_GoldenEdge::ShotRotation' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombStep) == 0x000038, "Member 'FSkillAttackInfo_GoldenEdge::BombStep' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombTime) == 0x00003C, "Member 'FSkillAttackInfo_GoldenEdge::BombTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_GoldenEdge, BombDist) == 0x000040, "Member 'FSkillAttackInfo_GoldenEdge::BombDist' has a wrong offset!");

// ScriptStruct AT.ATAtrociousPhaseClasses
// 0x0018 (0x0018 - 0x0000)
struct FATAtrociousPhaseClasses final
{
public:
	TSubclassOf<class UATAtrociousPreBattleBase>  PreBattleClass;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UATAtrociousBattleBase>     BattleClass;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UATAtrociousCondition>      ConditionClass;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATAtrociousPhaseClasses) == 0x000008, "Wrong alignment on FATAtrociousPhaseClasses");
static_assert(sizeof(FATAtrociousPhaseClasses) == 0x000018, "Wrong size on FATAtrociousPhaseClasses");
static_assert(offsetof(FATAtrociousPhaseClasses, PreBattleClass) == 0x000000, "Member 'FATAtrociousPhaseClasses::PreBattleClass' has a wrong offset!");
static_assert(offsetof(FATAtrociousPhaseClasses, BattleClass) == 0x000008, "Member 'FATAtrociousPhaseClasses::BattleClass' has a wrong offset!");
static_assert(offsetof(FATAtrociousPhaseClasses, ConditionClass) == 0x000010, "Member 'FATAtrociousPhaseClasses::ConditionClass' has a wrong offset!");

// ScriptStruct AT.SkillGoldenSlicerMontageInfo
// 0x0038 (0x0038 - 0x0000)
struct FSkillGoldenSlicerMontageInfo final
{
public:
	class UAnimMontage*                           MontageST;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageLP;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageShotR;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageShotL;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageMV;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageShotFinish;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESkillGoldenSlicerMvType                      GoldenSlicerMoveType;                              // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillGoldenSlicerMontageInfo) == 0x000008, "Wrong alignment on FSkillGoldenSlicerMontageInfo");
static_assert(sizeof(FSkillGoldenSlicerMontageInfo) == 0x000038, "Wrong size on FSkillGoldenSlicerMontageInfo");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, MontageST) == 0x000000, "Member 'FSkillGoldenSlicerMontageInfo::MontageST' has a wrong offset!");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, MontageLP) == 0x000008, "Member 'FSkillGoldenSlicerMontageInfo::MontageLP' has a wrong offset!");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, MontageShotR) == 0x000010, "Member 'FSkillGoldenSlicerMontageInfo::MontageShotR' has a wrong offset!");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, MontageShotL) == 0x000018, "Member 'FSkillGoldenSlicerMontageInfo::MontageShotL' has a wrong offset!");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, MontageMV) == 0x000020, "Member 'FSkillGoldenSlicerMontageInfo::MontageMV' has a wrong offset!");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, MontageShotFinish) == 0x000028, "Member 'FSkillGoldenSlicerMontageInfo::MontageShotFinish' has a wrong offset!");
static_assert(offsetof(FSkillGoldenSlicerMontageInfo, GoldenSlicerMoveType) == 0x000030, "Member 'FSkillGoldenSlicerMontageInfo::GoldenSlicerMoveType' has a wrong offset!");

// ScriptStruct AT.Cpl005LongRangeAProjectileParam
// 0x0024 (0x0024 - 0x0000)
struct FCpl005LongRangeAProjectileParam final
{
public:
	struct FRotator                               RotationOffsetList[0x3];                           // 0x0000(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCpl005LongRangeAProjectileParam) == 0x000004, "Wrong alignment on FCpl005LongRangeAProjectileParam");
static_assert(sizeof(FCpl005LongRangeAProjectileParam) == 0x000024, "Wrong size on FCpl005LongRangeAProjectileParam");
static_assert(offsetof(FCpl005LongRangeAProjectileParam, RotationOffsetList) == 0x000000, "Member 'FCpl005LongRangeAProjectileParam::RotationOffsetList' has a wrong offset!");

// ScriptStruct AT.CookCharacterMotion
// 0x0090 (0x0090 - 0x0000)
struct FCookCharacterMotion final
{
public:
	class UAnimMontage*                           M_pReaction_Grade1_Motion;                         // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pReaction_Grade2_Motion;                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pReaction_Grade3_Motion;                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pMeal_Seize_Motion;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pMeal_Stick1_Motion;                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pMeal_Stick2_Motion;                             // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pMeal_Stick3_Motion;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pMeal_Stick4_Motion;                             // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pMeal_Grasp_Motion;                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAfter_Grade1_Motion;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAfter_Grade2_Motion;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAfter_Grade3_Motion;                            // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAfter_Grade1_LP_Motion;                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAfter_Grade2_LP_Motion;                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pAfter_Grade3_LP_Motion;                         // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pResult_St_Motion;                               // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           M_pResult_Lp_Motion;                               // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          StartAttachmentMesh;                               // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookCharacterMotion) == 0x000008, "Wrong alignment on FCookCharacterMotion");
static_assert(sizeof(FCookCharacterMotion) == 0x000090, "Wrong size on FCookCharacterMotion");
static_assert(offsetof(FCookCharacterMotion, M_pReaction_Grade1_Motion) == 0x000000, "Member 'FCookCharacterMotion::M_pReaction_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pReaction_Grade2_Motion) == 0x000008, "Member 'FCookCharacterMotion::M_pReaction_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pReaction_Grade3_Motion) == 0x000010, "Member 'FCookCharacterMotion::M_pReaction_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pMeal_Seize_Motion) == 0x000018, "Member 'FCookCharacterMotion::M_pMeal_Seize_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pMeal_Stick1_Motion) == 0x000020, "Member 'FCookCharacterMotion::M_pMeal_Stick1_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pMeal_Stick2_Motion) == 0x000028, "Member 'FCookCharacterMotion::M_pMeal_Stick2_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pMeal_Stick3_Motion) == 0x000030, "Member 'FCookCharacterMotion::M_pMeal_Stick3_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pMeal_Stick4_Motion) == 0x000038, "Member 'FCookCharacterMotion::M_pMeal_Stick4_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pMeal_Grasp_Motion) == 0x000040, "Member 'FCookCharacterMotion::M_pMeal_Grasp_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pAfter_Grade1_Motion) == 0x000048, "Member 'FCookCharacterMotion::M_pAfter_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pAfter_Grade2_Motion) == 0x000050, "Member 'FCookCharacterMotion::M_pAfter_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pAfter_Grade3_Motion) == 0x000058, "Member 'FCookCharacterMotion::M_pAfter_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pAfter_Grade1_LP_Motion) == 0x000060, "Member 'FCookCharacterMotion::M_pAfter_Grade1_LP_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pAfter_Grade2_LP_Motion) == 0x000068, "Member 'FCookCharacterMotion::M_pAfter_Grade2_LP_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pAfter_Grade3_LP_Motion) == 0x000070, "Member 'FCookCharacterMotion::M_pAfter_Grade3_LP_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pResult_St_Motion) == 0x000078, "Member 'FCookCharacterMotion::M_pResult_St_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, M_pResult_Lp_Motion) == 0x000080, "Member 'FCookCharacterMotion::M_pResult_Lp_Motion' has a wrong offset!");
static_assert(offsetof(FCookCharacterMotion, StartAttachmentMesh) == 0x000088, "Member 'FCookCharacterMotion::StartAttachmentMesh' has a wrong offset!");

// ScriptStruct AT.BeamWaitParam
// 0x0008 (0x0008 - 0x0000)
struct FBeamWaitParam final
{
public:
	uint8                                         Pad_0[0x4];                                        // 0x0000(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShotLoopTime;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FBeamWaitParam) == 0x000004, "Wrong alignment on FBeamWaitParam");
static_assert(sizeof(FBeamWaitParam) == 0x000008, "Wrong size on FBeamWaitParam");
static_assert(offsetof(FBeamWaitParam, ShotLoopTime) == 0x000004, "Member 'FBeamWaitParam::ShotLoopTime' has a wrong offset!");

// ScriptStruct AT.ATDataAssetCharacterActionInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetCharacterActionInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActionClassTable;                                  // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetCharacterActionInfo) == 0x000008, "Wrong alignment on FATDataAssetCharacterActionInfo");
static_assert(sizeof(FATDataAssetCharacterActionInfo) == 0x000030, "Wrong size on FATDataAssetCharacterActionInfo");
static_assert(offsetof(FATDataAssetCharacterActionInfo, MasterId) == 0x000000, "Member 'FATDataAssetCharacterActionInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetCharacterActionInfo, ActionClassTable) == 0x000008, "Member 'FATDataAssetCharacterActionInfo::ActionClassTable' has a wrong offset!");

// ScriptStruct AT.DoubleSundayBeamOrbitInfo
// 0x0020 (0x0020 - 0x0000)
struct FDoubleSundayBeamOrbitInfo final
{
public:
	float                                         SetAngleSecond;                                    // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDoubleSundayBeamEaseSet                      BeamEaseSet;                                       // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BeamEaseExp;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotAngle;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TraceTargetFlag;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceStrength;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetPitch;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetPitchSec;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDoubleSundayBeamOrbitInfo) == 0x000004, "Wrong alignment on FDoubleSundayBeamOrbitInfo");
static_assert(sizeof(FDoubleSundayBeamOrbitInfo) == 0x000020, "Wrong size on FDoubleSundayBeamOrbitInfo");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, SetAngleSecond) == 0x000000, "Member 'FDoubleSundayBeamOrbitInfo::SetAngleSecond' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, BeamEaseSet) == 0x000004, "Member 'FDoubleSundayBeamOrbitInfo::BeamEaseSet' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, BeamEaseExp) == 0x000008, "Member 'FDoubleSundayBeamOrbitInfo::BeamEaseExp' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, RotAngle) == 0x00000C, "Member 'FDoubleSundayBeamOrbitInfo::RotAngle' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, TraceTargetFlag) == 0x000010, "Member 'FDoubleSundayBeamOrbitInfo::TraceTargetFlag' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, TraceStrength) == 0x000014, "Member 'FDoubleSundayBeamOrbitInfo::TraceStrength' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, SetPitch) == 0x000018, "Member 'FDoubleSundayBeamOrbitInfo::SetPitch' has a wrong offset!");
static_assert(offsetof(FDoubleSundayBeamOrbitInfo, SetPitchSec) == 0x00001C, "Member 'FDoubleSundayBeamOrbitInfo::SetPitchSec' has a wrong offset!");

// ScriptStruct AT.SpawnDataTable
// 0x0048 (0x0050 - 0x0008)
struct FSpawnDataTable final : public FTableRowBase
{
public:
	class FName                                   SpawnDataTableID;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseID;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnWeight;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_ENCOUNT_BEHAVIOR                         SymbolMovement;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnemyPartyID;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             EnemyParty;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ATROCIOUS_TYPE                              EnemyAtrociousType;                                // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropGroupID;                                       // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DropGroup;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FieldAttack;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_SPECIAL_PROGRESS_ENCOUNT                    SpecialProgressEncountType;                        // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpecialProgressEncount;                            // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnDataTable) == 0x000008, "Wrong alignment on FSpawnDataTable");
static_assert(sizeof(FSpawnDataTable) == 0x000050, "Wrong size on FSpawnDataTable");
static_assert(offsetof(FSpawnDataTable, SpawnDataTableID) == 0x000008, "Member 'FSpawnDataTable::SpawnDataTableID' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, PhaseID) == 0x000010, "Member 'FSpawnDataTable::PhaseID' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, SpawnWeight) == 0x000018, "Member 'FSpawnDataTable::SpawnWeight' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, SymbolMovement) == 0x00001C, "Member 'FSpawnDataTable::SymbolMovement' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, EnemyPartyID) == 0x000020, "Member 'FSpawnDataTable::EnemyPartyID' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, EnemyParty) == 0x000028, "Member 'FSpawnDataTable::EnemyParty' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, EnemyAtrociousType) == 0x000030, "Member 'FSpawnDataTable::EnemyAtrociousType' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, DropGroupID) == 0x000038, "Member 'FSpawnDataTable::DropGroupID' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, DropGroup) == 0x000040, "Member 'FSpawnDataTable::DropGroup' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, FieldAttack) == 0x000048, "Member 'FSpawnDataTable::FieldAttack' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, SpecialProgressEncountType) == 0x000049, "Member 'FSpawnDataTable::SpecialProgressEncountType' has a wrong offset!");
static_assert(offsetof(FSpawnDataTable, SpecialProgressEncount) == 0x00004C, "Member 'FSpawnDataTable::SpecialProgressEncount' has a wrong offset!");

// ScriptStruct AT.ATActCpl034SkillPunishStormData
// 0x0020 (0x0020 - 0x0000)
struct FATActCpl034SkillPunishStormData final
{
public:
	class UAnimMontage*                           Montage;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectile>                ExplosionSpawnClass;                               // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartWaitTime;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndWaitTime;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayExplodeTime;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATActCpl034SkillPunishStormData) == 0x000008, "Wrong alignment on FATActCpl034SkillPunishStormData");
static_assert(sizeof(FATActCpl034SkillPunishStormData) == 0x000020, "Wrong size on FATActCpl034SkillPunishStormData");
static_assert(offsetof(FATActCpl034SkillPunishStormData, Montage) == 0x000000, "Member 'FATActCpl034SkillPunishStormData::Montage' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillPunishStormData, ExplosionSpawnClass) == 0x000008, "Member 'FATActCpl034SkillPunishStormData::ExplosionSpawnClass' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillPunishStormData, StartWaitTime) == 0x000010, "Member 'FATActCpl034SkillPunishStormData::StartWaitTime' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillPunishStormData, EndWaitTime) == 0x000014, "Member 'FATActCpl034SkillPunishStormData::EndWaitTime' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillPunishStormData, DelayExplodeTime) == 0x000018, "Member 'FATActCpl034SkillPunishStormData::DelayExplodeTime' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateFadeOutInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FTerrainDecorateFadeOutInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainDecorateFadeOutInfo) == 0x000004, "Wrong alignment on FTerrainDecorateFadeOutInfo");
static_assert(sizeof(FTerrainDecorateFadeOutInfo) == 0x000008, "Wrong size on FTerrainDecorateFadeOutInfo");

// ScriptStruct AT.ATActCpl034SkillSonicBlowData
// 0x0010 (0x0010 - 0x0000)
struct FATActCpl034SkillSonicBlowData final
{
public:
	TSubclassOf<class UATCharacterTeleport>       SubClassTeleport;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportStartTime;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanAttackState;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CorrectHorizontal;                                 // 0x000D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATActCpl034SkillSonicBlowData) == 0x000008, "Wrong alignment on FATActCpl034SkillSonicBlowData");
static_assert(sizeof(FATActCpl034SkillSonicBlowData) == 0x000010, "Wrong size on FATActCpl034SkillSonicBlowData");
static_assert(offsetof(FATActCpl034SkillSonicBlowData, SubClassTeleport) == 0x000000, "Member 'FATActCpl034SkillSonicBlowData::SubClassTeleport' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillSonicBlowData, TeleportStartTime) == 0x000008, "Member 'FATActCpl034SkillSonicBlowData::TeleportStartTime' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillSonicBlowData, CanAttackState) == 0x00000C, "Member 'FATActCpl034SkillSonicBlowData::CanAttackState' has a wrong offset!");
static_assert(offsetof(FATActCpl034SkillSonicBlowData, CorrectHorizontal) == 0x00000D, "Member 'FATActCpl034SkillSonicBlowData::CorrectHorizontal' has a wrong offset!");

// ScriptStruct AT.FlamethrowerPattern
// 0x0008 (0x0008 - 0x0000)
struct FFlamethrowerPattern final
{
public:
	int32                                         ListId;                                            // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChargeTimes;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFlamethrowerPattern) == 0x000004, "Wrong alignment on FFlamethrowerPattern");
static_assert(sizeof(FFlamethrowerPattern) == 0x000008, "Wrong size on FFlamethrowerPattern");
static_assert(offsetof(FFlamethrowerPattern, ListId) == 0x000000, "Member 'FFlamethrowerPattern::ListId' has a wrong offset!");
static_assert(offsetof(FFlamethrowerPattern, ChargeTimes) == 0x000004, "Member 'FFlamethrowerPattern::ChargeTimes' has a wrong offset!");

// ScriptStruct AT.AT_Timer
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAT_Timer final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAT_Timer) == 0x000008, "Wrong alignment on FAT_Timer");
static_assert(sizeof(FAT_Timer) == 0x000020, "Wrong size on FAT_Timer");

// ScriptStruct AT.SummonCharacterParam
// 0x000C (0x000C - 0x0000)
struct FSummonCharacterParam final
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VariationId;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FormID;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSummonCharacterParam) == 0x000004, "Wrong alignment on FSummonCharacterParam");
static_assert(sizeof(FSummonCharacterParam) == 0x00000C, "Wrong size on FSummonCharacterParam");
static_assert(offsetof(FSummonCharacterParam, CharacterType) == 0x000000, "Member 'FSummonCharacterParam::CharacterType' has a wrong offset!");
static_assert(offsetof(FSummonCharacterParam, VariationId) == 0x000004, "Member 'FSummonCharacterParam::VariationId' has a wrong offset!");
static_assert(offsetof(FSummonCharacterParam, FormID) == 0x000008, "Member 'FSummonCharacterParam::FormID' has a wrong offset!");

// ScriptStruct AT.CarGroupInfo
// 0x0020 (0x0028 - 0x0008)
struct FCarGroupInfo final : public FTableRowBase
{
public:
	TArray<class UStaticMesh*>                    MeshList;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ProbabilityList;                                   // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarGroupInfo) == 0x000008, "Wrong alignment on FCarGroupInfo");
static_assert(sizeof(FCarGroupInfo) == 0x000028, "Wrong size on FCarGroupInfo");
static_assert(offsetof(FCarGroupInfo, MeshList) == 0x000008, "Member 'FCarGroupInfo::MeshList' has a wrong offset!");
static_assert(offsetof(FCarGroupInfo, ProbabilityList) == 0x000018, "Member 'FCarGroupInfo::ProbabilityList' has a wrong offset!");

// ScriptStruct AT.SkillAttackInfo_S007
// 0x0010 (0x0010 - 0x0000)
struct FSkillAttackInfo_S007 final
{
public:
	float                                         WaitWarpChkTime;                                   // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitAttackTime;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackTime;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationRate;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillAttackInfo_S007) == 0x000004, "Wrong alignment on FSkillAttackInfo_S007");
static_assert(sizeof(FSkillAttackInfo_S007) == 0x000010, "Wrong size on FSkillAttackInfo_S007");
static_assert(offsetof(FSkillAttackInfo_S007, WaitWarpChkTime) == 0x000000, "Member 'FSkillAttackInfo_S007::WaitWarpChkTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S007, WaitAttackTime) == 0x000004, "Member 'FSkillAttackInfo_S007::WaitAttackTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S007, AttackTime) == 0x000008, "Member 'FSkillAttackInfo_S007::AttackTime' has a wrong offset!");
static_assert(offsetof(FSkillAttackInfo_S007, RotationRate) == 0x00000C, "Member 'FSkillAttackInfo_S007::RotationRate' has a wrong offset!");

// ScriptStruct AT.ActGroundBattleChargeHeatCutInfo
// 0x0038 (0x0038 - 0x0000)
struct FActGroundBattleChargeHeatCutInfo final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableFade;                                        // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ColorParameter;                                    // 0x0014(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutStartDelayTime;                             // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInStartDelayTime;                              // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActGroundBattleChargeHeatCutInfo) == 0x000008, "Wrong alignment on FActGroundBattleChargeHeatCutInfo");
static_assert(sizeof(FActGroundBattleChargeHeatCutInfo) == 0x000038, "Wrong size on FActGroundBattleChargeHeatCutInfo");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, FormChangeID) == 0x000000, "Member 'FActGroundBattleChargeHeatCutInfo::FormChangeID' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, Montage) == 0x000008, "Member 'FActGroundBattleChargeHeatCutInfo::Montage' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, EnableFade) == 0x000010, "Member 'FActGroundBattleChargeHeatCutInfo::EnableFade' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, ColorParameter) == 0x000014, "Member 'FActGroundBattleChargeHeatCutInfo::ColorParameter' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, FadeOutStartDelayTime) == 0x000024, "Member 'FActGroundBattleChargeHeatCutInfo::FadeOutStartDelayTime' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, FadeOutTime) == 0x000028, "Member 'FActGroundBattleChargeHeatCutInfo::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, FadeInStartDelayTime) == 0x00002C, "Member 'FActGroundBattleChargeHeatCutInfo::FadeInStartDelayTime' has a wrong offset!");
static_assert(offsetof(FActGroundBattleChargeHeatCutInfo, FadeInTime) == 0x000030, "Member 'FActGroundBattleChargeHeatCutInfo::FadeInTime' has a wrong offset!");

// ScriptStruct AT.ReferenceToCrossTalkAssetInstance
// 0x0018 (0x0018 - 0x0000)
struct FReferenceToCrossTalkAssetInstance final
{
public:
	class UDataTable*                             ConditionDataTable;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UDataTable*>                     EventDataTableArray;                               // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToCrossTalkAssetInstance) == 0x000008, "Wrong alignment on FReferenceToCrossTalkAssetInstance");
static_assert(sizeof(FReferenceToCrossTalkAssetInstance) == 0x000018, "Wrong size on FReferenceToCrossTalkAssetInstance");
static_assert(offsetof(FReferenceToCrossTalkAssetInstance, ConditionDataTable) == 0x000000, "Member 'FReferenceToCrossTalkAssetInstance::ConditionDataTable' has a wrong offset!");
static_assert(offsetof(FReferenceToCrossTalkAssetInstance, EventDataTableArray) == 0x000008, "Member 'FReferenceToCrossTalkAssetInstance::EventDataTableArray' has a wrong offset!");

// ScriptStruct AT.RootDebrisRemoveInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FRootDebrisRemoveInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRootDebrisRemoveInfo) == 0x000008, "Wrong alignment on FRootDebrisRemoveInfo");
static_assert(sizeof(FRootDebrisRemoveInfo) == 0x000020, "Wrong size on FRootDebrisRemoveInfo");

// ScriptStruct AT.GroundBattleLongBlowoffChaseMontageInfo
// 0x0018 (0x0018 - 0x0000)
struct FGroundBattleLongBlowoffChaseMontageInfo final
{
public:
	class UAnimMontage*                           MontageMove;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveEndDist;                                       // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageAttack;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundBattleLongBlowoffChaseMontageInfo) == 0x000008, "Wrong alignment on FGroundBattleLongBlowoffChaseMontageInfo");
static_assert(sizeof(FGroundBattleLongBlowoffChaseMontageInfo) == 0x000018, "Wrong size on FGroundBattleLongBlowoffChaseMontageInfo");
static_assert(offsetof(FGroundBattleLongBlowoffChaseMontageInfo, MontageMove) == 0x000000, "Member 'FGroundBattleLongBlowoffChaseMontageInfo::MontageMove' has a wrong offset!");
static_assert(offsetof(FGroundBattleLongBlowoffChaseMontageInfo, MoveTime) == 0x000008, "Member 'FGroundBattleLongBlowoffChaseMontageInfo::MoveTime' has a wrong offset!");
static_assert(offsetof(FGroundBattleLongBlowoffChaseMontageInfo, MoveEndDist) == 0x00000C, "Member 'FGroundBattleLongBlowoffChaseMontageInfo::MoveEndDist' has a wrong offset!");
static_assert(offsetof(FGroundBattleLongBlowoffChaseMontageInfo, MontageAttack) == 0x000010, "Member 'FGroundBattleLongBlowoffChaseMontageInfo::MontageAttack' has a wrong offset!");

// ScriptStruct AT.GroundBattleLongComboInfo
// 0x0018 (0x0018 - 0x0000)
struct FGroundBattleLongComboInfo final
{
public:
	TArray<class UAnimMontage*>                   MontageCombo;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFinish;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundBattleLongComboInfo) == 0x000008, "Wrong alignment on FGroundBattleLongComboInfo");
static_assert(sizeof(FGroundBattleLongComboInfo) == 0x000018, "Wrong size on FGroundBattleLongComboInfo");
static_assert(offsetof(FGroundBattleLongComboInfo, MontageCombo) == 0x000000, "Member 'FGroundBattleLongComboInfo::MontageCombo' has a wrong offset!");
static_assert(offsetof(FGroundBattleLongComboInfo, MontageFinish) == 0x000010, "Member 'FGroundBattleLongComboInfo::MontageFinish' has a wrong offset!");

// ScriptStruct AT.ZOrbSet
// 0x0018 (0x0018 - 0x0000)
struct FZOrbSet final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               OpenPSC;                                           // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZOrbSet) == 0x000008, "Wrong alignment on FZOrbSet");
static_assert(sizeof(FZOrbSet) == 0x000018, "Wrong size on FZOrbSet");
static_assert(offsetof(FZOrbSet, OpenPSC) == 0x000010, "Member 'FZOrbSet::OpenPSC' has a wrong offset!");

// ScriptStruct AT.GroundBattleShortComboInfo
// 0x00E0 (0x00E0 - 0x0000)
struct FGroundBattleShortComboInfo final
{
public:
	TArray<class UAnimMontage*>                   MontageCombo;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv2;                                   // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv3;                                   // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   MontageComboLv4;                                   // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageComboFinishCut;                             // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ComboFinishCutPutCharacter;                        // 0x0048(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 RightComboAdditionalDamage;                        // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageUpComboNormal;                              // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageUpComboSpecial;                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPercentageUpComboAffect;                         // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpComboAffect;                                     // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 UpComboAdditionalAffect;                           // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageDownComboNormal;                            // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageDownComboSpecial;                           // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPercentageDownComboAffect;                       // 0x0098(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DownComboAffect;                                   // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 DownComboAdditionalDamage;                         // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageLeftComboNormal;                            // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageLeftComboSpecial;                           // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPercentageLeftComboAffect;                       // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftComboAffect;                                   // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftComboInputNum;                                 // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftComboInputValuePer;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGroundBattleSparkingComboInfo> MontageComboSp;                                    // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroundBattleShortComboInfo) == 0x000008, "Wrong alignment on FGroundBattleShortComboInfo");
static_assert(sizeof(FGroundBattleShortComboInfo) == 0x0000E0, "Wrong size on FGroundBattleShortComboInfo");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageCombo) == 0x000000, "Member 'FGroundBattleShortComboInfo::MontageCombo' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageComboLv2) == 0x000010, "Member 'FGroundBattleShortComboInfo::MontageComboLv2' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageComboLv3) == 0x000020, "Member 'FGroundBattleShortComboInfo::MontageComboLv3' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageComboLv4) == 0x000030, "Member 'FGroundBattleShortComboInfo::MontageComboLv4' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageComboFinishCut) == 0x000040, "Member 'FGroundBattleShortComboInfo::MontageComboFinishCut' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, ComboFinishCutPutCharacter) == 0x000048, "Member 'FGroundBattleShortComboInfo::ComboFinishCutPutCharacter' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, RightComboAdditionalDamage) == 0x000050, "Member 'FGroundBattleShortComboInfo::RightComboAdditionalDamage' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageUpComboNormal) == 0x000060, "Member 'FGroundBattleShortComboInfo::MontageUpComboNormal' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageUpComboSpecial) == 0x000068, "Member 'FGroundBattleShortComboInfo::MontageUpComboSpecial' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, IsPercentageUpComboAffect) == 0x000070, "Member 'FGroundBattleShortComboInfo::IsPercentageUpComboAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, UpComboAffect) == 0x000074, "Member 'FGroundBattleShortComboInfo::UpComboAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, UpComboAdditionalAffect) == 0x000078, "Member 'FGroundBattleShortComboInfo::UpComboAdditionalAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageDownComboNormal) == 0x000088, "Member 'FGroundBattleShortComboInfo::MontageDownComboNormal' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageDownComboSpecial) == 0x000090, "Member 'FGroundBattleShortComboInfo::MontageDownComboSpecial' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, IsPercentageDownComboAffect) == 0x000098, "Member 'FGroundBattleShortComboInfo::IsPercentageDownComboAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, DownComboAffect) == 0x00009C, "Member 'FGroundBattleShortComboInfo::DownComboAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, DownComboAdditionalDamage) == 0x0000A0, "Member 'FGroundBattleShortComboInfo::DownComboAdditionalDamage' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageLeftComboNormal) == 0x0000B0, "Member 'FGroundBattleShortComboInfo::MontageLeftComboNormal' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageLeftComboSpecial) == 0x0000B8, "Member 'FGroundBattleShortComboInfo::MontageLeftComboSpecial' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, IsPercentageLeftComboAffect) == 0x0000C0, "Member 'FGroundBattleShortComboInfo::IsPercentageLeftComboAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, LeftComboAffect) == 0x0000C4, "Member 'FGroundBattleShortComboInfo::LeftComboAffect' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, LeftComboInputNum) == 0x0000C8, "Member 'FGroundBattleShortComboInfo::LeftComboInputNum' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, LeftComboInputValuePer) == 0x0000CC, "Member 'FGroundBattleShortComboInfo::LeftComboInputValuePer' has a wrong offset!");
static_assert(offsetof(FGroundBattleShortComboInfo, MontageComboSp) == 0x0000D0, "Member 'FGroundBattleShortComboInfo::MontageComboSp' has a wrong offset!");

// ScriptStruct AT.TimeInfo
// 0x0008 (0x0008 - 0x0000)
struct FTimeInfo final
{
public:
	float                                         DownTime;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimeInfo) == 0x000004, "Wrong alignment on FTimeInfo");
static_assert(sizeof(FTimeInfo) == 0x000008, "Wrong size on FTimeInfo");
static_assert(offsetof(FTimeInfo, DownTime) == 0x000000, "Member 'FTimeInfo::DownTime' has a wrong offset!");

// ScriptStruct AT.ATDataAssetSupportCharacterTalkInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetSupportCharacterTalkInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              TalkDataTable;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetSupportCharacterTalkInfo) == 0x000008, "Wrong alignment on FATDataAssetSupportCharacterTalkInfo");
static_assert(sizeof(FATDataAssetSupportCharacterTalkInfo) == 0x000030, "Wrong size on FATDataAssetSupportCharacterTalkInfo");
static_assert(offsetof(FATDataAssetSupportCharacterTalkInfo, MasterId) == 0x000000, "Member 'FATDataAssetSupportCharacterTalkInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetSupportCharacterTalkInfo, TalkDataTable) == 0x000008, "Member 'FATDataAssetSupportCharacterTalkInfo::TalkDataTable' has a wrong offset!");

// ScriptStruct AT.ATLoadingCookingDemoCharacterResourceAsset
// 0x02D8 (0x02D8 - 0x0000)
struct FATLoadingCookingDemoCharacterResourceAsset final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reaction_Grade1_Motion;                            // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reaction_Grade2_Motion;                            // 0x0030(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Reaction_Grade3_Motion;                            // 0x0058(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Seize_Motion;                                 // 0x0080(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick1_Motion;                                // 0x00A8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick2_Motion;                                // 0x00D0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick3_Motion;                                // 0x00F8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Stick4_Motion;                                // 0x0120(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Meal_Grasp_Motion;                                 // 0x0148(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade1_Motion;                               // 0x0170(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade2_Motion;                               // 0x0198(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade3_Motion;                               // 0x01C0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade1_LP_Motion;                            // 0x01E8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade2_LP_Motion;                            // 0x0210(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            After_Grade3_LP_Motion;                            // 0x0238(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Result_St_Motion;                                  // 0x0260(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Result_Lp_Motion;                                  // 0x0288(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           StartAttachmentMesh;                               // 0x02B0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATLoadingCookingDemoCharacterResourceAsset) == 0x000008, "Wrong alignment on FATLoadingCookingDemoCharacterResourceAsset");
static_assert(sizeof(FATLoadingCookingDemoCharacterResourceAsset) == 0x0002D8, "Wrong size on FATLoadingCookingDemoCharacterResourceAsset");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, MasterId) == 0x000000, "Member 'FATLoadingCookingDemoCharacterResourceAsset::MasterId' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Reaction_Grade1_Motion) == 0x000008, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Reaction_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Reaction_Grade2_Motion) == 0x000030, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Reaction_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Reaction_Grade3_Motion) == 0x000058, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Reaction_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Meal_Seize_Motion) == 0x000080, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Meal_Seize_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Meal_Stick1_Motion) == 0x0000A8, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Meal_Stick1_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Meal_Stick2_Motion) == 0x0000D0, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Meal_Stick2_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Meal_Stick3_Motion) == 0x0000F8, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Meal_Stick3_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Meal_Stick4_Motion) == 0x000120, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Meal_Stick4_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Meal_Grasp_Motion) == 0x000148, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Meal_Grasp_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, After_Grade1_Motion) == 0x000170, "Member 'FATLoadingCookingDemoCharacterResourceAsset::After_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, After_Grade2_Motion) == 0x000198, "Member 'FATLoadingCookingDemoCharacterResourceAsset::After_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, After_Grade3_Motion) == 0x0001C0, "Member 'FATLoadingCookingDemoCharacterResourceAsset::After_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, After_Grade1_LP_Motion) == 0x0001E8, "Member 'FATLoadingCookingDemoCharacterResourceAsset::After_Grade1_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, After_Grade2_LP_Motion) == 0x000210, "Member 'FATLoadingCookingDemoCharacterResourceAsset::After_Grade2_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, After_Grade3_LP_Motion) == 0x000238, "Member 'FATLoadingCookingDemoCharacterResourceAsset::After_Grade3_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Result_St_Motion) == 0x000260, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Result_St_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, Result_Lp_Motion) == 0x000288, "Member 'FATLoadingCookingDemoCharacterResourceAsset::Result_Lp_Motion' has a wrong offset!");
static_assert(offsetof(FATLoadingCookingDemoCharacterResourceAsset, StartAttachmentMesh) == 0x0002B0, "Member 'FATLoadingCookingDemoCharacterResourceAsset::StartAttachmentMesh' has a wrong offset!");

// ScriptStruct AT.SubQuestPeriod
// 0x0020 (0x0028 - 0x0008)
struct FSubQuestPeriod final : public FTableRowBase
{
public:
	class FName                                   StartQuestId;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPhaseId;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndQuestId;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndPhaseId;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubQuestPeriod) == 0x000008, "Wrong alignment on FSubQuestPeriod");
static_assert(sizeof(FSubQuestPeriod) == 0x000028, "Wrong size on FSubQuestPeriod");
static_assert(offsetof(FSubQuestPeriod, StartQuestId) == 0x000008, "Member 'FSubQuestPeriod::StartQuestId' has a wrong offset!");
static_assert(offsetof(FSubQuestPeriod, StartPhaseId) == 0x000010, "Member 'FSubQuestPeriod::StartPhaseId' has a wrong offset!");
static_assert(offsetof(FSubQuestPeriod, EndQuestId) == 0x000018, "Member 'FSubQuestPeriod::EndQuestId' has a wrong offset!");
static_assert(offsetof(FSubQuestPeriod, EndPhaseId) == 0x000020, "Member 'FSubQuestPeriod::EndPhaseId' has a wrong offset!");

// ScriptStruct AT.AnimationPathSet
// 0x0040 (0x0040 - 0x0000)
struct FAnimationPathSet final
{
public:
	class FString                                 Paths[0x4];                                        // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimationPathSet) == 0x000008, "Wrong alignment on FAnimationPathSet");
static_assert(sizeof(FAnimationPathSet) == 0x000040, "Wrong size on FAnimationPathSet");
static_assert(offsetof(FAnimationPathSet, Paths) == 0x000000, "Member 'FAnimationPathSet::Paths' has a wrong offset!");

// ScriptStruct AT.ItemTablePresent
// 0x0040 (0x0080 - 0x0040)
struct FItemTablePresent final : public FItemInfoParam
{
public:
	int32                                         Favorability;                                      // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Cooking;                                           // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Training;                                          // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Develop;                                           // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gods;                                              // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adult;                                             // 0x0054(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Adventure;                                         // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Zfighters;                                         // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CookingLb;                                         // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TrainingLb;                                        // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DevelopLb;                                         // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GodsLb;                                            // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdultLb;                                           // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AdventureLb;                                       // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZfightersLb;                                       // 0x0078(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTablePresent) == 0x000008, "Wrong alignment on FItemTablePresent");
static_assert(sizeof(FItemTablePresent) == 0x000080, "Wrong size on FItemTablePresent");
static_assert(offsetof(FItemTablePresent, Favorability) == 0x000040, "Member 'FItemTablePresent::Favorability' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Cooking) == 0x000044, "Member 'FItemTablePresent::Cooking' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Training) == 0x000048, "Member 'FItemTablePresent::Training' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Develop) == 0x00004C, "Member 'FItemTablePresent::Develop' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Gods) == 0x000050, "Member 'FItemTablePresent::Gods' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Adult) == 0x000054, "Member 'FItemTablePresent::Adult' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Adventure) == 0x000058, "Member 'FItemTablePresent::Adventure' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, Zfighters) == 0x00005C, "Member 'FItemTablePresent::Zfighters' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, CookingLb) == 0x000060, "Member 'FItemTablePresent::CookingLb' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, TrainingLb) == 0x000064, "Member 'FItemTablePresent::TrainingLb' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, DevelopLb) == 0x000068, "Member 'FItemTablePresent::DevelopLb' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, GodsLb) == 0x00006C, "Member 'FItemTablePresent::GodsLb' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, AdultLb) == 0x000070, "Member 'FItemTablePresent::AdultLb' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, AdventureLb) == 0x000074, "Member 'FItemTablePresent::AdventureLb' has a wrong offset!");
static_assert(offsetof(FItemTablePresent, ZfightersLb) == 0x000078, "Member 'FItemTablePresent::ZfightersLb' has a wrong offset!");

// ScriptStruct AT.LongComboInfo
// 0x0018 (0x0018 - 0x0000)
struct FLongComboInfo final
{
public:
	TArray<class UAnimMontage*>                   MontageCombo;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageFinish;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLongComboInfo) == 0x000008, "Wrong alignment on FLongComboInfo");
static_assert(sizeof(FLongComboInfo) == 0x000018, "Wrong size on FLongComboInfo");
static_assert(offsetof(FLongComboInfo, MontageCombo) == 0x000000, "Member 'FLongComboInfo::MontageCombo' has a wrong offset!");
static_assert(offsetof(FLongComboInfo, MontageFinish) == 0x000010, "Member 'FLongComboInfo::MontageFinish' has a wrong offset!");

// ScriptStruct AT.ReferenceToEventBattlePostProcessEffectAssetInstance
// 0x0018 (0x0018 - 0x0000)
struct FReferenceToEventBattlePostProcessEffectAssetInstance final
{
public:
	class UParticleSystem*                        ATPostProcessEffectCmnHologram_NoiseEffect;        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ATPostProcessEffectCmnHologram_Material;           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              ATPostEffectCmnSkillAquisition_Material;           // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToEventBattlePostProcessEffectAssetInstance) == 0x000008, "Wrong alignment on FReferenceToEventBattlePostProcessEffectAssetInstance");
static_assert(sizeof(FReferenceToEventBattlePostProcessEffectAssetInstance) == 0x000018, "Wrong size on FReferenceToEventBattlePostProcessEffectAssetInstance");
static_assert(offsetof(FReferenceToEventBattlePostProcessEffectAssetInstance, ATPostProcessEffectCmnHologram_NoiseEffect) == 0x000000, "Member 'FReferenceToEventBattlePostProcessEffectAssetInstance::ATPostProcessEffectCmnHologram_NoiseEffect' has a wrong offset!");
static_assert(offsetof(FReferenceToEventBattlePostProcessEffectAssetInstance, ATPostProcessEffectCmnHologram_Material) == 0x000008, "Member 'FReferenceToEventBattlePostProcessEffectAssetInstance::ATPostProcessEffectCmnHologram_Material' has a wrong offset!");
static_assert(offsetof(FReferenceToEventBattlePostProcessEffectAssetInstance, ATPostEffectCmnSkillAquisition_Material) == 0x000010, "Member 'FReferenceToEventBattlePostProcessEffectAssetInstance::ATPostEffectCmnSkillAquisition_Material' has a wrong offset!");

// ScriptStruct AT.QuestHuntingCondition
// 0x0038 (0x0040 - 0x0008)
struct FQuestHuntingCondition final : public FTableRowBase
{
public:
	class FName                                   ConditionGroupId;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHuntingPhaseConditionType                    ConditionType;                                     // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GroupName;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContainsName;                                      // 0x0020(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageId;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestHuntingCondition) == 0x000008, "Wrong alignment on FQuestHuntingCondition");
static_assert(sizeof(FQuestHuntingCondition) == 0x000040, "Wrong size on FQuestHuntingCondition");
static_assert(offsetof(FQuestHuntingCondition, ConditionGroupId) == 0x000008, "Member 'FQuestHuntingCondition::ConditionGroupId' has a wrong offset!");
static_assert(offsetof(FQuestHuntingCondition, ConditionType) == 0x000010, "Member 'FQuestHuntingCondition::ConditionType' has a wrong offset!");
static_assert(offsetof(FQuestHuntingCondition, GroupName) == 0x000018, "Member 'FQuestHuntingCondition::GroupName' has a wrong offset!");
static_assert(offsetof(FQuestHuntingCondition, ContainsName) == 0x000020, "Member 'FQuestHuntingCondition::ContainsName' has a wrong offset!");
static_assert(offsetof(FQuestHuntingCondition, MessageId) == 0x000030, "Member 'FQuestHuntingCondition::MessageId' has a wrong offset!");
static_assert(offsetof(FQuestHuntingCondition, Count) == 0x000038, "Member 'FQuestHuntingCondition::Count' has a wrong offset!");

// ScriptStruct AT.ReferenceToBattleAIAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FReferenceToBattleAIAssetInstance final
{
public:
	class UDataTable*                             PhaseTable;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BehaviorTable;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToBattleAIAssetInstance) == 0x000008, "Wrong alignment on FReferenceToBattleAIAssetInstance");
static_assert(sizeof(FReferenceToBattleAIAssetInstance) == 0x000010, "Wrong size on FReferenceToBattleAIAssetInstance");
static_assert(offsetof(FReferenceToBattleAIAssetInstance, PhaseTable) == 0x000000, "Member 'FReferenceToBattleAIAssetInstance::PhaseTable' has a wrong offset!");
static_assert(offsetof(FReferenceToBattleAIAssetInstance, BehaviorTable) == 0x000008, "Member 'FReferenceToBattleAIAssetInstance::BehaviorTable' has a wrong offset!");

// ScriptStruct AT.DisableFormChangeVariationParam
// 0x0008 (0x0008 - 0x0000)
struct FDisableFormChangeVariationParam final
{
public:
	int32                                         ProgressVariationID;                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DisableFormChangeVariationID;                      // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDisableFormChangeVariationParam) == 0x000004, "Wrong alignment on FDisableFormChangeVariationParam");
static_assert(sizeof(FDisableFormChangeVariationParam) == 0x000008, "Wrong size on FDisableFormChangeVariationParam");
static_assert(offsetof(FDisableFormChangeVariationParam, ProgressVariationID) == 0x000000, "Member 'FDisableFormChangeVariationParam::ProgressVariationID' has a wrong offset!");
static_assert(offsetof(FDisableFormChangeVariationParam, DisableFormChangeVariationID) == 0x000004, "Member 'FDisableFormChangeVariationParam::DisableFormChangeVariationID' has a wrong offset!");

// ScriptStruct AT.RequestData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FRequestData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRequestData) == 0x000008, "Wrong alignment on FRequestData");
static_assert(sizeof(FRequestData) == 0x000018, "Wrong size on FRequestData");

// ScriptStruct AT.RushShot1RotParam
// 0x001C (0x001C - 0x0000)
struct FRushShot1RotParam final
{
public:
	float                                         RushShot1RotTime;                                  // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSideRot;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandSideRotMax;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandSideRotMin;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseUpRot;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandUpRotMax;                                      // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandUpRotMin;                                      // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRushShot1RotParam) == 0x000004, "Wrong alignment on FRushShot1RotParam");
static_assert(sizeof(FRushShot1RotParam) == 0x00001C, "Wrong size on FRushShot1RotParam");
static_assert(offsetof(FRushShot1RotParam, RushShot1RotTime) == 0x000000, "Member 'FRushShot1RotParam::RushShot1RotTime' has a wrong offset!");
static_assert(offsetof(FRushShot1RotParam, BaseSideRot) == 0x000004, "Member 'FRushShot1RotParam::BaseSideRot' has a wrong offset!");
static_assert(offsetof(FRushShot1RotParam, RandSideRotMax) == 0x000008, "Member 'FRushShot1RotParam::RandSideRotMax' has a wrong offset!");
static_assert(offsetof(FRushShot1RotParam, RandSideRotMin) == 0x00000C, "Member 'FRushShot1RotParam::RandSideRotMin' has a wrong offset!");
static_assert(offsetof(FRushShot1RotParam, BaseUpRot) == 0x000010, "Member 'FRushShot1RotParam::BaseUpRot' has a wrong offset!");
static_assert(offsetof(FRushShot1RotParam, RandUpRotMax) == 0x000014, "Member 'FRushShot1RotParam::RandUpRotMax' has a wrong offset!");
static_assert(offsetof(FRushShot1RotParam, RandUpRotMin) == 0x000018, "Member 'FRushShot1RotParam::RandUpRotMin' has a wrong offset!");

// ScriptStruct AT.CooperationCameraInfo
// 0x0000 (0x002C - 0x002C)
struct FCooperationCameraInfo final : public FSkillCameraInfo
{
};
static_assert(alignof(FCooperationCameraInfo) == 0x000004, "Wrong alignment on FCooperationCameraInfo");
static_assert(sizeof(FCooperationCameraInfo) == 0x00002C, "Wrong size on FCooperationCameraInfo");

// ScriptStruct AT.SkillMoveChaseExtAroundInfo
// 0x0028 (0x0028 - 0x0000)
struct FSkillMoveChaseExtAroundInfo final
{
public:
	float                                         AroundTime;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundPitch;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundYawMin;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundYawMax;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ChaseTargetDist;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundSpeedStart;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundSpeedEnd;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundCameraDistMin;                               // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundCameraDistMax;                               // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AroundCameraSpeed;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillMoveChaseExtAroundInfo) == 0x000004, "Wrong alignment on FSkillMoveChaseExtAroundInfo");
static_assert(sizeof(FSkillMoveChaseExtAroundInfo) == 0x000028, "Wrong size on FSkillMoveChaseExtAroundInfo");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundTime) == 0x000000, "Member 'FSkillMoveChaseExtAroundInfo::AroundTime' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundPitch) == 0x000004, "Member 'FSkillMoveChaseExtAroundInfo::AroundPitch' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundYawMin) == 0x000008, "Member 'FSkillMoveChaseExtAroundInfo::AroundYawMin' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundYawMax) == 0x00000C, "Member 'FSkillMoveChaseExtAroundInfo::AroundYawMax' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, ChaseTargetDist) == 0x000010, "Member 'FSkillMoveChaseExtAroundInfo::ChaseTargetDist' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundSpeedStart) == 0x000014, "Member 'FSkillMoveChaseExtAroundInfo::AroundSpeedStart' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundSpeedEnd) == 0x000018, "Member 'FSkillMoveChaseExtAroundInfo::AroundSpeedEnd' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundCameraDistMin) == 0x00001C, "Member 'FSkillMoveChaseExtAroundInfo::AroundCameraDistMin' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundCameraDistMax) == 0x000020, "Member 'FSkillMoveChaseExtAroundInfo::AroundCameraDistMax' has a wrong offset!");
static_assert(offsetof(FSkillMoveChaseExtAroundInfo, AroundCameraSpeed) == 0x000024, "Member 'FSkillMoveChaseExtAroundInfo::AroundCameraSpeed' has a wrong offset!");

// ScriptStruct AT.RushShotProjectileParam
// 0x0030 (0x0030 - 0x0000)
struct FRushShotProjectileParam final
{
public:
	class UParticleSystem*                        ParticleProjectile;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleFire;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitEffect;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        VanishEffect;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PresageScaleRate;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandWeight;                                        // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRushShotProjectileParam) == 0x000008, "Wrong alignment on FRushShotProjectileParam");
static_assert(sizeof(FRushShotProjectileParam) == 0x000030, "Wrong size on FRushShotProjectileParam");
static_assert(offsetof(FRushShotProjectileParam, ParticleProjectile) == 0x000000, "Member 'FRushShotProjectileParam::ParticleProjectile' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, ParticleFire) == 0x000008, "Member 'FRushShotProjectileParam::ParticleFire' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, HitEffect) == 0x000010, "Member 'FRushShotProjectileParam::HitEffect' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, VanishEffect) == 0x000018, "Member 'FRushShotProjectileParam::VanishEffect' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, SphereRadius) == 0x000020, "Member 'FRushShotProjectileParam::SphereRadius' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, Speed) == 0x000024, "Member 'FRushShotProjectileParam::Speed' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, PresageScaleRate) == 0x000028, "Member 'FRushShotProjectileParam::PresageScaleRate' has a wrong offset!");
static_assert(offsetof(FRushShotProjectileParam, RandWeight) == 0x00002C, "Member 'FRushShotProjectileParam::RandWeight' has a wrong offset!");

// ScriptStruct AT.SkillMoveTeleportParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSkillMoveTeleportParam final
{
public:
	class FName                                   SkillId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDist;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeleportDistCut;                                   // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutsideTeleport;                                   // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillMoveTeleportParam) == 0x000008, "Wrong alignment on FSkillMoveTeleportParam");
static_assert(sizeof(FSkillMoveTeleportParam) == 0x000018, "Wrong size on FSkillMoveTeleportParam");
static_assert(offsetof(FSkillMoveTeleportParam, SkillId) == 0x000000, "Member 'FSkillMoveTeleportParam::SkillId' has a wrong offset!");
static_assert(offsetof(FSkillMoveTeleportParam, TeleportDist) == 0x000008, "Member 'FSkillMoveTeleportParam::TeleportDist' has a wrong offset!");
static_assert(offsetof(FSkillMoveTeleportParam, TeleportDistCut) == 0x00000C, "Member 'FSkillMoveTeleportParam::TeleportDistCut' has a wrong offset!");
static_assert(offsetof(FSkillMoveTeleportParam, OutsideTeleport) == 0x000010, "Member 'FSkillMoveTeleportParam::OutsideTeleport' has a wrong offset!");

// ScriptStruct AT.ATFieldMemoriesParameter
// 0x0040 (0x0048 - 0x0008)
struct FATFieldMemoriesParameter final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaID;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEpisodeId                                    CondEpisode;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CondProgress;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CondPhase;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollectionId;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoriesItemId;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationX;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationY;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationZ;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GeneralQuestTalkId;                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATFieldMemoriesParameter) == 0x000008, "Wrong alignment on FATFieldMemoriesParameter");
static_assert(sizeof(FATFieldMemoriesParameter) == 0x000048, "Wrong size on FATFieldMemoriesParameter");
static_assert(offsetof(FATFieldMemoriesParameter, AreaID) == 0x000008, "Member 'FATFieldMemoriesParameter::AreaID' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, CondEpisode) == 0x000009, "Member 'FATFieldMemoriesParameter::CondEpisode' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, CondProgress) == 0x000010, "Member 'FATFieldMemoriesParameter::CondProgress' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, CondPhase) == 0x000018, "Member 'FATFieldMemoriesParameter::CondPhase' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, CollectionId) == 0x000020, "Member 'FATFieldMemoriesParameter::CollectionId' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, MemoriesItemId) == 0x000028, "Member 'FATFieldMemoriesParameter::MemoriesItemId' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, SpawnLocationX) == 0x000030, "Member 'FATFieldMemoriesParameter::SpawnLocationX' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, SpawnLocationY) == 0x000034, "Member 'FATFieldMemoriesParameter::SpawnLocationY' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, SpawnLocationZ) == 0x000038, "Member 'FATFieldMemoriesParameter::SpawnLocationZ' has a wrong offset!");
static_assert(offsetof(FATFieldMemoriesParameter, GeneralQuestTalkId) == 0x000040, "Member 'FATFieldMemoriesParameter::GeneralQuestTalkId' has a wrong offset!");

// ScriptStruct AT.AnimalActionData
// 0x0010 (0x0018 - 0x0008)
struct FAnimalActionData : public FTableRowBase
{
public:
	E_NPC_ACTIONTYPE_ID                           Action;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ANIMAL_CONDITION_TYPE                       Condition;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_NPC_ACTIONTYPE_ID                           ActionStatus;                                      // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_ANIMAL_ACTION_CATEGORY                      ActionCategory;                                    // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value1;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value2;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimalActionData) == 0x000008, "Wrong alignment on FAnimalActionData");
static_assert(sizeof(FAnimalActionData) == 0x000018, "Wrong size on FAnimalActionData");
static_assert(offsetof(FAnimalActionData, Action) == 0x000008, "Member 'FAnimalActionData::Action' has a wrong offset!");
static_assert(offsetof(FAnimalActionData, Condition) == 0x000009, "Member 'FAnimalActionData::Condition' has a wrong offset!");
static_assert(offsetof(FAnimalActionData, ActionStatus) == 0x00000A, "Member 'FAnimalActionData::ActionStatus' has a wrong offset!");
static_assert(offsetof(FAnimalActionData, ActionCategory) == 0x00000B, "Member 'FAnimalActionData::ActionCategory' has a wrong offset!");
static_assert(offsetof(FAnimalActionData, Value1) == 0x00000C, "Member 'FAnimalActionData::Value1' has a wrong offset!");
static_assert(offsetof(FAnimalActionData, Value2) == 0x000010, "Member 'FAnimalActionData::Value2' has a wrong offset!");

// ScriptStruct AT.AnimalActionTbl
// 0x0008 (0x0020 - 0x0018)
struct FAnimalActionTbl final : public FAnimalActionData
{
public:
	E_ANIMAL_TYPE                                 AnimalType;                                        // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimalActionTbl) == 0x000008, "Wrong alignment on FAnimalActionTbl");
static_assert(sizeof(FAnimalActionTbl) == 0x000020, "Wrong size on FAnimalActionTbl");
static_assert(offsetof(FAnimalActionTbl, AnimalType) == 0x000018, "Member 'FAnimalActionTbl::AnimalType' has a wrong offset!");

// ScriptStruct AT.LoadingFishGameMeshAsset
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLoadingFishGameMeshAsset final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingFishGameMeshAsset) == 0x000008, "Wrong alignment on FLoadingFishGameMeshAsset");
static_assert(sizeof(FLoadingFishGameMeshAsset) == 0x000050, "Wrong size on FLoadingFishGameMeshAsset");

// ScriptStruct AT.ReplicateBodyAttackPattern
// 0x000C (0x000C - 0x0000)
struct FReplicateBodyAttackPattern final
{
public:
	EReplicateBodyAttackTargetType                TargetType;                                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetParameter;                                   // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReplicateBodyAttackPattern) == 0x000004, "Wrong alignment on FReplicateBodyAttackPattern");
static_assert(sizeof(FReplicateBodyAttackPattern) == 0x00000C, "Wrong size on FReplicateBodyAttackPattern");
static_assert(offsetof(FReplicateBodyAttackPattern, TargetType) == 0x000000, "Member 'FReplicateBodyAttackPattern::TargetType' has a wrong offset!");
static_assert(offsetof(FReplicateBodyAttackPattern, TargetParameter) == 0x000004, "Member 'FReplicateBodyAttackPattern::TargetParameter' has a wrong offset!");
static_assert(offsetof(FReplicateBodyAttackPattern, Interval) == 0x000008, "Member 'FReplicateBodyAttackPattern::Interval' has a wrong offset!");

// ScriptStruct AT.ReferenceToEventBattleAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToEventBattleAssetInstance final
{
public:
	TSubclassOf<class AATEventBattleRootManagerBase> EventBattle;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToEventBattleAssetInstance) == 0x000008, "Wrong alignment on FReferenceToEventBattleAssetInstance");
static_assert(sizeof(FReferenceToEventBattleAssetInstance) == 0x000008, "Wrong size on FReferenceToEventBattleAssetInstance");
static_assert(offsetof(FReferenceToEventBattleAssetInstance, EventBattle) == 0x000000, "Member 'FReferenceToEventBattleAssetInstance::EventBattle' has a wrong offset!");

// ScriptStruct AT.TemporaryMeshInfo
// 0x0030 (0x0030 - 0x0000)
struct FTemporaryMeshInfo final
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          Mesh;                                              // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimNut;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        AnimEnd;                                           // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0020(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTemporaryMeshInfo) == 0x000008, "Wrong alignment on FTemporaryMeshInfo");
static_assert(sizeof(FTemporaryMeshInfo) == 0x000030, "Wrong size on FTemporaryMeshInfo");
static_assert(offsetof(FTemporaryMeshInfo, CharacterType) == 0x000000, "Member 'FTemporaryMeshInfo::CharacterType' has a wrong offset!");
static_assert(offsetof(FTemporaryMeshInfo, Mesh) == 0x000008, "Member 'FTemporaryMeshInfo::Mesh' has a wrong offset!");
static_assert(offsetof(FTemporaryMeshInfo, AnimNut) == 0x000010, "Member 'FTemporaryMeshInfo::AnimNut' has a wrong offset!");
static_assert(offsetof(FTemporaryMeshInfo, AnimEnd) == 0x000018, "Member 'FTemporaryMeshInfo::AnimEnd' has a wrong offset!");
static_assert(offsetof(FTemporaryMeshInfo, Scale) == 0x000020, "Member 'FTemporaryMeshInfo::Scale' has a wrong offset!");

// ScriptStruct AT.TeleportAttackData
// 0x0018 (0x0018 - 0x0000)
struct FTeleportAttackData final
{
public:
	float                                         TeleportAngle;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarpDistance;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextSupportAtkTime;                                // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MontageAttack;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeleportAttackData) == 0x000008, "Wrong alignment on FTeleportAttackData");
static_assert(sizeof(FTeleportAttackData) == 0x000018, "Wrong size on FTeleportAttackData");
static_assert(offsetof(FTeleportAttackData, TeleportAngle) == 0x000000, "Member 'FTeleportAttackData::TeleportAngle' has a wrong offset!");
static_assert(offsetof(FTeleportAttackData, WarpDistance) == 0x000004, "Member 'FTeleportAttackData::WarpDistance' has a wrong offset!");
static_assert(offsetof(FTeleportAttackData, WaitTime) == 0x000008, "Member 'FTeleportAttackData::WaitTime' has a wrong offset!");
static_assert(offsetof(FTeleportAttackData, NextSupportAtkTime) == 0x00000C, "Member 'FTeleportAttackData::NextSupportAtkTime' has a wrong offset!");
static_assert(offsetof(FTeleportAttackData, MontageAttack) == 0x000010, "Member 'FTeleportAttackData::MontageAttack' has a wrong offset!");

// ScriptStruct AT.ATAdjustConstParam
// 0x0008 (0x0010 - 0x0008)
struct FATAdjustConstParam final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATAdjustConstParam) == 0x000008, "Wrong alignment on FATAdjustConstParam");
static_assert(sizeof(FATAdjustConstParam) == 0x000010, "Wrong size on FATAdjustConstParam");
static_assert(offsetof(FATAdjustConstParam, Value) == 0x000008, "Member 'FATAdjustConstParam::Value' has a wrong offset!");

// ScriptStruct AT.ATAmbientSplineData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FATAmbientSplineData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATAmbientSplineData) == 0x000008, "Wrong alignment on FATAmbientSplineData");
static_assert(sizeof(FATAmbientSplineData) == 0x000018, "Wrong size on FATAmbientSplineData");

// ScriptStruct AT.ParticleFloatParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FParticleFloatParam final
{
public:
	class FName                                   Name;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartValue;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndValue;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FParticleFloatParam) == 0x000008, "Wrong alignment on FParticleFloatParam");
static_assert(sizeof(FParticleFloatParam) == 0x000018, "Wrong size on FParticleFloatParam");
static_assert(offsetof(FParticleFloatParam, Name) == 0x000000, "Member 'FParticleFloatParam::Name' has a wrong offset!");
static_assert(offsetof(FParticleFloatParam, StartTime) == 0x000008, "Member 'FParticleFloatParam::StartTime' has a wrong offset!");
static_assert(offsetof(FParticleFloatParam, Duration) == 0x00000C, "Member 'FParticleFloatParam::Duration' has a wrong offset!");
static_assert(offsetof(FParticleFloatParam, StartValue) == 0x000010, "Member 'FParticleFloatParam::StartValue' has a wrong offset!");
static_assert(offsetof(FParticleFloatParam, EndValue) == 0x000014, "Member 'FParticleFloatParam::EndValue' has a wrong offset!");

// ScriptStruct AT.ReferenceToQuestAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToQuestAssetInstance final
{
public:
	class UDataTable*                             DataTable;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToQuestAssetInstance) == 0x000008, "Wrong alignment on FReferenceToQuestAssetInstance");
static_assert(sizeof(FReferenceToQuestAssetInstance) == 0x000008, "Wrong size on FReferenceToQuestAssetInstance");
static_assert(offsetof(FReferenceToQuestAssetInstance, DataTable) == 0x000000, "Member 'FReferenceToQuestAssetInstance::DataTable' has a wrong offset!");

// ScriptStruct AT.PlayParticleEffectFcidInfo
// 0x0010 (0x0010 - 0x0000)
struct FPlayParticleEffectFcidInfo final
{
public:
	class FName                                   FormChangeID;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayParticleEffectFcidInfo) == 0x000008, "Wrong alignment on FPlayParticleEffectFcidInfo");
static_assert(sizeof(FPlayParticleEffectFcidInfo) == 0x000010, "Wrong size on FPlayParticleEffectFcidInfo");
static_assert(offsetof(FPlayParticleEffectFcidInfo, FormChangeID) == 0x000000, "Member 'FPlayParticleEffectFcidInfo::FormChangeID' has a wrong offset!");
static_assert(offsetof(FPlayParticleEffectFcidInfo, Particle) == 0x000008, "Member 'FPlayParticleEffectFcidInfo::Particle' has a wrong offset!");

// ScriptStruct AT.LocalRankParam
// 0x0018 (0x0018 - 0x0000)
struct FLocalRankParam final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        Score;                                             // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLocalRankParam) == 0x000008, "Wrong alignment on FLocalRankParam");
static_assert(sizeof(FLocalRankParam) == 0x000018, "Wrong size on FLocalRankParam");
static_assert(offsetof(FLocalRankParam, Name) == 0x000000, "Member 'FLocalRankParam::Name' has a wrong offset!");
static_assert(offsetof(FLocalRankParam, Score) == 0x000010, "Member 'FLocalRankParam::Score' has a wrong offset!");

// ScriptStruct AT.LocalRank
// 0x0010 (0x0010 - 0x0000)
struct FLocalRank final
{
public:
	TArray<struct FLocalRankParam>                LocalRanking;                                      // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalRank) == 0x000008, "Wrong alignment on FLocalRank");
static_assert(sizeof(FLocalRank) == 0x000010, "Wrong size on FLocalRank");
static_assert(offsetof(FLocalRank, LocalRanking) == 0x000000, "Member 'FLocalRank::LocalRanking' has a wrong offset!");

// ScriptStruct AT.MiniGameBaseBallSaveInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FMiniGameBaseBallSaveInfo final
{
public:
	TMap<EBaseballGameDifficulty, struct FMiniGameBaseballSaveDetails> Records;                                           // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EBaseballGameDifficulty, struct FLocalRank> DifficultyRanking;                                 // 0x0050(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMiniGameAcquiredReward>        AcquiredRewardList;                                // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniGameBaseBallSaveInfo) == 0x000008, "Wrong alignment on FMiniGameBaseBallSaveInfo");
static_assert(sizeof(FMiniGameBaseBallSaveInfo) == 0x0000B0, "Wrong size on FMiniGameBaseBallSaveInfo");
static_assert(offsetof(FMiniGameBaseBallSaveInfo, Records) == 0x000000, "Member 'FMiniGameBaseBallSaveInfo::Records' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseBallSaveInfo, DifficultyRanking) == 0x000050, "Member 'FMiniGameBaseBallSaveInfo::DifficultyRanking' has a wrong offset!");
static_assert(offsetof(FMiniGameBaseBallSaveInfo, AcquiredRewardList) == 0x0000A0, "Member 'FMiniGameBaseBallSaveInfo::AcquiredRewardList' has a wrong offset!");

// ScriptStruct AT.FruitRadiusSetting
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FFruitRadiusSetting final
{
public:
	class FName                                   StartID;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndID;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TableRowName;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFruitRadiusSetting) == 0x000008, "Wrong alignment on FFruitRadiusSetting");
static_assert(sizeof(FFruitRadiusSetting) == 0x000018, "Wrong size on FFruitRadiusSetting");
static_assert(offsetof(FFruitRadiusSetting, StartID) == 0x000000, "Member 'FFruitRadiusSetting::StartID' has a wrong offset!");
static_assert(offsetof(FFruitRadiusSetting, EndID) == 0x000008, "Member 'FFruitRadiusSetting::EndID' has a wrong offset!");
static_assert(offsetof(FFruitRadiusSetting, TableRowName) == 0x000010, "Member 'FFruitRadiusSetting::TableRowName' has a wrong offset!");

// ScriptStruct AT.ATAtrociousConditionParam
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FATAtrociousConditionParam final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATAtrociousPhase                             Phase;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATAtrociousConditionParam) == 0x000008, "Wrong alignment on FATAtrociousConditionParam");
static_assert(sizeof(FATAtrociousConditionParam) == 0x000010, "Wrong size on FATAtrociousConditionParam");
static_assert(offsetof(FATAtrociousConditionParam, LevelName) == 0x000000, "Member 'FATAtrociousConditionParam::LevelName' has a wrong offset!");
static_assert(offsetof(FATAtrociousConditionParam, Phase) == 0x000008, "Member 'FATAtrociousConditionParam::Phase' has a wrong offset!");

// ScriptStruct AT.ATAtrociousAdjustParam
// 0x0010 (0x0018 - 0x0008)
struct FATAtrociousAdjustParam final : public FTableRowBase
{
public:
	TArray<class FName>                           Values;                                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATAtrociousAdjustParam) == 0x000008, "Wrong alignment on FATAtrociousAdjustParam");
static_assert(sizeof(FATAtrociousAdjustParam) == 0x000018, "Wrong size on FATAtrociousAdjustParam");
static_assert(offsetof(FATAtrociousAdjustParam, Values) == 0x000008, "Member 'FATAtrociousAdjustParam::Values' has a wrong offset!");

// ScriptStruct AT.QuestCharacterSet
// 0x0048 (0x0050 - 0x0008)
struct FQuestCharacterSet final : public FTableRowBase
{
public:
	class FName                                   QuestId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestCharacterName;                                // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PersistentLevelName;                               // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubLevelName;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MainQuestActor;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   HasSubQuestId;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RequiredQuestId;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestCharacterSet) == 0x000008, "Wrong alignment on FQuestCharacterSet");
static_assert(sizeof(FQuestCharacterSet) == 0x000050, "Wrong size on FQuestCharacterSet");
static_assert(offsetof(FQuestCharacterSet, QuestId) == 0x000008, "Member 'FQuestCharacterSet::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, QuestCharacterName) == 0x000010, "Member 'FQuestCharacterSet::QuestCharacterName' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, PersistentLevelName) == 0x000018, "Member 'FQuestCharacterSet::PersistentLevelName' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, SubLevelName) == 0x000020, "Member 'FQuestCharacterSet::SubLevelName' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, MainQuestActor) == 0x000028, "Member 'FQuestCharacterSet::MainQuestActor' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, HasSubQuestId) == 0x000030, "Member 'FQuestCharacterSet::HasSubQuestId' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, Location) == 0x000038, "Member 'FQuestCharacterSet::Location' has a wrong offset!");
static_assert(offsetof(FQuestCharacterSet, RequiredQuestId) == 0x000048, "Member 'FQuestCharacterSet::RequiredQuestId' has a wrong offset!");

// ScriptStruct AT.LoadingMechaDevAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingMechaDevAsset final
{
public:
	TSoftObjectPtr<class UObject>                 Object;                                            // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingMechaDevAsset) == 0x000008, "Wrong alignment on FLoadingMechaDevAsset");
static_assert(sizeof(FLoadingMechaDevAsset) == 0x000028, "Wrong size on FLoadingMechaDevAsset");
static_assert(offsetof(FLoadingMechaDevAsset, Object) == 0x000000, "Member 'FLoadingMechaDevAsset::Object' has a wrong offset!");

// ScriptStruct AT.ATBattleLookAtParam
// 0x001C (0x001C - 0x0000)
struct FATBattleLookAtParam final
{
public:
	bool                                          bEnableBattleLookAt;                               // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBattleLookAtRotateHead;                     // 0x0001(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBattleLookAtRotateSpine01;                  // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBattleLookAtRotateSpine02;                  // 0x0003(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableBattleLookAtRotateSpine03;                  // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattleLookAtAngleHead;                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleLookAtAngleHeadUpDown;                       // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleLookAtAngleSpine01;                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleLookAtAngleSpine02;                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleLookAtAngleSpine03;                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATBattleLookAtParam) == 0x000004, "Wrong alignment on FATBattleLookAtParam");
static_assert(sizeof(FATBattleLookAtParam) == 0x00001C, "Wrong size on FATBattleLookAtParam");
static_assert(offsetof(FATBattleLookAtParam, bEnableBattleLookAt) == 0x000000, "Member 'FATBattleLookAtParam::bEnableBattleLookAt' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, bEnableBattleLookAtRotateHead) == 0x000001, "Member 'FATBattleLookAtParam::bEnableBattleLookAtRotateHead' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, bEnableBattleLookAtRotateSpine01) == 0x000002, "Member 'FATBattleLookAtParam::bEnableBattleLookAtRotateSpine01' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, bEnableBattleLookAtRotateSpine02) == 0x000003, "Member 'FATBattleLookAtParam::bEnableBattleLookAtRotateSpine02' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, bEnableBattleLookAtRotateSpine03) == 0x000004, "Member 'FATBattleLookAtParam::bEnableBattleLookAtRotateSpine03' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, BattleLookAtAngleHead) == 0x000008, "Member 'FATBattleLookAtParam::BattleLookAtAngleHead' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, BattleLookAtAngleHeadUpDown) == 0x00000C, "Member 'FATBattleLookAtParam::BattleLookAtAngleHeadUpDown' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, BattleLookAtAngleSpine01) == 0x000010, "Member 'FATBattleLookAtParam::BattleLookAtAngleSpine01' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, BattleLookAtAngleSpine02) == 0x000014, "Member 'FATBattleLookAtParam::BattleLookAtAngleSpine02' has a wrong offset!");
static_assert(offsetof(FATBattleLookAtParam, BattleLookAtAngleSpine03) == 0x000018, "Member 'FATBattleLookAtParam::BattleLookAtAngleSpine03' has a wrong offset!");

// ScriptStruct AT.ATDLC6FieldMemoriesParameter
// 0x0058 (0x0060 - 0x0008)
struct FATDLC6FieldMemoriesParameter final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaID;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEpisodeId                                    CondEpisode;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CondProgress;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CondPhase;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsBattlePoint;                                     // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CollectionId;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationX;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationY;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationZ;                                    // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionCommand;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetRangeX;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetRangeY;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetRangeZ;                                      // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeRadius;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Recommendedlevel;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldStageId                                 WorldMapLocation;                                  // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDLC6FieldMemoriesParameter) == 0x000008, "Wrong alignment on FATDLC6FieldMemoriesParameter");
static_assert(sizeof(FATDLC6FieldMemoriesParameter) == 0x000060, "Wrong size on FATDLC6FieldMemoriesParameter");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, AreaID) == 0x000008, "Member 'FATDLC6FieldMemoriesParameter::AreaID' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, CondEpisode) == 0x000009, "Member 'FATDLC6FieldMemoriesParameter::CondEpisode' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, CondProgress) == 0x000010, "Member 'FATDLC6FieldMemoriesParameter::CondProgress' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, CondPhase) == 0x000018, "Member 'FATDLC6FieldMemoriesParameter::CondPhase' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, IsBattlePoint) == 0x000020, "Member 'FATDLC6FieldMemoriesParameter::IsBattlePoint' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, CollectionId) == 0x000028, "Member 'FATDLC6FieldMemoriesParameter::CollectionId' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, SpawnLocationX) == 0x000030, "Member 'FATDLC6FieldMemoriesParameter::SpawnLocationX' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, SpawnLocationY) == 0x000034, "Member 'FATDLC6FieldMemoriesParameter::SpawnLocationY' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, SpawnLocationZ) == 0x000038, "Member 'FATDLC6FieldMemoriesParameter::SpawnLocationZ' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, ActionCommand) == 0x000040, "Member 'FATDLC6FieldMemoriesParameter::ActionCommand' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, OffsetRangeX) == 0x000048, "Member 'FATDLC6FieldMemoriesParameter::OffsetRangeX' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, OffsetRangeY) == 0x00004C, "Member 'FATDLC6FieldMemoriesParameter::OffsetRangeY' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, OffsetRangeZ) == 0x000050, "Member 'FATDLC6FieldMemoriesParameter::OffsetRangeZ' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, RangeRadius) == 0x000054, "Member 'FATDLC6FieldMemoriesParameter::RangeRadius' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, Recommendedlevel) == 0x000058, "Member 'FATDLC6FieldMemoriesParameter::Recommendedlevel' has a wrong offset!");
static_assert(offsetof(FATDLC6FieldMemoriesParameter, WorldMapLocation) == 0x00005C, "Member 'FATDLC6FieldMemoriesParameter::WorldMapLocation' has a wrong offset!");

// ScriptStruct AT.AttachParticleParameter
// 0x0050 (0x0050 - 0x0000)
struct FAttachParticleParameter final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        Particle;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ParameterName;                                     // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttachParticleParameter) == 0x000008, "Wrong alignment on FAttachParticleParameter");
static_assert(sizeof(FAttachParticleParameter) == 0x000050, "Wrong size on FAttachParticleParameter");
static_assert(offsetof(FAttachParticleParameter, ID) == 0x000000, "Member 'FAttachParticleParameter::ID' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, Particle) == 0x000008, "Member 'FAttachParticleParameter::Particle' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, SocketName) == 0x000010, "Member 'FAttachParticleParameter::SocketName' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, Location) == 0x000018, "Member 'FAttachParticleParameter::Location' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, Rotation) == 0x000024, "Member 'FAttachParticleParameter::Rotation' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, Scale) == 0x000030, "Member 'FAttachParticleParameter::Scale' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, ParameterName) == 0x000040, "Member 'FAttachParticleParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(FAttachParticleParameter, ParameterValue) == 0x000048, "Member 'FAttachParticleParameter::ParameterValue' has a wrong offset!");

// ScriptStruct AT.BattleAIPhaseTable
// 0x0020 (0x0028 - 0x0008)
struct FBattleAIPhaseTable final : public FTableRowBase
{
public:
	int32                                         Phase;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            ConditionType1;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue1;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            ConditionType2;                                    // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue2;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleAICondition                            ConditionType3;                                    // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue3;                                   // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleAIPhaseTable) == 0x000008, "Wrong alignment on FBattleAIPhaseTable");
static_assert(sizeof(FBattleAIPhaseTable) == 0x000028, "Wrong size on FBattleAIPhaseTable");
static_assert(offsetof(FBattleAIPhaseTable, Phase) == 0x000008, "Member 'FBattleAIPhaseTable::Phase' has a wrong offset!");
static_assert(offsetof(FBattleAIPhaseTable, ConditionType1) == 0x00000C, "Member 'FBattleAIPhaseTable::ConditionType1' has a wrong offset!");
static_assert(offsetof(FBattleAIPhaseTable, ConditionValue1) == 0x000010, "Member 'FBattleAIPhaseTable::ConditionValue1' has a wrong offset!");
static_assert(offsetof(FBattleAIPhaseTable, ConditionType2) == 0x000014, "Member 'FBattleAIPhaseTable::ConditionType2' has a wrong offset!");
static_assert(offsetof(FBattleAIPhaseTable, ConditionValue2) == 0x000018, "Member 'FBattleAIPhaseTable::ConditionValue2' has a wrong offset!");
static_assert(offsetof(FBattleAIPhaseTable, ConditionType3) == 0x00001C, "Member 'FBattleAIPhaseTable::ConditionType3' has a wrong offset!");
static_assert(offsetof(FBattleAIPhaseTable, ConditionValue3) == 0x000020, "Member 'FBattleAIPhaseTable::ConditionValue3' has a wrong offset!");

// ScriptStruct AT.StartingBoostBlockInfo
// 0x0010 (0x0018 - 0x0008)
struct FStartingBoostBlockInfo final : public FTableRowBase
{
public:
	class FName                                   PhaseID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaID;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartingBoostBlockInfo) == 0x000008, "Wrong alignment on FStartingBoostBlockInfo");
static_assert(sizeof(FStartingBoostBlockInfo) == 0x000018, "Wrong size on FStartingBoostBlockInfo");
static_assert(offsetof(FStartingBoostBlockInfo, PhaseID) == 0x000008, "Member 'FStartingBoostBlockInfo::PhaseID' has a wrong offset!");
static_assert(offsetof(FStartingBoostBlockInfo, AreaID) == 0x000010, "Member 'FStartingBoostBlockInfo::AreaID' has a wrong offset!");

// ScriptStruct AT.BattleCheerData
// 0x0048 (0x0050 - 0x0008)
struct FBattleCheerData final : public FTableRowBase
{
public:
	uint8                                         Pad_8[0x48];                                       // 0x0008(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleCheerData) == 0x000008, "Wrong alignment on FBattleCheerData");
static_assert(sizeof(FBattleCheerData) == 0x000050, "Wrong size on FBattleCheerData");

// ScriptStruct AT.BattleCheerTableRow
// 0x0048 (0x0050 - 0x0008)
struct FBattleCheerTableRow final : public FTableRowBase
{
public:
	EBattleCheerCondition                         Condition;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoundAisac;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               UseCharacterID;                                    // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartQuestId;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntProperty;                                       // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringProperty;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseOnlyOnce;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBattleCheerTableRow) == 0x000008, "Wrong alignment on FBattleCheerTableRow");
static_assert(sizeof(FBattleCheerTableRow) == 0x000050, "Wrong size on FBattleCheerTableRow");
static_assert(offsetof(FBattleCheerTableRow, Condition) == 0x000008, "Member 'FBattleCheerTableRow::Condition' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, SoundAisac) == 0x00000C, "Member 'FBattleCheerTableRow::SoundAisac' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, Priority) == 0x000010, "Member 'FBattleCheerTableRow::Priority' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, UseCharacterID) == 0x000014, "Member 'FBattleCheerTableRow::UseCharacterID' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, EventBattleID) == 0x000018, "Member 'FBattleCheerTableRow::EventBattleID' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, StartQuestId) == 0x000020, "Member 'FBattleCheerTableRow::StartQuestId' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, StartPhaseNo) == 0x000028, "Member 'FBattleCheerTableRow::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, EndQuestId) == 0x000030, "Member 'FBattleCheerTableRow::EndQuestId' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, EndPhaseNo) == 0x000038, "Member 'FBattleCheerTableRow::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, IntProperty) == 0x00003C, "Member 'FBattleCheerTableRow::IntProperty' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, StringProperty) == 0x000040, "Member 'FBattleCheerTableRow::StringProperty' has a wrong offset!");
static_assert(offsetof(FBattleCheerTableRow, UseOnlyOnce) == 0x000048, "Member 'FBattleCheerTableRow::UseOnlyOnce' has a wrong offset!");

// ScriptStruct AT.ItemTradeProbability
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FItemTradeProbability final
{
public:
	class FName                                   TradeId;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTradeProbability) == 0x000008, "Wrong alignment on FItemTradeProbability");
static_assert(sizeof(FItemTradeProbability) == 0x000010, "Wrong size on FItemTradeProbability");
static_assert(offsetof(FItemTradeProbability, TradeId) == 0x000000, "Member 'FItemTradeProbability::TradeId' has a wrong offset!");
static_assert(offsetof(FItemTradeProbability, Rate) == 0x000008, "Member 'FItemTradeProbability::Rate' has a wrong offset!");

// ScriptStruct AT.ATReferenceToVariationMeshAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FATReferenceToVariationMeshAssetInstance final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AATVariationParts>          Mesh;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATReferenceToVariationMeshAssetInstance) == 0x000008, "Wrong alignment on FATReferenceToVariationMeshAssetInstance");
static_assert(sizeof(FATReferenceToVariationMeshAssetInstance) == 0x000010, "Wrong size on FATReferenceToVariationMeshAssetInstance");
static_assert(offsetof(FATReferenceToVariationMeshAssetInstance, MasterId) == 0x000000, "Member 'FATReferenceToVariationMeshAssetInstance::MasterId' has a wrong offset!");
static_assert(offsetof(FATReferenceToVariationMeshAssetInstance, Mesh) == 0x000008, "Member 'FATReferenceToVariationMeshAssetInstance::Mesh' has a wrong offset!");

// ScriptStruct AT.ATBattleDemoBranch
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FATBattleDemoBranch final
{
public:
	EATBattleDemoBranch                           Condition;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue;                                    // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ToSceneIndex;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATBattleDemoBranch) == 0x000008, "Wrong alignment on FATBattleDemoBranch");
static_assert(sizeof(FATBattleDemoBranch) == 0x000010, "Wrong size on FATBattleDemoBranch");
static_assert(offsetof(FATBattleDemoBranch, Condition) == 0x000000, "Member 'FATBattleDemoBranch::Condition' has a wrong offset!");
static_assert(offsetof(FATBattleDemoBranch, ConditionValue) == 0x000004, "Member 'FATBattleDemoBranch::ConditionValue' has a wrong offset!");
static_assert(offsetof(FATBattleDemoBranch, ToSceneIndex) == 0x000008, "Member 'FATBattleDemoBranch::ToSceneIndex' has a wrong offset!");

// ScriptStruct AT.ATBattleDemoSceneParameter
// 0x0020 (0x0020 - 0x0000)
struct FATBattleDemoSceneParameter final
{
public:
	class FName                                   SceneIndex;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DemoId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FATBattleDemoBranch>            BranchTbl;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATBattleDemoSceneParameter) == 0x000008, "Wrong alignment on FATBattleDemoSceneParameter");
static_assert(sizeof(FATBattleDemoSceneParameter) == 0x000020, "Wrong size on FATBattleDemoSceneParameter");
static_assert(offsetof(FATBattleDemoSceneParameter, SceneIndex) == 0x000000, "Member 'FATBattleDemoSceneParameter::SceneIndex' has a wrong offset!");
static_assert(offsetof(FATBattleDemoSceneParameter, DemoId) == 0x000008, "Member 'FATBattleDemoSceneParameter::DemoId' has a wrong offset!");
static_assert(offsetof(FATBattleDemoSceneParameter, BranchTbl) == 0x000010, "Member 'FATBattleDemoSceneParameter::BranchTbl' has a wrong offset!");

// ScriptStruct AT.BattleGroupAIMemberConditionTable
// 0x0008 (0x0010 - 0x0008)
struct FBattleGroupAIMemberConditionTable final : public FTableRowBase
{
public:
	EBattleGroupAIMemberCondition                 ConditionType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleGroupAIMemberConditionTable) == 0x000008, "Wrong alignment on FBattleGroupAIMemberConditionTable");
static_assert(sizeof(FBattleGroupAIMemberConditionTable) == 0x000010, "Wrong size on FBattleGroupAIMemberConditionTable");
static_assert(offsetof(FBattleGroupAIMemberConditionTable, ConditionType) == 0x000008, "Member 'FBattleGroupAIMemberConditionTable::ConditionType' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIMemberConditionTable, ConditionValue) == 0x00000C, "Member 'FBattleGroupAIMemberConditionTable::ConditionValue' has a wrong offset!");

// ScriptStruct AT.LoadingUiCaptureAsset
// 0x0100 (0x0100 - 0x0000)
struct FLoadingUiCaptureAsset final
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkelMesh;                                          // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          AnimBP;                                            // 0x0050(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimationAsset>> Animations;                                        // 0x0078(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         Particle;                                          // 0x0088(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x00B0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Montage;                                           // 0x00D8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingUiCaptureAsset) == 0x000008, "Wrong alignment on FLoadingUiCaptureAsset");
static_assert(sizeof(FLoadingUiCaptureAsset) == 0x000100, "Wrong size on FLoadingUiCaptureAsset");
static_assert(offsetof(FLoadingUiCaptureAsset, StaticMesh) == 0x000000, "Member 'FLoadingUiCaptureAsset::StaticMesh' has a wrong offset!");
static_assert(offsetof(FLoadingUiCaptureAsset, SkelMesh) == 0x000028, "Member 'FLoadingUiCaptureAsset::SkelMesh' has a wrong offset!");
static_assert(offsetof(FLoadingUiCaptureAsset, AnimBP) == 0x000050, "Member 'FLoadingUiCaptureAsset::AnimBP' has a wrong offset!");
static_assert(offsetof(FLoadingUiCaptureAsset, Animations) == 0x000078, "Member 'FLoadingUiCaptureAsset::Animations' has a wrong offset!");
static_assert(offsetof(FLoadingUiCaptureAsset, Particle) == 0x000088, "Member 'FLoadingUiCaptureAsset::Particle' has a wrong offset!");
static_assert(offsetof(FLoadingUiCaptureAsset, ActorClass) == 0x0000B0, "Member 'FLoadingUiCaptureAsset::ActorClass' has a wrong offset!");
static_assert(offsetof(FLoadingUiCaptureAsset, Montage) == 0x0000D8, "Member 'FLoadingUiCaptureAsset::Montage' has a wrong offset!");

// ScriptStruct AT.BattleGroupAIBreakConditionTable
// 0x0020 (0x0028 - 0x0008)
struct FBattleGroupAIBreakConditionTable final : public FTableRowBase
{
public:
	EBattleAIPhaseCondition                       PhaseConditionType;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhaseConditionValue;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType1;                                    // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue1;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType2;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue2;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType3;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue3;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleGroupAIBreakConditionTable) == 0x000008, "Wrong alignment on FBattleGroupAIBreakConditionTable");
static_assert(sizeof(FBattleGroupAIBreakConditionTable) == 0x000028, "Wrong size on FBattleGroupAIBreakConditionTable");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, PhaseConditionType) == 0x000008, "Member 'FBattleGroupAIBreakConditionTable::PhaseConditionType' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, PhaseConditionValue) == 0x00000C, "Member 'FBattleGroupAIBreakConditionTable::PhaseConditionValue' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, ConditionType1) == 0x000010, "Member 'FBattleGroupAIBreakConditionTable::ConditionType1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, ConditionValue1) == 0x000014, "Member 'FBattleGroupAIBreakConditionTable::ConditionValue1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, ConditionType2) == 0x000018, "Member 'FBattleGroupAIBreakConditionTable::ConditionType2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, ConditionValue2) == 0x00001C, "Member 'FBattleGroupAIBreakConditionTable::ConditionValue2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, ConditionType3) == 0x000020, "Member 'FBattleGroupAIBreakConditionTable::ConditionType3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIBreakConditionTable, ConditionValue3) == 0x000024, "Member 'FBattleGroupAIBreakConditionTable::ConditionValue3' has a wrong offset!");

// ScriptStruct AT.SlashWaveLaunchData
// 0x0018 (0x0018 - 0x0000)
struct FSlashWaveLaunchData final
{
public:
	float                                         ShotRot;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileRot;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ProjectileTurnSpeed;                               // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotWaitTime;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseShotSpeed;                                      // 0x0010(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileShotSpeed;                               // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlashWaveLaunchData) == 0x000004, "Wrong alignment on FSlashWaveLaunchData");
static_assert(sizeof(FSlashWaveLaunchData) == 0x000018, "Wrong size on FSlashWaveLaunchData");
static_assert(offsetof(FSlashWaveLaunchData, ShotRot) == 0x000000, "Member 'FSlashWaveLaunchData::ShotRot' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchData, ProjectileRot) == 0x000004, "Member 'FSlashWaveLaunchData::ProjectileRot' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchData, ProjectileTurnSpeed) == 0x000008, "Member 'FSlashWaveLaunchData::ProjectileTurnSpeed' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchData, ShotWaitTime) == 0x00000C, "Member 'FSlashWaveLaunchData::ShotWaitTime' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchData, UseShotSpeed) == 0x000010, "Member 'FSlashWaveLaunchData::UseShotSpeed' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchData, ProjectileShotSpeed) == 0x000014, "Member 'FSlashWaveLaunchData::ProjectileShotSpeed' has a wrong offset!");

// ScriptStruct AT.SlashWaveLaunchPattern
// 0x0030 (0x0030 - 0x0000)
struct FSlashWaveLaunchPattern final
{
public:
	int32                                         RandWeight;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           MontageShot;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MontageShotLoopTime;                               // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AProjectile>                ProjectileClassOverride;                           // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSlashWaveLaunchData>           LaunchData;                                        // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSlashWaveLaunchPattern) == 0x000008, "Wrong alignment on FSlashWaveLaunchPattern");
static_assert(sizeof(FSlashWaveLaunchPattern) == 0x000030, "Wrong size on FSlashWaveLaunchPattern");
static_assert(offsetof(FSlashWaveLaunchPattern, RandWeight) == 0x000000, "Member 'FSlashWaveLaunchPattern::RandWeight' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchPattern, MontageShot) == 0x000008, "Member 'FSlashWaveLaunchPattern::MontageShot' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchPattern, MontageShotLoopTime) == 0x000010, "Member 'FSlashWaveLaunchPattern::MontageShotLoopTime' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchPattern, ProjectileClassOverride) == 0x000018, "Member 'FSlashWaveLaunchPattern::ProjectileClassOverride' has a wrong offset!");
static_assert(offsetof(FSlashWaveLaunchPattern, LaunchData) == 0x000020, "Member 'FSlashWaveLaunchPattern::LaunchData' has a wrong offset!");

// ScriptStruct AT.BattleGroupAIEntryConditionTable
// 0x0038 (0x0040 - 0x0008)
struct FBattleGroupAIEntryConditionTable final : public FTableRowBase
{
public:
	EBattleAIPhaseCondition                       PhaseConditionType;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhaseConditionValue;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemberMin;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemberMax;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType1;                                    // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue1;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType2;                                    // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue2;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType3;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue3;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType4;                                    // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue4;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBattleGroupAICondition                       ConditionType5;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue5;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleGroupAIEntryConditionTable) == 0x000008, "Wrong alignment on FBattleGroupAIEntryConditionTable");
static_assert(sizeof(FBattleGroupAIEntryConditionTable) == 0x000040, "Wrong size on FBattleGroupAIEntryConditionTable");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, PhaseConditionType) == 0x000008, "Member 'FBattleGroupAIEntryConditionTable::PhaseConditionType' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, PhaseConditionValue) == 0x00000C, "Member 'FBattleGroupAIEntryConditionTable::PhaseConditionValue' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, MemberMin) == 0x000010, "Member 'FBattleGroupAIEntryConditionTable::MemberMin' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, MemberMax) == 0x000014, "Member 'FBattleGroupAIEntryConditionTable::MemberMax' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionType1) == 0x000018, "Member 'FBattleGroupAIEntryConditionTable::ConditionType1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionValue1) == 0x00001C, "Member 'FBattleGroupAIEntryConditionTable::ConditionValue1' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionType2) == 0x000020, "Member 'FBattleGroupAIEntryConditionTable::ConditionType2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionValue2) == 0x000024, "Member 'FBattleGroupAIEntryConditionTable::ConditionValue2' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionType3) == 0x000028, "Member 'FBattleGroupAIEntryConditionTable::ConditionType3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionValue3) == 0x00002C, "Member 'FBattleGroupAIEntryConditionTable::ConditionValue3' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionType4) == 0x000030, "Member 'FBattleGroupAIEntryConditionTable::ConditionType4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionValue4) == 0x000034, "Member 'FBattleGroupAIEntryConditionTable::ConditionValue4' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionType5) == 0x000038, "Member 'FBattleGroupAIEntryConditionTable::ConditionType5' has a wrong offset!");
static_assert(offsetof(FBattleGroupAIEntryConditionTable, ConditionValue5) == 0x00003C, "Member 'FBattleGroupAIEntryConditionTable::ConditionValue5' has a wrong offset!");

// ScriptStruct AT.MobCategoryStateTbl
// 0x0010 (0x0018 - 0x0008)
struct FMobCategoryStateTbl final : public FTableRowBase
{
public:
	float                                         SetBottomRange;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetBottomRange_ScreenIn;                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSpawnNum;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMobCategoryStateTbl) == 0x000008, "Wrong alignment on FMobCategoryStateTbl");
static_assert(sizeof(FMobCategoryStateTbl) == 0x000018, "Wrong size on FMobCategoryStateTbl");
static_assert(offsetof(FMobCategoryStateTbl, SetBottomRange) == 0x000008, "Member 'FMobCategoryStateTbl::SetBottomRange' has a wrong offset!");
static_assert(offsetof(FMobCategoryStateTbl, SetBottomRange_ScreenIn) == 0x00000C, "Member 'FMobCategoryStateTbl::SetBottomRange_ScreenIn' has a wrong offset!");
static_assert(offsetof(FMobCategoryStateTbl, MaxSpawnNum) == 0x000010, "Member 'FMobCategoryStateTbl::MaxSpawnNum' has a wrong offset!");

// ScriptStruct AT.BgmSelect
// 0x0028 (0x0030 - 0x0008)
struct FBgmSelect final : public FTableRowBase
{
public:
	int32                                         SaveNo;                                            // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReleaseDlcId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BgmTitleMsgId;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      bgmID;                                             // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCategory;                                         // 0x0021(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFieldBgm;                                         // 0x0022(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleBgm;                                        // 0x0023(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVocal;                                            // 0x0024(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayTimeSec;                                       // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBgmSelect) == 0x000008, "Wrong alignment on FBgmSelect");
static_assert(sizeof(FBgmSelect) == 0x000030, "Wrong size on FBgmSelect");
static_assert(offsetof(FBgmSelect, SaveNo) == 0x000008, "Member 'FBgmSelect::SaveNo' has a wrong offset!");
static_assert(offsetof(FBgmSelect, ReleaseDlcId) == 0x000010, "Member 'FBgmSelect::ReleaseDlcId' has a wrong offset!");
static_assert(offsetof(FBgmSelect, BgmTitleMsgId) == 0x000018, "Member 'FBgmSelect::BgmTitleMsgId' has a wrong offset!");
static_assert(offsetof(FBgmSelect, bgmID) == 0x000020, "Member 'FBgmSelect::bgmID' has a wrong offset!");
static_assert(offsetof(FBgmSelect, bCategory) == 0x000021, "Member 'FBgmSelect::bCategory' has a wrong offset!");
static_assert(offsetof(FBgmSelect, bFieldBgm) == 0x000022, "Member 'FBgmSelect::bFieldBgm' has a wrong offset!");
static_assert(offsetof(FBgmSelect, bBattleBgm) == 0x000023, "Member 'FBgmSelect::bBattleBgm' has a wrong offset!");
static_assert(offsetof(FBgmSelect, bVocal) == 0x000024, "Member 'FBgmSelect::bVocal' has a wrong offset!");
static_assert(offsetof(FBgmSelect, PlayTimeSec) == 0x000028, "Member 'FBgmSelect::PlayTimeSec' has a wrong offset!");

// ScriptStruct AT.WorldMapLandMarkParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FWorldMapLandMarkParam final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWorldMapLandMarkParam) == 0x000008, "Wrong alignment on FWorldMapLandMarkParam");
static_assert(sizeof(FWorldMapLandMarkParam) == 0x000018, "Wrong size on FWorldMapLandMarkParam");

// ScriptStruct AT.QuestRewardExpCondition
// 0x0018 (0x0020 - 0x0008)
struct FQuestRewardExpCondition final : public FTableRowBase
{
public:
	bool                                          EnableCharaName;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CharacterAll;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Goku;                                              // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gohan;                                             // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gohan_C;                                           // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gohan_D;                                           // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gohan_E;                                           // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gohan_F;                                           // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Vegeta;                                            // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Trunks;                                            // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Piccolo;                                           // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Vegito;                                            // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Gotenks;                                           // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Kuririn;                                           // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Tien;                                              // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Chiaotzu;                                          // 0x0017(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Yamcha;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Goten;                                             // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Trunks_B;                                          // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Trunks_C;                                          // 0x001B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Trunks_D;                                          // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Android18;                                         // 0x001D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cpl001D;                                           // 0x001E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Cpl008B;                                           // 0x001F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestRewardExpCondition) == 0x000008, "Wrong alignment on FQuestRewardExpCondition");
static_assert(sizeof(FQuestRewardExpCondition) == 0x000020, "Wrong size on FQuestRewardExpCondition");
static_assert(offsetof(FQuestRewardExpCondition, EnableCharaName) == 0x000008, "Member 'FQuestRewardExpCondition::EnableCharaName' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, CharacterAll) == 0x000009, "Member 'FQuestRewardExpCondition::CharacterAll' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Goku) == 0x00000A, "Member 'FQuestRewardExpCondition::Goku' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Gohan) == 0x00000B, "Member 'FQuestRewardExpCondition::Gohan' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Gohan_C) == 0x00000C, "Member 'FQuestRewardExpCondition::Gohan_C' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Gohan_D) == 0x00000D, "Member 'FQuestRewardExpCondition::Gohan_D' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Gohan_E) == 0x00000E, "Member 'FQuestRewardExpCondition::Gohan_E' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Gohan_F) == 0x00000F, "Member 'FQuestRewardExpCondition::Gohan_F' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Vegeta) == 0x000010, "Member 'FQuestRewardExpCondition::Vegeta' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Trunks) == 0x000011, "Member 'FQuestRewardExpCondition::Trunks' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Piccolo) == 0x000012, "Member 'FQuestRewardExpCondition::Piccolo' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Vegito) == 0x000013, "Member 'FQuestRewardExpCondition::Vegito' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Gotenks) == 0x000014, "Member 'FQuestRewardExpCondition::Gotenks' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Kuririn) == 0x000015, "Member 'FQuestRewardExpCondition::Kuririn' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Tien) == 0x000016, "Member 'FQuestRewardExpCondition::Tien' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Chiaotzu) == 0x000017, "Member 'FQuestRewardExpCondition::Chiaotzu' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Yamcha) == 0x000018, "Member 'FQuestRewardExpCondition::Yamcha' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Goten) == 0x000019, "Member 'FQuestRewardExpCondition::Goten' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Trunks_B) == 0x00001A, "Member 'FQuestRewardExpCondition::Trunks_B' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Trunks_C) == 0x00001B, "Member 'FQuestRewardExpCondition::Trunks_C' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Trunks_D) == 0x00001C, "Member 'FQuestRewardExpCondition::Trunks_D' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Android18) == 0x00001D, "Member 'FQuestRewardExpCondition::Android18' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Cpl001D) == 0x00001E, "Member 'FQuestRewardExpCondition::Cpl001D' has a wrong offset!");
static_assert(offsetof(FQuestRewardExpCondition, Cpl008B) == 0x00001F, "Member 'FQuestRewardExpCondition::Cpl008B' has a wrong offset!");

// ScriptStruct AT.BonfireActivateCondition
// 0x0050 (0x0058 - 0x0008)
struct FBonfireActivateCondition final : public FTableRowBase
{
public:
	class FName                                   QuestIdST;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestPhaseIdST;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestIdED;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestPhaseIdED;                                    // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtendQuestIdST;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtendQuestPhaseIdST;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtendQuestIdED;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtendQuestPhaseIdED;                              // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestActorId;                                      // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              BonfireEnable;                                     // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              RestEnable;                                        // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              BonfireCollision;                                  // 0x0052(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              SmokeParticle;                                     // 0x0053(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              FireParticle;                                      // 0x0054(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              FireWoodObjects;                                   // 0x0055(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBonfireActivate                              WoodObjects;                                       // 0x0056(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBonfireActivateCondition) == 0x000008, "Wrong alignment on FBonfireActivateCondition");
static_assert(sizeof(FBonfireActivateCondition) == 0x000058, "Wrong size on FBonfireActivateCondition");
static_assert(offsetof(FBonfireActivateCondition, QuestIdST) == 0x000008, "Member 'FBonfireActivateCondition::QuestIdST' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, QuestPhaseIdST) == 0x000010, "Member 'FBonfireActivateCondition::QuestPhaseIdST' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, QuestIdED) == 0x000018, "Member 'FBonfireActivateCondition::QuestIdED' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, QuestPhaseIdED) == 0x000020, "Member 'FBonfireActivateCondition::QuestPhaseIdED' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, ExtendQuestIdST) == 0x000028, "Member 'FBonfireActivateCondition::ExtendQuestIdST' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, ExtendQuestPhaseIdST) == 0x000030, "Member 'FBonfireActivateCondition::ExtendQuestPhaseIdST' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, ExtendQuestIdED) == 0x000038, "Member 'FBonfireActivateCondition::ExtendQuestIdED' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, ExtendQuestPhaseIdED) == 0x000040, "Member 'FBonfireActivateCondition::ExtendQuestPhaseIdED' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, QuestActorId) == 0x000048, "Member 'FBonfireActivateCondition::QuestActorId' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, BonfireEnable) == 0x000050, "Member 'FBonfireActivateCondition::BonfireEnable' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, RestEnable) == 0x000051, "Member 'FBonfireActivateCondition::RestEnable' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, BonfireCollision) == 0x000052, "Member 'FBonfireActivateCondition::BonfireCollision' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, SmokeParticle) == 0x000053, "Member 'FBonfireActivateCondition::SmokeParticle' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, FireParticle) == 0x000054, "Member 'FBonfireActivateCondition::FireParticle' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, FireWoodObjects) == 0x000055, "Member 'FBonfireActivateCondition::FireWoodObjects' has a wrong offset!");
static_assert(offsetof(FBonfireActivateCondition, WoodObjects) == 0x000056, "Member 'FBonfireActivateCondition::WoodObjects' has a wrong offset!");

// ScriptStruct AT.ReferenceToItemAssetInstance
// 0x0001 (0x0001 - 0x0000)
struct FReferenceToItemAssetInstance final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReferenceToItemAssetInstance) == 0x000001, "Wrong alignment on FReferenceToItemAssetInstance");
static_assert(sizeof(FReferenceToItemAssetInstance) == 0x000001, "Wrong size on FReferenceToItemAssetInstance");

// ScriptStruct AT.ATCharacterStandWaitVariationLoopParam
// 0x000C (0x000C - 0x0000)
struct FATCharacterStandWaitVariationLoopParam final
{
public:
	EATCharacterStandWaitVariationState           Type;                                              // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              RandomLoopCount;                                   // 0x0004(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterStandWaitVariationLoopParam) == 0x000004, "Wrong alignment on FATCharacterStandWaitVariationLoopParam");
static_assert(sizeof(FATCharacterStandWaitVariationLoopParam) == 0x00000C, "Wrong size on FATCharacterStandWaitVariationLoopParam");
static_assert(offsetof(FATCharacterStandWaitVariationLoopParam, Type) == 0x000000, "Member 'FATCharacterStandWaitVariationLoopParam::Type' has a wrong offset!");
static_assert(offsetof(FATCharacterStandWaitVariationLoopParam, RandomLoopCount) == 0x000004, "Member 'FATCharacterStandWaitVariationLoopParam::RandomLoopCount' has a wrong offset!");

// ScriptStruct AT.CharacterBuffTable
// 0x00E8 (0x00F0 - 0x0008)
struct FCharacterBuffTable final : public FTableRowBase
{
public:
	struct FATCharacterBuff                       Buff;                                              // 0x0008(0x00E8)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterBuffTable) == 0x000008, "Wrong alignment on FCharacterBuffTable");
static_assert(sizeof(FCharacterBuffTable) == 0x0000F0, "Wrong size on FCharacterBuffTable");
static_assert(offsetof(FCharacterBuffTable, Buff) == 0x000008, "Member 'FCharacterBuffTable::Buff' has a wrong offset!");

// ScriptStruct AT.ATUniqueCharacterTableRow
// 0x0008 (0x0010 - 0x0008)
struct FATUniqueCharacterTableRow final : public FTableRowBase
{
public:
	TSubclassOf<class UATUniqueCharacterTable>    Row;                                               // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATUniqueCharacterTableRow) == 0x000008, "Wrong alignment on FATUniqueCharacterTableRow");
static_assert(sizeof(FATUniqueCharacterTableRow) == 0x000010, "Wrong size on FATUniqueCharacterTableRow");
static_assert(offsetof(FATUniqueCharacterTableRow, Row) == 0x000008, "Member 'FATUniqueCharacterTableRow::Row' has a wrong offset!");

// ScriptStruct AT.ATFightingPowerPhaseParam
// 0x0018 (0x0020 - 0x0008)
struct FATFightingPowerPhaseParam final : public FTableRowBase
{
public:
	class FName                                   CharacterID;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseID;                                           // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightingPowerRate;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FightingPowerAdd;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATFightingPowerPhaseParam) == 0x000008, "Wrong alignment on FATFightingPowerPhaseParam");
static_assert(sizeof(FATFightingPowerPhaseParam) == 0x000020, "Wrong size on FATFightingPowerPhaseParam");
static_assert(offsetof(FATFightingPowerPhaseParam, CharacterID) == 0x000008, "Member 'FATFightingPowerPhaseParam::CharacterID' has a wrong offset!");
static_assert(offsetof(FATFightingPowerPhaseParam, PhaseID) == 0x000010, "Member 'FATFightingPowerPhaseParam::PhaseID' has a wrong offset!");
static_assert(offsetof(FATFightingPowerPhaseParam, FightingPowerRate) == 0x000018, "Member 'FATFightingPowerPhaseParam::FightingPowerRate' has a wrong offset!");
static_assert(offsetof(FATFightingPowerPhaseParam, FightingPowerAdd) == 0x00001C, "Member 'FATFightingPowerPhaseParam::FightingPowerAdd' has a wrong offset!");

// ScriptStruct AT.FeverAreaTableRow
// 0x0010 (0x0018 - 0x0008)
struct FFeverAreaTableRow final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaIndex;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bFishing;                                          // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bDinosaur;                                         // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bAnimal;                                           // 0x000B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bMineral;                                          // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bFruit;                                            // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bDrop;                                             // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bSmallFish;                                        // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bShop;                                             // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     bPeopleSaving;                                     // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFeverAreaTableRow) == 0x000008, "Wrong alignment on FFeverAreaTableRow");
static_assert(sizeof(FFeverAreaTableRow) == 0x000018, "Wrong size on FFeverAreaTableRow");
static_assert(offsetof(FFeverAreaTableRow, AreaIndex) == 0x000008, "Member 'FFeverAreaTableRow::AreaIndex' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bFishing) == 0x000009, "Member 'FFeverAreaTableRow::bFishing' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bDinosaur) == 0x00000A, "Member 'FFeverAreaTableRow::bDinosaur' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bAnimal) == 0x00000B, "Member 'FFeverAreaTableRow::bAnimal' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bMineral) == 0x00000C, "Member 'FFeverAreaTableRow::bMineral' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bFruit) == 0x00000D, "Member 'FFeverAreaTableRow::bFruit' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bDrop) == 0x00000E, "Member 'FFeverAreaTableRow::bDrop' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bSmallFish) == 0x00000F, "Member 'FFeverAreaTableRow::bSmallFish' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bShop) == 0x000010, "Member 'FFeverAreaTableRow::bShop' has a wrong offset!");
static_assert(offsetof(FFeverAreaTableRow, bPeopleSaving) == 0x000011, "Member 'FFeverAreaTableRow::bPeopleSaving' has a wrong offset!");

// ScriptStruct AT.ConsecutiveQuestSet
// 0x0008 (0x0010 - 0x0008)
struct FConsecutiveQuestSet final : public FTableRowBase
{
public:
	class FName                                   ReceiveQuestId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FConsecutiveQuestSet) == 0x000008, "Wrong alignment on FConsecutiveQuestSet");
static_assert(sizeof(FConsecutiveQuestSet) == 0x000010, "Wrong size on FConsecutiveQuestSet");
static_assert(offsetof(FConsecutiveQuestSet, ReceiveQuestId) == 0x000008, "Member 'FConsecutiveQuestSet::ReceiveQuestId' has a wrong offset!");

// ScriptStruct AT.DamageCollisionElem
// 0x0170 (0x0170 - 0x0000)
struct alignas(0x08) FDamageCollisionElem final
{
public:
	uint8                                         Pad_0[0x170];                                      // 0x0000(0x0170)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageCollisionElem) == 0x000008, "Wrong alignment on FDamageCollisionElem");
static_assert(sizeof(FDamageCollisionElem) == 0x000170, "Wrong size on FDamageCollisionElem");

// ScriptStruct AT.DestructibleDelayRemoveData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDestructibleDelayRemoveData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDestructibleDelayRemoveData) == 0x000008, "Wrong alignment on FDestructibleDelayRemoveData");
static_assert(sizeof(FDestructibleDelayRemoveData) == 0x000018, "Wrong size on FDestructibleDelayRemoveData");

// ScriptStruct AT.AnimalStatusData
// 0x0020 (0x0028 - 0x0008)
struct FAnimalStatusData final : public FTableRowBase
{
public:
	float                                         RandReactionStartTime;                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningRange;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySpeedHigh;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySpeedLow;                                       // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAngleYawHigh;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAngleYawLow;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAnglePitchHigh;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAnglePitchLow;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimalStatusData) == 0x000008, "Wrong alignment on FAnimalStatusData");
static_assert(sizeof(FAnimalStatusData) == 0x000028, "Wrong size on FAnimalStatusData");
static_assert(offsetof(FAnimalStatusData, RandReactionStartTime) == 0x000008, "Member 'FAnimalStatusData::RandReactionStartTime' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, WarningRange) == 0x00000C, "Member 'FAnimalStatusData::WarningRange' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, FlySpeedHigh) == 0x000010, "Member 'FAnimalStatusData::FlySpeedHigh' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, FlySpeedLow) == 0x000014, "Member 'FAnimalStatusData::FlySpeedLow' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, FlyAngleYawHigh) == 0x000018, "Member 'FAnimalStatusData::FlyAngleYawHigh' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, FlyAngleYawLow) == 0x00001C, "Member 'FAnimalStatusData::FlyAngleYawLow' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, FlyAnglePitchHigh) == 0x000020, "Member 'FAnimalStatusData::FlyAnglePitchHigh' has a wrong offset!");
static_assert(offsetof(FAnimalStatusData, FlyAnglePitchLow) == 0x000024, "Member 'FAnimalStatusData::FlyAnglePitchLow' has a wrong offset!");

// ScriptStruct AT.DamageRequestData
// 0x0178 (0x0178 - 0x0000)
struct alignas(0x08) FDamageRequestData final
{
public:
	uint8                                         Pad_0[0x178];                                      // 0x0000(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageRequestData) == 0x000008, "Wrong alignment on FDamageRequestData");
static_assert(sizeof(FDamageRequestData) == 0x000178, "Wrong size on FDamageRequestData");

// ScriptStruct AT.ReferenceToAIMoveAssetInstance
// 0x0018 (0x0018 - 0x0000)
struct FReferenceToAIMoveAssetInstance final
{
public:
	class UDataTable*                             MoveForwardData;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MoveDistanceData;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MoveAroundData;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToAIMoveAssetInstance) == 0x000008, "Wrong alignment on FReferenceToAIMoveAssetInstance");
static_assert(sizeof(FReferenceToAIMoveAssetInstance) == 0x000018, "Wrong size on FReferenceToAIMoveAssetInstance");
static_assert(offsetof(FReferenceToAIMoveAssetInstance, MoveForwardData) == 0x000000, "Member 'FReferenceToAIMoveAssetInstance::MoveForwardData' has a wrong offset!");
static_assert(offsetof(FReferenceToAIMoveAssetInstance, MoveDistanceData) == 0x000008, "Member 'FReferenceToAIMoveAssetInstance::MoveDistanceData' has a wrong offset!");
static_assert(offsetof(FReferenceToAIMoveAssetInstance, MoveAroundData) == 0x000010, "Member 'FReferenceToAIMoveAssetInstance::MoveAroundData' has a wrong offset!");

// ScriptStruct AT.QuestUseAssetMap
// 0x0030 (0x0038 - 0x0008)
struct FQuestUseAssetMap final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   QuestUseAsset;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MasterId;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestUseAssetMap) == 0x000008, "Wrong alignment on FQuestUseAssetMap");
static_assert(sizeof(FQuestUseAssetMap) == 0x000038, "Wrong size on FQuestUseAssetMap");
static_assert(offsetof(FQuestUseAssetMap, QuestUseAsset) == 0x000008, "Member 'FQuestUseAssetMap::QuestUseAsset' has a wrong offset!");
static_assert(offsetof(FQuestUseAssetMap, MasterId) == 0x000030, "Member 'FQuestUseAssetMap::MasterId' has a wrong offset!");

// ScriptStruct AT.ReferenceToEncountAssetInstance
// 0x0018 (0x0018 - 0x0000)
struct FReferenceToEncountAssetInstance final
{
public:
	class UDataTable*                             EnemyParameterList;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             EnemyAppearTable;                                  // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             EnemyParamDistRelation;                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToEncountAssetInstance) == 0x000008, "Wrong alignment on FReferenceToEncountAssetInstance");
static_assert(sizeof(FReferenceToEncountAssetInstance) == 0x000018, "Wrong size on FReferenceToEncountAssetInstance");
static_assert(offsetof(FReferenceToEncountAssetInstance, EnemyParameterList) == 0x000000, "Member 'FReferenceToEncountAssetInstance::EnemyParameterList' has a wrong offset!");
static_assert(offsetof(FReferenceToEncountAssetInstance, EnemyAppearTable) == 0x000008, "Member 'FReferenceToEncountAssetInstance::EnemyAppearTable' has a wrong offset!");
static_assert(offsetof(FReferenceToEncountAssetInstance, EnemyParamDistRelation) == 0x000010, "Member 'FReferenceToEncountAssetInstance::EnemyParamDistRelation' has a wrong offset!");

// ScriptStruct AT.ReferenceToFishGameAnimationAssetInstance
// 0x0030 (0x0030 - 0x0000)
struct FReferenceToFishGameAnimationAssetInstance final
{
public:
	class UAnimMontage*                           MissMontage;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           PullMontage;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           SuccessMontage;                                    // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ResultStartMontage;                                // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ResultLoopMontage;                                 // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           RarePullMontage;                                   // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToFishGameAnimationAssetInstance) == 0x000008, "Wrong alignment on FReferenceToFishGameAnimationAssetInstance");
static_assert(sizeof(FReferenceToFishGameAnimationAssetInstance) == 0x000030, "Wrong size on FReferenceToFishGameAnimationAssetInstance");
static_assert(offsetof(FReferenceToFishGameAnimationAssetInstance, MissMontage) == 0x000000, "Member 'FReferenceToFishGameAnimationAssetInstance::MissMontage' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameAnimationAssetInstance, PullMontage) == 0x000008, "Member 'FReferenceToFishGameAnimationAssetInstance::PullMontage' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameAnimationAssetInstance, SuccessMontage) == 0x000010, "Member 'FReferenceToFishGameAnimationAssetInstance::SuccessMontage' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameAnimationAssetInstance, ResultStartMontage) == 0x000018, "Member 'FReferenceToFishGameAnimationAssetInstance::ResultStartMontage' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameAnimationAssetInstance, ResultLoopMontage) == 0x000020, "Member 'FReferenceToFishGameAnimationAssetInstance::ResultLoopMontage' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameAnimationAssetInstance, RarePullMontage) == 0x000028, "Member 'FReferenceToFishGameAnimationAssetInstance::RarePullMontage' has a wrong offset!");

// ScriptStruct AT.LoadingAIBehaviorAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FLoadingAIBehaviorAssetInstance final
{
public:
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlackboardData*                        BlackboardData;                                    // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingAIBehaviorAssetInstance) == 0x000008, "Wrong alignment on FLoadingAIBehaviorAssetInstance");
static_assert(sizeof(FLoadingAIBehaviorAssetInstance) == 0x000010, "Wrong size on FLoadingAIBehaviorAssetInstance");
static_assert(offsetof(FLoadingAIBehaviorAssetInstance, BehaviorTree) == 0x000000, "Member 'FLoadingAIBehaviorAssetInstance::BehaviorTree' has a wrong offset!");
static_assert(offsetof(FLoadingAIBehaviorAssetInstance, BlackboardData) == 0x000008, "Member 'FLoadingAIBehaviorAssetInstance::BlackboardData' has a wrong offset!");

// ScriptStruct AT.ATEventBattleVisionParam
// 0x0018 (0x0020 - 0x0008)
struct FATEventBattleVisionParam final : public FTableRowBase
{
public:
	class FName                                   VisionId;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATEventBattleVisionCondition                 ConditionType;                                     // 0x0014(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue;                                    // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATEventBattleVisionParam) == 0x000008, "Wrong alignment on FATEventBattleVisionParam");
static_assert(sizeof(FATEventBattleVisionParam) == 0x000020, "Wrong size on FATEventBattleVisionParam");
static_assert(offsetof(FATEventBattleVisionParam, VisionId) == 0x000008, "Member 'FATEventBattleVisionParam::VisionId' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionParam, Priority) == 0x000010, "Member 'FATEventBattleVisionParam::Priority' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionParam, ConditionType) == 0x000014, "Member 'FATEventBattleVisionParam::ConditionType' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionParam, ConditionValue) == 0x000018, "Member 'FATEventBattleVisionParam::ConditionValue' has a wrong offset!");

// ScriptStruct AT.LoadingAIMoveAsset
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FLoadingAIMoveAsset final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingAIMoveAsset) == 0x000008, "Wrong alignment on FLoadingAIMoveAsset");
static_assert(sizeof(FLoadingAIMoveAsset) == 0x000078, "Wrong size on FLoadingAIMoveAsset");

// ScriptStruct AT.LoadingEncountAsset
// 0x0078 (0x0078 - 0x0000)
struct alignas(0x08) FLoadingEncountAsset final
{
public:
	uint8                                         Pad_0[0x78];                                       // 0x0000(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingEncountAsset) == 0x000008, "Wrong alignment on FLoadingEncountAsset");
static_assert(sizeof(FLoadingEncountAsset) == 0x000078, "Wrong size on FLoadingEncountAsset");

// ScriptStruct AT.ATParticleDataBase
// 0x0018 (0x0018 - 0x0000)
struct FATParticleDataBase
{
public:
	class UParticleSystem*                        Particle;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATParticleDataBase) == 0x000008, "Wrong alignment on FATParticleDataBase");
static_assert(sizeof(FATParticleDataBase) == 0x000018, "Wrong size on FATParticleDataBase");
static_assert(offsetof(FATParticleDataBase, Particle) == 0x000000, "Member 'FATParticleDataBase::Particle' has a wrong offset!");
static_assert(offsetof(FATParticleDataBase, LifeSpan) == 0x000008, "Member 'FATParticleDataBase::LifeSpan' has a wrong offset!");
static_assert(offsetof(FATParticleDataBase, Sound) == 0x000010, "Member 'FATParticleDataBase::Sound' has a wrong offset!");

// ScriptStruct AT.ATParticleData
// 0x0028 (0x0040 - 0x0018)
struct FATParticleData final : public FATParticleDataBase
{
public:
	class FName                                   SocketName;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLocationRoot;                                // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EParticleSpawnLocation                        SpawnLocationType;                                 // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x0024(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0030(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         RandomAngle;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATParticleData) == 0x000008, "Wrong alignment on FATParticleData");
static_assert(sizeof(FATParticleData) == 0x000040, "Wrong size on FATParticleData");
static_assert(offsetof(FATParticleData, SocketName) == 0x000018, "Member 'FATParticleData::SocketName' has a wrong offset!");
static_assert(offsetof(FATParticleData, bSpawnLocationRoot) == 0x000020, "Member 'FATParticleData::bSpawnLocationRoot' has a wrong offset!");
static_assert(offsetof(FATParticleData, SpawnLocationType) == 0x000021, "Member 'FATParticleData::SpawnLocationType' has a wrong offset!");
static_assert(offsetof(FATParticleData, LocationOffset) == 0x000024, "Member 'FATParticleData::LocationOffset' has a wrong offset!");
static_assert(offsetof(FATParticleData, RotationOffset) == 0x000030, "Member 'FATParticleData::RotationOffset' has a wrong offset!");
static_assert(offsetof(FATParticleData, RandomAngle) == 0x00003C, "Member 'FATParticleData::RandomAngle' has a wrong offset!");

// ScriptStruct AT.LoadingAIBehaviorAsset
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLoadingAIBehaviorAsset final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingAIBehaviorAsset) == 0x000008, "Wrong alignment on FLoadingAIBehaviorAsset");
static_assert(sizeof(FLoadingAIBehaviorAsset) == 0x000050, "Wrong size on FLoadingAIBehaviorAsset");

// ScriptStruct AT.ATDataAssetBaseballGameCommonInfo
// 0x0938 (0x0938 - 0x0000)
struct FATDataAssetBaseballGameCommonInfo final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           BallMesh;                                          // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           BatMesh;                                           // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           GroveMesh;                                         // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           StraightBallAnimSequence;                          // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           CurveBallAnimSequence;                             // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           ForkBallAnimSequence;                              // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           KnuckleBallAnimSequence;                           // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           SpiralBallAnimSequence;                            // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimSequence>           WaveBallAnimSequence;                              // 0x0140(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            WaitR01_01ST_Montage;                              // 0x0168(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            WaitR01_02LP_Montage;                              // 0x0190(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ThrowR01_01ST_Montage;                             // 0x01B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ThrowR01_02LP_Montage;                             // 0x01E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ThrowR01_03ED_Montage;                             // 0x0208(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            HitR01_L_01ST_Montage;                             // 0x0230(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            HitR01_L_02LP_Montage;                             // 0x0258(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            HitR01_R_01ST_Montage;                             // 0x0280(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            HitR01_R_02LP_Montage;                             // 0x02A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            WaitR01_01ST_Aura_Montage;                         // 0x02D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            WaitR01_02LP_Aura_Montage;                         // 0x02F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            WaitR01_02LP_NoLoop_Aura_Montage;                  // 0x0320(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ThrowR01_01ST_Aura_Montage;                        // 0x0348(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ThrowR01_02LP_Aura_Montage;                        // 0x0370(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ThrowR01_03ED_Aura_Montage;                        // 0x0398(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Wait01_Montage;                                    // 0x03C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SwingWait_Montage;                                 // 0x03E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SwingMiss_Montage;                                 // 0x0410(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Swing01_01ST_Montage;                              // 0x0438(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Swing01_02LP_Montage;                              // 0x0460(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Swing01_03ED_Montage;                              // 0x0488(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Wait01_Aura_Montage;                               // 0x04B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SwingWait_Aura_Montage;                            // 0x04D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SwingMiss_Aura_Montage;                            // 0x0500(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Swing01_01ST_Aura_Montage;                         // 0x0528(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Swing01_02LP_Aura_Montage;                         // 0x0550(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Swing01_03ED_Aura_Montage;                         // 0x0578(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Result_Montage;                                    // 0x05A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         BallAuraBlueS_Particle;                            // 0x05C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         BallAuraBlueL_Particle;                            // 0x05F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         BallAuraRedS_Particle;                             // 0x0618(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         BallAuraRedL_Particle;                             // 0x0640(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         Hit_Particle;                                      // 0x0668(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         HitDist_Particle;                                  // 0x0690(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         Radiation_Particle;                                // 0x06B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ConstantDataTable;                                 // 0x06E0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              PitcherDataTable;                                  // 0x0708(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              BallDataTable;                                     // 0x0730(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              BallTypeDataTable;                                 // 0x0758(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              HitTimingDataTable;                                // 0x0780(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CameraDataTable;                                   // 0x07A8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              BattlePowerDataTable;                              // 0x07D0(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CutinDataTable;                                    // 0x07F8(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              MobPresetDataTable;                                // 0x0820(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Mob_Man_Reaction01;                                // 0x0848(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Mob_Man_Reaction02;                                // 0x0870(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Mob_Man_Reaction03;                                // 0x0898(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Mob_Woman_Reaction01;                              // 0x08C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Mob_Woman_Reaction02;                              // 0x08E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Mob_Kid_Reaction01;                                // 0x0910(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetBaseballGameCommonInfo) == 0x000008, "Wrong alignment on FATDataAssetBaseballGameCommonInfo");
static_assert(sizeof(FATDataAssetBaseballGameCommonInfo) == 0x000938, "Wrong size on FATDataAssetBaseballGameCommonInfo");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallMesh) == 0x000000, "Member 'FATDataAssetBaseballGameCommonInfo::BallMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BatMesh) == 0x000028, "Member 'FATDataAssetBaseballGameCommonInfo::BatMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, GroveMesh) == 0x000050, "Member 'FATDataAssetBaseballGameCommonInfo::GroveMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, StraightBallAnimSequence) == 0x000078, "Member 'FATDataAssetBaseballGameCommonInfo::StraightBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, CurveBallAnimSequence) == 0x0000A0, "Member 'FATDataAssetBaseballGameCommonInfo::CurveBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ForkBallAnimSequence) == 0x0000C8, "Member 'FATDataAssetBaseballGameCommonInfo::ForkBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, KnuckleBallAnimSequence) == 0x0000F0, "Member 'FATDataAssetBaseballGameCommonInfo::KnuckleBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, SpiralBallAnimSequence) == 0x000118, "Member 'FATDataAssetBaseballGameCommonInfo::SpiralBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, WaveBallAnimSequence) == 0x000140, "Member 'FATDataAssetBaseballGameCommonInfo::WaveBallAnimSequence' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, WaitR01_01ST_Montage) == 0x000168, "Member 'FATDataAssetBaseballGameCommonInfo::WaitR01_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, WaitR01_02LP_Montage) == 0x000190, "Member 'FATDataAssetBaseballGameCommonInfo::WaitR01_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ThrowR01_01ST_Montage) == 0x0001B8, "Member 'FATDataAssetBaseballGameCommonInfo::ThrowR01_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ThrowR01_02LP_Montage) == 0x0001E0, "Member 'FATDataAssetBaseballGameCommonInfo::ThrowR01_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ThrowR01_03ED_Montage) == 0x000208, "Member 'FATDataAssetBaseballGameCommonInfo::ThrowR01_03ED_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, HitR01_L_01ST_Montage) == 0x000230, "Member 'FATDataAssetBaseballGameCommonInfo::HitR01_L_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, HitR01_L_02LP_Montage) == 0x000258, "Member 'FATDataAssetBaseballGameCommonInfo::HitR01_L_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, HitR01_R_01ST_Montage) == 0x000280, "Member 'FATDataAssetBaseballGameCommonInfo::HitR01_R_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, HitR01_R_02LP_Montage) == 0x0002A8, "Member 'FATDataAssetBaseballGameCommonInfo::HitR01_R_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, WaitR01_01ST_Aura_Montage) == 0x0002D0, "Member 'FATDataAssetBaseballGameCommonInfo::WaitR01_01ST_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, WaitR01_02LP_Aura_Montage) == 0x0002F8, "Member 'FATDataAssetBaseballGameCommonInfo::WaitR01_02LP_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, WaitR01_02LP_NoLoop_Aura_Montage) == 0x000320, "Member 'FATDataAssetBaseballGameCommonInfo::WaitR01_02LP_NoLoop_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ThrowR01_01ST_Aura_Montage) == 0x000348, "Member 'FATDataAssetBaseballGameCommonInfo::ThrowR01_01ST_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ThrowR01_02LP_Aura_Montage) == 0x000370, "Member 'FATDataAssetBaseballGameCommonInfo::ThrowR01_02LP_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ThrowR01_03ED_Aura_Montage) == 0x000398, "Member 'FATDataAssetBaseballGameCommonInfo::ThrowR01_03ED_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Wait01_Montage) == 0x0003C0, "Member 'FATDataAssetBaseballGameCommonInfo::Wait01_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, SwingWait_Montage) == 0x0003E8, "Member 'FATDataAssetBaseballGameCommonInfo::SwingWait_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, SwingMiss_Montage) == 0x000410, "Member 'FATDataAssetBaseballGameCommonInfo::SwingMiss_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Swing01_01ST_Montage) == 0x000438, "Member 'FATDataAssetBaseballGameCommonInfo::Swing01_01ST_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Swing01_02LP_Montage) == 0x000460, "Member 'FATDataAssetBaseballGameCommonInfo::Swing01_02LP_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Swing01_03ED_Montage) == 0x000488, "Member 'FATDataAssetBaseballGameCommonInfo::Swing01_03ED_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Wait01_Aura_Montage) == 0x0004B0, "Member 'FATDataAssetBaseballGameCommonInfo::Wait01_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, SwingWait_Aura_Montage) == 0x0004D8, "Member 'FATDataAssetBaseballGameCommonInfo::SwingWait_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, SwingMiss_Aura_Montage) == 0x000500, "Member 'FATDataAssetBaseballGameCommonInfo::SwingMiss_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Swing01_01ST_Aura_Montage) == 0x000528, "Member 'FATDataAssetBaseballGameCommonInfo::Swing01_01ST_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Swing01_02LP_Aura_Montage) == 0x000550, "Member 'FATDataAssetBaseballGameCommonInfo::Swing01_02LP_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Swing01_03ED_Aura_Montage) == 0x000578, "Member 'FATDataAssetBaseballGameCommonInfo::Swing01_03ED_Aura_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Result_Montage) == 0x0005A0, "Member 'FATDataAssetBaseballGameCommonInfo::Result_Montage' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallAuraBlueS_Particle) == 0x0005C8, "Member 'FATDataAssetBaseballGameCommonInfo::BallAuraBlueS_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallAuraBlueL_Particle) == 0x0005F0, "Member 'FATDataAssetBaseballGameCommonInfo::BallAuraBlueL_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallAuraRedS_Particle) == 0x000618, "Member 'FATDataAssetBaseballGameCommonInfo::BallAuraRedS_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallAuraRedL_Particle) == 0x000640, "Member 'FATDataAssetBaseballGameCommonInfo::BallAuraRedL_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Hit_Particle) == 0x000668, "Member 'FATDataAssetBaseballGameCommonInfo::Hit_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, HitDist_Particle) == 0x000690, "Member 'FATDataAssetBaseballGameCommonInfo::HitDist_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Radiation_Particle) == 0x0006B8, "Member 'FATDataAssetBaseballGameCommonInfo::Radiation_Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, ConstantDataTable) == 0x0006E0, "Member 'FATDataAssetBaseballGameCommonInfo::ConstantDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, PitcherDataTable) == 0x000708, "Member 'FATDataAssetBaseballGameCommonInfo::PitcherDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallDataTable) == 0x000730, "Member 'FATDataAssetBaseballGameCommonInfo::BallDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BallTypeDataTable) == 0x000758, "Member 'FATDataAssetBaseballGameCommonInfo::BallTypeDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, HitTimingDataTable) == 0x000780, "Member 'FATDataAssetBaseballGameCommonInfo::HitTimingDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, CameraDataTable) == 0x0007A8, "Member 'FATDataAssetBaseballGameCommonInfo::CameraDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, BattlePowerDataTable) == 0x0007D0, "Member 'FATDataAssetBaseballGameCommonInfo::BattlePowerDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, CutinDataTable) == 0x0007F8, "Member 'FATDataAssetBaseballGameCommonInfo::CutinDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, MobPresetDataTable) == 0x000820, "Member 'FATDataAssetBaseballGameCommonInfo::MobPresetDataTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Mob_Man_Reaction01) == 0x000848, "Member 'FATDataAssetBaseballGameCommonInfo::Mob_Man_Reaction01' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Mob_Man_Reaction02) == 0x000870, "Member 'FATDataAssetBaseballGameCommonInfo::Mob_Man_Reaction02' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Mob_Man_Reaction03) == 0x000898, "Member 'FATDataAssetBaseballGameCommonInfo::Mob_Man_Reaction03' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Mob_Woman_Reaction01) == 0x0008C0, "Member 'FATDataAssetBaseballGameCommonInfo::Mob_Woman_Reaction01' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Mob_Woman_Reaction02) == 0x0008E8, "Member 'FATDataAssetBaseballGameCommonInfo::Mob_Woman_Reaction02' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameCommonInfo, Mob_Kid_Reaction01) == 0x000910, "Member 'FATDataAssetBaseballGameCommonInfo::Mob_Kid_Reaction01' has a wrong offset!");

// ScriptStruct AT.ItemGetParticleManageComponentParam
// 0x0008 (0x0010 - 0x0008)
struct FItemGetParticleManageComponentParam final : public FTableRowBase
{
public:
	float                                         EffectInterval;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemGetParticleManageComponentParam) == 0x000008, "Wrong alignment on FItemGetParticleManageComponentParam");
static_assert(sizeof(FItemGetParticleManageComponentParam) == 0x000010, "Wrong size on FItemGetParticleManageComponentParam");
static_assert(offsetof(FItemGetParticleManageComponentParam, EffectInterval) == 0x000008, "Member 'FItemGetParticleManageComponentParam::EffectInterval' has a wrong offset!");

// ScriptStruct AT.ATDataAssetBaseballGameInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetBaseballGameInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           CharacterMesh;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetBaseballGameInfo) == 0x000008, "Wrong alignment on FATDataAssetBaseballGameInfo");
static_assert(sizeof(FATDataAssetBaseballGameInfo) == 0x000030, "Wrong size on FATDataAssetBaseballGameInfo");
static_assert(offsetof(FATDataAssetBaseballGameInfo, MasterId) == 0x000000, "Member 'FATDataAssetBaseballGameInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetBaseballGameInfo, CharacterMesh) == 0x000008, "Member 'FATDataAssetBaseballGameInfo::CharacterMesh' has a wrong offset!");

// ScriptStruct AT.LoadingBaseballGameCommonAsset
// 0x0938 (0x0938 - 0x0000)
struct alignas(0x08) FLoadingBaseballGameCommonAsset final
{
public:
	uint8                                         Pad_0[0x938];                                      // 0x0000(0x0938)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingBaseballGameCommonAsset) == 0x000008, "Wrong alignment on FLoadingBaseballGameCommonAsset");
static_assert(sizeof(FLoadingBaseballGameCommonAsset) == 0x000938, "Wrong size on FLoadingBaseballGameCommonAsset");

// ScriptStruct AT.ReferenceToBaseballGameAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToBaseballGameAssetInstance final
{
public:
	class USkeletalMesh*                          CharacterMesh;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToBaseballGameAssetInstance) == 0x000008, "Wrong alignment on FReferenceToBaseballGameAssetInstance");
static_assert(sizeof(FReferenceToBaseballGameAssetInstance) == 0x000008, "Wrong size on FReferenceToBaseballGameAssetInstance");
static_assert(offsetof(FReferenceToBaseballGameAssetInstance, CharacterMesh) == 0x000000, "Member 'FReferenceToBaseballGameAssetInstance::CharacterMesh' has a wrong offset!");

// ScriptStruct AT.LoadingBaseballGameAsset
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLoadingBaseballGameAsset final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingBaseballGameAsset) == 0x000008, "Wrong alignment on FLoadingBaseballGameAsset");
static_assert(sizeof(FLoadingBaseballGameAsset) == 0x000028, "Wrong size on FLoadingBaseballGameAsset");

// ScriptStruct AT.ATDataAssetBattleGroupAIInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetBattleGroupAIInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GroupInfo;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetBattleGroupAIInfo) == 0x000008, "Wrong alignment on FATDataAssetBattleGroupAIInfo");
static_assert(sizeof(FATDataAssetBattleGroupAIInfo) == 0x000030, "Wrong size on FATDataAssetBattleGroupAIInfo");
static_assert(offsetof(FATDataAssetBattleGroupAIInfo, MasterId) == 0x000000, "Member 'FATDataAssetBattleGroupAIInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleGroupAIInfo, GroupInfo) == 0x000008, "Member 'FATDataAssetBattleGroupAIInfo::GroupInfo' has a wrong offset!");

// ScriptStruct AT.DevelopLevelTable
// 0x0028 (0x0030 - 0x0008)
struct FDevelopLevelTable final : public FTableRowBase
{
public:
	int32                                         TotalExp;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NextExp;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MemorySlot;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Jump;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Battery;                                           // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rader;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Efficiency;                                        // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Discoverability;                                   // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDevelopLevelTable) == 0x000008, "Wrong alignment on FDevelopLevelTable");
static_assert(sizeof(FDevelopLevelTable) == 0x000030, "Wrong size on FDevelopLevelTable");
static_assert(offsetof(FDevelopLevelTable, TotalExp) == 0x000008, "Member 'FDevelopLevelTable::TotalExp' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, NextExp) == 0x00000C, "Member 'FDevelopLevelTable::NextExp' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, MemorySlot) == 0x000010, "Member 'FDevelopLevelTable::MemorySlot' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, Speed) == 0x000014, "Member 'FDevelopLevelTable::Speed' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, Jump) == 0x000018, "Member 'FDevelopLevelTable::Jump' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, Battery) == 0x00001C, "Member 'FDevelopLevelTable::Battery' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, Rader) == 0x000020, "Member 'FDevelopLevelTable::Rader' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, Efficiency) == 0x000024, "Member 'FDevelopLevelTable::Efficiency' has a wrong offset!");
static_assert(offsetof(FDevelopLevelTable, Discoverability) == 0x000028, "Member 'FDevelopLevelTable::Discoverability' has a wrong offset!");

// ScriptStruct AT.ATDataAssetBattleAIInfo
// 0x0058 (0x0058 - 0x0000)
struct FATDataAssetBattleAIInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              PhaseTable;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              BehaviorTable;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetBattleAIInfo) == 0x000008, "Wrong alignment on FATDataAssetBattleAIInfo");
static_assert(sizeof(FATDataAssetBattleAIInfo) == 0x000058, "Wrong size on FATDataAssetBattleAIInfo");
static_assert(offsetof(FATDataAssetBattleAIInfo, MasterId) == 0x000000, "Member 'FATDataAssetBattleAIInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleAIInfo, PhaseTable) == 0x000008, "Member 'FATDataAssetBattleAIInfo::PhaseTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleAIInfo, BehaviorTable) == 0x000030, "Member 'FATDataAssetBattleAIInfo::BehaviorTable' has a wrong offset!");

// ScriptStruct AT.LoadingBattleAIAsset
// 0x0050 (0x0050 - 0x0000)
struct alignas(0x08) FLoadingBattleAIAsset final
{
public:
	uint8                                         Pad_0[0x50];                                       // 0x0000(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingBattleAIAsset) == 0x000008, "Wrong alignment on FLoadingBattleAIAsset");
static_assert(sizeof(FLoadingBattleAIAsset) == 0x000050, "Wrong size on FLoadingBattleAIAsset");

// ScriptStruct AT.ATCharacterList
// 0x0010 (0x0010 - 0x0000)
struct FATCharacterList final
{
public:
	TArray<class AAT_Character*>                  Entries;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATCharacterList) == 0x000008, "Wrong alignment on FATCharacterList");
static_assert(sizeof(FATCharacterList) == 0x000010, "Wrong size on FATCharacterList");
static_assert(offsetof(FATCharacterList, Entries) == 0x000000, "Member 'FATCharacterList::Entries' has a wrong offset!");

// ScriptStruct AT.NpcTalkEventParameter
// 0x0008 (0x0010 - 0x0008)
struct FNpcTalkEventParameter final : public FTableRowBase
{
public:
	class FName                                   QuestItemId;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcTalkEventParameter) == 0x000008, "Wrong alignment on FNpcTalkEventParameter");
static_assert(sizeof(FNpcTalkEventParameter) == 0x000010, "Wrong size on FNpcTalkEventParameter");
static_assert(offsetof(FNpcTalkEventParameter, QuestItemId) == 0x000008, "Member 'FNpcTalkEventParameter::QuestItemId' has a wrong offset!");

// ScriptStruct AT.ATDataAssetBattleDemoSceneInfo
// 0x0058 (0x0058 - 0x0000)
struct FATDataAssetBattleDemoSceneInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelPath;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelSequencerName;                                // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class ULevelSequence>          Sequencer;                                         // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetBattleDemoSceneInfo) == 0x000008, "Wrong alignment on FATDataAssetBattleDemoSceneInfo");
static_assert(sizeof(FATDataAssetBattleDemoSceneInfo) == 0x000058, "Wrong size on FATDataAssetBattleDemoSceneInfo");
static_assert(offsetof(FATDataAssetBattleDemoSceneInfo, MasterId) == 0x000000, "Member 'FATDataAssetBattleDemoSceneInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleDemoSceneInfo, LevelPath) == 0x000008, "Member 'FATDataAssetBattleDemoSceneInfo::LevelPath' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleDemoSceneInfo, LevelSequencerName) == 0x000020, "Member 'FATDataAssetBattleDemoSceneInfo::LevelSequencerName' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleDemoSceneInfo, Sequencer) == 0x000028, "Member 'FATDataAssetBattleDemoSceneInfo::Sequencer' has a wrong offset!");
static_assert(offsetof(FATDataAssetBattleDemoSceneInfo, TagName) == 0x000050, "Member 'FATDataAssetBattleDemoSceneInfo::TagName' has a wrong offset!");

// ScriptStruct AT.ReferenceToMiniGameMobAnimBPInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToMiniGameMobAnimBPInstance final
{
public:
	TSubclassOf<class UAnimInstance>              AnimBP;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToMiniGameMobAnimBPInstance) == 0x000008, "Wrong alignment on FReferenceToMiniGameMobAnimBPInstance");
static_assert(sizeof(FReferenceToMiniGameMobAnimBPInstance) == 0x000008, "Wrong size on FReferenceToMiniGameMobAnimBPInstance");
static_assert(offsetof(FReferenceToMiniGameMobAnimBPInstance, AnimBP) == 0x000000, "Member 'FReferenceToMiniGameMobAnimBPInstance::AnimBP' has a wrong offset!");

// ScriptStruct AT.ProgressMap
// 0x0018 (0x0020 - 0x0008)
struct FProgressMap final : public FTableRowBase
{
public:
	int32                                         OrderNo;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Episode;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Part;                                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Character;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter1;                                 // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter2;                                 // 0x001A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x5];                                       // 0x001B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProgressMap) == 0x000008, "Wrong alignment on FProgressMap");
static_assert(sizeof(FProgressMap) == 0x000020, "Wrong size on FProgressMap");
static_assert(offsetof(FProgressMap, OrderNo) == 0x000008, "Member 'FProgressMap::OrderNo' has a wrong offset!");
static_assert(offsetof(FProgressMap, Episode) == 0x00000C, "Member 'FProgressMap::Episode' has a wrong offset!");
static_assert(offsetof(FProgressMap, Chapter) == 0x000010, "Member 'FProgressMap::Chapter' has a wrong offset!");
static_assert(offsetof(FProgressMap, Part) == 0x000014, "Member 'FProgressMap::Part' has a wrong offset!");
static_assert(offsetof(FProgressMap, Character) == 0x000018, "Member 'FProgressMap::Character' has a wrong offset!");
static_assert(offsetof(FProgressMap, SupportCharacter1) == 0x000019, "Member 'FProgressMap::SupportCharacter1' has a wrong offset!");
static_assert(offsetof(FProgressMap, SupportCharacter2) == 0x00001A, "Member 'FProgressMap::SupportCharacter2' has a wrong offset!");

// ScriptStruct AT.LoadingBattleDemoSceneAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingBattleDemoSceneAsset final
{
public:
	TSoftObjectPtr<class ULevelSequence>          Sequencer;                                         // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingBattleDemoSceneAsset) == 0x000008, "Wrong alignment on FLoadingBattleDemoSceneAsset");
static_assert(sizeof(FLoadingBattleDemoSceneAsset) == 0x000028, "Wrong size on FLoadingBattleDemoSceneAsset");
static_assert(offsetof(FLoadingBattleDemoSceneAsset, Sequencer) == 0x000000, "Member 'FLoadingBattleDemoSceneAsset::Sequencer' has a wrong offset!");

// ScriptStruct AT.ATDataAssetVariationMeshInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetVariationMeshInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PartsClass;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetVariationMeshInfo) == 0x000008, "Wrong alignment on FATDataAssetVariationMeshInfo");
static_assert(sizeof(FATDataAssetVariationMeshInfo) == 0x000030, "Wrong size on FATDataAssetVariationMeshInfo");
static_assert(offsetof(FATDataAssetVariationMeshInfo, MasterId) == 0x000000, "Member 'FATDataAssetVariationMeshInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetVariationMeshInfo, PartsClass) == 0x000008, "Member 'FATDataAssetVariationMeshInfo::PartsClass' has a wrong offset!");

// ScriptStruct AT.ATLoadingFormMeshAsset
// 0x0030 (0x0030 - 0x0000)
struct FATLoadingFormMeshAsset final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Mesh;                                              // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATLoadingFormMeshAsset) == 0x000008, "Wrong alignment on FATLoadingFormMeshAsset");
static_assert(sizeof(FATLoadingFormMeshAsset) == 0x000030, "Wrong size on FATLoadingFormMeshAsset");
static_assert(offsetof(FATLoadingFormMeshAsset, MasterId) == 0x000000, "Member 'FATLoadingFormMeshAsset::MasterId' has a wrong offset!");
static_assert(offsetof(FATLoadingFormMeshAsset, Mesh) == 0x000008, "Member 'FATLoadingFormMeshAsset::Mesh' has a wrong offset!");

// ScriptStruct AT.ATLoadingVariationMeshAsset
// 0x0030 (0x0030 - 0x0000)
struct FATLoadingVariationMeshAsset final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Mesh;                                              // 0x0008(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATLoadingVariationMeshAsset) == 0x000008, "Wrong alignment on FATLoadingVariationMeshAsset");
static_assert(sizeof(FATLoadingVariationMeshAsset) == 0x000030, "Wrong size on FATLoadingVariationMeshAsset");
static_assert(offsetof(FATLoadingVariationMeshAsset, MasterId) == 0x000000, "Member 'FATLoadingVariationMeshAsset::MasterId' has a wrong offset!");
static_assert(offsetof(FATLoadingVariationMeshAsset, Mesh) == 0x000008, "Member 'FATLoadingVariationMeshAsset::Mesh' has a wrong offset!");

// ScriptStruct AT.ATDataAssetCookingDemoInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetCookingDemoInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Sequencer;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetCookingDemoInfo) == 0x000008, "Wrong alignment on FATDataAssetCookingDemoInfo");
static_assert(sizeof(FATDataAssetCookingDemoInfo) == 0x000030, "Wrong size on FATDataAssetCookingDemoInfo");
static_assert(offsetof(FATDataAssetCookingDemoInfo, MasterId) == 0x000000, "Member 'FATDataAssetCookingDemoInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetCookingDemoInfo, Sequencer) == 0x000008, "Member 'FATDataAssetCookingDemoInfo::Sequencer' has a wrong offset!");

// ScriptStruct AT.LocalRaceRankParam
// 0x0018 (0x0018 - 0x0000)
struct FLocalRaceRankParam final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              Time;                                              // 0x0010(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalRaceRankParam) == 0x000008, "Wrong alignment on FLocalRaceRankParam");
static_assert(sizeof(FLocalRaceRankParam) == 0x000018, "Wrong size on FLocalRaceRankParam");
static_assert(offsetof(FLocalRaceRankParam, Name) == 0x000000, "Member 'FLocalRaceRankParam::Name' has a wrong offset!");
static_assert(offsetof(FLocalRaceRankParam, Time) == 0x000010, "Member 'FLocalRaceRankParam::Time' has a wrong offset!");

// ScriptStruct AT.MissionUpdateInfoIgnoreParameter
// 0x0010 (0x0018 - 0x0008)
struct FMissionUpdateInfoIgnoreParameter final : public FTableRowBase
{
public:
	class FName                                   IgnoreStart;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreEnd;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionUpdateInfoIgnoreParameter) == 0x000008, "Wrong alignment on FMissionUpdateInfoIgnoreParameter");
static_assert(sizeof(FMissionUpdateInfoIgnoreParameter) == 0x000018, "Wrong size on FMissionUpdateInfoIgnoreParameter");
static_assert(offsetof(FMissionUpdateInfoIgnoreParameter, IgnoreStart) == 0x000008, "Member 'FMissionUpdateInfoIgnoreParameter::IgnoreStart' has a wrong offset!");
static_assert(offsetof(FMissionUpdateInfoIgnoreParameter, IgnoreEnd) == 0x000010, "Member 'FMissionUpdateInfoIgnoreParameter::IgnoreEnd' has a wrong offset!");

// ScriptStruct AT.Cpl078Skl001Param
// 0x0020 (0x0020 - 0x0000)
struct FCpl078Skl001Param final
{
public:
	struct FVector                                TransOffset;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOffset;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectile>                ExplodeProjectile;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCpl078Skl001Param) == 0x000008, "Wrong alignment on FCpl078Skl001Param");
static_assert(sizeof(FCpl078Skl001Param) == 0x000020, "Wrong size on FCpl078Skl001Param");
static_assert(offsetof(FCpl078Skl001Param, TransOffset) == 0x000000, "Member 'FCpl078Skl001Param::TransOffset' has a wrong offset!");
static_assert(offsetof(FCpl078Skl001Param, RotOffset) == 0x00000C, "Member 'FCpl078Skl001Param::RotOffset' has a wrong offset!");
static_assert(offsetof(FCpl078Skl001Param, ExplodeProjectile) == 0x000018, "Member 'FCpl078Skl001Param::ExplodeProjectile' has a wrong offset!");

// ScriptStruct AT.ATReferenceToCookingDemoCharacterResourceAssetInstance
// 0x0098 (0x0098 - 0x0000)
struct FATReferenceToCookingDemoCharacterResourceAssetInstance final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reaction_Grade1_Motion;                            // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reaction_Grade2_Motion;                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Reaction_Grade3_Motion;                            // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Meal_Seize_Motion;                                 // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Meal_Stick1_Motion;                                // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Meal_Stick2_Motion;                                // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Meal_Stick3_Motion;                                // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Meal_Stick4_Motion;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Meal_Grasp_Motion;                                 // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           After_Grade1_Motion;                               // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           After_Grade2_Motion;                               // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           After_Grade3_Motion;                               // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           After_Grade1_LP_Motion;                            // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           After_Grade2_LP_Motion;                            // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           After_Grade3_LP_Motion;                            // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Result_St_Motion;                                  // 0x0080(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Result_Lp_Motion;                                  // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          StartAttachmentMesh;                               // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATReferenceToCookingDemoCharacterResourceAssetInstance) == 0x000008, "Wrong alignment on FATReferenceToCookingDemoCharacterResourceAssetInstance");
static_assert(sizeof(FATReferenceToCookingDemoCharacterResourceAssetInstance) == 0x000098, "Wrong size on FATReferenceToCookingDemoCharacterResourceAssetInstance");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, MasterId) == 0x000000, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::MasterId' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Reaction_Grade1_Motion) == 0x000008, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Reaction_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Reaction_Grade2_Motion) == 0x000010, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Reaction_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Reaction_Grade3_Motion) == 0x000018, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Reaction_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Meal_Seize_Motion) == 0x000020, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Meal_Seize_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Meal_Stick1_Motion) == 0x000028, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Meal_Stick1_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Meal_Stick2_Motion) == 0x000030, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Meal_Stick2_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Meal_Stick3_Motion) == 0x000038, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Meal_Stick3_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Meal_Stick4_Motion) == 0x000040, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Meal_Stick4_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Meal_Grasp_Motion) == 0x000048, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Meal_Grasp_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, After_Grade1_Motion) == 0x000050, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::After_Grade1_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, After_Grade2_Motion) == 0x000058, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::After_Grade2_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, After_Grade3_Motion) == 0x000060, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::After_Grade3_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, After_Grade1_LP_Motion) == 0x000068, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::After_Grade1_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, After_Grade2_LP_Motion) == 0x000070, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::After_Grade2_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, After_Grade3_LP_Motion) == 0x000078, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::After_Grade3_LP_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Result_St_Motion) == 0x000080, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Result_St_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, Result_Lp_Motion) == 0x000088, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::Result_Lp_Motion' has a wrong offset!");
static_assert(offsetof(FATReferenceToCookingDemoCharacterResourceAssetInstance, StartAttachmentMesh) == 0x000090, "Member 'FATReferenceToCookingDemoCharacterResourceAssetInstance::StartAttachmentMesh' has a wrong offset!");

// ScriptStruct AT.ATDataAssetCrossTalkInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FATDataAssetCrossTalkInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetCrossTalkInfo) == 0x000008, "Wrong alignment on FATDataAssetCrossTalkInfo");
static_assert(sizeof(FATDataAssetCrossTalkInfo) == 0x000008, "Wrong size on FATDataAssetCrossTalkInfo");
static_assert(offsetof(FATDataAssetCrossTalkInfo, MasterId) == 0x000000, "Member 'FATDataAssetCrossTalkInfo::MasterId' has a wrong offset!");

// ScriptStruct AT.ReferenceToDamageTypeAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToDamageTypeAssetInstance final
{
public:
	TSubclassOf<class UAT_DamageType>             DamageType;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToDamageTypeAssetInstance) == 0x000008, "Wrong alignment on FReferenceToDamageTypeAssetInstance");
static_assert(sizeof(FReferenceToDamageTypeAssetInstance) == 0x000008, "Wrong size on FReferenceToDamageTypeAssetInstance");
static_assert(offsetof(FReferenceToDamageTypeAssetInstance, DamageType) == 0x000000, "Member 'FReferenceToDamageTypeAssetInstance::DamageType' has a wrong offset!");

// ScriptStruct AT.ATDataAssetEventBattleMobInfo
// 0x0088 (0x0088 - 0x0000)
struct FATDataAssetEventBattleMobInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkeletalMesh;                                      // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimationAsset>         Animation;                                         // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshOffset;                                        // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDataAssetEventBattleMobInfo) == 0x000008, "Wrong alignment on FATDataAssetEventBattleMobInfo");
static_assert(sizeof(FATDataAssetEventBattleMobInfo) == 0x000088, "Wrong size on FATDataAssetEventBattleMobInfo");
static_assert(offsetof(FATDataAssetEventBattleMobInfo, MasterId) == 0x000000, "Member 'FATDataAssetEventBattleMobInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattleMobInfo, StaticMesh) == 0x000008, "Member 'FATDataAssetEventBattleMobInfo::StaticMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattleMobInfo, SkeletalMesh) == 0x000030, "Member 'FATDataAssetEventBattleMobInfo::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattleMobInfo, Animation) == 0x000058, "Member 'FATDataAssetEventBattleMobInfo::Animation' has a wrong offset!");
static_assert(offsetof(FATDataAssetEventBattleMobInfo, MeshOffset) == 0x000080, "Member 'FATDataAssetEventBattleMobInfo::MeshOffset' has a wrong offset!");

// ScriptStruct AT.ReferenceToEventBattleMobAssetInstance
// 0x0018 (0x0018 - 0x0000)
struct FReferenceToEventBattleMobAssetInstance final
{
public:
	class UStaticMesh*                            StaticMesh;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SkeletalMesh;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        Animation;                                         // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToEventBattleMobAssetInstance) == 0x000008, "Wrong alignment on FReferenceToEventBattleMobAssetInstance");
static_assert(sizeof(FReferenceToEventBattleMobAssetInstance) == 0x000018, "Wrong size on FReferenceToEventBattleMobAssetInstance");
static_assert(offsetof(FReferenceToEventBattleMobAssetInstance, StaticMesh) == 0x000000, "Member 'FReferenceToEventBattleMobAssetInstance::StaticMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToEventBattleMobAssetInstance, SkeletalMesh) == 0x000008, "Member 'FReferenceToEventBattleMobAssetInstance::SkeletalMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToEventBattleMobAssetInstance, Animation) == 0x000010, "Member 'FReferenceToEventBattleMobAssetInstance::Animation' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFieldInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetFieldInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFieldInfo) == 0x000008, "Wrong alignment on FATDataAssetFieldInfo");
static_assert(sizeof(FATDataAssetFieldInfo) == 0x000030, "Wrong size on FATDataAssetFieldInfo");
static_assert(offsetof(FATDataAssetFieldInfo, MasterId) == 0x000000, "Member 'FATDataAssetFieldInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetFieldInfo, StaticMesh) == 0x000008, "Member 'FATDataAssetFieldInfo::StaticMesh' has a wrong offset!");

// ScriptStruct AT.DebugMenuStruct
// 0x0098 (0x0098 - 0x0000)
struct alignas(0x08) FDebugMenuStruct final
{
public:
	uint8                                         Pad_0[0x98];                                       // 0x0000(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugMenuStruct) == 0x000008, "Wrong alignment on FDebugMenuStruct");
static_assert(sizeof(FDebugMenuStruct) == 0x000098, "Wrong size on FDebugMenuStruct");

// ScriptStruct AT.ATDataAssetFishGameCharaAnimationInfo
// 0x0328 (0x0328 - 0x0000)
struct FATDataAssetFishGameCharaAnimationInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingStart;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingStart_Rod;                                  // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingAction;                                     // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingAction_Rod;                                 // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingQTE1;                                       // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingQTE1_Rod;                                   // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingQTE2;                                       // 0x00F8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingQTE2_Rod;                                   // 0x0120(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingMiss;                                       // 0x0148(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingMiss_Rod;                                   // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingLoop;                                       // 0x0198(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingLoop_Rod;                                   // 0x01C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingResultStart;                                // 0x01E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingResultLoop;                                 // 0x0210(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingBait;                                       // 0x0238(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingFaceSweat;                                  // 0x0260(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingHit;                                        // 0x0288(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingHit_Rod;                                    // 0x02B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingStart2;                                     // 0x02D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            FishingStart2_Rod;                                 // 0x0300(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFishGameCharaAnimationInfo) == 0x000008, "Wrong alignment on FATDataAssetFishGameCharaAnimationInfo");
static_assert(sizeof(FATDataAssetFishGameCharaAnimationInfo) == 0x000328, "Wrong size on FATDataAssetFishGameCharaAnimationInfo");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, MasterId) == 0x000000, "Member 'FATDataAssetFishGameCharaAnimationInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingStart) == 0x000008, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingStart' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingStart_Rod) == 0x000030, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingStart_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingAction) == 0x000058, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingAction' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingAction_Rod) == 0x000080, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingAction_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingQTE1) == 0x0000A8, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingQTE1' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingQTE1_Rod) == 0x0000D0, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingQTE1_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingQTE2) == 0x0000F8, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingQTE2' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingQTE2_Rod) == 0x000120, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingQTE2_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingMiss) == 0x000148, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingMiss' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingMiss_Rod) == 0x000170, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingMiss_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingLoop) == 0x000198, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingLoop' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingLoop_Rod) == 0x0001C0, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingLoop_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingResultStart) == 0x0001E8, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingResultStart' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingResultLoop) == 0x000210, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingResultLoop' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingBait) == 0x000238, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingBait' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingFaceSweat) == 0x000260, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingFaceSweat' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingHit) == 0x000288, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingHit' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingHit_Rod) == 0x0002B0, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingHit_Rod' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingStart2) == 0x0002D8, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingStart2' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameCharaAnimationInfo, FishingStart2_Rod) == 0x000300, "Member 'FATDataAssetFishGameCharaAnimationInfo::FishingStart2_Rod' has a wrong offset!");

// ScriptStruct AT.DevelopCommunityTable
// 0x0018 (0x0020 - 0x0008)
struct FDevelopCommunityTable final : public FTableRowBase
{
public:
	int32                                         LimitLevel;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareSuccessRate;                                   // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareSuccessValue;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostDownMoney;                                     // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CostDownMaterial;                                  // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDevelopCommunityTable) == 0x000008, "Wrong alignment on FDevelopCommunityTable");
static_assert(sizeof(FDevelopCommunityTable) == 0x000020, "Wrong size on FDevelopCommunityTable");
static_assert(offsetof(FDevelopCommunityTable, LimitLevel) == 0x000008, "Member 'FDevelopCommunityTable::LimitLevel' has a wrong offset!");
static_assert(offsetof(FDevelopCommunityTable, RareSuccessRate) == 0x00000C, "Member 'FDevelopCommunityTable::RareSuccessRate' has a wrong offset!");
static_assert(offsetof(FDevelopCommunityTable, RareSuccessValue) == 0x000010, "Member 'FDevelopCommunityTable::RareSuccessValue' has a wrong offset!");
static_assert(offsetof(FDevelopCommunityTable, CostDownMoney) == 0x000014, "Member 'FDevelopCommunityTable::CostDownMoney' has a wrong offset!");
static_assert(offsetof(FDevelopCommunityTable, CostDownMaterial) == 0x000018, "Member 'FDevelopCommunityTable::CostDownMaterial' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFishParticleEffInfo
// 0x0140 (0x0140 - 0x0000)
struct FATDataAssetFishParticleEffInfo final
{
public:
	TSoftObjectPtr<class UParticleSystem>         FishinRippleEffect;                                // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishinBaitEffect_Normal;                           // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishinBaitEffect_Rare;                             // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishinBaitEffect_SuperRare;                        // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishingHitEffect;                                  // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishingHitLoopEffect;                              // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishingStartPointEffect;                           // 0x00F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         FishEscapeEffectComponent;                         // 0x0118(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFishParticleEffInfo) == 0x000008, "Wrong alignment on FATDataAssetFishParticleEffInfo");
static_assert(sizeof(FATDataAssetFishParticleEffInfo) == 0x000140, "Wrong size on FATDataAssetFishParticleEffInfo");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishinRippleEffect) == 0x000000, "Member 'FATDataAssetFishParticleEffInfo::FishinRippleEffect' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishinBaitEffect_Normal) == 0x000028, "Member 'FATDataAssetFishParticleEffInfo::FishinBaitEffect_Normal' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishinBaitEffect_Rare) == 0x000050, "Member 'FATDataAssetFishParticleEffInfo::FishinBaitEffect_Rare' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishinBaitEffect_SuperRare) == 0x000078, "Member 'FATDataAssetFishParticleEffInfo::FishinBaitEffect_SuperRare' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishingHitEffect) == 0x0000A0, "Member 'FATDataAssetFishParticleEffInfo::FishingHitEffect' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishingHitLoopEffect) == 0x0000C8, "Member 'FATDataAssetFishParticleEffInfo::FishingHitLoopEffect' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishingStartPointEffect) == 0x0000F0, "Member 'FATDataAssetFishParticleEffInfo::FishingStartPointEffect' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishParticleEffInfo, FishEscapeEffectComponent) == 0x000118, "Member 'FATDataAssetFishParticleEffInfo::FishEscapeEffectComponent' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFishCurveParamInfo
// 0x0078 (0x0078 - 0x0000)
struct FATDataAssetFishCurveParamInfo final
{
public:
	TSoftObjectPtr<class UCurveFloat>             SwimSpeedCurve;                                    // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             TurnSpeedCurve;                                    // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             DiscoverSpeedCurve;                                // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFishCurveParamInfo) == 0x000008, "Wrong alignment on FATDataAssetFishCurveParamInfo");
static_assert(sizeof(FATDataAssetFishCurveParamInfo) == 0x000078, "Wrong size on FATDataAssetFishCurveParamInfo");
static_assert(offsetof(FATDataAssetFishCurveParamInfo, SwimSpeedCurve) == 0x000000, "Member 'FATDataAssetFishCurveParamInfo::SwimSpeedCurve' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishCurveParamInfo, TurnSpeedCurve) == 0x000028, "Member 'FATDataAssetFishCurveParamInfo::TurnSpeedCurve' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishCurveParamInfo, DiscoverSpeedCurve) == 0x000050, "Member 'FATDataAssetFishCurveParamInfo::DiscoverSpeedCurve' has a wrong offset!");

// ScriptStruct AT.GroupBattleInfo
// 0x0020 (0x0020 - 0x0000)
struct FGroupBattleInfo final
{
public:
	int32                                         EnemyTotal;                                        // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OverKillExperience;                                // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterTable;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ReinforceTable;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyCountTitleName;                               // 0x0018(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGroupBattleInfo) == 0x000008, "Wrong alignment on FGroupBattleInfo");
static_assert(sizeof(FGroupBattleInfo) == 0x000020, "Wrong size on FGroupBattleInfo");
static_assert(offsetof(FGroupBattleInfo, EnemyTotal) == 0x000000, "Member 'FGroupBattleInfo::EnemyTotal' has a wrong offset!");
static_assert(offsetof(FGroupBattleInfo, OverKillExperience) == 0x000004, "Member 'FGroupBattleInfo::OverKillExperience' has a wrong offset!");
static_assert(offsetof(FGroupBattleInfo, CharacterTable) == 0x000008, "Member 'FGroupBattleInfo::CharacterTable' has a wrong offset!");
static_assert(offsetof(FGroupBattleInfo, ReinforceTable) == 0x000010, "Member 'FGroupBattleInfo::ReinforceTable' has a wrong offset!");
static_assert(offsetof(FGroupBattleInfo, EnemyCountTitleName) == 0x000018, "Member 'FGroupBattleInfo::EnemyCountTitleName' has a wrong offset!");

// ScriptStruct AT.ATDataAssetFishGameAnimationInfo
// 0x00F8 (0x00F8 - 0x0000)
struct FATDataAssetFishGameAnimationInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            MissMontage;                                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            PullMontage;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SuccessMontage;                                    // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ResultStartMontage;                                // 0x0080(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            ResultLoopMontage;                                 // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            RarePullMontage;                                   // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetFishGameAnimationInfo) == 0x000008, "Wrong alignment on FATDataAssetFishGameAnimationInfo");
static_assert(sizeof(FATDataAssetFishGameAnimationInfo) == 0x0000F8, "Wrong size on FATDataAssetFishGameAnimationInfo");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, MasterId) == 0x000000, "Member 'FATDataAssetFishGameAnimationInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, MissMontage) == 0x000008, "Member 'FATDataAssetFishGameAnimationInfo::MissMontage' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, PullMontage) == 0x000030, "Member 'FATDataAssetFishGameAnimationInfo::PullMontage' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, SuccessMontage) == 0x000058, "Member 'FATDataAssetFishGameAnimationInfo::SuccessMontage' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, ResultStartMontage) == 0x000080, "Member 'FATDataAssetFishGameAnimationInfo::ResultStartMontage' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, ResultLoopMontage) == 0x0000A8, "Member 'FATDataAssetFishGameAnimationInfo::ResultLoopMontage' has a wrong offset!");
static_assert(offsetof(FATDataAssetFishGameAnimationInfo, RarePullMontage) == 0x0000D0, "Member 'FATDataAssetFishGameAnimationInfo::RarePullMontage' has a wrong offset!");

// ScriptStruct AT.SubQuestCostume
// 0x0038 (0x0040 - 0x0008)
struct FSubQuestCostume final : public FTableRowBase
{
public:
	class FName                                   Quest_id;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Phase_id;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   End_phase_id;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Required_content_id;                               // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Unique_id;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Variation_id;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Form_id;                                           // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Facial_id;                                         // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Auto_form_change_id;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubQuestCostume) == 0x000008, "Wrong alignment on FSubQuestCostume");
static_assert(sizeof(FSubQuestCostume) == 0x000040, "Wrong size on FSubQuestCostume");
static_assert(offsetof(FSubQuestCostume, Quest_id) == 0x000008, "Member 'FSubQuestCostume::Quest_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Phase_id) == 0x000010, "Member 'FSubQuestCostume::Phase_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, End_phase_id) == 0x000018, "Member 'FSubQuestCostume::End_phase_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Required_content_id) == 0x000020, "Member 'FSubQuestCostume::Required_content_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Unique_id) == 0x000028, "Member 'FSubQuestCostume::Unique_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Variation_id) == 0x000030, "Member 'FSubQuestCostume::Variation_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Form_id) == 0x000031, "Member 'FSubQuestCostume::Form_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Facial_id) == 0x000032, "Member 'FSubQuestCostume::Facial_id' has a wrong offset!");
static_assert(offsetof(FSubQuestCostume, Auto_form_change_id) == 0x000038, "Member 'FSubQuestCostume::Auto_form_change_id' has a wrong offset!");

// ScriptStruct AT.AuraSearchItemEffectParam
// 0x0010 (0x0018 - 0x0008)
struct FAuraSearchItemEffectParam final : public FTableRowBase
{
public:
	float                                         Scale;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndTime;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAuraSearchItemEffectParam) == 0x000008, "Wrong alignment on FAuraSearchItemEffectParam");
static_assert(sizeof(FAuraSearchItemEffectParam) == 0x000018, "Wrong size on FAuraSearchItemEffectParam");
static_assert(offsetof(FAuraSearchItemEffectParam, Scale) == 0x000008, "Member 'FAuraSearchItemEffectParam::Scale' has a wrong offset!");
static_assert(offsetof(FAuraSearchItemEffectParam, StartTime) == 0x00000C, "Member 'FAuraSearchItemEffectParam::StartTime' has a wrong offset!");
static_assert(offsetof(FAuraSearchItemEffectParam, EndTime) == 0x000010, "Member 'FAuraSearchItemEffectParam::EndTime' has a wrong offset!");

// ScriptStruct AT.ReferenceToFishParticleEffAssetInstance
// 0x0040 (0x0040 - 0x0000)
struct FReferenceToFishParticleEffAssetInstance final
{
public:
	class UParticleSystem*                        FishinRippleEffect;                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishinBaitEffect_Normal;                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishinBaitEffect_Rare;                             // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishinBaitEffect_SuperRare;                        // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishingHitEffect;                                  // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishingHitLoopEffect;                              // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishingStartPointEffect;                           // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        FishEscapeEffectComponent;                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToFishParticleEffAssetInstance) == 0x000008, "Wrong alignment on FReferenceToFishParticleEffAssetInstance");
static_assert(sizeof(FReferenceToFishParticleEffAssetInstance) == 0x000040, "Wrong size on FReferenceToFishParticleEffAssetInstance");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishinRippleEffect) == 0x000000, "Member 'FReferenceToFishParticleEffAssetInstance::FishinRippleEffect' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishinBaitEffect_Normal) == 0x000008, "Member 'FReferenceToFishParticleEffAssetInstance::FishinBaitEffect_Normal' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishinBaitEffect_Rare) == 0x000010, "Member 'FReferenceToFishParticleEffAssetInstance::FishinBaitEffect_Rare' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishinBaitEffect_SuperRare) == 0x000018, "Member 'FReferenceToFishParticleEffAssetInstance::FishinBaitEffect_SuperRare' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishingHitEffect) == 0x000020, "Member 'FReferenceToFishParticleEffAssetInstance::FishingHitEffect' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishingHitLoopEffect) == 0x000028, "Member 'FReferenceToFishParticleEffAssetInstance::FishingHitLoopEffect' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishingStartPointEffect) == 0x000030, "Member 'FReferenceToFishParticleEffAssetInstance::FishingStartPointEffect' has a wrong offset!");
static_assert(offsetof(FReferenceToFishParticleEffAssetInstance, FishEscapeEffectComponent) == 0x000038, "Member 'FReferenceToFishParticleEffAssetInstance::FishEscapeEffectComponent' has a wrong offset!");

// ScriptStruct AT.IgnoreAssetCondition
// 0x0002 (0x0002 - 0x0000)
struct FIgnoreAssetCondition final
{
public:
	bool                                          IgnoreLoadingAtMainStory;                          // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreLoadingAtDLC;                                // 0x0001(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIgnoreAssetCondition) == 0x000001, "Wrong alignment on FIgnoreAssetCondition");
static_assert(sizeof(FIgnoreAssetCondition) == 0x000002, "Wrong size on FIgnoreAssetCondition");
static_assert(offsetof(FIgnoreAssetCondition, IgnoreLoadingAtMainStory) == 0x000000, "Member 'FIgnoreAssetCondition::IgnoreLoadingAtMainStory' has a wrong offset!");
static_assert(offsetof(FIgnoreAssetCondition, IgnoreLoadingAtDLC) == 0x000001, "Member 'FIgnoreAssetCondition::IgnoreLoadingAtDLC' has a wrong offset!");

// ScriptStruct AT.LocalRaceRank
// 0x0010 (0x0010 - 0x0000)
struct FLocalRaceRank final
{
public:
	TArray<struct FLocalRaceRankParam>            LocalRaceRanking;                                  // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLocalRaceRank) == 0x000008, "Wrong alignment on FLocalRaceRank");
static_assert(sizeof(FLocalRaceRank) == 0x000010, "Wrong size on FLocalRaceRank");
static_assert(offsetof(FLocalRaceRank, LocalRaceRanking) == 0x000000, "Member 'FLocalRaceRank::LocalRaceRanking' has a wrong offset!");

// ScriptStruct AT.ReferenceToFishGameMeshAssetInstance
// 0x0010 (0x0010 - 0x0000)
struct FReferenceToFishGameMeshAssetInstance final
{
public:
	class USkeletalMesh*                          FishMesh;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UAnimInstance>              AnimationBP;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToFishGameMeshAssetInstance) == 0x000008, "Wrong alignment on FReferenceToFishGameMeshAssetInstance");
static_assert(sizeof(FReferenceToFishGameMeshAssetInstance) == 0x000010, "Wrong size on FReferenceToFishGameMeshAssetInstance");
static_assert(offsetof(FReferenceToFishGameMeshAssetInstance, FishMesh) == 0x000000, "Member 'FReferenceToFishGameMeshAssetInstance::FishMesh' has a wrong offset!");
static_assert(offsetof(FReferenceToFishGameMeshAssetInstance, AnimationBP) == 0x000008, "Member 'FReferenceToFishGameMeshAssetInstance::AnimationBP' has a wrong offset!");

// ScriptStruct AT.DragonBallRecovery
// 0x0008 (0x0008 - 0x0000)
struct FDragonBallRecovery final
{
public:
	int32                                         ballNum;                                           // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyActor;                                      // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonBallRecovery) == 0x000004, "Wrong alignment on FDragonBallRecovery");
static_assert(sizeof(FDragonBallRecovery) == 0x000008, "Wrong size on FDragonBallRecovery");
static_assert(offsetof(FDragonBallRecovery, ballNum) == 0x000000, "Member 'FDragonBallRecovery::ballNum' has a wrong offset!");
static_assert(offsetof(FDragonBallRecovery, DestroyActor) == 0x000004, "Member 'FDragonBallRecovery::DestroyActor' has a wrong offset!");

// ScriptStruct AT.LoadingFishGameAnimationAsset
// 0x00F0 (0x00F0 - 0x0000)
struct alignas(0x08) FLoadingFishGameAnimationAsset final
{
public:
	uint8                                         Pad_0[0xF0];                                       // 0x0000(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingFishGameAnimationAsset) == 0x000008, "Wrong alignment on FLoadingFishGameAnimationAsset");
static_assert(sizeof(FLoadingFishGameAnimationAsset) == 0x0000F0, "Wrong size on FLoadingFishGameAnimationAsset");

// ScriptStruct AT.QuestRetryCondition
// 0x0078 (0x0080 - 0x0008)
struct FQuestRetryCondition final : public FTableRowBase
{
public:
	TArray<class FName>                           DisableEventFlags;                                 // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           EnableEventFlags;                                  // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           RetryQuestIds;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECHARACTER_TYPE>                       RecoveryCharacterTypes;                            // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FRestoreItemSet>                RestoreItemIds;                                    // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreResetItemIds;                                // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           IgnoreRemoveSubQuestIds;                           // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          DisableFadeinWhenQuestRetryStarted;                // 0x0078(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestRetryCondition) == 0x000008, "Wrong alignment on FQuestRetryCondition");
static_assert(sizeof(FQuestRetryCondition) == 0x000080, "Wrong size on FQuestRetryCondition");
static_assert(offsetof(FQuestRetryCondition, DisableEventFlags) == 0x000008, "Member 'FQuestRetryCondition::DisableEventFlags' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, EnableEventFlags) == 0x000018, "Member 'FQuestRetryCondition::EnableEventFlags' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, RetryQuestIds) == 0x000028, "Member 'FQuestRetryCondition::RetryQuestIds' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, RecoveryCharacterTypes) == 0x000038, "Member 'FQuestRetryCondition::RecoveryCharacterTypes' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, RestoreItemIds) == 0x000048, "Member 'FQuestRetryCondition::RestoreItemIds' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, IgnoreResetItemIds) == 0x000058, "Member 'FQuestRetryCondition::IgnoreResetItemIds' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, IgnoreRemoveSubQuestIds) == 0x000068, "Member 'FQuestRetryCondition::IgnoreRemoveSubQuestIds' has a wrong offset!");
static_assert(offsetof(FQuestRetryCondition, DisableFadeinWhenQuestRetryStarted) == 0x000078, "Member 'FQuestRetryCondition::DisableFadeinWhenQuestRetryStarted' has a wrong offset!");

// ScriptStruct AT.ATDataAssetGBCharacterInfo
// 0x00B0 (0x00B0 - 0x0000)
struct FATDataAssetGBCharacterInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           MeshMobNear;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UAnimMontage>> AnimationMap;                                      // 0x0058(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         MeshOffset;                                        // 0x00A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshScale;                                         // 0x00AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetGBCharacterInfo) == 0x000008, "Wrong alignment on FATDataAssetGBCharacterInfo");
static_assert(sizeof(FATDataAssetGBCharacterInfo) == 0x0000B0, "Wrong size on FATDataAssetGBCharacterInfo");
static_assert(offsetof(FATDataAssetGBCharacterInfo, MasterId) == 0x000000, "Member 'FATDataAssetGBCharacterInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetGBCharacterInfo, Mesh) == 0x000008, "Member 'FATDataAssetGBCharacterInfo::Mesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetGBCharacterInfo, MeshMobNear) == 0x000030, "Member 'FATDataAssetGBCharacterInfo::MeshMobNear' has a wrong offset!");
static_assert(offsetof(FATDataAssetGBCharacterInfo, AnimationMap) == 0x000058, "Member 'FATDataAssetGBCharacterInfo::AnimationMap' has a wrong offset!");
static_assert(offsetof(FATDataAssetGBCharacterInfo, MeshOffset) == 0x0000A8, "Member 'FATDataAssetGBCharacterInfo::MeshOffset' has a wrong offset!");
static_assert(offsetof(FATDataAssetGBCharacterInfo, MeshScale) == 0x0000AC, "Member 'FATDataAssetGBCharacterInfo::MeshScale' has a wrong offset!");

// ScriptStruct AT.BaseballGameCameraTable
// 0x0018 (0x0020 - 0x0008)
struct FBaseballGameCameraTable final : public FTableRowBase
{
public:
	float                                         FOV;                                               // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WidthOffset;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeightOffset;                                // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetWidthOffset;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseballGameCameraTable) == 0x000008, "Wrong alignment on FBaseballGameCameraTable");
static_assert(sizeof(FBaseballGameCameraTable) == 0x000020, "Wrong size on FBaseballGameCameraTable");
static_assert(offsetof(FBaseballGameCameraTable, FOV) == 0x000008, "Member 'FBaseballGameCameraTable::FOV' has a wrong offset!");
static_assert(offsetof(FBaseballGameCameraTable, Length) == 0x00000C, "Member 'FBaseballGameCameraTable::Length' has a wrong offset!");
static_assert(offsetof(FBaseballGameCameraTable, HeightOffset) == 0x000010, "Member 'FBaseballGameCameraTable::HeightOffset' has a wrong offset!");
static_assert(offsetof(FBaseballGameCameraTable, WidthOffset) == 0x000014, "Member 'FBaseballGameCameraTable::WidthOffset' has a wrong offset!");
static_assert(offsetof(FBaseballGameCameraTable, TargetHeightOffset) == 0x000018, "Member 'FBaseballGameCameraTable::TargetHeightOffset' has a wrong offset!");
static_assert(offsetof(FBaseballGameCameraTable, TargetWidthOffset) == 0x00001C, "Member 'FBaseballGameCameraTable::TargetWidthOffset' has a wrong offset!");

// ScriptStruct AT.LoadingGBCharacterAsset
// 0x00A0 (0x00A0 - 0x0000)
struct FLoadingGBCharacterAsset final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           MeshMobNear;                                       // 0x0028(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UAnimMontage>> AnimationMap;                                      // 0x0050(0x0050)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingGBCharacterAsset) == 0x000008, "Wrong alignment on FLoadingGBCharacterAsset");
static_assert(sizeof(FLoadingGBCharacterAsset) == 0x0000A0, "Wrong size on FLoadingGBCharacterAsset");
static_assert(offsetof(FLoadingGBCharacterAsset, Mesh) == 0x000000, "Member 'FLoadingGBCharacterAsset::Mesh' has a wrong offset!");
static_assert(offsetof(FLoadingGBCharacterAsset, MeshMobNear) == 0x000028, "Member 'FLoadingGBCharacterAsset::MeshMobNear' has a wrong offset!");
static_assert(offsetof(FLoadingGBCharacterAsset, AnimationMap) == 0x000050, "Member 'FLoadingGBCharacterAsset::AnimationMap' has a wrong offset!");

// ScriptStruct AT.SkillSaveInfo
// 0x0178 (0x0178 - 0x0000)
struct FSkillSaveInfo final
{
public:
	class FName                                   PaletteSkills[0x8];                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotSkills[0x14];                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SupportSkill[0x2];                                 // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OpenSkillTreeId;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           HaveSkillTreeId;                                   // 0x0100(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PassiveSkills[0x8];                                // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SparkingSkills[0x4];                               // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SparkingSkill;                                     // 0x0170(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_171[0x7];                                      // 0x0171(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillSaveInfo) == 0x000008, "Wrong alignment on FSkillSaveInfo");
static_assert(sizeof(FSkillSaveInfo) == 0x000178, "Wrong size on FSkillSaveInfo");
static_assert(offsetof(FSkillSaveInfo, PaletteSkills) == 0x000000, "Member 'FSkillSaveInfo::PaletteSkills' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, SlotSkills) == 0x000040, "Member 'FSkillSaveInfo::SlotSkills' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, SupportSkill) == 0x0000E0, "Member 'FSkillSaveInfo::SupportSkill' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, OpenSkillTreeId) == 0x0000F0, "Member 'FSkillSaveInfo::OpenSkillTreeId' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, HaveSkillTreeId) == 0x000100, "Member 'FSkillSaveInfo::HaveSkillTreeId' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, PassiveSkills) == 0x000110, "Member 'FSkillSaveInfo::PassiveSkills' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, SparkingSkills) == 0x000150, "Member 'FSkillSaveInfo::SparkingSkills' has a wrong offset!");
static_assert(offsetof(FSkillSaveInfo, SparkingSkill) == 0x000170, "Member 'FSkillSaveInfo::SparkingSkill' has a wrong offset!");

// ScriptStruct AT.ReferenceToGBResultAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToGBResultAssetInstance final
{
public:
	class UAnimMontage*                           PlayerAnimB;                                       // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToGBResultAssetInstance) == 0x000008, "Wrong alignment on FReferenceToGBResultAssetInstance");
static_assert(sizeof(FReferenceToGBResultAssetInstance) == 0x000008, "Wrong size on FReferenceToGBResultAssetInstance");
static_assert(offsetof(FReferenceToGBResultAssetInstance, PlayerAnimB) == 0x000000, "Member 'FReferenceToGBResultAssetInstance::PlayerAnimB' has a wrong offset!");

// ScriptStruct AT.LoadingGBResultAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingGBResultAsset final
{
public:
	TSoftObjectPtr<class UAnimMontage>            PlayerAnimB;                                       // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingGBResultAsset) == 0x000008, "Wrong alignment on FLoadingGBResultAsset");
static_assert(sizeof(FLoadingGBResultAsset) == 0x000028, "Wrong size on FLoadingGBResultAsset");
static_assert(offsetof(FLoadingGBResultAsset, PlayerAnimB) == 0x000000, "Member 'FLoadingGBResultAsset::PlayerAnimB' has a wrong offset!");

// ScriptStruct AT.ATDataAssetGroupBattleInfo
// 0x0250 (0x0250 - 0x0000)
struct FATDataAssetGroupBattleInfo final
{
public:
	TArray<TSoftObjectPtr<class USkeletalMesh>>   FarMobMeshes;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SZCDummyAnim;                                      // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SZCDummyMesh;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimMontage>>    SZCDamageAnim;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCameraAnim>             SZCCameraAnim;                                     // 0x0070(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SZCOverKillTable;                                  // 0x0098(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SZCOverKillTable2p;                                // 0x00C0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowOverKillTableLevel1;                     // 0x00E8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowOverKillTableLevel2;                     // 0x0110(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowOverKillTableLevel3;                     // 0x0138(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowOverKillTableLevel1_DLC5;                // 0x0160(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowOverKillTableLevel2_DLC5;                // 0x0188(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowOverKillTableLevel3_DLC5;                // 0x01B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UParticleSystem>> AuraParticleMap;                                   // 0x01D8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              GroupBattleReinforceParameterTable;                // 0x0228(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetGroupBattleInfo) == 0x000008, "Wrong alignment on FATDataAssetGroupBattleInfo");
static_assert(sizeof(FATDataAssetGroupBattleInfo) == 0x000250, "Wrong size on FATDataAssetGroupBattleInfo");
static_assert(offsetof(FATDataAssetGroupBattleInfo, FarMobMeshes) == 0x000000, "Member 'FATDataAssetGroupBattleInfo::FarMobMeshes' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, SZCDummyAnim) == 0x000010, "Member 'FATDataAssetGroupBattleInfo::SZCDummyAnim' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, SZCDummyMesh) == 0x000038, "Member 'FATDataAssetGroupBattleInfo::SZCDummyMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, SZCDamageAnim) == 0x000060, "Member 'FATDataAssetGroupBattleInfo::SZCDamageAnim' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, SZCCameraAnim) == 0x000070, "Member 'FATDataAssetGroupBattleInfo::SZCCameraAnim' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, SZCOverKillTable) == 0x000098, "Member 'FATDataAssetGroupBattleInfo::SZCOverKillTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, SZCOverKillTable2p) == 0x0000C0, "Member 'FATDataAssetGroupBattleInfo::SZCOverKillTable2p' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, ZOverthrowOverKillTableLevel1) == 0x0000E8, "Member 'FATDataAssetGroupBattleInfo::ZOverthrowOverKillTableLevel1' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, ZOverthrowOverKillTableLevel2) == 0x000110, "Member 'FATDataAssetGroupBattleInfo::ZOverthrowOverKillTableLevel2' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, ZOverthrowOverKillTableLevel3) == 0x000138, "Member 'FATDataAssetGroupBattleInfo::ZOverthrowOverKillTableLevel3' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, ZOverthrowOverKillTableLevel1_DLC5) == 0x000160, "Member 'FATDataAssetGroupBattleInfo::ZOverthrowOverKillTableLevel1_DLC5' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, ZOverthrowOverKillTableLevel2_DLC5) == 0x000188, "Member 'FATDataAssetGroupBattleInfo::ZOverthrowOverKillTableLevel2_DLC5' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, ZOverthrowOverKillTableLevel3_DLC5) == 0x0001B0, "Member 'FATDataAssetGroupBattleInfo::ZOverthrowOverKillTableLevel3_DLC5' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, AuraParticleMap) == 0x0001D8, "Member 'FATDataAssetGroupBattleInfo::AuraParticleMap' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleInfo, GroupBattleReinforceParameterTable) == 0x000228, "Member 'FATDataAssetGroupBattleInfo::GroupBattleReinforceParameterTable' has a wrong offset!");

// ScriptStruct AT.LoadingGroupBattleAsset
// 0x0250 (0x0250 - 0x0000)
struct FLoadingGroupBattleAsset final
{
public:
	TArray<TSoftObjectPtr<class USkeletalMesh>>   FarMobMeshes;                                      // 0x0000(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SZCDummyAnim;                                      // 0x0010(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SZCDummyMesh;                                      // 0x0038(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimMontage>>    SZCDamageAnim;                                     // 0x0060(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCameraAnim>             SZCCameraAnim;                                     // 0x0070(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SZCOverKillTable;                                  // 0x0098(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SZCOverKillTable2p;                                // 0x00C0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowverKillTableLevel1;                      // 0x00E8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowverKillTableLevel2;                      // 0x0110(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowverKillTableLevel3;                      // 0x0138(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowverKillTableLevel1_DLC5;                 // 0x0160(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowverKillTableLevel2_DLC5;                 // 0x0188(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ZOverthrowverKillTableLevel3_DLC5;                 // 0x01B0(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UParticleSystem>> AuraParticleMap;                                   // 0x01D8(0x0050)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              GroupBattleReinforceParameterTable;                // 0x0228(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingGroupBattleAsset) == 0x000008, "Wrong alignment on FLoadingGroupBattleAsset");
static_assert(sizeof(FLoadingGroupBattleAsset) == 0x000250, "Wrong size on FLoadingGroupBattleAsset");
static_assert(offsetof(FLoadingGroupBattleAsset, FarMobMeshes) == 0x000000, "Member 'FLoadingGroupBattleAsset::FarMobMeshes' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, SZCDummyAnim) == 0x000010, "Member 'FLoadingGroupBattleAsset::SZCDummyAnim' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, SZCDummyMesh) == 0x000038, "Member 'FLoadingGroupBattleAsset::SZCDummyMesh' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, SZCDamageAnim) == 0x000060, "Member 'FLoadingGroupBattleAsset::SZCDamageAnim' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, SZCCameraAnim) == 0x000070, "Member 'FLoadingGroupBattleAsset::SZCCameraAnim' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, SZCOverKillTable) == 0x000098, "Member 'FLoadingGroupBattleAsset::SZCOverKillTable' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, SZCOverKillTable2p) == 0x0000C0, "Member 'FLoadingGroupBattleAsset::SZCOverKillTable2p' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, ZOverthrowverKillTableLevel1) == 0x0000E8, "Member 'FLoadingGroupBattleAsset::ZOverthrowverKillTableLevel1' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, ZOverthrowverKillTableLevel2) == 0x000110, "Member 'FLoadingGroupBattleAsset::ZOverthrowverKillTableLevel2' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, ZOverthrowverKillTableLevel3) == 0x000138, "Member 'FLoadingGroupBattleAsset::ZOverthrowverKillTableLevel3' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, ZOverthrowverKillTableLevel1_DLC5) == 0x000160, "Member 'FLoadingGroupBattleAsset::ZOverthrowverKillTableLevel1_DLC5' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, ZOverthrowverKillTableLevel2_DLC5) == 0x000188, "Member 'FLoadingGroupBattleAsset::ZOverthrowverKillTableLevel2_DLC5' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, ZOverthrowverKillTableLevel3_DLC5) == 0x0001B0, "Member 'FLoadingGroupBattleAsset::ZOverthrowverKillTableLevel3_DLC5' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, AuraParticleMap) == 0x0001D8, "Member 'FLoadingGroupBattleAsset::AuraParticleMap' has a wrong offset!");
static_assert(offsetof(FLoadingGroupBattleAsset, GroupBattleReinforceParameterTable) == 0x000228, "Member 'FLoadingGroupBattleAsset::GroupBattleReinforceParameterTable' has a wrong offset!");

// ScriptStruct AT.MobMoveDataTbl
// 0x0018 (0x0020 - 0x0008)
struct FMobMoveDataTbl final : public FTableRowBase
{
public:
	float                                         CheckPointJRange;                                  // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckPointRandSize;                                // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SetMinRandSize;                                    // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeMaxAngle;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeMinRandAngleSize;                            // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMobMoveDataTbl) == 0x000008, "Wrong alignment on FMobMoveDataTbl");
static_assert(sizeof(FMobMoveDataTbl) == 0x000020, "Wrong size on FMobMoveDataTbl");
static_assert(offsetof(FMobMoveDataTbl, CheckPointJRange) == 0x000008, "Member 'FMobMoveDataTbl::CheckPointJRange' has a wrong offset!");
static_assert(offsetof(FMobMoveDataTbl, CheckPointRandSize) == 0x00000C, "Member 'FMobMoveDataTbl::CheckPointRandSize' has a wrong offset!");
static_assert(offsetof(FMobMoveDataTbl, SetMinRandSize) == 0x000010, "Member 'FMobMoveDataTbl::SetMinRandSize' has a wrong offset!");
static_assert(offsetof(FMobMoveDataTbl, EscapeMaxAngle) == 0x000014, "Member 'FMobMoveDataTbl::EscapeMaxAngle' has a wrong offset!");
static_assert(offsetof(FMobMoveDataTbl, EscapeMinRandAngleSize) == 0x000018, "Member 'FMobMoveDataTbl::EscapeMinRandAngleSize' has a wrong offset!");

// ScriptStruct AT.ATDataAssetGroupBattleOverwriteInfo
// 0x0140 (0x0140 - 0x0000)
struct FATDataAssetGroupBattleOverwriteInfo final
{
public:
	class FName                                   EventBattleID;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USkeletalMesh>>   FarMobMeshes;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SZCDummyAnim;                                      // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SZCDummyMesh;                                      // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimMontage>>    SZCDamageAnim;                                     // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCameraAnim>             SZCCameraAnim;                                     // 0x0078(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SZCOverKillTable;                                  // 0x00A0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              SZCOverKillTable2p;                                // 0x00C8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, TSoftObjectPtr<class UParticleSystem>> AuraParticleMap;                                   // 0x00F0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetGroupBattleOverwriteInfo) == 0x000008, "Wrong alignment on FATDataAssetGroupBattleOverwriteInfo");
static_assert(sizeof(FATDataAssetGroupBattleOverwriteInfo) == 0x000140, "Wrong size on FATDataAssetGroupBattleOverwriteInfo");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, EventBattleID) == 0x000000, "Member 'FATDataAssetGroupBattleOverwriteInfo::EventBattleID' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, FarMobMeshes) == 0x000008, "Member 'FATDataAssetGroupBattleOverwriteInfo::FarMobMeshes' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, SZCDummyAnim) == 0x000018, "Member 'FATDataAssetGroupBattleOverwriteInfo::SZCDummyAnim' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, SZCDummyMesh) == 0x000040, "Member 'FATDataAssetGroupBattleOverwriteInfo::SZCDummyMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, SZCDamageAnim) == 0x000068, "Member 'FATDataAssetGroupBattleOverwriteInfo::SZCDamageAnim' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, SZCCameraAnim) == 0x000078, "Member 'FATDataAssetGroupBattleOverwriteInfo::SZCCameraAnim' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, SZCOverKillTable) == 0x0000A0, "Member 'FATDataAssetGroupBattleOverwriteInfo::SZCOverKillTable' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, SZCOverKillTable2p) == 0x0000C8, "Member 'FATDataAssetGroupBattleOverwriteInfo::SZCOverKillTable2p' has a wrong offset!");
static_assert(offsetof(FATDataAssetGroupBattleOverwriteInfo, AuraParticleMap) == 0x0000F0, "Member 'FATDataAssetGroupBattleOverwriteInfo::AuraParticleMap' has a wrong offset!");

// ScriptStruct AT.EnemyPartyTable
// 0x0120 (0x0128 - 0x0008)
struct FEnemyPartyTable final : public FTableRowBase
{
public:
	class FName                                   EnemyPartyID;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min_Zorb;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Zorb;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevelRate_Min;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevelRate_Max;                                // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_1;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_1;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_1;                                  // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_2;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_2;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_2;                                  // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_3;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_3;                                  // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_3;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_4;                                         // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_4;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_4;                                  // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_5;                                         // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_5;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_5;                                  // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_6;                                         // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_6;                                  // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_6;                                  // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_7;                                         // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_7;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_7;                                  // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_8;                                         // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_8;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_8;                                  // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_9;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_9;                                  // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_9;                                  // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemyID_10;                                        // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Min_10;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyLevel_Max_10;                                 // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupAI_ID;                                        // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PartyName;                                         // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusSymbol;                                 // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend01;                               // 0x00D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend02;                               // 0x00E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend03;                               // 0x00E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend04;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend05;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend06;                               // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend07;                               // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend08;                               // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CharaStatusFriend09;                               // 0x0118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LotNum;                                            // 0x0120(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_AI_ENCOUNT_BEHAVIOR                         EncountType;                                       // 0x0121(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x6];                                      // 0x0122(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEnemyPartyTable) == 0x000008, "Wrong alignment on FEnemyPartyTable");
static_assert(sizeof(FEnemyPartyTable) == 0x000128, "Wrong size on FEnemyPartyTable");
static_assert(offsetof(FEnemyPartyTable, EnemyPartyID) == 0x000008, "Member 'FEnemyPartyTable::EnemyPartyID' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, Min_Zorb) == 0x000010, "Member 'FEnemyPartyTable::Min_Zorb' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, Max_Zorb) == 0x000014, "Member 'FEnemyPartyTable::Max_Zorb' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevelRate_Min) == 0x000018, "Member 'FEnemyPartyTable::EnemyLevelRate_Min' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevelRate_Max) == 0x00001C, "Member 'FEnemyPartyTable::EnemyLevelRate_Max' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_1) == 0x000020, "Member 'FEnemyPartyTable::EnemyID_1' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_1) == 0x000028, "Member 'FEnemyPartyTable::EnemyLevel_Min_1' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_1) == 0x00002C, "Member 'FEnemyPartyTable::EnemyLevel_Max_1' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_2) == 0x000030, "Member 'FEnemyPartyTable::EnemyID_2' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_2) == 0x000038, "Member 'FEnemyPartyTable::EnemyLevel_Min_2' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_2) == 0x00003C, "Member 'FEnemyPartyTable::EnemyLevel_Max_2' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_3) == 0x000040, "Member 'FEnemyPartyTable::EnemyID_3' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_3) == 0x000048, "Member 'FEnemyPartyTable::EnemyLevel_Min_3' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_3) == 0x00004C, "Member 'FEnemyPartyTable::EnemyLevel_Max_3' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_4) == 0x000050, "Member 'FEnemyPartyTable::EnemyID_4' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_4) == 0x000058, "Member 'FEnemyPartyTable::EnemyLevel_Min_4' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_4) == 0x00005C, "Member 'FEnemyPartyTable::EnemyLevel_Max_4' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_5) == 0x000060, "Member 'FEnemyPartyTable::EnemyID_5' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_5) == 0x000068, "Member 'FEnemyPartyTable::EnemyLevel_Min_5' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_5) == 0x00006C, "Member 'FEnemyPartyTable::EnemyLevel_Max_5' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_6) == 0x000070, "Member 'FEnemyPartyTable::EnemyID_6' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_6) == 0x000078, "Member 'FEnemyPartyTable::EnemyLevel_Min_6' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_6) == 0x00007C, "Member 'FEnemyPartyTable::EnemyLevel_Max_6' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_7) == 0x000080, "Member 'FEnemyPartyTable::EnemyID_7' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_7) == 0x000088, "Member 'FEnemyPartyTable::EnemyLevel_Min_7' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_7) == 0x00008C, "Member 'FEnemyPartyTable::EnemyLevel_Max_7' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_8) == 0x000090, "Member 'FEnemyPartyTable::EnemyID_8' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_8) == 0x000098, "Member 'FEnemyPartyTable::EnemyLevel_Min_8' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_8) == 0x00009C, "Member 'FEnemyPartyTable::EnemyLevel_Max_8' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_9) == 0x0000A0, "Member 'FEnemyPartyTable::EnemyID_9' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_9) == 0x0000A8, "Member 'FEnemyPartyTable::EnemyLevel_Min_9' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_9) == 0x0000AC, "Member 'FEnemyPartyTable::EnemyLevel_Max_9' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyID_10) == 0x0000B0, "Member 'FEnemyPartyTable::EnemyID_10' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Min_10) == 0x0000B8, "Member 'FEnemyPartyTable::EnemyLevel_Min_10' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EnemyLevel_Max_10) == 0x0000BC, "Member 'FEnemyPartyTable::EnemyLevel_Max_10' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, GroupAI_ID) == 0x0000C0, "Member 'FEnemyPartyTable::GroupAI_ID' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, PartyName) == 0x0000C8, "Member 'FEnemyPartyTable::PartyName' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusSymbol) == 0x0000D0, "Member 'FEnemyPartyTable::CharaStatusSymbol' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend01) == 0x0000D8, "Member 'FEnemyPartyTable::CharaStatusFriend01' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend02) == 0x0000E0, "Member 'FEnemyPartyTable::CharaStatusFriend02' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend03) == 0x0000E8, "Member 'FEnemyPartyTable::CharaStatusFriend03' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend04) == 0x0000F0, "Member 'FEnemyPartyTable::CharaStatusFriend04' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend05) == 0x0000F8, "Member 'FEnemyPartyTable::CharaStatusFriend05' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend06) == 0x000100, "Member 'FEnemyPartyTable::CharaStatusFriend06' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend07) == 0x000108, "Member 'FEnemyPartyTable::CharaStatusFriend07' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend08) == 0x000110, "Member 'FEnemyPartyTable::CharaStatusFriend08' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, CharaStatusFriend09) == 0x000118, "Member 'FEnemyPartyTable::CharaStatusFriend09' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, LotNum) == 0x000120, "Member 'FEnemyPartyTable::LotNum' has a wrong offset!");
static_assert(offsetof(FEnemyPartyTable, EncountType) == 0x000121, "Member 'FEnemyPartyTable::EncountType' has a wrong offset!");

// ScriptStruct AT.BattleConditionInfo
// 0x0030 (0x0030 - 0x0000)
struct FBattleConditionInfo final
{
public:
	EExCondition                                  ConditionId;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ConditionValue;                                    // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ConditionString;                                   // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETarget                                       Target;                                            // 0x0018(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MessageId;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleConditionInfo) == 0x000008, "Wrong alignment on FBattleConditionInfo");
static_assert(sizeof(FBattleConditionInfo) == 0x000030, "Wrong size on FBattleConditionInfo");
static_assert(offsetof(FBattleConditionInfo, ConditionId) == 0x000000, "Member 'FBattleConditionInfo::ConditionId' has a wrong offset!");
static_assert(offsetof(FBattleConditionInfo, ConditionValue) == 0x000004, "Member 'FBattleConditionInfo::ConditionValue' has a wrong offset!");
static_assert(offsetof(FBattleConditionInfo, ConditionString) == 0x000008, "Member 'FBattleConditionInfo::ConditionString' has a wrong offset!");
static_assert(offsetof(FBattleConditionInfo, Target) == 0x000018, "Member 'FBattleConditionInfo::Target' has a wrong offset!");
static_assert(offsetof(FBattleConditionInfo, MessageId) == 0x000020, "Member 'FBattleConditionInfo::MessageId' has a wrong offset!");

// ScriptStruct AT.ATDataAssetItemInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FATDataAssetItemInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetItemInfo) == 0x000008, "Wrong alignment on FATDataAssetItemInfo");
static_assert(sizeof(FATDataAssetItemInfo) == 0x000008, "Wrong size on FATDataAssetItemInfo");
static_assert(offsetof(FATDataAssetItemInfo, MasterId) == 0x000000, "Member 'FATDataAssetItemInfo::MasterId' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataCarddass
// 0x0038 (0x0040 - 0x0008)
struct FZCompworksUIDataCarddass final : public FTableRowBase
{
public:
	class FName                                   PicturePath;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Rarity;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Vertical;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Title;                                             // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Description;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CardName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Words;                                             // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataCarddass) == 0x000008, "Wrong alignment on FZCompworksUIDataCarddass");
static_assert(sizeof(FZCompworksUIDataCarddass) == 0x000040, "Wrong size on FZCompworksUIDataCarddass");
static_assert(offsetof(FZCompworksUIDataCarddass, PicturePath) == 0x000008, "Member 'FZCompworksUIDataCarddass::PicturePath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataCarddass, Rarity) == 0x000010, "Member 'FZCompworksUIDataCarddass::Rarity' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataCarddass, Vertical) == 0x000018, "Member 'FZCompworksUIDataCarddass::Vertical' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataCarddass, Title) == 0x000020, "Member 'FZCompworksUIDataCarddass::Title' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataCarddass, Description) == 0x000028, "Member 'FZCompworksUIDataCarddass::Description' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataCarddass, CardName) == 0x000030, "Member 'FZCompworksUIDataCarddass::CardName' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataCarddass, Words) == 0x000038, "Member 'FZCompworksUIDataCarddass::Words' has a wrong offset!");

// ScriptStruct AT.ATDataAssetJostleBeamInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetJostleBeamInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ATJostleBeamParam;                                 // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetJostleBeamInfo) == 0x000008, "Wrong alignment on FATDataAssetJostleBeamInfo");
static_assert(sizeof(FATDataAssetJostleBeamInfo) == 0x000030, "Wrong size on FATDataAssetJostleBeamInfo");
static_assert(offsetof(FATDataAssetJostleBeamInfo, MasterId) == 0x000000, "Member 'FATDataAssetJostleBeamInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetJostleBeamInfo, ATJostleBeamParam) == 0x000008, "Member 'FATDataAssetJostleBeamInfo::ATJostleBeamParam' has a wrong offset!");

// ScriptStruct AT.BattleMissionInfo
// 0x0030 (0x0030 - 0x0000)
struct FBattleMissionInfo final
{
public:
	EExMission                                    MissionId;                                         // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionValue;                                      // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MissionDifficulty;                                 // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropGroupID;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageId;                                         // 0x0018(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          M_bSuccess;                                        // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MissionNowValue;                                   // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleMissionInfo) == 0x000008, "Wrong alignment on FBattleMissionInfo");
static_assert(sizeof(FBattleMissionInfo) == 0x000030, "Wrong size on FBattleMissionInfo");
static_assert(offsetof(FBattleMissionInfo, MissionId) == 0x000000, "Member 'FBattleMissionInfo::MissionId' has a wrong offset!");
static_assert(offsetof(FBattleMissionInfo, MissionValue) == 0x000004, "Member 'FBattleMissionInfo::MissionValue' has a wrong offset!");
static_assert(offsetof(FBattleMissionInfo, MissionDifficulty) == 0x000008, "Member 'FBattleMissionInfo::MissionDifficulty' has a wrong offset!");
static_assert(offsetof(FBattleMissionInfo, DropGroupID) == 0x000010, "Member 'FBattleMissionInfo::DropGroupID' has a wrong offset!");
static_assert(offsetof(FBattleMissionInfo, MessageId) == 0x000018, "Member 'FBattleMissionInfo::MessageId' has a wrong offset!");
static_assert(offsetof(FBattleMissionInfo, M_bSuccess) == 0x000028, "Member 'FBattleMissionInfo::M_bSuccess' has a wrong offset!");
static_assert(offsetof(FBattleMissionInfo, MissionNowValue) == 0x00002C, "Member 'FBattleMissionInfo::MissionNowValue' has a wrong offset!");

// ScriptStruct AT.EventBattleVictoryConditions
// 0x0008 (0x0008 - 0x0000)
struct FEventBattleVictoryConditions final
{
public:
	EEVENTBATTLE_VICTORY_CONDITIONS               ConditionId;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleVictoryConditions) == 0x000004, "Wrong alignment on FEventBattleVictoryConditions");
static_assert(sizeof(FEventBattleVictoryConditions) == 0x000008, "Wrong size on FEventBattleVictoryConditions");
static_assert(offsetof(FEventBattleVictoryConditions, ConditionId) == 0x000000, "Member 'FEventBattleVictoryConditions::ConditionId' has a wrong offset!");
static_assert(offsetof(FEventBattleVictoryConditions, Value) == 0x000004, "Member 'FEventBattleVictoryConditions::Value' has a wrong offset!");

// ScriptStruct AT.EventBattleDefeatConditions
// 0x0008 (0x0008 - 0x0000)
struct FEventBattleDefeatConditions final
{
public:
	EEVENTBATTLE_DEFEAT_CONDITIONS                ConditionId;                                       // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleDefeatConditions) == 0x000004, "Wrong alignment on FEventBattleDefeatConditions");
static_assert(sizeof(FEventBattleDefeatConditions) == 0x000008, "Wrong size on FEventBattleDefeatConditions");
static_assert(offsetof(FEventBattleDefeatConditions, ConditionId) == 0x000000, "Member 'FEventBattleDefeatConditions::ConditionId' has a wrong offset!");
static_assert(offsetof(FEventBattleDefeatConditions, Value) == 0x000004, "Member 'FEventBattleDefeatConditions::Value' has a wrong offset!");

// ScriptStruct AT.EventBattleEnemyInfo
// 0x0090 (0x0090 - 0x0000)
struct FEventBattleEnemyInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StatusTableSuffix;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OverwriteNameId;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x001C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x001D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         AuraId;                                            // 0x001E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F[0x1];                                       // 0x001F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HPRate;                                            // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverwriteBattleAI;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleAISuffix;                                    // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseReplicateAI;                                   // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ActTablePhase;                                     // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEVENTBATTLE_DEATH_REACTION                   DeathReactionID;                                   // 0x0042(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverwriteSkillPalette;                             // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UATFightingPowerParam>      FightingPowerParamClass;                           // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakRecoverValue;                                // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBreakRecoverValue;                                // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakRecoverIntervalTime;                         // 0x0068(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBreakRecoverIntervalTime;                         // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakRecoverStartTime;                            // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBreakRecoverStartTime;                            // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakTime;                                        // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBreakTime;                                        // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakDamageRate;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBreakDamageRate;                                  // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakCriticalRate;                                // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FBreakCriticalRate;                                // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleEnemyInfo) == 0x000008, "Wrong alignment on FEventBattleEnemyInfo");
static_assert(sizeof(FEventBattleEnemyInfo) == 0x000090, "Wrong size on FEventBattleEnemyInfo");
static_assert(offsetof(FEventBattleEnemyInfo, MasterId) == 0x000000, "Member 'FEventBattleEnemyInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, StatusTableSuffix) == 0x000008, "Member 'FEventBattleEnemyInfo::StatusTableSuffix' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, OverwriteNameId) == 0x000010, "Member 'FEventBattleEnemyInfo::OverwriteNameId' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, Level) == 0x000018, "Member 'FEventBattleEnemyInfo::Level' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, VariationId) == 0x00001C, "Member 'FEventBattleEnemyInfo::VariationId' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FormID) == 0x00001D, "Member 'FEventBattleEnemyInfo::FormID' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, AuraId) == 0x00001E, "Member 'FEventBattleEnemyInfo::AuraId' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, HPRate) == 0x000020, "Member 'FEventBattleEnemyInfo::HPRate' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, OverwriteBattleAI) == 0x000028, "Member 'FEventBattleEnemyInfo::OverwriteBattleAI' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, BattleAISuffix) == 0x000038, "Member 'FEventBattleEnemyInfo::BattleAISuffix' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bUseReplicateAI) == 0x000040, "Member 'FEventBattleEnemyInfo::bUseReplicateAI' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, ActTablePhase) == 0x000041, "Member 'FEventBattleEnemyInfo::ActTablePhase' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, DeathReactionID) == 0x000042, "Member 'FEventBattleEnemyInfo::DeathReactionID' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, OverwriteSkillPalette) == 0x000048, "Member 'FEventBattleEnemyInfo::OverwriteSkillPalette' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FightingPowerParamClass) == 0x000058, "Member 'FEventBattleEnemyInfo::FightingPowerParamClass' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bBreakRecoverValue) == 0x000060, "Member 'FEventBattleEnemyInfo::bBreakRecoverValue' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FBreakRecoverValue) == 0x000064, "Member 'FEventBattleEnemyInfo::FBreakRecoverValue' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bBreakRecoverIntervalTime) == 0x000068, "Member 'FEventBattleEnemyInfo::bBreakRecoverIntervalTime' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FBreakRecoverIntervalTime) == 0x00006C, "Member 'FEventBattleEnemyInfo::FBreakRecoverIntervalTime' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bBreakRecoverStartTime) == 0x000070, "Member 'FEventBattleEnemyInfo::bBreakRecoverStartTime' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FBreakRecoverStartTime) == 0x000074, "Member 'FEventBattleEnemyInfo::FBreakRecoverStartTime' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bBreakTime) == 0x000078, "Member 'FEventBattleEnemyInfo::bBreakTime' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FBreakTime) == 0x00007C, "Member 'FEventBattleEnemyInfo::FBreakTime' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bBreakDamageRate) == 0x000080, "Member 'FEventBattleEnemyInfo::bBreakDamageRate' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FBreakDamageRate) == 0x000084, "Member 'FEventBattleEnemyInfo::FBreakDamageRate' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, bBreakCriticalRate) == 0x000088, "Member 'FEventBattleEnemyInfo::bBreakCriticalRate' has a wrong offset!");
static_assert(offsetof(FEventBattleEnemyInfo, FBreakCriticalRate) == 0x00008C, "Member 'FEventBattleEnemyInfo::FBreakCriticalRate' has a wrong offset!");

// ScriptStruct AT.EventBattleInfo
// 0x01A0 (0x01A0 - 0x0000)
struct FEventBattleInfo final
{
public:
	EEVENTBATTLE_PERFORMANCE                      PerformanceID;                                     // 0x0000(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   InGameDemoName;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           BattleDemoId;                                      // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	EEventBattleMode                              BattleMode;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEventBattleFinishBlow                        BattleFinishBlow;                                  // 0x0021(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFaceActionBackFormChange;                         // 0x0022(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventBattleVictoryConditions>  VictoryConditionTbl;                               // 0x0028(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEventBattleDefeatConditions>   DefeatConditionTbl;                                // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEventBattleVictoryConditions>  LotteryConstConditionTbl;                          // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEventBattleVictoryConditions>  LotteryRandomConditionTbl;                         // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         LotteryRandomConditionNum;                         // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEventBattleVictoryConditions>  LotteryRandomConditionTbl2;                        // 0x0070(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         LotteryRandomConditionNum2;                        // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DropGroupID;                                       // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Red;                                          // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Blue;                                         // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Green;                                        // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Rainbow;                                      // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Super;                                        // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrb_Ultimate;                                     // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      BattleBgmID;                                       // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DesignatedCharacterNameId;                         // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FEventBattleEnemyInfo>          EnemyInfoTbl;                                      // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGroupBattleInfo                       GroupBattleInfo;                                   // 0x00C8(0x0020)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   GroupAI_ID;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroupAITickStop;                                  // 0x00F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	ECREATE_CHARACTER_TYPE                        CreateType;                                        // 0x00F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableResult;                                     // 0x00F8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableFadeOut;                                    // 0x00F9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUMG_FADE_COLOR                               FadeColor;                                         // 0x00FA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FB[0x5];                                       // 0x00FB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ExitConditionsMsgID;                               // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBattleConditionInfo>           BattleConditions;                                  // 0x0110(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FBattleMissionInfo>             BattleMissions;                                    // 0x0120(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   DisableFormChangeID;                               // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHeatUp;                                       // 0x0138(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillDarkEffect;                                  // 0x0139(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRematchable;                                      // 0x013A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanRetire;                                        // 0x013B(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFormChangeWithHeatUp;                             // 0x013C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipGameOverMenu;                                 // 0x013D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkillLoadTurnChange;                              // 0x013E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13F[0x1];                                      // 0x013F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MobPlaceDummyId;                                   // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, class FName>                MobPlacePattern;                                   // 0x0148(0x0050)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   TipsId;                                            // 0x0198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleInfo) == 0x000008, "Wrong alignment on FEventBattleInfo");
static_assert(sizeof(FEventBattleInfo) == 0x0001A0, "Wrong size on FEventBattleInfo");
static_assert(offsetof(FEventBattleInfo, PerformanceID) == 0x000000, "Member 'FEventBattleInfo::PerformanceID' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, InGameDemoName) == 0x000008, "Member 'FEventBattleInfo::InGameDemoName' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, BattleDemoId) == 0x000010, "Member 'FEventBattleInfo::BattleDemoId' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, BattleMode) == 0x000020, "Member 'FEventBattleInfo::BattleMode' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, BattleFinishBlow) == 0x000021, "Member 'FEventBattleInfo::BattleFinishBlow' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bFaceActionBackFormChange) == 0x000022, "Member 'FEventBattleInfo::bFaceActionBackFormChange' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, VictoryConditionTbl) == 0x000028, "Member 'FEventBattleInfo::VictoryConditionTbl' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, DefeatConditionTbl) == 0x000038, "Member 'FEventBattleInfo::DefeatConditionTbl' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, LotteryConstConditionTbl) == 0x000048, "Member 'FEventBattleInfo::LotteryConstConditionTbl' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, LotteryRandomConditionTbl) == 0x000058, "Member 'FEventBattleInfo::LotteryRandomConditionTbl' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, LotteryRandomConditionNum) == 0x000068, "Member 'FEventBattleInfo::LotteryRandomConditionNum' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, LotteryRandomConditionTbl2) == 0x000070, "Member 'FEventBattleInfo::LotteryRandomConditionTbl2' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, LotteryRandomConditionNum2) == 0x000080, "Member 'FEventBattleInfo::LotteryRandomConditionNum2' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, Experience) == 0x000084, "Member 'FEventBattleInfo::Experience' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, DropGroupID) == 0x000088, "Member 'FEventBattleInfo::DropGroupID' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ZOrb_Red) == 0x000090, "Member 'FEventBattleInfo::ZOrb_Red' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ZOrb_Blue) == 0x000094, "Member 'FEventBattleInfo::ZOrb_Blue' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ZOrb_Green) == 0x000098, "Member 'FEventBattleInfo::ZOrb_Green' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ZOrb_Rainbow) == 0x00009C, "Member 'FEventBattleInfo::ZOrb_Rainbow' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ZOrb_Super) == 0x0000A0, "Member 'FEventBattleInfo::ZOrb_Super' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ZOrb_Ultimate) == 0x0000A4, "Member 'FEventBattleInfo::ZOrb_Ultimate' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, BattleBgmID) == 0x0000A8, "Member 'FEventBattleInfo::BattleBgmID' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, DesignatedCharacterNameId) == 0x0000B0, "Member 'FEventBattleInfo::DesignatedCharacterNameId' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, EnemyInfoTbl) == 0x0000B8, "Member 'FEventBattleInfo::EnemyInfoTbl' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, GroupBattleInfo) == 0x0000C8, "Member 'FEventBattleInfo::GroupBattleInfo' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, GroupAI_ID) == 0x0000E8, "Member 'FEventBattleInfo::GroupAI_ID' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bGroupAITickStop) == 0x0000F0, "Member 'FEventBattleInfo::bGroupAITickStop' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, CreateType) == 0x0000F4, "Member 'FEventBattleInfo::CreateType' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bEnableResult) == 0x0000F8, "Member 'FEventBattleInfo::bEnableResult' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bEnableFadeOut) == 0x0000F9, "Member 'FEventBattleInfo::bEnableFadeOut' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, FadeColor) == 0x0000FA, "Member 'FEventBattleInfo::FadeColor' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, ExitConditionsMsgID) == 0x000100, "Member 'FEventBattleInfo::ExitConditionsMsgID' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, BattleConditions) == 0x000110, "Member 'FEventBattleInfo::BattleConditions' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, BattleMissions) == 0x000120, "Member 'FEventBattleInfo::BattleMissions' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, DisableFormChangeID) == 0x000130, "Member 'FEventBattleInfo::DisableFormChangeID' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bAutoHeatUp) == 0x000138, "Member 'FEventBattleInfo::bAutoHeatUp' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bSkillDarkEffect) == 0x000139, "Member 'FEventBattleInfo::bSkillDarkEffect' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bRematchable) == 0x00013A, "Member 'FEventBattleInfo::bRematchable' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bCanRetire) == 0x00013B, "Member 'FEventBattleInfo::bCanRetire' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bFormChangeWithHeatUp) == 0x00013C, "Member 'FEventBattleInfo::bFormChangeWithHeatUp' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bSkipGameOverMenu) == 0x00013D, "Member 'FEventBattleInfo::bSkipGameOverMenu' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, bSkillLoadTurnChange) == 0x00013E, "Member 'FEventBattleInfo::bSkillLoadTurnChange' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, MobPlaceDummyId) == 0x000140, "Member 'FEventBattleInfo::MobPlaceDummyId' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, MobPlacePattern) == 0x000148, "Member 'FEventBattleInfo::MobPlacePattern' has a wrong offset!");
static_assert(offsetof(FEventBattleInfo, TipsId) == 0x000198, "Member 'FEventBattleInfo::TipsId' has a wrong offset!");

// ScriptStruct AT.EventBattleParam
// 0x01A0 (0x01A8 - 0x0008)
struct FEventBattleParam final : public FTableRowBase
{
public:
	struct FEventBattleInfo                       EventBattleParam;                                  // 0x0008(0x01A0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleParam) == 0x000008, "Wrong alignment on FEventBattleParam");
static_assert(sizeof(FEventBattleParam) == 0x0001A8, "Wrong size on FEventBattleParam");
static_assert(offsetof(FEventBattleParam, EventBattleParam) == 0x000008, "Member 'FEventBattleParam::EventBattleParam' has a wrong offset!");

// ScriptStruct AT.ReferenceToJostleBeamAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToJostleBeamAssetInstance final
{
public:
	class UClass*                                 ATJostleBeamParam;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToJostleBeamAssetInstance) == 0x000008, "Wrong alignment on FReferenceToJostleBeamAssetInstance");
static_assert(sizeof(FReferenceToJostleBeamAssetInstance) == 0x000008, "Wrong size on FReferenceToJostleBeamAssetInstance");
static_assert(offsetof(FReferenceToJostleBeamAssetInstance, ATJostleBeamParam) == 0x000000, "Member 'FReferenceToJostleBeamAssetInstance::ATJostleBeamParam' has a wrong offset!");

// ScriptStruct AT.ATDataAssetMechaDevInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetMechaDevInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 AssetType;                                         // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetMechaDevInfo) == 0x000008, "Wrong alignment on FATDataAssetMechaDevInfo");
static_assert(sizeof(FATDataAssetMechaDevInfo) == 0x000030, "Wrong size on FATDataAssetMechaDevInfo");
static_assert(offsetof(FATDataAssetMechaDevInfo, MasterId) == 0x000000, "Member 'FATDataAssetMechaDevInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetMechaDevInfo, AssetType) == 0x000008, "Member 'FATDataAssetMechaDevInfo::AssetType' has a wrong offset!");

// ScriptStruct AT.NpcMultipurposeInfo
// 0x0018 (0x0018 - 0x0000)
struct FNpcMultipurposeInfo final
{
public:
	int32                                         IntValue;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FloatValue;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMultipurposeInfo) == 0x000008, "Wrong alignment on FNpcMultipurposeInfo");
static_assert(sizeof(FNpcMultipurposeInfo) == 0x000018, "Wrong size on FNpcMultipurposeInfo");
static_assert(offsetof(FNpcMultipurposeInfo, IntValue) == 0x000000, "Member 'FNpcMultipurposeInfo::IntValue' has a wrong offset!");
static_assert(offsetof(FNpcMultipurposeInfo, FloatValue) == 0x000004, "Member 'FNpcMultipurposeInfo::FloatValue' has a wrong offset!");
static_assert(offsetof(FNpcMultipurposeInfo, Comment) == 0x000008, "Member 'FNpcMultipurposeInfo::Comment' has a wrong offset!");

// ScriptStruct AT.NpcMultipurposeTable
// 0x0050 (0x0058 - 0x0008)
struct FNpcMultipurposeTable final : public FTableRowBase
{
public:
	TMap<class FName, struct FNpcMultipurposeInfo> Parameter;                                         // 0x0008(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMultipurposeTable) == 0x000008, "Wrong alignment on FNpcMultipurposeTable");
static_assert(sizeof(FNpcMultipurposeTable) == 0x000058, "Wrong size on FNpcMultipurposeTable");
static_assert(offsetof(FNpcMultipurposeTable, Parameter) == 0x000008, "Member 'FNpcMultipurposeTable::Parameter' has a wrong offset!");

// ScriptStruct AT.ReferenceToMechaDevAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToMechaDevAssetInstance final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToMechaDevAssetInstance) == 0x000008, "Wrong alignment on FReferenceToMechaDevAssetInstance");
static_assert(sizeof(FReferenceToMechaDevAssetInstance) == 0x000008, "Wrong size on FReferenceToMechaDevAssetInstance");
static_assert(offsetof(FReferenceToMechaDevAssetInstance, Object) == 0x000000, "Member 'FReferenceToMechaDevAssetInstance::Object' has a wrong offset!");

// ScriptStruct AT.ReferenceToMiniGameMobMeshInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToMiniGameMobMeshInstance final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToMiniGameMobMeshInstance) == 0x000008, "Wrong alignment on FReferenceToMiniGameMobMeshInstance");
static_assert(sizeof(FReferenceToMiniGameMobMeshInstance) == 0x000008, "Wrong size on FReferenceToMiniGameMobMeshInstance");
static_assert(offsetof(FReferenceToMiniGameMobMeshInstance, Mesh) == 0x000000, "Member 'FReferenceToMiniGameMobMeshInstance::Mesh' has a wrong offset!");

// ScriptStruct AT.LoadingMiniGameMobMesh
// 0x0028 (0x0028 - 0x0000)
struct FLoadingMiniGameMobMesh final
{
public:
	TSoftObjectPtr<class USkeletalMesh>           Mesh;                                              // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingMiniGameMobMesh) == 0x000008, "Wrong alignment on FLoadingMiniGameMobMesh");
static_assert(sizeof(FLoadingMiniGameMobMesh) == 0x000028, "Wrong size on FLoadingMiniGameMobMesh");
static_assert(offsetof(FLoadingMiniGameMobMesh, Mesh) == 0x000000, "Member 'FLoadingMiniGameMobMesh::Mesh' has a wrong offset!");

// ScriptStruct AT.LoadingMiniGameMobAnimBP
// 0x0028 (0x0028 - 0x0000)
struct FLoadingMiniGameMobAnimBP final
{
public:
	TSoftClassPtr<class UClass>                   AnimBP;                                            // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingMiniGameMobAnimBP) == 0x000008, "Wrong alignment on FLoadingMiniGameMobAnimBP");
static_assert(sizeof(FLoadingMiniGameMobAnimBP) == 0x000028, "Wrong size on FLoadingMiniGameMobAnimBP");
static_assert(offsetof(FLoadingMiniGameMobAnimBP, AnimBP) == 0x000000, "Member 'FLoadingMiniGameMobAnimBP::AnimBP' has a wrong offset!");

// ScriptStruct AT.ShadowData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x04) FShadowData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShadowData) == 0x000004, "Wrong alignment on FShadowData");
static_assert(sizeof(FShadowData) == 0x000018, "Wrong size on FShadowData");

// ScriptStruct AT.NpcFightingSetting
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FNpcFightingSetting final
{
public:
	class FName                                   StartQuestId;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartPhaseNo;                                      // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndPhaseNo;                                        // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENpcFightingPowerType                         Type;                                              // 0x001C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Power;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcFightingSetting) == 0x000008, "Wrong alignment on FNpcFightingSetting");
static_assert(sizeof(FNpcFightingSetting) == 0x000028, "Wrong size on FNpcFightingSetting");
static_assert(offsetof(FNpcFightingSetting, StartQuestId) == 0x000000, "Member 'FNpcFightingSetting::StartQuestId' has a wrong offset!");
static_assert(offsetof(FNpcFightingSetting, StartPhaseNo) == 0x000008, "Member 'FNpcFightingSetting::StartPhaseNo' has a wrong offset!");
static_assert(offsetof(FNpcFightingSetting, EndQuestId) == 0x000010, "Member 'FNpcFightingSetting::EndQuestId' has a wrong offset!");
static_assert(offsetof(FNpcFightingSetting, EndPhaseNo) == 0x000018, "Member 'FNpcFightingSetting::EndPhaseNo' has a wrong offset!");
static_assert(offsetof(FNpcFightingSetting, Type) == 0x00001C, "Member 'FNpcFightingSetting::Type' has a wrong offset!");
static_assert(offsetof(FNpcFightingSetting, Power) == 0x000020, "Member 'FNpcFightingSetting::Power' has a wrong offset!");

// ScriptStruct AT.LoadingQuestAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingQuestAsset final
{
public:
	TSoftObjectPtr<class UDataTable>              DataTable;                                         // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingQuestAsset) == 0x000008, "Wrong alignment on FLoadingQuestAsset");
static_assert(sizeof(FLoadingQuestAsset) == 0x000028, "Wrong size on FLoadingQuestAsset");
static_assert(offsetof(FLoadingQuestAsset, DataTable) == 0x000000, "Member 'FLoadingQuestAsset::DataTable' has a wrong offset!");

// ScriptStruct AT.AuraMaterialColorInfo
// 0x00E8 (0x00E8 - 0x0000)
struct alignas(0x08) FAuraMaterialColorInfo final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WhiteColor[0x7];                                   // 0x0008(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           BlackColor[0x7];                                   // 0x0078(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAuraMaterialColorInfo) == 0x000008, "Wrong alignment on FAuraMaterialColorInfo");
static_assert(sizeof(FAuraMaterialColorInfo) == 0x0000E8, "Wrong size on FAuraMaterialColorInfo");
static_assert(offsetof(FAuraMaterialColorInfo, MaterialSlotName) == 0x000000, "Member 'FAuraMaterialColorInfo::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(FAuraMaterialColorInfo, WhiteColor) == 0x000008, "Member 'FAuraMaterialColorInfo::WhiteColor' has a wrong offset!");
static_assert(offsetof(FAuraMaterialColorInfo, BlackColor) == 0x000078, "Member 'FAuraMaterialColorInfo::BlackColor' has a wrong offset!");

// ScriptStruct AT.ATDragonBallSpawnIgnoreProgress
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FATDragonBallSpawnIgnoreProgress final
{
public:
	class FName                                   StartProgress;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndProgress;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDragonBallSpawnIgnoreProgress) == 0x000008, "Wrong alignment on FATDragonBallSpawnIgnoreProgress");
static_assert(sizeof(FATDragonBallSpawnIgnoreProgress) == 0x000010, "Wrong size on FATDragonBallSpawnIgnoreProgress");
static_assert(offsetof(FATDragonBallSpawnIgnoreProgress, StartProgress) == 0x000000, "Member 'FATDragonBallSpawnIgnoreProgress::StartProgress' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnIgnoreProgress, EndProgress) == 0x000008, "Member 'FATDragonBallSpawnIgnoreProgress::EndProgress' has a wrong offset!");

// ScriptStruct AT.ATDragonBallSpawnGroupInfo
// 0x0030 (0x0038 - 0x0008)
struct FATDragonBallSpawnGroupInfo final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaIndex;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Lv;                                                // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DlcId;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FATDragonBallSpawnIgnoreProgress> IgnoreProgress;                                    // 0x0018(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ActiveQuestId;                                     // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDragonBallSpawnGroupInfo) == 0x000008, "Wrong alignment on FATDragonBallSpawnGroupInfo");
static_assert(sizeof(FATDragonBallSpawnGroupInfo) == 0x000038, "Wrong size on FATDragonBallSpawnGroupInfo");
static_assert(offsetof(FATDragonBallSpawnGroupInfo, AreaIndex) == 0x000008, "Member 'FATDragonBallSpawnGroupInfo::AreaIndex' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnGroupInfo, Lv) == 0x00000C, "Member 'FATDragonBallSpawnGroupInfo::Lv' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnGroupInfo, DlcId) == 0x000010, "Member 'FATDragonBallSpawnGroupInfo::DlcId' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnGroupInfo, IgnoreProgress) == 0x000018, "Member 'FATDragonBallSpawnGroupInfo::IgnoreProgress' has a wrong offset!");
static_assert(offsetof(FATDragonBallSpawnGroupInfo, ActiveQuestId) == 0x000028, "Member 'FATDragonBallSpawnGroupInfo::ActiveQuestId' has a wrong offset!");

// ScriptStruct AT.ATDataAssetRaceGameAssistantInfo
// 0x0028 (0x0028 - 0x0000)
struct FATDataAssetRaceGameAssistantInfo final
{
public:
	TSoftClassPtr<class UClass>                   AssistantMobActor;                                 // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetRaceGameAssistantInfo) == 0x000008, "Wrong alignment on FATDataAssetRaceGameAssistantInfo");
static_assert(sizeof(FATDataAssetRaceGameAssistantInfo) == 0x000028, "Wrong size on FATDataAssetRaceGameAssistantInfo");
static_assert(offsetof(FATDataAssetRaceGameAssistantInfo, AssistantMobActor) == 0x000000, "Member 'FATDataAssetRaceGameAssistantInfo::AssistantMobActor' has a wrong offset!");

// ScriptStruct AT.RootMenuInvalidTableRow
// 0x0020 (0x0028 - 0x0008)
struct FRootMenuInvalidTableRow final : public FTableRowBase
{
public:
	class FName                                   BeginPhaseId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndPhaseId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESTART_TOP_LIST_ID                            MenuItemId;                                        // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WarningMessageId;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRootMenuInvalidTableRow) == 0x000008, "Wrong alignment on FRootMenuInvalidTableRow");
static_assert(sizeof(FRootMenuInvalidTableRow) == 0x000028, "Wrong size on FRootMenuInvalidTableRow");
static_assert(offsetof(FRootMenuInvalidTableRow, BeginPhaseId) == 0x000008, "Member 'FRootMenuInvalidTableRow::BeginPhaseId' has a wrong offset!");
static_assert(offsetof(FRootMenuInvalidTableRow, EndPhaseId) == 0x000010, "Member 'FRootMenuInvalidTableRow::EndPhaseId' has a wrong offset!");
static_assert(offsetof(FRootMenuInvalidTableRow, MenuItemId) == 0x000018, "Member 'FRootMenuInvalidTableRow::MenuItemId' has a wrong offset!");
static_assert(offsetof(FRootMenuInvalidTableRow, WarningMessageId) == 0x000020, "Member 'FRootMenuInvalidTableRow::WarningMessageId' has a wrong offset!");

// ScriptStruct AT.ReferenceToRaceGameAssistantAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToRaceGameAssistantAssetInstance final
{
public:
	TSubclassOf<class AActor>                     AssistantMobActor;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToRaceGameAssistantAssetInstance) == 0x000008, "Wrong alignment on FReferenceToRaceGameAssistantAssetInstance");
static_assert(sizeof(FReferenceToRaceGameAssistantAssetInstance) == 0x000008, "Wrong size on FReferenceToRaceGameAssistantAssetInstance");
static_assert(offsetof(FReferenceToRaceGameAssistantAssetInstance, AssistantMobActor) == 0x000000, "Member 'FReferenceToRaceGameAssistantAssetInstance::AssistantMobActor' has a wrong offset!");

// ScriptStruct AT.FullCourseMealParam
// 0x0010 (0x0018 - 0x0008)
struct FFullCourseMealParam final : public FTableRowBase
{
public:
	EFoodList                                     MainFood;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     MainMealType;                                      // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     MainMealTypeSaiyan;                                // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoodList                                     SubFood1;                                          // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType1;                                      // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType1Saiyan;                                // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoodList                                     SubFood2;                                          // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType2;                                      // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType2Saiyan;                                // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoodList                                     SubFood3;                                          // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType3;                                      // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType3Saiyan;                                // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoodList                                     SubFood4;                                          // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType4;                                      // 0x0015(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMealType                                     SubMealType4Saiyan;                                // 0x0016(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17[0x1];                                       // 0x0017(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFullCourseMealParam) == 0x000008, "Wrong alignment on FFullCourseMealParam");
static_assert(sizeof(FFullCourseMealParam) == 0x000018, "Wrong size on FFullCourseMealParam");
static_assert(offsetof(FFullCourseMealParam, MainFood) == 0x000008, "Member 'FFullCourseMealParam::MainFood' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, MainMealType) == 0x000009, "Member 'FFullCourseMealParam::MainMealType' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, MainMealTypeSaiyan) == 0x00000A, "Member 'FFullCourseMealParam::MainMealTypeSaiyan' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubFood1) == 0x00000B, "Member 'FFullCourseMealParam::SubFood1' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType1) == 0x00000C, "Member 'FFullCourseMealParam::SubMealType1' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType1Saiyan) == 0x00000D, "Member 'FFullCourseMealParam::SubMealType1Saiyan' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubFood2) == 0x00000E, "Member 'FFullCourseMealParam::SubFood2' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType2) == 0x00000F, "Member 'FFullCourseMealParam::SubMealType2' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType2Saiyan) == 0x000010, "Member 'FFullCourseMealParam::SubMealType2Saiyan' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubFood3) == 0x000011, "Member 'FFullCourseMealParam::SubFood3' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType3) == 0x000012, "Member 'FFullCourseMealParam::SubMealType3' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType3Saiyan) == 0x000013, "Member 'FFullCourseMealParam::SubMealType3Saiyan' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubFood4) == 0x000014, "Member 'FFullCourseMealParam::SubFood4' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType4) == 0x000015, "Member 'FFullCourseMealParam::SubMealType4' has a wrong offset!");
static_assert(offsetof(FFullCourseMealParam, SubMealType4Saiyan) == 0x000016, "Member 'FFullCourseMealParam::SubMealType4Saiyan' has a wrong offset!");

// ScriptStruct AT.LoadingRaceGameAssistantAsset
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLoadingRaceGameAssistantAsset final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadingRaceGameAssistantAsset) == 0x000008, "Wrong alignment on FLoadingRaceGameAssistantAsset");
static_assert(sizeof(FLoadingRaceGameAssistantAsset) == 0x000028, "Wrong size on FLoadingRaceGameAssistantAsset");

// ScriptStruct AT.ExperienceReplay
// 0x0010 (0x0010 - 0x0000)
struct FExperienceReplay final
{
public:
	float                                         ExperienceRate;                                    // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DecreaseBattleID;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExperienceReplay) == 0x000008, "Wrong alignment on FExperienceReplay");
static_assert(sizeof(FExperienceReplay) == 0x000010, "Wrong size on FExperienceReplay");
static_assert(offsetof(FExperienceReplay, ExperienceRate) == 0x000000, "Member 'FExperienceReplay::ExperienceRate' has a wrong offset!");
static_assert(offsetof(FExperienceReplay, DecreaseBattleID) == 0x000008, "Member 'FExperienceReplay::DecreaseBattleID' has a wrong offset!");

// ScriptStruct AT.BaseballMobTable
// 0x0008 (0x0010 - 0x0008)
struct FBaseballMobTable final : public FTableRowBase
{
public:
	class FName                                   PresetID;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseballMobTable) == 0x000008, "Wrong alignment on FBaseballMobTable");
static_assert(sizeof(FBaseballMobTable) == 0x000010, "Wrong size on FBaseballMobTable");
static_assert(offsetof(FBaseballMobTable, PresetID) == 0x000008, "Member 'FBaseballMobTable::PresetID' has a wrong offset!");

// ScriptStruct AT.ReferenceToRaceGameAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToRaceGameAssetInstance final
{
public:
	class UAnimMontage*                           Result_Montage;                                    // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToRaceGameAssetInstance) == 0x000008, "Wrong alignment on FReferenceToRaceGameAssetInstance");
static_assert(sizeof(FReferenceToRaceGameAssetInstance) == 0x000008, "Wrong size on FReferenceToRaceGameAssetInstance");
static_assert(offsetof(FReferenceToRaceGameAssetInstance, Result_Montage) == 0x000000, "Member 'FReferenceToRaceGameAssetInstance::Result_Montage' has a wrong offset!");

// ScriptStruct AT.ATDataTableSound
// 0x0030 (0x0038 - 0x0008)
struct FATDataTableSound final : public FTableRowBase
{
public:
	ESndAcbId                                     ID;                                                // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               CharCode;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundAtomCueSheet>      CueSheet;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataTableSound) == 0x000008, "Wrong alignment on FATDataTableSound");
static_assert(sizeof(FATDataTableSound) == 0x000038, "Wrong size on FATDataTableSound");
static_assert(offsetof(FATDataTableSound, ID) == 0x000008, "Member 'FATDataTableSound::ID' has a wrong offset!");
static_assert(offsetof(FATDataTableSound, CharCode) == 0x000009, "Member 'FATDataTableSound::CharCode' has a wrong offset!");
static_assert(offsetof(FATDataTableSound, CueSheet) == 0x000010, "Member 'FATDataTableSound::CueSheet' has a wrong offset!");

// ScriptStruct AT.AuraColorInfo
// 0x0030 (0x0030 - 0x0000)
struct FAuraColorInfo final
{
public:
	float                                         PowerCompare[0x7];                                 // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAuraMaterialColorInfo>         MaterialColor;                                     // 0x0020(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAuraColorInfo) == 0x000008, "Wrong alignment on FAuraColorInfo");
static_assert(sizeof(FAuraColorInfo) == 0x000030, "Wrong size on FAuraColorInfo");
static_assert(offsetof(FAuraColorInfo, PowerCompare) == 0x000000, "Member 'FAuraColorInfo::PowerCompare' has a wrong offset!");
static_assert(offsetof(FAuraColorInfo, MaterialColor) == 0x000020, "Member 'FAuraColorInfo::MaterialColor' has a wrong offset!");

// ScriptStruct AT.CharacterAuraParamRow
// 0x00D0 (0x00D8 - 0x0008)
struct FCharacterAuraParamRow final : public FTableRowBase
{
public:
	struct FAuraScaleInfo                         Info;                                              // 0x0008(0x0060)(Edit, NativeAccessSpecifierPublic)
	struct FAuraColorInfo                         Player_color;                                      // 0x0068(0x0030)(Edit, NativeAccessSpecifierPublic)
	struct FAuraColorInfo                         Enemy_color;                                       // 0x0098(0x0030)(Edit, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EffectScaleMax;                                    // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAuraParamRow) == 0x000008, "Wrong alignment on FCharacterAuraParamRow");
static_assert(sizeof(FCharacterAuraParamRow) == 0x0000D8, "Wrong size on FCharacterAuraParamRow");
static_assert(offsetof(FCharacterAuraParamRow, Info) == 0x000008, "Member 'FCharacterAuraParamRow::Info' has a wrong offset!");
static_assert(offsetof(FCharacterAuraParamRow, Player_color) == 0x000068, "Member 'FCharacterAuraParamRow::Player_color' has a wrong offset!");
static_assert(offsetof(FCharacterAuraParamRow, Enemy_color) == 0x000098, "Member 'FCharacterAuraParamRow::Enemy_color' has a wrong offset!");
static_assert(offsetof(FCharacterAuraParamRow, FadeInTime) == 0x0000C8, "Member 'FCharacterAuraParamRow::FadeInTime' has a wrong offset!");
static_assert(offsetof(FCharacterAuraParamRow, FadeOutTime) == 0x0000CC, "Member 'FCharacterAuraParamRow::FadeOutTime' has a wrong offset!");
static_assert(offsetof(FCharacterAuraParamRow, EffectScaleMax) == 0x0000D0, "Member 'FCharacterAuraParamRow::EffectScaleMax' has a wrong offset!");

// ScriptStruct AT.ATDataAssetSoundInfo
// 0x0058 (0x0058 - 0x0000)
struct FATDataAssetSoundInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCueSheet>      SheetClass_ja;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundAtomCueSheet>      SheetClass_en;                                     // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetSoundInfo) == 0x000008, "Wrong alignment on FATDataAssetSoundInfo");
static_assert(sizeof(FATDataAssetSoundInfo) == 0x000058, "Wrong size on FATDataAssetSoundInfo");
static_assert(offsetof(FATDataAssetSoundInfo, MasterId) == 0x000000, "Member 'FATDataAssetSoundInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetSoundInfo, SheetClass_ja) == 0x000008, "Member 'FATDataAssetSoundInfo::SheetClass_ja' has a wrong offset!");
static_assert(offsetof(FATDataAssetSoundInfo, SheetClass_en) == 0x000030, "Member 'FATDataAssetSoundInfo::SheetClass_en' has a wrong offset!");

// ScriptStruct AT.LoadingSoundAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingSoundAsset final
{
public:
	TSoftObjectPtr<class USoundAtomCueSheet>      SheetClass;                                        // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingSoundAsset) == 0x000008, "Wrong alignment on FLoadingSoundAsset");
static_assert(sizeof(FLoadingSoundAsset) == 0x000028, "Wrong size on FLoadingSoundAsset");
static_assert(offsetof(FLoadingSoundAsset, SheetClass) == 0x000000, "Member 'FLoadingSoundAsset::SheetClass' has a wrong offset!");

// ScriptStruct AT.LoadingStarScaleFinishAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingStarScaleFinishAsset final
{
public:
	TSoftClassPtr<class UClass>                   Sequencer;                                         // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingStarScaleFinishAsset) == 0x000008, "Wrong alignment on FLoadingStarScaleFinishAsset");
static_assert(sizeof(FLoadingStarScaleFinishAsset) == 0x000028, "Wrong size on FLoadingStarScaleFinishAsset");
static_assert(offsetof(FLoadingStarScaleFinishAsset, Sequencer) == 0x000000, "Member 'FLoadingStarScaleFinishAsset::Sequencer' has a wrong offset!");

// ScriptStruct AT.ReferenceToSupportCharacterTalkAssetInstance
// 0x0008 (0x0008 - 0x0000)
struct FReferenceToSupportCharacterTalkAssetInstance final
{
public:
	class UDataTable*                             TalkDataTable;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FReferenceToSupportCharacterTalkAssetInstance) == 0x000008, "Wrong alignment on FReferenceToSupportCharacterTalkAssetInstance");
static_assert(sizeof(FReferenceToSupportCharacterTalkAssetInstance) == 0x000008, "Wrong size on FReferenceToSupportCharacterTalkAssetInstance");
static_assert(offsetof(FReferenceToSupportCharacterTalkAssetInstance, TalkDataTable) == 0x000000, "Member 'FReferenceToSupportCharacterTalkAssetInstance::TalkDataTable' has a wrong offset!");

// ScriptStruct AT.LoadingSupportCharacterTalkAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingSupportCharacterTalkAsset final
{
public:
	TSoftObjectPtr<class UDataTable>              TalkDataTable;                                     // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingSupportCharacterTalkAsset) == 0x000008, "Wrong alignment on FLoadingSupportCharacterTalkAsset");
static_assert(sizeof(FLoadingSupportCharacterTalkAsset) == 0x000028, "Wrong size on FLoadingSupportCharacterTalkAsset");
static_assert(offsetof(FLoadingSupportCharacterTalkAsset, TalkDataTable) == 0x000000, "Member 'FLoadingSupportCharacterTalkAsset::TalkDataTable' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateDecalInfo
// 0x00C8 (0x00C8 - 0x0000)
struct alignas(0x08) FTerrainDecorateDecalInfo final
{
public:
	uint8                                         Pad_0[0xC8];                                       // 0x0000(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainDecorateDecalInfo) == 0x000008, "Wrong alignment on FTerrainDecorateDecalInfo");
static_assert(sizeof(FTerrainDecorateDecalInfo) == 0x0000C8, "Wrong size on FTerrainDecorateDecalInfo");

// ScriptStruct AT.ATDataAssetTPSSkillViewCancelInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetTPSSkillViewCancelInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              TPSSkillViewCancelDataTable;                       // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetTPSSkillViewCancelInfo) == 0x000008, "Wrong alignment on FATDataAssetTPSSkillViewCancelInfo");
static_assert(sizeof(FATDataAssetTPSSkillViewCancelInfo) == 0x000030, "Wrong size on FATDataAssetTPSSkillViewCancelInfo");
static_assert(offsetof(FATDataAssetTPSSkillViewCancelInfo, MasterId) == 0x000000, "Member 'FATDataAssetTPSSkillViewCancelInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetTPSSkillViewCancelInfo, TPSSkillViewCancelDataTable) == 0x000008, "Member 'FATDataAssetTPSSkillViewCancelInfo::TPSSkillViewCancelDataTable' has a wrong offset!");

// ScriptStruct AT.TPCharacterList
// 0x0010 (0x0010 - 0x0000)
struct FTPCharacterList final
{
public:
	TArray<class ATargetPointIngameDemoCharacter*> Entries;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTPCharacterList) == 0x000008, "Wrong alignment on FTPCharacterList");
static_assert(sizeof(FTPCharacterList) == 0x000010, "Wrong size on FTPCharacterList");
static_assert(offsetof(FTPCharacterList, Entries) == 0x000000, "Member 'FTPCharacterList::Entries' has a wrong offset!");

// ScriptStruct AT.LoadingTPSSkillViewCancelAsset
// 0x0028 (0x0028 - 0x0000)
struct FLoadingTPSSkillViewCancelAsset final
{
public:
	TSoftObjectPtr<class UDataTable>              TPSSkillViewCancelDataTable;                       // 0x0000(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLoadingTPSSkillViewCancelAsset) == 0x000008, "Wrong alignment on FLoadingTPSSkillViewCancelAsset");
static_assert(sizeof(FLoadingTPSSkillViewCancelAsset) == 0x000028, "Wrong size on FLoadingTPSSkillViewCancelAsset");
static_assert(offsetof(FLoadingTPSSkillViewCancelAsset, TPSSkillViewCancelDataTable) == 0x000000, "Member 'FLoadingTPSSkillViewCancelAsset::TPSSkillViewCancelDataTable' has a wrong offset!");

// ScriptStruct AT.ATDataTableUiInfo
// 0x0038 (0x0038 - 0x0000)
struct FATDataTableUiInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              DataTableAsset;                                    // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAlwaysLoad;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATDataTableUiInfo) == 0x000008, "Wrong alignment on FATDataTableUiInfo");
static_assert(sizeof(FATDataTableUiInfo) == 0x000038, "Wrong size on FATDataTableUiInfo");
static_assert(offsetof(FATDataTableUiInfo, MasterId) == 0x000000, "Member 'FATDataTableUiInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataTableUiInfo, DataTableAsset) == 0x000008, "Member 'FATDataTableUiInfo::DataTableAsset' has a wrong offset!");
static_assert(offsetof(FATDataTableUiInfo, IsAlwaysLoad) == 0x000030, "Member 'FATDataTableUiInfo::IsAlwaysLoad' has a wrong offset!");

// ScriptStruct AT.ATDataAssetUiInfo
// 0x0030 (0x0030 - 0x0000)
struct FATDataAssetUiInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   UserWidgetClass;                                   // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetUiInfo) == 0x000008, "Wrong alignment on FATDataAssetUiInfo");
static_assert(sizeof(FATDataAssetUiInfo) == 0x000030, "Wrong size on FATDataAssetUiInfo");
static_assert(offsetof(FATDataAssetUiInfo, MasterId) == 0x000000, "Member 'FATDataAssetUiInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiInfo, UserWidgetClass) == 0x000008, "Member 'FATDataAssetUiInfo::UserWidgetClass' has a wrong offset!");

// ScriptStruct AT.PageLayoutIndex
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FPageLayoutIndex final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPageLayoutIndex) == 0x000004, "Wrong alignment on FPageLayoutIndex");
static_assert(sizeof(FPageLayoutIndex) == 0x000008, "Wrong size on FPageLayoutIndex");

// ScriptStruct AT.PageLayoutStack
// 0x0088 (0x0088 - 0x0000)
struct FPageLayoutStack final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPageLayoutPair>                Pair_List;                                         // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<int32, struct FPageLayoutIndex>          Index_Map;                                         // 0x0038(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPageLayoutStack) == 0x000008, "Wrong alignment on FPageLayoutStack");
static_assert(sizeof(FPageLayoutStack) == 0x000088, "Wrong size on FPageLayoutStack");
static_assert(offsetof(FPageLayoutStack, Pair_List) == 0x000028, "Member 'FPageLayoutStack::Pair_List' has a wrong offset!");
static_assert(offsetof(FPageLayoutStack, Index_Map) == 0x000038, "Member 'FPageLayoutStack::Index_Map' has a wrong offset!");

// ScriptStruct AT.ATDataAssetUiCaptureInfo
// 0x0108 (0x0108 - 0x0000)
struct FATDataAssetUiCaptureInfo final
{
public:
	class FName                                   MasterId;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USkeletalMesh>           SkelMesh;                                          // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimBlueprint>          AnimBP;                                            // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UAnimationAsset>> Animations;                                        // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         Particle;                                          // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ActorClass;                                        // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Montage;                                           // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataAssetUiCaptureInfo) == 0x000008, "Wrong alignment on FATDataAssetUiCaptureInfo");
static_assert(sizeof(FATDataAssetUiCaptureInfo) == 0x000108, "Wrong size on FATDataAssetUiCaptureInfo");
static_assert(offsetof(FATDataAssetUiCaptureInfo, MasterId) == 0x000000, "Member 'FATDataAssetUiCaptureInfo::MasterId' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, StaticMesh) == 0x000008, "Member 'FATDataAssetUiCaptureInfo::StaticMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, SkelMesh) == 0x000030, "Member 'FATDataAssetUiCaptureInfo::SkelMesh' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, AnimBP) == 0x000058, "Member 'FATDataAssetUiCaptureInfo::AnimBP' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, Animations) == 0x000080, "Member 'FATDataAssetUiCaptureInfo::Animations' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, Particle) == 0x000090, "Member 'FATDataAssetUiCaptureInfo::Particle' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, ActorClass) == 0x0000B8, "Member 'FATDataAssetUiCaptureInfo::ActorClass' has a wrong offset!");
static_assert(offsetof(FATDataAssetUiCaptureInfo, Montage) == 0x0000E0, "Member 'FATDataAssetUiCaptureInfo::Montage' has a wrong offset!");

// ScriptStruct AT.CookingEffectOffsetConstParam
// 0x0018 (0x0020 - 0x0008)
struct FCookingEffectOffsetConstParam final : public FTableRowBase
{
public:
	float                                         OffsetX;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetY;                                           // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetZ;                                           // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLC3OffsetX;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLC3OffsetY;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DLC3OffsetZ;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCookingEffectOffsetConstParam) == 0x000008, "Wrong alignment on FCookingEffectOffsetConstParam");
static_assert(sizeof(FCookingEffectOffsetConstParam) == 0x000020, "Wrong size on FCookingEffectOffsetConstParam");
static_assert(offsetof(FCookingEffectOffsetConstParam, OffsetX) == 0x000008, "Member 'FCookingEffectOffsetConstParam::OffsetX' has a wrong offset!");
static_assert(offsetof(FCookingEffectOffsetConstParam, OffsetY) == 0x00000C, "Member 'FCookingEffectOffsetConstParam::OffsetY' has a wrong offset!");
static_assert(offsetof(FCookingEffectOffsetConstParam, OffsetZ) == 0x000010, "Member 'FCookingEffectOffsetConstParam::OffsetZ' has a wrong offset!");
static_assert(offsetof(FCookingEffectOffsetConstParam, DLC3OffsetX) == 0x000014, "Member 'FCookingEffectOffsetConstParam::DLC3OffsetX' has a wrong offset!");
static_assert(offsetof(FCookingEffectOffsetConstParam, DLC3OffsetY) == 0x000018, "Member 'FCookingEffectOffsetConstParam::DLC3OffsetY' has a wrong offset!");
static_assert(offsetof(FCookingEffectOffsetConstParam, DLC3OffsetZ) == 0x00001C, "Member 'FCookingEffectOffsetConstParam::DLC3OffsetZ' has a wrong offset!");

// ScriptStruct AT.DemoTimingDelayed
// 0x0008 (0x0018 - 0x0010)
struct FDemoTimingDelayed final : public FDemoInfoBase
{
public:
	float                                         DelayedTime;                                       // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDemoTimingDelayed) == 0x000008, "Wrong alignment on FDemoTimingDelayed");
static_assert(sizeof(FDemoTimingDelayed) == 0x000018, "Wrong size on FDemoTimingDelayed");
static_assert(offsetof(FDemoTimingDelayed, DelayedTime) == 0x000010, "Member 'FDemoTimingDelayed::DelayedTime' has a wrong offset!");

// ScriptStruct AT.DemoParam
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDemoParam final
{
public:
	EDEMO_TYPE                                    DemoType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDEMO_TIMING_TYPE                             DemoTiming;                                        // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DemoName;                                          // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bContinueFlag;                                     // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDemoParam) == 0x000008, "Wrong alignment on FDemoParam");
static_assert(sizeof(FDemoParam) == 0x000018, "Wrong size on FDemoParam");
static_assert(offsetof(FDemoParam, DemoType) == 0x000000, "Member 'FDemoParam::DemoType' has a wrong offset!");
static_assert(offsetof(FDemoParam, DemoTiming) == 0x000001, "Member 'FDemoParam::DemoTiming' has a wrong offset!");
static_assert(offsetof(FDemoParam, DemoName) == 0x000008, "Member 'FDemoParam::DemoName' has a wrong offset!");
static_assert(offsetof(FDemoParam, bContinueFlag) == 0x000010, "Member 'FDemoParam::bContinueFlag' has a wrong offset!");

// ScriptStruct AT.QuestPhaseParam
// 0x0090 (0x0098 - 0x0008)
struct FQuestPhaseParam final : public FTableRowBase
{
public:
	class FName                                   Phase_id;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_PHASE_TYPE                             Phase_type;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Phase_no;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Phase_title_id;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Phase_message_id;                                  // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Phase_message_parameter_id;                        // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Client_icon_id;                                    // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Progress_message_id;                               // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Object_name;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Target_id;                                         // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     Item_loss;                                         // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_SET_PHASE_TIMING                       Change_player;                                     // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Change_player_chara;                               // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Change_support1_chara;                             // 0x0073(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Change_support2_chara;                             // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Cross_talk_id;                                     // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     No_opening_menu;                                   // 0x0080(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Play_bgm;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bgm_priority;                                      // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestRestrictCondition                       Restrict_condition;                                // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuestSaveCondition                           Save_condition;                                    // 0x0095(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     Skip_retry;                                        // 0x0096(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_BGM_CHANGE_PERMISSION                  bgm_change_permission;                             // 0x0097(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestPhaseParam) == 0x000008, "Wrong alignment on FQuestPhaseParam");
static_assert(sizeof(FQuestPhaseParam) == 0x000098, "Wrong size on FQuestPhaseParam");
static_assert(offsetof(FQuestPhaseParam, Phase_id) == 0x000008, "Member 'FQuestPhaseParam::Phase_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Phase_type) == 0x000010, "Member 'FQuestPhaseParam::Phase_type' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Phase_no) == 0x000014, "Member 'FQuestPhaseParam::Phase_no' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Phase_title_id) == 0x000018, "Member 'FQuestPhaseParam::Phase_title_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Phase_message_id) == 0x000028, "Member 'FQuestPhaseParam::Phase_message_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Phase_message_parameter_id) == 0x000038, "Member 'FQuestPhaseParam::Phase_message_parameter_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Client_icon_id) == 0x000048, "Member 'FQuestPhaseParam::Client_icon_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Progress_message_id) == 0x000050, "Member 'FQuestPhaseParam::Progress_message_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Object_name) == 0x000060, "Member 'FQuestPhaseParam::Object_name' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Target_id) == 0x000068, "Member 'FQuestPhaseParam::Target_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Item_loss) == 0x000070, "Member 'FQuestPhaseParam::Item_loss' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Change_player) == 0x000071, "Member 'FQuestPhaseParam::Change_player' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Change_player_chara) == 0x000072, "Member 'FQuestPhaseParam::Change_player_chara' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Change_support1_chara) == 0x000073, "Member 'FQuestPhaseParam::Change_support1_chara' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Change_support2_chara) == 0x000074, "Member 'FQuestPhaseParam::Change_support2_chara' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Cross_talk_id) == 0x000078, "Member 'FQuestPhaseParam::Cross_talk_id' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, No_opening_menu) == 0x000080, "Member 'FQuestPhaseParam::No_opening_menu' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Play_bgm) == 0x000088, "Member 'FQuestPhaseParam::Play_bgm' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, bgm_priority) == 0x000090, "Member 'FQuestPhaseParam::bgm_priority' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Restrict_condition) == 0x000094, "Member 'FQuestPhaseParam::Restrict_condition' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Save_condition) == 0x000095, "Member 'FQuestPhaseParam::Save_condition' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, Skip_retry) == 0x000096, "Member 'FQuestPhaseParam::Skip_retry' has a wrong offset!");
static_assert(offsetof(FQuestPhaseParam, bgm_change_permission) == 0x000097, "Member 'FQuestPhaseParam::bgm_change_permission' has a wrong offset!");

// ScriptStruct AT.EncountEnemyPartyListTableRow
// 0x0018 (0x0020 - 0x0008)
struct FEncountEnemyPartyListTableRow final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               LeaderCharacter;                                   // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     LeaderCharacterState;                              // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter01;                                 // 0x000A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState01;                            // 0x000B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter02;                                 // 0x000C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState02;                            // 0x000D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter03;                                 // 0x000E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState03;                            // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter04;                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState04;                            // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter05;                                 // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState05;                            // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter06;                                 // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState06;                            // 0x0015(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter07;                                 // 0x0016(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState07;                            // 0x0017(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter08;                                 // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState08;                            // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FriendCharacter09;                                 // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPARAM_ID                                     FriendCharacterState09;                            // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncountEnemyPartyListTableRow) == 0x000008, "Wrong alignment on FEncountEnemyPartyListTableRow");
static_assert(sizeof(FEncountEnemyPartyListTableRow) == 0x000020, "Wrong size on FEncountEnemyPartyListTableRow");
static_assert(offsetof(FEncountEnemyPartyListTableRow, LeaderCharacter) == 0x000008, "Member 'FEncountEnemyPartyListTableRow::LeaderCharacter' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, LeaderCharacterState) == 0x000009, "Member 'FEncountEnemyPartyListTableRow::LeaderCharacterState' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter01) == 0x00000A, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter01' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState01) == 0x00000B, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState01' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter02) == 0x00000C, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter02' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState02) == 0x00000D, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState02' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter03) == 0x00000E, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter03' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState03) == 0x00000F, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState03' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter04) == 0x000010, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter04' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState04) == 0x000011, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState04' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter05) == 0x000012, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter05' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState05) == 0x000013, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState05' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter06) == 0x000014, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter06' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState06) == 0x000015, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState06' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter07) == 0x000016, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter07' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState07) == 0x000017, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState07' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter08) == 0x000018, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter08' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState08) == 0x000019, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState08' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacter09) == 0x00001A, "Member 'FEncountEnemyPartyListTableRow::FriendCharacter09' has a wrong offset!");
static_assert(offsetof(FEncountEnemyPartyListTableRow, FriendCharacterState09) == 0x00001B, "Member 'FEncountEnemyPartyListTableRow::FriendCharacterState09' has a wrong offset!");

// ScriptStruct AT.DiffLevelInfoParameter
// 0x0008 (0x0008 - 0x0000)
struct FDiffLevelInfoParameter final
{
public:
	int32                                         DiffLevel;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalAddValue;                                  // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDiffLevelInfoParameter) == 0x000004, "Wrong alignment on FDiffLevelInfoParameter");
static_assert(sizeof(FDiffLevelInfoParameter) == 0x000008, "Wrong size on FDiffLevelInfoParameter");
static_assert(offsetof(FDiffLevelInfoParameter, DiffLevel) == 0x000000, "Member 'FDiffLevelInfoParameter::DiffLevel' has a wrong offset!");
static_assert(offsetof(FDiffLevelInfoParameter, CriticalAddValue) == 0x000004, "Member 'FDiffLevelInfoParameter::CriticalAddValue' has a wrong offset!");

// ScriptStruct AT.DLCIdParam
// 0x0010 (0x0018 - 0x0008)
struct FDLCIdParam final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ContentId;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCIdParam) == 0x000008, "Wrong alignment on FDLCIdParam");
static_assert(sizeof(FDLCIdParam) == 0x000018, "Wrong size on FDLCIdParam");
static_assert(offsetof(FDLCIdParam, ID) == 0x000008, "Member 'FDLCIdParam::ID' has a wrong offset!");
static_assert(offsetof(FDLCIdParam, ContentId) == 0x000010, "Member 'FDLCIdParam::ContentId' has a wrong offset!");

// ScriptStruct AT.ATEnemiesBaseCondition
// 0x0010 (0x0018 - 0x0008)
struct FATEnemiesBaseCondition final : public FTableRowBase
{
public:
	EAreaIndex                                    AreaID;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEpisodeId                                    CondEpisode;                                       // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnLimit;                                        // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnemiesLocationId;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATEnemiesBaseCondition) == 0x000008, "Wrong alignment on FATEnemiesBaseCondition");
static_assert(sizeof(FATEnemiesBaseCondition) == 0x000018, "Wrong size on FATEnemiesBaseCondition");
static_assert(offsetof(FATEnemiesBaseCondition, AreaID) == 0x000008, "Member 'FATEnemiesBaseCondition::AreaID' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseCondition, CondEpisode) == 0x000009, "Member 'FATEnemiesBaseCondition::CondEpisode' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseCondition, SpawnLimit) == 0x00000C, "Member 'FATEnemiesBaseCondition::SpawnLimit' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseCondition, EnemiesLocationId) == 0x000010, "Member 'FATEnemiesBaseCondition::EnemiesLocationId' has a wrong offset!");

// ScriptStruct AT.ATEnemiesBaseParameter
// 0x0038 (0x0040 - 0x0008)
struct FATEnemiesBaseParameter final : public FTableRowBase
{
public:
	int32                                         EnemiesBaseId;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EnemiesLocationId;                                 // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitPoint;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemTableId;                                   // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATEnemyBaseType                              EnemiesBaseType;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnLocationX;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationY;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationZ;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnAngle;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATEnemiesBaseParameter) == 0x000008, "Wrong alignment on FATEnemiesBaseParameter");
static_assert(sizeof(FATEnemiesBaseParameter) == 0x000040, "Wrong size on FATEnemiesBaseParameter");
static_assert(offsetof(FATEnemiesBaseParameter, EnemiesBaseId) == 0x000008, "Member 'FATEnemiesBaseParameter::EnemiesBaseId' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, EnemiesLocationId) == 0x000010, "Member 'FATEnemiesBaseParameter::EnemiesLocationId' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, HitPoint) == 0x000018, "Member 'FATEnemiesBaseParameter::HitPoint' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, DropItemTableId) == 0x000020, "Member 'FATEnemiesBaseParameter::DropItemTableId' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, EnemiesBaseType) == 0x000028, "Member 'FATEnemiesBaseParameter::EnemiesBaseType' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, SpawnLocationX) == 0x00002C, "Member 'FATEnemiesBaseParameter::SpawnLocationX' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, SpawnLocationY) == 0x000030, "Member 'FATEnemiesBaseParameter::SpawnLocationY' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, SpawnLocationZ) == 0x000034, "Member 'FATEnemiesBaseParameter::SpawnLocationZ' has a wrong offset!");
static_assert(offsetof(FATEnemiesBaseParameter, SpawnAngle) == 0x000038, "Member 'FATEnemiesBaseParameter::SpawnAngle' has a wrong offset!");

// ScriptStruct AT.DirectionRequest
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDirectionRequest final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDirectionRequest) == 0x000008, "Wrong alignment on FDirectionRequest");
static_assert(sizeof(FDirectionRequest) == 0x000018, "Wrong size on FDirectionRequest");

// ScriptStruct AT.DirectionRequests
// 0x0010 (0x0010 - 0x0000)
struct FDirectionRequests final
{
public:
	TArray<struct FDirectionRequest>              Element;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirectionRequests) == 0x000008, "Wrong alignment on FDirectionRequests");
static_assert(sizeof(FDirectionRequests) == 0x000010, "Wrong size on FDirectionRequests");
static_assert(offsetof(FDirectionRequests, Element) == 0x000000, "Member 'FDirectionRequests::Element' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataDemo
// 0x0010 (0x0018 - 0x0008)
struct FZCompworksUIDataDemo final : public FTableRowBase
{
public:
	class FName                                   DemoPath;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ThumbPath;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataDemo) == 0x000008, "Wrong alignment on FZCompworksUIDataDemo");
static_assert(sizeof(FZCompworksUIDataDemo) == 0x000018, "Wrong size on FZCompworksUIDataDemo");
static_assert(offsetof(FZCompworksUIDataDemo, DemoPath) == 0x000008, "Member 'FZCompworksUIDataDemo::DemoPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataDemo, ThumbPath) == 0x000010, "Member 'FZCompworksUIDataDemo::ThumbPath' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamDiagram
// 0x0018 (0x0038 - 0x0020)
struct FZCompworksParamDiagram final : public FZCompworksParamBase
{
public:
	class FName                                   WedgetNameClose;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WedgetNameOpen;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WedgetNameName;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksParamDiagram) == 0x000008, "Wrong alignment on FZCompworksParamDiagram");
static_assert(sizeof(FZCompworksParamDiagram) == 0x000038, "Wrong size on FZCompworksParamDiagram");
static_assert(offsetof(FZCompworksParamDiagram, WedgetNameClose) == 0x000020, "Member 'FZCompworksParamDiagram::WedgetNameClose' has a wrong offset!");
static_assert(offsetof(FZCompworksParamDiagram, WedgetNameOpen) == 0x000028, "Member 'FZCompworksParamDiagram::WedgetNameOpen' has a wrong offset!");
static_assert(offsetof(FZCompworksParamDiagram, WedgetNameName) == 0x000030, "Member 'FZCompworksParamDiagram::WedgetNameName' has a wrong offset!");

// ScriptStruct AT.Direction
// 0x0020 (0x0020 - 0x0000)
struct FDirection final
{
public:
	TArray<class FName>                           Enable;                                            // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           Disable;                                           // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDirection) == 0x000008, "Wrong alignment on FDirection");
static_assert(sizeof(FDirection) == 0x000020, "Wrong size on FDirection");
static_assert(offsetof(FDirection, Enable) == 0x000000, "Member 'FDirection::Enable' has a wrong offset!");
static_assert(offsetof(FDirection, Disable) == 0x000010, "Member 'FDirection::Disable' has a wrong offset!");

// ScriptStruct AT.ATStarScaleFinishTableRow
// 0x0018 (0x0020 - 0x0008)
struct FATStarScaleFinishTableRow final : public FTableRowBase
{
public:
	class FName                                   CharaId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SkillId;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FinishId;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATStarScaleFinishTableRow) == 0x000008, "Wrong alignment on FATStarScaleFinishTableRow");
static_assert(sizeof(FATStarScaleFinishTableRow) == 0x000020, "Wrong size on FATStarScaleFinishTableRow");
static_assert(offsetof(FATStarScaleFinishTableRow, CharaId) == 0x000008, "Member 'FATStarScaleFinishTableRow::CharaId' has a wrong offset!");
static_assert(offsetof(FATStarScaleFinishTableRow, SkillId) == 0x000010, "Member 'FATStarScaleFinishTableRow::SkillId' has a wrong offset!");
static_assert(offsetof(FATStarScaleFinishTableRow, FinishId) == 0x000018, "Member 'FATStarScaleFinishTableRow::FinishId' has a wrong offset!");

// ScriptStruct AT.EnemyAppearTableRow
// 0x0018 (0x0020 - 0x0008)
struct FEnemyAppearTableRow final : public FTableRowBase
{
public:
	EAppearType                                   AppearType0;                                       // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance0;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ext0;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAppearType                                   AppearType1;                                       // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance1;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ext1;                                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyAppearTableRow) == 0x000008, "Wrong alignment on FEnemyAppearTableRow");
static_assert(sizeof(FEnemyAppearTableRow) == 0x000020, "Wrong size on FEnemyAppearTableRow");
static_assert(offsetof(FEnemyAppearTableRow, AppearType0) == 0x000008, "Member 'FEnemyAppearTableRow::AppearType0' has a wrong offset!");
static_assert(offsetof(FEnemyAppearTableRow, Distance0) == 0x00000C, "Member 'FEnemyAppearTableRow::Distance0' has a wrong offset!");
static_assert(offsetof(FEnemyAppearTableRow, Ext0) == 0x000010, "Member 'FEnemyAppearTableRow::Ext0' has a wrong offset!");
static_assert(offsetof(FEnemyAppearTableRow, AppearType1) == 0x000014, "Member 'FEnemyAppearTableRow::AppearType1' has a wrong offset!");
static_assert(offsetof(FEnemyAppearTableRow, Distance1) == 0x000018, "Member 'FEnemyAppearTableRow::Distance1' has a wrong offset!");
static_assert(offsetof(FEnemyAppearTableRow, Ext1) == 0x00001C, "Member 'FEnemyAppearTableRow::Ext1' has a wrong offset!");

// ScriptStruct AT.DebugEventBattleCondition
// 0x0010 (0x0018 - 0x0008)
struct FDebugEventBattleCondition final : public FTableRowBase
{
public:
	int32                                         LeaderLevel;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstSupportLevel;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondSupportLevel;                                // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDebugEventBattleCondition) == 0x000008, "Wrong alignment on FDebugEventBattleCondition");
static_assert(sizeof(FDebugEventBattleCondition) == 0x000018, "Wrong size on FDebugEventBattleCondition");
static_assert(offsetof(FDebugEventBattleCondition, LeaderLevel) == 0x000008, "Member 'FDebugEventBattleCondition::LeaderLevel' has a wrong offset!");
static_assert(offsetof(FDebugEventBattleCondition, FirstSupportLevel) == 0x00000C, "Member 'FDebugEventBattleCondition::FirstSupportLevel' has a wrong offset!");
static_assert(offsetof(FDebugEventBattleCondition, SecondSupportLevel) == 0x000010, "Member 'FDebugEventBattleCondition::SecondSupportLevel' has a wrong offset!");

// ScriptStruct AT.EventBattleMobMeshNear
// 0x0010 (0x0010 - 0x0000)
struct FEventBattleMobMeshNear final
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Montage;                                           // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleMobMeshNear) == 0x000008, "Wrong alignment on FEventBattleMobMeshNear");
static_assert(sizeof(FEventBattleMobMeshNear) == 0x000010, "Wrong size on FEventBattleMobMeshNear");
static_assert(offsetof(FEventBattleMobMeshNear, Mesh) == 0x000000, "Member 'FEventBattleMobMeshNear::Mesh' has a wrong offset!");
static_assert(offsetof(FEventBattleMobMeshNear, Montage) == 0x000008, "Member 'FEventBattleMobMeshNear::Montage' has a wrong offset!");

// ScriptStruct AT.QuestBlurParameter
// 0x0040 (0x0048 - 0x0008)
struct FQuestBlurParameter final : public FTableRowBase
{
public:
	float                                         Duration;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetActorName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetActorSocketName;                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurAmountMin;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurAmountMax;                                     // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurRadius;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurExponent;                                      // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurInterpTime;                                    // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurLifeTime;                                      // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlurFadeTime;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeWaitTime;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFADE_COLOR                                   Color;                                             // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestBlurParameter) == 0x000008, "Wrong alignment on FQuestBlurParameter");
static_assert(sizeof(FQuestBlurParameter) == 0x000048, "Wrong size on FQuestBlurParameter");
static_assert(offsetof(FQuestBlurParameter, Duration) == 0x000008, "Member 'FQuestBlurParameter::Duration' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, TargetActorName) == 0x000010, "Member 'FQuestBlurParameter::TargetActorName' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, TargetActorSocketName) == 0x000018, "Member 'FQuestBlurParameter::TargetActorSocketName' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurAmountMin) == 0x000020, "Member 'FQuestBlurParameter::BlurAmountMin' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurAmountMax) == 0x000024, "Member 'FQuestBlurParameter::BlurAmountMax' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurRadius) == 0x000028, "Member 'FQuestBlurParameter::BlurRadius' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurExponent) == 0x00002C, "Member 'FQuestBlurParameter::BlurExponent' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurInterpTime) == 0x000030, "Member 'FQuestBlurParameter::BlurInterpTime' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurLifeTime) == 0x000034, "Member 'FQuestBlurParameter::BlurLifeTime' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, BlurFadeTime) == 0x000038, "Member 'FQuestBlurParameter::BlurFadeTime' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, FadeTime) == 0x00003C, "Member 'FQuestBlurParameter::FadeTime' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, FadeWaitTime) == 0x000040, "Member 'FQuestBlurParameter::FadeWaitTime' has a wrong offset!");
static_assert(offsetof(FQuestBlurParameter, Color) == 0x000044, "Member 'FQuestBlurParameter::Color' has a wrong offset!");

// ScriptStruct AT.EventBattleMobPlace
// 0x0030 (0x0030 - 0x0000)
struct FEventBattleMobPlace final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        SplitNum;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint32>                                SplitTbl;                                          // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint32                                        NearActorNum;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearActorDistanceMin;                              // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearActorDistanceMax;                              // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearActorHeightRange;                              // 0x002C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleMobPlace) == 0x000008, "Wrong alignment on FEventBattleMobPlace");
static_assert(sizeof(FEventBattleMobPlace) == 0x000030, "Wrong size on FEventBattleMobPlace");
static_assert(offsetof(FEventBattleMobPlace, Distance) == 0x000000, "Member 'FEventBattleMobPlace::Distance' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, Height) == 0x000004, "Member 'FEventBattleMobPlace::Height' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, SplitNum) == 0x000008, "Member 'FEventBattleMobPlace::SplitNum' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, SplitTbl) == 0x000010, "Member 'FEventBattleMobPlace::SplitTbl' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, NearActorNum) == 0x000020, "Member 'FEventBattleMobPlace::NearActorNum' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, NearActorDistanceMin) == 0x000024, "Member 'FEventBattleMobPlace::NearActorDistanceMin' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, NearActorDistanceMax) == 0x000028, "Member 'FEventBattleMobPlace::NearActorDistanceMax' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlace, NearActorHeightRange) == 0x00002C, "Member 'FEventBattleMobPlace::NearActorHeightRange' has a wrong offset!");

// ScriptStruct AT.DLC6ProgressAreaMoveList
// 0x0018 (0x0020 - 0x0008)
struct FDLC6ProgressAreaMoveList final : public FTableRowBase
{
public:
	class FName                                   StartSubQuestId;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATAreaMoveState                              AreaMoveState;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDLC6ProgressAreaMoveList) == 0x000008, "Wrong alignment on FDLC6ProgressAreaMoveList");
static_assert(sizeof(FDLC6ProgressAreaMoveList) == 0x000020, "Wrong size on FDLC6ProgressAreaMoveList");
static_assert(offsetof(FDLC6ProgressAreaMoveList, StartSubQuestId) == 0x000008, "Member 'FDLC6ProgressAreaMoveList::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC6ProgressAreaMoveList, EndSubQuestId) == 0x000010, "Member 'FDLC6ProgressAreaMoveList::EndSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC6ProgressAreaMoveList, AreaMoveState) == 0x000018, "Member 'FDLC6ProgressAreaMoveList::AreaMoveState' has a wrong offset!");

// ScriptStruct AT.EventBattleMobPlacePattern
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FEventBattleMobPlacePattern final
{
public:
	class FName                                   MobId;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ratio;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEventBattleMobPlacePattern) == 0x000008, "Wrong alignment on FEventBattleMobPlacePattern");
static_assert(sizeof(FEventBattleMobPlacePattern) == 0x000010, "Wrong size on FEventBattleMobPlacePattern");
static_assert(offsetof(FEventBattleMobPlacePattern, MobId) == 0x000000, "Member 'FEventBattleMobPlacePattern::MobId' has a wrong offset!");
static_assert(offsetof(FEventBattleMobPlacePattern, Ratio) == 0x000008, "Member 'FEventBattleMobPlacePattern::Ratio' has a wrong offset!");

// ScriptStruct AT.EventBattleMobPlacePatternTable
// 0x0010 (0x0018 - 0x0008)
struct FEventBattleMobPlacePatternTable final : public FTableRowBase
{
public:
	TArray<struct FEventBattleMobPlacePattern>    Pattern;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEventBattleMobPlacePatternTable) == 0x000008, "Wrong alignment on FEventBattleMobPlacePatternTable");
static_assert(sizeof(FEventBattleMobPlacePatternTable) == 0x000018, "Wrong size on FEventBattleMobPlacePatternTable");
static_assert(offsetof(FEventBattleMobPlacePatternTable, Pattern) == 0x000008, "Member 'FEventBattleMobPlacePatternTable::Pattern' has a wrong offset!");

// ScriptStruct AT.AndroidAssaultEndConditionInfo
// 0x0028 (0x0028 - 0x0000)
struct FAndroidAssaultEndConditionInfo final
{
public:
	EEVENTBATTLE_VICTORY_CONDITIONS               ConditionId;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProgressTracked;                                  // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ConditionValue;                                    // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentTrackedValue;                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MessageId;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAndroidAssaultEndConditionType               ConditionSelectionType;                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAndroidAssaultEndConditionInfo) == 0x000008, "Wrong alignment on FAndroidAssaultEndConditionInfo");
static_assert(sizeof(FAndroidAssaultEndConditionInfo) == 0x000028, "Wrong size on FAndroidAssaultEndConditionInfo");
static_assert(offsetof(FAndroidAssaultEndConditionInfo, ConditionId) == 0x000000, "Member 'FAndroidAssaultEndConditionInfo::ConditionId' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultEndConditionInfo, bProgressTracked) == 0x000001, "Member 'FAndroidAssaultEndConditionInfo::bProgressTracked' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultEndConditionInfo, ConditionValue) == 0x000004, "Member 'FAndroidAssaultEndConditionInfo::ConditionValue' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultEndConditionInfo, CurrentTrackedValue) == 0x000008, "Member 'FAndroidAssaultEndConditionInfo::CurrentTrackedValue' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultEndConditionInfo, MessageId) == 0x000010, "Member 'FAndroidAssaultEndConditionInfo::MessageId' has a wrong offset!");
static_assert(offsetof(FAndroidAssaultEndConditionInfo, ConditionSelectionType) == 0x000020, "Member 'FAndroidAssaultEndConditionInfo::ConditionSelectionType' has a wrong offset!");

// ScriptStruct AT.ATEventBattleVisionPicture
// 0x0040 (0x0040 - 0x0000)
struct FATEventBattleVisionPicture final
{
public:
	TSoftObjectPtr<class UTexture2D>              TexturePath;                                       // 0x0000(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SyncMessageId;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SyncMessageDelay;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATEventBattleVisionPicture) == 0x000008, "Wrong alignment on FATEventBattleVisionPicture");
static_assert(sizeof(FATEventBattleVisionPicture) == 0x000040, "Wrong size on FATEventBattleVisionPicture");
static_assert(offsetof(FATEventBattleVisionPicture, TexturePath) == 0x000000, "Member 'FATEventBattleVisionPicture::TexturePath' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionPicture, LifeTime) == 0x000028, "Member 'FATEventBattleVisionPicture::LifeTime' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionPicture, SyncMessageId) == 0x000030, "Member 'FATEventBattleVisionPicture::SyncMessageId' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionPicture, SyncMessageDelay) == 0x000038, "Member 'FATEventBattleVisionPicture::SyncMessageDelay' has a wrong offset!");

// ScriptStruct AT.ATEventBattleVisionData
// 0x0040 (0x0040 - 0x0000)
struct FATEventBattleVisionData final
{
public:
	TArray<struct FATEventBattleVisionPicture>    PictureTable;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           OmenMessageTable;                                  // 0x0010(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           PlayMessageTable;                                  // 0x0020(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           StopMessageTable;                                  // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATEventBattleVisionData) == 0x000008, "Wrong alignment on FATEventBattleVisionData");
static_assert(sizeof(FATEventBattleVisionData) == 0x000040, "Wrong size on FATEventBattleVisionData");
static_assert(offsetof(FATEventBattleVisionData, PictureTable) == 0x000000, "Member 'FATEventBattleVisionData::PictureTable' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionData, OmenMessageTable) == 0x000010, "Member 'FATEventBattleVisionData::OmenMessageTable' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionData, PlayMessageTable) == 0x000020, "Member 'FATEventBattleVisionData::PlayMessageTable' has a wrong offset!");
static_assert(offsetof(FATEventBattleVisionData, StopMessageTable) == 0x000030, "Member 'FATEventBattleVisionData::StopMessageTable' has a wrong offset!");

// ScriptStruct AT.ExtendProgressTypes
// 0x0008 (0x0010 - 0x0008)
struct FExtendProgressTypes final : public FTableRowBase
{
public:
	int32                                         OrderNo;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtendProgressTypes) == 0x000008, "Wrong alignment on FExtendProgressTypes");
static_assert(sizeof(FExtendProgressTypes) == 0x000010, "Wrong size on FExtendProgressTypes");
static_assert(offsetof(FExtendProgressTypes, OrderNo) == 0x000008, "Member 'FExtendProgressTypes::OrderNo' has a wrong offset!");

// ScriptStruct AT.StrongholdMeshs
// 0x0018 (0x0018 - 0x0000)
struct FStrongholdMeshs final
{
public:
	TSubclassOf<class ASkeletalMeshActor>         MeshActor;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OffsetSpawnPos;                                    // 0x0008(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FStrongholdMeshs) == 0x000008, "Wrong alignment on FStrongholdMeshs");
static_assert(sizeof(FStrongholdMeshs) == 0x000018, "Wrong size on FStrongholdMeshs");
static_assert(offsetof(FStrongholdMeshs, MeshActor) == 0x000000, "Member 'FStrongholdMeshs::MeshActor' has a wrong offset!");
static_assert(offsetof(FStrongholdMeshs, OffsetSpawnPos) == 0x000008, "Member 'FStrongholdMeshs::OffsetSpawnPos' has a wrong offset!");

// ScriptStruct AT.CameraAnimParam
// 0x0008 (0x0010 - 0x0008)
struct FCameraAnimParam final : public FTableRowBase
{
public:
	class UCameraAnim*                            RefCameraAnim;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCameraAnimParam) == 0x000008, "Wrong alignment on FCameraAnimParam");
static_assert(sizeof(FCameraAnimParam) == 0x000010, "Wrong size on FCameraAnimParam");
static_assert(offsetof(FCameraAnimParam, RefCameraAnim) == 0x000008, "Member 'FCameraAnimParam::RefCameraAnim' has a wrong offset!");

// ScriptStruct AT.FeverIgnoreMainQuestTableRow
// 0x0010 (0x0018 - 0x0008)
struct FFeverIgnoreMainQuestTableRow final : public FTableRowBase
{
public:
	class FName                                   IgnoreStart;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IgnoreEnd;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeverIgnoreMainQuestTableRow) == 0x000008, "Wrong alignment on FFeverIgnoreMainQuestTableRow");
static_assert(sizeof(FFeverIgnoreMainQuestTableRow) == 0x000018, "Wrong size on FFeverIgnoreMainQuestTableRow");
static_assert(offsetof(FFeverIgnoreMainQuestTableRow, IgnoreStart) == 0x000008, "Member 'FFeverIgnoreMainQuestTableRow::IgnoreStart' has a wrong offset!");
static_assert(offsetof(FFeverIgnoreMainQuestTableRow, IgnoreEnd) == 0x000010, "Member 'FFeverIgnoreMainQuestTableRow::IgnoreEnd' has a wrong offset!");

// ScriptStruct AT.FeverDetailTableRow
// 0x0048 (0x0050 - 0x0008)
struct FFeverDetailTableRow final : public FTableRowBase
{
public:
	class FName                                   FeverDetailId;                                     // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFeverCategory                                FeverCategory;                                     // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Weight;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFeverKind                                    EffectKind_1;                                      // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectParam_1;                                     // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFeverKind                                    EffectKind_2;                                      // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectParam_2;                                     // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFeverKind                                    EffectKind_3;                                      // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectParam_3;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   IconName;                                          // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaTextId;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldMapTextId;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ShortTextId;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFeverDetailTableRow) == 0x000008, "Wrong alignment on FFeverDetailTableRow");
static_assert(sizeof(FFeverDetailTableRow) == 0x000050, "Wrong size on FFeverDetailTableRow");
static_assert(offsetof(FFeverDetailTableRow, FeverDetailId) == 0x000008, "Member 'FFeverDetailTableRow::FeverDetailId' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, FeverCategory) == 0x000010, "Member 'FFeverDetailTableRow::FeverCategory' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, Weight) == 0x000014, "Member 'FFeverDetailTableRow::Weight' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, EffectKind_1) == 0x000018, "Member 'FFeverDetailTableRow::EffectKind_1' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, EffectParam_1) == 0x00001C, "Member 'FFeverDetailTableRow::EffectParam_1' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, EffectKind_2) == 0x000020, "Member 'FFeverDetailTableRow::EffectKind_2' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, EffectParam_2) == 0x000024, "Member 'FFeverDetailTableRow::EffectParam_2' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, EffectKind_3) == 0x000028, "Member 'FFeverDetailTableRow::EffectKind_3' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, EffectParam_3) == 0x00002C, "Member 'FFeverDetailTableRow::EffectParam_3' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, IconName) == 0x000030, "Member 'FFeverDetailTableRow::IconName' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, AreaTextId) == 0x000038, "Member 'FFeverDetailTableRow::AreaTextId' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, WorldMapTextId) == 0x000040, "Member 'FFeverDetailTableRow::WorldMapTextId' has a wrong offset!");
static_assert(offsetof(FFeverDetailTableRow, ShortTextId) == 0x000048, "Member 'FFeverDetailTableRow::ShortTextId' has a wrong offset!");

// ScriptStruct AT.FeverParamsRow
// 0x0028 (0x0030 - 0x0008)
struct FFeverParamsRow final : public FTableRowBase
{
public:
	class FName                                   CondUnlockFeverQuestId;                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerMin;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerMax;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimerCalcBase;                                     // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProbAdd;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IntervalAddTime;                                   // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ThroughLimitCount;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFeverParamsRow) == 0x000008, "Wrong alignment on FFeverParamsRow");
static_assert(sizeof(FFeverParamsRow) == 0x000030, "Wrong size on FFeverParamsRow");
static_assert(offsetof(FFeverParamsRow, CondUnlockFeverQuestId) == 0x000008, "Member 'FFeverParamsRow::CondUnlockFeverQuestId' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, TimerMin) == 0x000010, "Member 'FFeverParamsRow::TimerMin' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, TimerMax) == 0x000014, "Member 'FFeverParamsRow::TimerMax' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, TimerCalcBase) == 0x000018, "Member 'FFeverParamsRow::TimerCalcBase' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, Probability) == 0x00001C, "Member 'FFeverParamsRow::Probability' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, ProbAdd) == 0x000020, "Member 'FFeverParamsRow::ProbAdd' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, IntervalAddTime) == 0x000024, "Member 'FFeverParamsRow::IntervalAddTime' has a wrong offset!");
static_assert(offsetof(FFeverParamsRow, ThroughLimitCount) == 0x000028, "Member 'FFeverParamsRow::ThroughLimitCount' has a wrong offset!");

// ScriptStruct AT.ATWindRoadPointParamCamera
// 0x0018 (0x0018 - 0x0000)
struct FATWindRoadPointParamCamera final
{
public:
	bool                                          bApplyFov;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FOV;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FovInterp;                                         // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyDistance;                                    // 0x000C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceInterp;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWindRoadPointParamCamera) == 0x000004, "Wrong alignment on FATWindRoadPointParamCamera");
static_assert(sizeof(FATWindRoadPointParamCamera) == 0x000018, "Wrong size on FATWindRoadPointParamCamera");
static_assert(offsetof(FATWindRoadPointParamCamera, bApplyFov) == 0x000000, "Member 'FATWindRoadPointParamCamera::bApplyFov' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamCamera, FOV) == 0x000004, "Member 'FATWindRoadPointParamCamera::FOV' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamCamera, FovInterp) == 0x000008, "Member 'FATWindRoadPointParamCamera::FovInterp' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamCamera, bApplyDistance) == 0x00000C, "Member 'FATWindRoadPointParamCamera::bApplyDistance' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamCamera, Distance) == 0x000010, "Member 'FATWindRoadPointParamCamera::Distance' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParamCamera, DistanceInterp) == 0x000014, "Member 'FATWindRoadPointParamCamera::DistanceInterp' has a wrong offset!");

// ScriptStruct AT.ATWindRoadPointParam
// 0x0024 (0x0024 - 0x0000)
struct FATWindRoadPointParam final
{
public:
	struct FATWindRoadPointParamChangeSpeed       ChangeSpeedParam;                                  // 0x0000(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FATWindRoadPointParamCamera            CameraParam;                                       // 0x000C(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWindRoadPointParam) == 0x000004, "Wrong alignment on FATWindRoadPointParam");
static_assert(sizeof(FATWindRoadPointParam) == 0x000024, "Wrong size on FATWindRoadPointParam");
static_assert(offsetof(FATWindRoadPointParam, ChangeSpeedParam) == 0x000000, "Member 'FATWindRoadPointParam::ChangeSpeedParam' has a wrong offset!");
static_assert(offsetof(FATWindRoadPointParam, CameraParam) == 0x00000C, "Member 'FATWindRoadPointParam::CameraParam' has a wrong offset!");

// ScriptStruct AT.MiniGameRaceSaveOutline
// 0x00A0 (0x00A0 - 0x0000)
struct FMiniGameRaceSaveOutline final
{
public:
	TMap<EMiniGameRaceMode, struct FMiniGameRaceSaveDetails> Details;                                           // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EMiniGameRaceMode, struct FLocalRaceRank> RaceModeRanking;                                   // 0x0050(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniGameRaceSaveOutline) == 0x000008, "Wrong alignment on FMiniGameRaceSaveOutline");
static_assert(sizeof(FMiniGameRaceSaveOutline) == 0x0000A0, "Wrong size on FMiniGameRaceSaveOutline");
static_assert(offsetof(FMiniGameRaceSaveOutline, Details) == 0x000000, "Member 'FMiniGameRaceSaveOutline::Details' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveOutline, RaceModeRanking) == 0x000050, "Member 'FMiniGameRaceSaveOutline::RaceModeRanking' has a wrong offset!");

// ScriptStruct AT.FetchingTalkParameter
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FFetchingTalkParameter final
{
public:
	class FName                                   ExistTalkId;                                       // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotExistTalkId;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HaveMoneyTalkId;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NotHaveMoneyTalkId;                                // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FinishedTalkId;                                    // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFetchingTalkParameter) == 0x000008, "Wrong alignment on FFetchingTalkParameter");
static_assert(sizeof(FFetchingTalkParameter) == 0x000028, "Wrong size on FFetchingTalkParameter");
static_assert(offsetof(FFetchingTalkParameter, ExistTalkId) == 0x000000, "Member 'FFetchingTalkParameter::ExistTalkId' has a wrong offset!");
static_assert(offsetof(FFetchingTalkParameter, NotExistTalkId) == 0x000008, "Member 'FFetchingTalkParameter::NotExistTalkId' has a wrong offset!");
static_assert(offsetof(FFetchingTalkParameter, HaveMoneyTalkId) == 0x000010, "Member 'FFetchingTalkParameter::HaveMoneyTalkId' has a wrong offset!");
static_assert(offsetof(FFetchingTalkParameter, NotHaveMoneyTalkId) == 0x000018, "Member 'FFetchingTalkParameter::NotHaveMoneyTalkId' has a wrong offset!");
static_assert(offsetof(FFetchingTalkParameter, FinishedTalkId) == 0x000020, "Member 'FFetchingTalkParameter::FinishedTalkId' has a wrong offset!");

// ScriptStruct AT.QuestFutureVisionParam
// 0x0020 (0x0028 - 0x0008)
struct FQuestFutureVisionParam final : public FTableRowBase
{
public:
	TArray<TSoftObjectPtr<class UTexture2D>>      PictureTexturePath;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         OmenCount;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrossFadeTime;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestFutureVisionParam) == 0x000008, "Wrong alignment on FQuestFutureVisionParam");
static_assert(sizeof(FQuestFutureVisionParam) == 0x000028, "Wrong size on FQuestFutureVisionParam");
static_assert(offsetof(FQuestFutureVisionParam, PictureTexturePath) == 0x000008, "Member 'FQuestFutureVisionParam::PictureTexturePath' has a wrong offset!");
static_assert(offsetof(FQuestFutureVisionParam, OmenCount) == 0x000018, "Member 'FQuestFutureVisionParam::OmenCount' has a wrong offset!");
static_assert(offsetof(FQuestFutureVisionParam, FadeInTime) == 0x00001C, "Member 'FQuestFutureVisionParam::FadeInTime' has a wrong offset!");
static_assert(offsetof(FQuestFutureVisionParam, CrossFadeTime) == 0x000020, "Member 'FQuestFutureVisionParam::CrossFadeTime' has a wrong offset!");

// ScriptStruct AT.ATGameModeActorComponentSettings
// 0x0018 (0x0018 - 0x0000)
struct FATGameModeActorComponentSettings final
{
public:
	TSubclassOf<class UActorComponent>            Class;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        Component;                                         // 0x0008(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATGameModeActorComponentSettings) == 0x000008, "Wrong alignment on FATGameModeActorComponentSettings");
static_assert(sizeof(FATGameModeActorComponentSettings) == 0x000018, "Wrong size on FATGameModeActorComponentSettings");
static_assert(offsetof(FATGameModeActorComponentSettings, Class) == 0x000000, "Member 'FATGameModeActorComponentSettings::Class' has a wrong offset!");
static_assert(offsetof(FATGameModeActorComponentSettings, Component) == 0x000008, "Member 'FATGameModeActorComponentSettings::Component' has a wrong offset!");

// ScriptStruct AT.ItemShopDataTableType
// 0x0020 (0x0028 - 0x0008)
struct FItemShopDataTableType final : public FTableRowBase
{
public:
	class FName                                   ShopId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ShopListData;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartProgress;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndProgress;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemShopDataTableType) == 0x000008, "Wrong alignment on FItemShopDataTableType");
static_assert(sizeof(FItemShopDataTableType) == 0x000028, "Wrong size on FItemShopDataTableType");
static_assert(offsetof(FItemShopDataTableType, ShopId) == 0x000008, "Member 'FItemShopDataTableType::ShopId' has a wrong offset!");
static_assert(offsetof(FItemShopDataTableType, ShopListData) == 0x000010, "Member 'FItemShopDataTableType::ShopListData' has a wrong offset!");
static_assert(offsetof(FItemShopDataTableType, StartProgress) == 0x000018, "Member 'FItemShopDataTableType::StartProgress' has a wrong offset!");
static_assert(offsetof(FItemShopDataTableType, EndProgress) == 0x000020, "Member 'FItemShopDataTableType::EndProgress' has a wrong offset!");

// ScriptStruct AT.QuestFlagPair
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FQuestFlagPair final
{
public:
	class FName                                   Key;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestFlagPair) == 0x000008, "Wrong alignment on FQuestFlagPair");
static_assert(sizeof(FQuestFlagPair) == 0x000010, "Wrong size on FQuestFlagPair");
static_assert(offsetof(FQuestFlagPair, Key) == 0x000000, "Member 'FQuestFlagPair::Key' has a wrong offset!");
static_assert(offsetof(FQuestFlagPair, Value) == 0x000008, "Member 'FQuestFlagPair::Value' has a wrong offset!");

// ScriptStruct AT.ItemPair
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FItemPair final
{
public:
	class FName                                   ItemId;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemPair) == 0x000008, "Wrong alignment on FItemPair");
static_assert(sizeof(FItemPair) == 0x000010, "Wrong size on FItemPair");
static_assert(offsetof(FItemPair, ItemId) == 0x000000, "Member 'FItemPair::ItemId' has a wrong offset!");
static_assert(offsetof(FItemPair, Count) == 0x000008, "Member 'FItemPair::Count' has a wrong offset!");

// ScriptStruct AT.InitialPlayerData
// 0x00B0 (0x00B8 - 0x0008)
struct FInitialPlayerData final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharactersType;                                    // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharactersExp;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Money;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RedOrb;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GreenOrb;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlueOrb;                                           // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RainbowOrb;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemPair>                      Items;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 ItemPaletteSettingTablePath;                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          GainImportantItems;                                // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlreadyReadWorldMapGuidance;                       // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AlreadyReadTutorial;                               // 0x004A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnlockMission;                                     // 0x004B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReleaseZCollection;                                // 0x004C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnlockZCollection;                                 // 0x004D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CompletedSubQuest;                                 // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TeleportActorName;                                 // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TeleportSubQuestId;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ClearedQuestIds;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 FulfilledWishIds;                                  // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   ProgressID;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FQuestFlagPair>                 EnabledQuestFlags;                                 // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FQuestPair>                     QuestIds;                                          // 0x00A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   PlayingDlcId;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInitialPlayerData) == 0x000008, "Wrong alignment on FInitialPlayerData");
static_assert(sizeof(FInitialPlayerData) == 0x0000B8, "Wrong size on FInitialPlayerData");
static_assert(offsetof(FInitialPlayerData, CharactersType) == 0x000008, "Member 'FInitialPlayerData::CharactersType' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, CharactersExp) == 0x00000C, "Member 'FInitialPlayerData::CharactersExp' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, Money) == 0x000010, "Member 'FInitialPlayerData::Money' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, RedOrb) == 0x000014, "Member 'FInitialPlayerData::RedOrb' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, GreenOrb) == 0x000018, "Member 'FInitialPlayerData::GreenOrb' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, BlueOrb) == 0x00001C, "Member 'FInitialPlayerData::BlueOrb' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, RainbowOrb) == 0x000020, "Member 'FInitialPlayerData::RainbowOrb' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, Items) == 0x000028, "Member 'FInitialPlayerData::Items' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, ItemPaletteSettingTablePath) == 0x000038, "Member 'FInitialPlayerData::ItemPaletteSettingTablePath' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, GainImportantItems) == 0x000048, "Member 'FInitialPlayerData::GainImportantItems' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, AlreadyReadWorldMapGuidance) == 0x000049, "Member 'FInitialPlayerData::AlreadyReadWorldMapGuidance' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, AlreadyReadTutorial) == 0x00004A, "Member 'FInitialPlayerData::AlreadyReadTutorial' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, UnlockMission) == 0x00004B, "Member 'FInitialPlayerData::UnlockMission' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, ReleaseZCollection) == 0x00004C, "Member 'FInitialPlayerData::ReleaseZCollection' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, UnlockZCollection) == 0x00004D, "Member 'FInitialPlayerData::UnlockZCollection' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, CompletedSubQuest) == 0x00004E, "Member 'FInitialPlayerData::CompletedSubQuest' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, TeleportActorName) == 0x000050, "Member 'FInitialPlayerData::TeleportActorName' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, TeleportSubQuestId) == 0x000058, "Member 'FInitialPlayerData::TeleportSubQuestId' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, ClearedQuestIds) == 0x000060, "Member 'FInitialPlayerData::ClearedQuestIds' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, FulfilledWishIds) == 0x000070, "Member 'FInitialPlayerData::FulfilledWishIds' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, ProgressID) == 0x000080, "Member 'FInitialPlayerData::ProgressID' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, AreaName) == 0x000088, "Member 'FInitialPlayerData::AreaName' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, EnabledQuestFlags) == 0x000090, "Member 'FInitialPlayerData::EnabledQuestFlags' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, QuestIds) == 0x0000A0, "Member 'FInitialPlayerData::QuestIds' has a wrong offset!");
static_assert(offsetof(FInitialPlayerData, PlayingDlcId) == 0x0000B0, "Member 'FInitialPlayerData::PlayingDlcId' has a wrong offset!");

// ScriptStruct AT.ATInteractiveActionParam
// 0x0008 (0x0010 - 0x0008)
struct FATInteractiveActionParam final : public FTableRowBase
{
public:
	float                                         Distance;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Degree;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATInteractiveActionParam) == 0x000008, "Wrong alignment on FATInteractiveActionParam");
static_assert(sizeof(FATInteractiveActionParam) == 0x000010, "Wrong size on FATInteractiveActionParam");
static_assert(offsetof(FATInteractiveActionParam, Distance) == 0x000008, "Member 'FATInteractiveActionParam::Distance' has a wrong offset!");
static_assert(offsetof(FATInteractiveActionParam, Degree) == 0x00000C, "Member 'FATInteractiveActionParam::Degree' has a wrong offset!");

// ScriptStruct AT.NpcTalkParam
// 0x00F8 (0x0100 - 0x0008)
struct FNpcTalkParam final : public FTableRowBase
{
public:
	class FString                                 Talk_id;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_id;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETALK_REACTION                                Reaction;                                          // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Chapter;                                           // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Talk_times_num;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETALK_TIMES_CONFIG                            TALK_TIMES_CONFIG;                                 // 0x0034(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Quest_id;                                          // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETalkWindowType                               Window_type;                                       // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Exception_bp_name;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Selection_item_id;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 begin_action_command_id;                           // 0x0068(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 End_action_command_id;                             // 0x0078(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETalkEventType                                Talk_event;                                        // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Talk_event_parameter_id;                           // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Progress_id;                                       // 0x0098(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Extend_progress_id;                                // 0x00A8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Talk_condition_param;                              // 0x00B8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Talk_condition_talk_id;                            // 0x00C8(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Talk_condition_item_id;                            // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Talk_minigame_id;                                  // 0x00E0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Quest_item_param_id;                               // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Player_chara_type;                                 // 0x00F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Support_chara_type;                                // 0x00F9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FA[0x6];                                       // 0x00FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcTalkParam) == 0x000008, "Wrong alignment on FNpcTalkParam");
static_assert(sizeof(FNpcTalkParam) == 0x000100, "Wrong size on FNpcTalkParam");
static_assert(offsetof(FNpcTalkParam, Talk_id) == 0x000008, "Member 'FNpcTalkParam::Talk_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Message_id) == 0x000018, "Member 'FNpcTalkParam::Message_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Reaction) == 0x000028, "Member 'FNpcTalkParam::Reaction' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Chapter) == 0x00002C, "Member 'FNpcTalkParam::Chapter' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_times_num) == 0x000030, "Member 'FNpcTalkParam::Talk_times_num' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, TALK_TIMES_CONFIG) == 0x000034, "Member 'FNpcTalkParam::TALK_TIMES_CONFIG' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Quest_id) == 0x000038, "Member 'FNpcTalkParam::Quest_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Window_type) == 0x000040, "Member 'FNpcTalkParam::Window_type' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Exception_bp_name) == 0x000048, "Member 'FNpcTalkParam::Exception_bp_name' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Selection_item_id) == 0x000058, "Member 'FNpcTalkParam::Selection_item_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, begin_action_command_id) == 0x000068, "Member 'FNpcTalkParam::begin_action_command_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, End_action_command_id) == 0x000078, "Member 'FNpcTalkParam::End_action_command_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_event) == 0x000088, "Member 'FNpcTalkParam::Talk_event' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_event_parameter_id) == 0x000090, "Member 'FNpcTalkParam::Talk_event_parameter_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Progress_id) == 0x000098, "Member 'FNpcTalkParam::Progress_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Extend_progress_id) == 0x0000A8, "Member 'FNpcTalkParam::Extend_progress_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_condition_param) == 0x0000B8, "Member 'FNpcTalkParam::Talk_condition_param' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_condition_talk_id) == 0x0000C8, "Member 'FNpcTalkParam::Talk_condition_talk_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_condition_item_id) == 0x0000D8, "Member 'FNpcTalkParam::Talk_condition_item_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Talk_minigame_id) == 0x0000E0, "Member 'FNpcTalkParam::Talk_minigame_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Quest_item_param_id) == 0x0000F0, "Member 'FNpcTalkParam::Quest_item_param_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Player_chara_type) == 0x0000F8, "Member 'FNpcTalkParam::Player_chara_type' has a wrong offset!");
static_assert(offsetof(FNpcTalkParam, Support_chara_type) == 0x0000F9, "Member 'FNpcTalkParam::Support_chara_type' has a wrong offset!");

// ScriptStruct AT.ItemTradeParameter
// 0x0010 (0x0018 - 0x0008)
struct FItemTradeParameter final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTradeParameter) == 0x000008, "Wrong alignment on FItemTradeParameter");
static_assert(sizeof(FItemTradeParameter) == 0x000018, "Wrong size on FItemTradeParameter");
static_assert(offsetof(FItemTradeParameter, ItemId) == 0x000008, "Member 'FItemTradeParameter::ItemId' has a wrong offset!");
static_assert(offsetof(FItemTradeParameter, ItemNum) == 0x000010, "Member 'FItemTradeParameter::ItemNum' has a wrong offset!");

// ScriptStruct AT.ItemTraderCondition
// 0x0030 (0x0038 - 0x0008)
struct FItemTraderCondition final : public FTableRowBase
{
public:
	TArray<struct FItemTradeProbability>          TradableId;                                        // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ReceivableInterval;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReceivableItemMax;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableCommunitySkill;                              // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FItemTradeUpdatableCondition>   UpdatableCondition;                                // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTraderCondition) == 0x000008, "Wrong alignment on FItemTraderCondition");
static_assert(sizeof(FItemTraderCondition) == 0x000038, "Wrong size on FItemTraderCondition");
static_assert(offsetof(FItemTraderCondition, TradableId) == 0x000008, "Member 'FItemTraderCondition::TradableId' has a wrong offset!");
static_assert(offsetof(FItemTraderCondition, ReceivableInterval) == 0x000018, "Member 'FItemTraderCondition::ReceivableInterval' has a wrong offset!");
static_assert(offsetof(FItemTraderCondition, ReceivableItemMax) == 0x00001C, "Member 'FItemTraderCondition::ReceivableItemMax' has a wrong offset!");
static_assert(offsetof(FItemTraderCondition, EnableCommunitySkill) == 0x000020, "Member 'FItemTraderCondition::EnableCommunitySkill' has a wrong offset!");
static_assert(offsetof(FItemTraderCondition, UpdatableCondition) == 0x000028, "Member 'FItemTraderCondition::UpdatableCondition' has a wrong offset!");

// ScriptStruct AT.CookFoodMeshData
// 0x0078 (0x0078 - 0x0000)
struct FCookFoodMeshData final
{
public:
	class USkeletalMesh*                          MainFoodMesh;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          SubFoodMesh;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          GrabFoodMainMesh;                                  // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          GrabSaiyaFoodMainMesh;                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrabMainMeshScaleValue;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          GrabSubFoodMesh;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          GrabSaiyaSubFoodMesh;                              // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GrabSubMeshScaleValue;                             // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          LeftoverFoodMesh;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FreeMainDishMesh;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          FreeSubDishMesh;                                   // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          AttachmentMesh;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          AttachmentMeshSaiyan;                              // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMesh*                          AttachmentMeshLastDish;                            // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFreeSocket;                                  // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCookFoodMeshData) == 0x000008, "Wrong alignment on FCookFoodMeshData");
static_assert(sizeof(FCookFoodMeshData) == 0x000078, "Wrong size on FCookFoodMeshData");
static_assert(offsetof(FCookFoodMeshData, MainFoodMesh) == 0x000000, "Member 'FCookFoodMeshData::MainFoodMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, SubFoodMesh) == 0x000008, "Member 'FCookFoodMeshData::SubFoodMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, GrabFoodMainMesh) == 0x000010, "Member 'FCookFoodMeshData::GrabFoodMainMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, GrabSaiyaFoodMainMesh) == 0x000018, "Member 'FCookFoodMeshData::GrabSaiyaFoodMainMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, GrabMainMeshScaleValue) == 0x000020, "Member 'FCookFoodMeshData::GrabMainMeshScaleValue' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, GrabSubFoodMesh) == 0x000028, "Member 'FCookFoodMeshData::GrabSubFoodMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, GrabSaiyaSubFoodMesh) == 0x000030, "Member 'FCookFoodMeshData::GrabSaiyaSubFoodMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, GrabSubMeshScaleValue) == 0x000038, "Member 'FCookFoodMeshData::GrabSubMeshScaleValue' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, LeftoverFoodMesh) == 0x000040, "Member 'FCookFoodMeshData::LeftoverFoodMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, FreeMainDishMesh) == 0x000048, "Member 'FCookFoodMeshData::FreeMainDishMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, FreeSubDishMesh) == 0x000050, "Member 'FCookFoodMeshData::FreeSubDishMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, AttachmentMesh) == 0x000058, "Member 'FCookFoodMeshData::AttachmentMesh' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, AttachmentMeshSaiyan) == 0x000060, "Member 'FCookFoodMeshData::AttachmentMeshSaiyan' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, AttachmentMeshLastDish) == 0x000068, "Member 'FCookFoodMeshData::AttachmentMeshLastDish' has a wrong offset!");
static_assert(offsetof(FCookFoodMeshData, IgnoreFreeSocket) == 0x000070, "Member 'FCookFoodMeshData::IgnoreFreeSocket' has a wrong offset!");

// ScriptStruct AT.JostleBeamDiffLevelInfoParameter
// 0x0008 (0x0008 - 0x0000)
struct FJostleBeamDiffLevelInfoParameter final
{
public:
	int32                                         DiffLevel;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelRate;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJostleBeamDiffLevelInfoParameter) == 0x000004, "Wrong alignment on FJostleBeamDiffLevelInfoParameter");
static_assert(sizeof(FJostleBeamDiffLevelInfoParameter) == 0x000008, "Wrong size on FJostleBeamDiffLevelInfoParameter");
static_assert(offsetof(FJostleBeamDiffLevelInfoParameter, DiffLevel) == 0x000000, "Member 'FJostleBeamDiffLevelInfoParameter::DiffLevel' has a wrong offset!");
static_assert(offsetof(FJostleBeamDiffLevelInfoParameter, LevelRate) == 0x000004, "Member 'FJostleBeamDiffLevelInfoParameter::LevelRate' has a wrong offset!");

// ScriptStruct AT.PhaseTimingInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FPhaseTimingInfo final
{
public:
	class FName                                   PhaseID;                                           // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_GENERAL_TIMING                         Timing;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhaseTimingInfo) == 0x000008, "Wrong alignment on FPhaseTimingInfo");
static_assert(sizeof(FPhaseTimingInfo) == 0x000010, "Wrong size on FPhaseTimingInfo");
static_assert(offsetof(FPhaseTimingInfo, PhaseID) == 0x000000, "Member 'FPhaseTimingInfo::PhaseID' has a wrong offset!");
static_assert(offsetof(FPhaseTimingInfo, Timing) == 0x000008, "Member 'FPhaseTimingInfo::Timing' has a wrong offset!");

// ScriptStruct AT.KpiBNIDEntryData
// 0x0014 (0x0018 - 0x0004)
struct FKpiBNIDEntryData final : public FKpiBNIDData
{
public:
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QRCodeBaseURL;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKpiBNIDEntryData) == 0x000008, "Wrong alignment on FKpiBNIDEntryData");
static_assert(sizeof(FKpiBNIDEntryData) == 0x000018, "Wrong size on FKpiBNIDEntryData");
static_assert(offsetof(FKpiBNIDEntryData, QRCodeBaseURL) == 0x000008, "Member 'FKpiBNIDEntryData::QRCodeBaseURL' has a wrong offset!");

// ScriptStruct AT.LoginParam
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FLoginParam final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoginParam) == 0x000008, "Wrong alignment on FLoginParam");
static_assert(sizeof(FLoginParam) == 0x000028, "Wrong size on FLoginParam");

// ScriptStruct AT.ATLevelChangeTable
// 0x0018 (0x0020 - 0x0008)
struct FATLevelChangeTable final : public FTableRowBase
{
public:
	class FName                                   Tag;                                               // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATLevelChangeTable) == 0x000008, "Wrong alignment on FATLevelChangeTable");
static_assert(sizeof(FATLevelChangeTable) == 0x000020, "Wrong size on FATLevelChangeTable");
static_assert(offsetof(FATLevelChangeTable, Tag) == 0x000008, "Member 'FATLevelChangeTable::Tag' has a wrong offset!");
static_assert(offsetof(FATLevelChangeTable, LevelName) == 0x000010, "Member 'FATLevelChangeTable::LevelName' has a wrong offset!");

// ScriptStruct AT.ATPersistentLevelInfo
// 0x0020 (0x0028 - 0x0008)
struct FATPersistentLevelInfo final : public FTableRowBase
{
public:
	class FName                                   LevelName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelPath;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EAreaDirection>                        Direction;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATPersistentLevelInfo) == 0x000008, "Wrong alignment on FATPersistentLevelInfo");
static_assert(sizeof(FATPersistentLevelInfo) == 0x000028, "Wrong size on FATPersistentLevelInfo");
static_assert(offsetof(FATPersistentLevelInfo, LevelName) == 0x000008, "Member 'FATPersistentLevelInfo::LevelName' has a wrong offset!");
static_assert(offsetof(FATPersistentLevelInfo, LevelPath) == 0x000010, "Member 'FATPersistentLevelInfo::LevelPath' has a wrong offset!");
static_assert(offsetof(FATPersistentLevelInfo, Direction) == 0x000018, "Member 'FATPersistentLevelInfo::Direction' has a wrong offset!");

// ScriptStruct AT.ATLevelProgressPair
// 0x0098 (0x00A0 - 0x0008)
struct FATLevelProgressPair final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressBegin;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressBeginCondition;                            // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressEnd;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressEndCondition;                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VisibleBegin;                                      // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVisibleTiming                                TimingType;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TimingValue;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DeactivateValue;                                   // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EnableRequiredDlcId;                               // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisableRequiredDlcId;                              // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRestrictedByPhaseNum;                             // 0x0090(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PhaseBegin;                                        // 0x0094(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseEnd;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATLevelProgressPair) == 0x000008, "Wrong alignment on FATLevelProgressPair");
static_assert(sizeof(FATLevelProgressPair) == 0x0000A0, "Wrong size on FATLevelProgressPair");
static_assert(offsetof(FATLevelProgressPair, Level) == 0x000008, "Member 'FATLevelProgressPair::Level' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, ProgressBegin) == 0x000030, "Member 'FATLevelProgressPair::ProgressBegin' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, ProgressBeginCondition) == 0x000038, "Member 'FATLevelProgressPair::ProgressBeginCondition' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, ProgressEnd) == 0x000040, "Member 'FATLevelProgressPair::ProgressEnd' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, ProgressEndCondition) == 0x000048, "Member 'FATLevelProgressPair::ProgressEndCondition' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, VisibleBegin) == 0x000050, "Member 'FATLevelProgressPair::VisibleBegin' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, TimingType) == 0x000058, "Member 'FATLevelProgressPair::TimingType' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, TimingValue) == 0x000060, "Member 'FATLevelProgressPair::TimingValue' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, DeactivateValue) == 0x000070, "Member 'FATLevelProgressPair::DeactivateValue' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, EnableRequiredDlcId) == 0x000080, "Member 'FATLevelProgressPair::EnableRequiredDlcId' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, DisableRequiredDlcId) == 0x000088, "Member 'FATLevelProgressPair::DisableRequiredDlcId' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, bRestrictedByPhaseNum) == 0x000090, "Member 'FATLevelProgressPair::bRestrictedByPhaseNum' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, PhaseBegin) == 0x000094, "Member 'FATLevelProgressPair::PhaseBegin' has a wrong offset!");
static_assert(offsetof(FATLevelProgressPair, PhaseEnd) == 0x000098, "Member 'FATLevelProgressPair::PhaseEnd' has a wrong offset!");

// ScriptStruct AT.ATLoadedLevel
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FATLoadedLevel final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATLoadedLevel) == 0x000008, "Wrong alignment on FATLoadedLevel");
static_assert(sizeof(FATLoadedLevel) == 0x000010, "Wrong size on FATLoadedLevel");

// ScriptStruct AT.ATLevelLoadInfo
// 0x0030 (0x0038 - 0x0008)
struct FATLevelLoadInfo final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UWorld>                  Level;                                             // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELevelLoadType                                Type;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBeVisible;                                  // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATLevelLoadInfo) == 0x000008, "Wrong alignment on FATLevelLoadInfo");
static_assert(sizeof(FATLevelLoadInfo) == 0x000038, "Wrong size on FATLevelLoadInfo");
static_assert(offsetof(FATLevelLoadInfo, Level) == 0x000008, "Member 'FATLevelLoadInfo::Level' has a wrong offset!");
static_assert(offsetof(FATLevelLoadInfo, Type) == 0x000030, "Member 'FATLevelLoadInfo::Type' has a wrong offset!");
static_assert(offsetof(FATLevelLoadInfo, bShouldBeVisible) == 0x000031, "Member 'FATLevelLoadInfo::bShouldBeVisible' has a wrong offset!");

// ScriptStruct AT.ATLevelEventParam
// 0x0020 (0x0020 - 0x0000)
struct FATLevelEventParam final
{
public:
	class FString                                 SendMessage;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SendValue;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATLevelEventParam) == 0x000008, "Wrong alignment on FATLevelEventParam");
static_assert(sizeof(FATLevelEventParam) == 0x000020, "Wrong size on FATLevelEventParam");
static_assert(offsetof(FATLevelEventParam, SendMessage) == 0x000000, "Member 'FATLevelEventParam::SendMessage' has a wrong offset!");
static_assert(offsetof(FATLevelEventParam, SendValue) == 0x000010, "Member 'FATLevelEventParam::SendValue' has a wrong offset!");

// ScriptStruct AT.ATLongBlowoffObject
// 0x0018 (0x0018 - 0x0000)
struct FATLongBlowoffObject final
{
public:
	TSubclassOf<class ABreakableDestructibleActor> ObjectClass;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectScale;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectScaleXY;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        ObjectType;                                        // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATLongBlowoffObject) == 0x000008, "Wrong alignment on FATLongBlowoffObject");
static_assert(sizeof(FATLongBlowoffObject) == 0x000018, "Wrong size on FATLongBlowoffObject");
static_assert(offsetof(FATLongBlowoffObject, ObjectClass) == 0x000000, "Member 'FATLongBlowoffObject::ObjectClass' has a wrong offset!");
static_assert(offsetof(FATLongBlowoffObject, ObjectScale) == 0x000008, "Member 'FATLongBlowoffObject::ObjectScale' has a wrong offset!");
static_assert(offsetof(FATLongBlowoffObject, ObjectScaleXY) == 0x00000C, "Member 'FATLongBlowoffObject::ObjectScaleXY' has a wrong offset!");
static_assert(offsetof(FATLongBlowoffObject, ObjectType) == 0x000010, "Member 'FATLongBlowoffObject::ObjectType' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateResourcesLoadManualy
// 0x0220 (0x0220 - 0x0000)
struct FTerrainDecorateResourcesLoadManualy final
{
public:
	TSoftObjectPtr<class UMaterialInterface>      LineLoopDecal;                                     // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LineLoopDecalInstance;                             // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      LineDecalStart;                                    // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LineDecalStartInstance;                            // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      LineDecalEnd;                                      // 0x0060(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     LineDecalEndInstance;                              // 0x0088(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInterface>      CraterDecal;                                       // 0x0090(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     CraterDecalInstance;                               // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         LineEffectParticle;                                // 0x00C0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        LineEffectParticleInstance;                        // 0x00E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeColorLineEffect;                            // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           LineEffectSmkColor;                                // 0x00F4(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineEffectDebColor;                                // 0x0104(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         CraterEffectParticle;                              // 0x0118(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        CraterEffectParticleInstance;                      // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeColorCraterEffect;                          // 0x0148(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x3];                                      // 0x0149(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CraterEffectSmkColor;                              // 0x014C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CraterEffectDebColor;                              // 0x015C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         PenetratetionEffectParticle;                       // 0x0170(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        PenetratetionEffectParticleInstance;               // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeColorPenetratetionEffect;                   // 0x01A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           PenetratetionEffectSmkColor;                       // 0x01A4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PenetratetionEffectDebColor;                       // 0x01B4(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UParticleSystem>         EdgeEffectParticle;                                // 0x01C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EdgeEffectParticleInstance;                        // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EdgeEffectOffset;                                  // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChangeColorEdgeEffect;                            // 0x01FC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD[0x3];                                      // 0x01FD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           EdgeEffectSmkColor;                                // 0x0200(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EdgeEffectDebColor;                                // 0x0210(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainDecorateResourcesLoadManualy) == 0x000008, "Wrong alignment on FTerrainDecorateResourcesLoadManualy");
static_assert(sizeof(FTerrainDecorateResourcesLoadManualy) == 0x000220, "Wrong size on FTerrainDecorateResourcesLoadManualy");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineLoopDecal) == 0x000000, "Member 'FTerrainDecorateResourcesLoadManualy::LineLoopDecal' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineLoopDecalInstance) == 0x000028, "Member 'FTerrainDecorateResourcesLoadManualy::LineLoopDecalInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineDecalStart) == 0x000030, "Member 'FTerrainDecorateResourcesLoadManualy::LineDecalStart' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineDecalStartInstance) == 0x000058, "Member 'FTerrainDecorateResourcesLoadManualy::LineDecalStartInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineDecalEnd) == 0x000060, "Member 'FTerrainDecorateResourcesLoadManualy::LineDecalEnd' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineDecalEndInstance) == 0x000088, "Member 'FTerrainDecorateResourcesLoadManualy::LineDecalEndInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, CraterDecal) == 0x000090, "Member 'FTerrainDecorateResourcesLoadManualy::CraterDecal' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, CraterDecalInstance) == 0x0000B8, "Member 'FTerrainDecorateResourcesLoadManualy::CraterDecalInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineEffectParticle) == 0x0000C0, "Member 'FTerrainDecorateResourcesLoadManualy::LineEffectParticle' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineEffectParticleInstance) == 0x0000E8, "Member 'FTerrainDecorateResourcesLoadManualy::LineEffectParticleInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, bChangeColorLineEffect) == 0x0000F0, "Member 'FTerrainDecorateResourcesLoadManualy::bChangeColorLineEffect' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineEffectSmkColor) == 0x0000F4, "Member 'FTerrainDecorateResourcesLoadManualy::LineEffectSmkColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, LineEffectDebColor) == 0x000104, "Member 'FTerrainDecorateResourcesLoadManualy::LineEffectDebColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, CraterEffectParticle) == 0x000118, "Member 'FTerrainDecorateResourcesLoadManualy::CraterEffectParticle' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, CraterEffectParticleInstance) == 0x000140, "Member 'FTerrainDecorateResourcesLoadManualy::CraterEffectParticleInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, bChangeColorCraterEffect) == 0x000148, "Member 'FTerrainDecorateResourcesLoadManualy::bChangeColorCraterEffect' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, CraterEffectSmkColor) == 0x00014C, "Member 'FTerrainDecorateResourcesLoadManualy::CraterEffectSmkColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, CraterEffectDebColor) == 0x00015C, "Member 'FTerrainDecorateResourcesLoadManualy::CraterEffectDebColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, PenetratetionEffectParticle) == 0x000170, "Member 'FTerrainDecorateResourcesLoadManualy::PenetratetionEffectParticle' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, PenetratetionEffectParticleInstance) == 0x000198, "Member 'FTerrainDecorateResourcesLoadManualy::PenetratetionEffectParticleInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, bChangeColorPenetratetionEffect) == 0x0001A0, "Member 'FTerrainDecorateResourcesLoadManualy::bChangeColorPenetratetionEffect' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, PenetratetionEffectSmkColor) == 0x0001A4, "Member 'FTerrainDecorateResourcesLoadManualy::PenetratetionEffectSmkColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, PenetratetionEffectDebColor) == 0x0001B4, "Member 'FTerrainDecorateResourcesLoadManualy::PenetratetionEffectDebColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, EdgeEffectParticle) == 0x0001C8, "Member 'FTerrainDecorateResourcesLoadManualy::EdgeEffectParticle' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, EdgeEffectParticleInstance) == 0x0001F0, "Member 'FTerrainDecorateResourcesLoadManualy::EdgeEffectParticleInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, EdgeEffectOffset) == 0x0001F8, "Member 'FTerrainDecorateResourcesLoadManualy::EdgeEffectOffset' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, bChangeColorEdgeEffect) == 0x0001FC, "Member 'FTerrainDecorateResourcesLoadManualy::bChangeColorEdgeEffect' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, EdgeEffectSmkColor) == 0x000200, "Member 'FTerrainDecorateResourcesLoadManualy::EdgeEffectSmkColor' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateResourcesLoadManualy, EdgeEffectDebColor) == 0x000210, "Member 'FTerrainDecorateResourcesLoadManualy::EdgeEffectDebColor' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateParameters
// 0x0130 (0x0130 - 0x0000)
struct FTerrainDecorateParameters final
{
public:
	EFadeType                                     FadeType;                                          // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineDecorateSpawnDelaySeconds;                     // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraterDecorateSpawnDelaySeconds;                   // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLineDecals;                                  // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineDecalLifeSeconds;                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDecalFadeSeconds;                              // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDecalStartOffset;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDecalLength;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDecalWidthMax;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDecalWidthMin;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalOverlapRatioMax;                              // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecalOverlapRatioMin;                              // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnLineDebris;                                  // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineDebrisLifeSeconds;                             // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDebrisFadeSeconds;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineSpawnBaseInterval;                       // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TotalDebrisInBaseInterval;                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineSpawnRatio;                              // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             DebrisLineSpawnRetioCurveByDistance;               // 0x0048(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DebrisLineSpawnRetioCurveByDistanceInstance;       // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineDistanceMax;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineDistanceMin;                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineMaxDegrees;                              // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineMinDegrees;                              // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineSnapInMax;                               // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineSnapInMin;                               // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineScaleMax;                                // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisLineScaleMin;                                // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UCurveFloat>             DebrisLineCurve;                                   // 0x0098(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DebrisLineCurveInstance;                           // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableIncidenceAngle;                             // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinIncidenceAngle;                                 // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnCraterDecals;                                // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CraterDecalLifeSeconds;                            // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraterDecalFadeSeconds;                            // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraterDecalRadius;                                 // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnCraterDebris;                                // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CraterDebrisLifeSeconds;                           // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CraterDebrisFadeSeconds;                           // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint32                                        TotalDebrisAroundCrater;                           // 0x00EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterSpawnRatio;                            // 0x00F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterDistanceMax;                           // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterDistanceMin;                           // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterMaxDegrees;                            // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterMinDegrees;                            // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterSnapInMax;                             // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterSnapInMin;                             // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterScaleMax;                              // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DebrisCraterScaleMin;                              // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseCraterEffectRot;                                // 0x0114(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CraterFirstDecal;                                  // 0x0115(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ParticleLifeSeconds;                               // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleCreateInterval;                            // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDecalPhotonRot;                                   // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideRelativeRotation;                         // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               RelativeRotationOverride;                          // 0x0124(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainDecorateParameters) == 0x000008, "Wrong alignment on FTerrainDecorateParameters");
static_assert(sizeof(FTerrainDecorateParameters) == 0x000130, "Wrong size on FTerrainDecorateParameters");
static_assert(offsetof(FTerrainDecorateParameters, FadeType) == 0x000000, "Member 'FTerrainDecorateParameters::FadeType' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecorateSpawnDelaySeconds) == 0x000004, "Member 'FTerrainDecorateParameters::LineDecorateSpawnDelaySeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterDecorateSpawnDelaySeconds) == 0x000008, "Member 'FTerrainDecorateParameters::CraterDecorateSpawnDelaySeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bSpawnLineDecals) == 0x00000C, "Member 'FTerrainDecorateParameters::bSpawnLineDecals' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecalLifeSeconds) == 0x000010, "Member 'FTerrainDecorateParameters::LineDecalLifeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecalFadeSeconds) == 0x000014, "Member 'FTerrainDecorateParameters::LineDecalFadeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecalStartOffset) == 0x000018, "Member 'FTerrainDecorateParameters::LineDecalStartOffset' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecalLength) == 0x00001C, "Member 'FTerrainDecorateParameters::LineDecalLength' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecalWidthMax) == 0x000020, "Member 'FTerrainDecorateParameters::LineDecalWidthMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDecalWidthMin) == 0x000024, "Member 'FTerrainDecorateParameters::LineDecalWidthMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DecalOverlapRatioMax) == 0x000028, "Member 'FTerrainDecorateParameters::DecalOverlapRatioMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DecalOverlapRatioMin) == 0x00002C, "Member 'FTerrainDecorateParameters::DecalOverlapRatioMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bSpawnLineDebris) == 0x000030, "Member 'FTerrainDecorateParameters::bSpawnLineDebris' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDebrisLifeSeconds) == 0x000034, "Member 'FTerrainDecorateParameters::LineDebrisLifeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, LineDebrisFadeSeconds) == 0x000038, "Member 'FTerrainDecorateParameters::LineDebrisFadeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineSpawnBaseInterval) == 0x00003C, "Member 'FTerrainDecorateParameters::DebrisLineSpawnBaseInterval' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, TotalDebrisInBaseInterval) == 0x000040, "Member 'FTerrainDecorateParameters::TotalDebrisInBaseInterval' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineSpawnRatio) == 0x000044, "Member 'FTerrainDecorateParameters::DebrisLineSpawnRatio' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineSpawnRetioCurveByDistance) == 0x000048, "Member 'FTerrainDecorateParameters::DebrisLineSpawnRetioCurveByDistance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineSpawnRetioCurveByDistanceInstance) == 0x000070, "Member 'FTerrainDecorateParameters::DebrisLineSpawnRetioCurveByDistanceInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineDistanceMax) == 0x000078, "Member 'FTerrainDecorateParameters::DebrisLineDistanceMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineDistanceMin) == 0x00007C, "Member 'FTerrainDecorateParameters::DebrisLineDistanceMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineMaxDegrees) == 0x000080, "Member 'FTerrainDecorateParameters::DebrisLineMaxDegrees' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineMinDegrees) == 0x000084, "Member 'FTerrainDecorateParameters::DebrisLineMinDegrees' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineSnapInMax) == 0x000088, "Member 'FTerrainDecorateParameters::DebrisLineSnapInMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineSnapInMin) == 0x00008C, "Member 'FTerrainDecorateParameters::DebrisLineSnapInMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineScaleMax) == 0x000090, "Member 'FTerrainDecorateParameters::DebrisLineScaleMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineScaleMin) == 0x000094, "Member 'FTerrainDecorateParameters::DebrisLineScaleMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineCurve) == 0x000098, "Member 'FTerrainDecorateParameters::DebrisLineCurve' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisLineCurveInstance) == 0x0000C0, "Member 'FTerrainDecorateParameters::DebrisLineCurveInstance' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bEnableIncidenceAngle) == 0x0000C8, "Member 'FTerrainDecorateParameters::bEnableIncidenceAngle' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, MinIncidenceAngle) == 0x0000CC, "Member 'FTerrainDecorateParameters::MinIncidenceAngle' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bSpawnCraterDecals) == 0x0000D0, "Member 'FTerrainDecorateParameters::bSpawnCraterDecals' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterDecalLifeSeconds) == 0x0000D4, "Member 'FTerrainDecorateParameters::CraterDecalLifeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterDecalFadeSeconds) == 0x0000D8, "Member 'FTerrainDecorateParameters::CraterDecalFadeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterDecalRadius) == 0x0000DC, "Member 'FTerrainDecorateParameters::CraterDecalRadius' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bSpawnCraterDebris) == 0x0000E0, "Member 'FTerrainDecorateParameters::bSpawnCraterDebris' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterDebrisLifeSeconds) == 0x0000E4, "Member 'FTerrainDecorateParameters::CraterDebrisLifeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterDebrisFadeSeconds) == 0x0000E8, "Member 'FTerrainDecorateParameters::CraterDebrisFadeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, TotalDebrisAroundCrater) == 0x0000EC, "Member 'FTerrainDecorateParameters::TotalDebrisAroundCrater' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterSpawnRatio) == 0x0000F0, "Member 'FTerrainDecorateParameters::DebrisCraterSpawnRatio' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterDistanceMax) == 0x0000F4, "Member 'FTerrainDecorateParameters::DebrisCraterDistanceMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterDistanceMin) == 0x0000F8, "Member 'FTerrainDecorateParameters::DebrisCraterDistanceMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterMaxDegrees) == 0x0000FC, "Member 'FTerrainDecorateParameters::DebrisCraterMaxDegrees' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterMinDegrees) == 0x000100, "Member 'FTerrainDecorateParameters::DebrisCraterMinDegrees' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterSnapInMax) == 0x000104, "Member 'FTerrainDecorateParameters::DebrisCraterSnapInMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterSnapInMin) == 0x000108, "Member 'FTerrainDecorateParameters::DebrisCraterSnapInMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterScaleMax) == 0x00010C, "Member 'FTerrainDecorateParameters::DebrisCraterScaleMax' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, DebrisCraterScaleMin) == 0x000110, "Member 'FTerrainDecorateParameters::DebrisCraterScaleMin' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, UseCraterEffectRot) == 0x000114, "Member 'FTerrainDecorateParameters::UseCraterEffectRot' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, CraterFirstDecal) == 0x000115, "Member 'FTerrainDecorateParameters::CraterFirstDecal' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, ParticleLifeSeconds) == 0x000118, "Member 'FTerrainDecorateParameters::ParticleLifeSeconds' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, ParticleCreateInterval) == 0x00011C, "Member 'FTerrainDecorateParameters::ParticleCreateInterval' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bDecalPhotonRot) == 0x000120, "Member 'FTerrainDecorateParameters::bDecalPhotonRot' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, bOverrideRelativeRotation) == 0x000121, "Member 'FTerrainDecorateParameters::bOverrideRelativeRotation' has a wrong offset!");
static_assert(offsetof(FTerrainDecorateParameters, RelativeRotationOverride) == 0x000124, "Member 'FTerrainDecorateParameters::RelativeRotationOverride' has a wrong offset!");

// ScriptStruct AT.UniqueTerrainDecorateResourcesRow
// 0x03B0 (0x03B0 - 0x0000)
struct FUniqueTerrainDecorateResourcesRow final
{
public:
	struct FTerrainDecorateResourcesLoadManualy   DecorateResources;                                 // 0x0000(0x0220)(Edit, NativeAccessSpecifierPublic)
	struct FTerrainDecorateParameters             DecorateParameters;                                // 0x0220(0x0130)(Edit, NativeAccessSpecifierPublic)
	class UTerrainDecorateResourcesReferenceCounter* ReferenceCounter;                                  // 0x0350(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EATSurfaceType, struct FTerrainDecorateResourcesLoadManualy> DecorateSurfaceResources;                          // 0x0358(0x0050)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          UseSurfaceType;                                    // 0x03A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueTerrainDecorateResourcesRow) == 0x000008, "Wrong alignment on FUniqueTerrainDecorateResourcesRow");
static_assert(sizeof(FUniqueTerrainDecorateResourcesRow) == 0x0003B0, "Wrong size on FUniqueTerrainDecorateResourcesRow");
static_assert(offsetof(FUniqueTerrainDecorateResourcesRow, DecorateResources) == 0x000000, "Member 'FUniqueTerrainDecorateResourcesRow::DecorateResources' has a wrong offset!");
static_assert(offsetof(FUniqueTerrainDecorateResourcesRow, DecorateParameters) == 0x000220, "Member 'FUniqueTerrainDecorateResourcesRow::DecorateParameters' has a wrong offset!");
static_assert(offsetof(FUniqueTerrainDecorateResourcesRow, ReferenceCounter) == 0x000350, "Member 'FUniqueTerrainDecorateResourcesRow::ReferenceCounter' has a wrong offset!");
static_assert(offsetof(FUniqueTerrainDecorateResourcesRow, DecorateSurfaceResources) == 0x000358, "Member 'FUniqueTerrainDecorateResourcesRow::DecorateSurfaceResources' has a wrong offset!");
static_assert(offsetof(FUniqueTerrainDecorateResourcesRow, UseSurfaceType) == 0x0003A8, "Member 'FUniqueTerrainDecorateResourcesRow::UseSurfaceType' has a wrong offset!");

// ScriptStruct AT.DevelopColorTable
// 0x0010 (0x0018 - 0x0008)
struct FDevelopColorTable final : public FTableRowBase
{
public:
	class FName                                   MsgId;                                             // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         R;                                                 // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         G;                                                 // 0x0011(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0012(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         A;                                                 // 0x0013(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TexId;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevelopColorTable) == 0x000008, "Wrong alignment on FDevelopColorTable");
static_assert(sizeof(FDevelopColorTable) == 0x000018, "Wrong size on FDevelopColorTable");
static_assert(offsetof(FDevelopColorTable, MsgId) == 0x000008, "Member 'FDevelopColorTable::MsgId' has a wrong offset!");
static_assert(offsetof(FDevelopColorTable, R) == 0x000010, "Member 'FDevelopColorTable::R' has a wrong offset!");
static_assert(offsetof(FDevelopColorTable, G) == 0x000011, "Member 'FDevelopColorTable::G' has a wrong offset!");
static_assert(offsetof(FDevelopColorTable, B) == 0x000012, "Member 'FDevelopColorTable::B' has a wrong offset!");
static_assert(offsetof(FDevelopColorTable, A) == 0x000013, "Member 'FDevelopColorTable::A' has a wrong offset!");
static_assert(offsetof(FDevelopColorTable, TexId) == 0x000014, "Member 'FDevelopColorTable::TexId' has a wrong offset!");

// ScriptStruct AT.DevelopSettingTable
// 0x0048 (0x0050 - 0x0008)
struct FDevelopSettingTable final : public FTableRowBase
{
public:
	float                                         Border_RankS;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Border_RankA;                                      // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Border_RankB;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Border_RankC;                                      // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battery_BaseRate;                                  // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battery_DeltaUse;                                  // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battery_RecoverySecond;                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Battery_RecoveryValue;                             // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultColor_AirCar;                               // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultColor_Robot;                                // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Memory;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Speed;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Jump;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Battery;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Rader;                                         // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Efficiency;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_Discoverability;                               // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDevelopSettingTable) == 0x000008, "Wrong alignment on FDevelopSettingTable");
static_assert(sizeof(FDevelopSettingTable) == 0x000050, "Wrong size on FDevelopSettingTable");
static_assert(offsetof(FDevelopSettingTable, Border_RankS) == 0x000008, "Member 'FDevelopSettingTable::Border_RankS' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Border_RankA) == 0x00000C, "Member 'FDevelopSettingTable::Border_RankA' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Border_RankB) == 0x000010, "Member 'FDevelopSettingTable::Border_RankB' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Border_RankC) == 0x000014, "Member 'FDevelopSettingTable::Border_RankC' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Battery_BaseRate) == 0x000018, "Member 'FDevelopSettingTable::Battery_BaseRate' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Battery_DeltaUse) == 0x00001C, "Member 'FDevelopSettingTable::Battery_DeltaUse' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Battery_RecoverySecond) == 0x000020, "Member 'FDevelopSettingTable::Battery_RecoverySecond' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Battery_RecoveryValue) == 0x000024, "Member 'FDevelopSettingTable::Battery_RecoveryValue' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, DefaultColor_AirCar) == 0x000028, "Member 'FDevelopSettingTable::DefaultColor_AirCar' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, DefaultColor_Robot) == 0x00002C, "Member 'FDevelopSettingTable::DefaultColor_Robot' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Memory) == 0x000030, "Member 'FDevelopSettingTable::Max_Memory' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Speed) == 0x000034, "Member 'FDevelopSettingTable::Max_Speed' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Jump) == 0x000038, "Member 'FDevelopSettingTable::Max_Jump' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Battery) == 0x00003C, "Member 'FDevelopSettingTable::Max_Battery' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Rader) == 0x000040, "Member 'FDevelopSettingTable::Max_Rader' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Efficiency) == 0x000044, "Member 'FDevelopSettingTable::Max_Efficiency' has a wrong offset!");
static_assert(offsetof(FDevelopSettingTable, Max_Discoverability) == 0x000048, "Member 'FDevelopSettingTable::Max_Discoverability' has a wrong offset!");

// ScriptStruct AT.DevelopCaptureTable
// 0x0018 (0x0020 - 0x0008)
struct FDevelopCaptureTable final : public FTableRowBase
{
public:
	float                                         CameraPositionX;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPositionY;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPositionZ;                                   // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRotationX;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRotationY;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetRotationZ;                                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDevelopCaptureTable) == 0x000008, "Wrong alignment on FDevelopCaptureTable");
static_assert(sizeof(FDevelopCaptureTable) == 0x000020, "Wrong size on FDevelopCaptureTable");
static_assert(offsetof(FDevelopCaptureTable, CameraPositionX) == 0x000008, "Member 'FDevelopCaptureTable::CameraPositionX' has a wrong offset!");
static_assert(offsetof(FDevelopCaptureTable, CameraPositionY) == 0x00000C, "Member 'FDevelopCaptureTable::CameraPositionY' has a wrong offset!");
static_assert(offsetof(FDevelopCaptureTable, CameraPositionZ) == 0x000010, "Member 'FDevelopCaptureTable::CameraPositionZ' has a wrong offset!");
static_assert(offsetof(FDevelopCaptureTable, TargetRotationX) == 0x000014, "Member 'FDevelopCaptureTable::TargetRotationX' has a wrong offset!");
static_assert(offsetof(FDevelopCaptureTable, TargetRotationY) == 0x000018, "Member 'FDevelopCaptureTable::TargetRotationY' has a wrong offset!");
static_assert(offsetof(FDevelopCaptureTable, TargetRotationZ) == 0x00001C, "Member 'FDevelopCaptureTable::TargetRotationZ' has a wrong offset!");

// ScriptStruct AT.RidingParam
// 0x001C (0x001C - 0x0000)
struct FRidingParam final
{
public:
	int32                                         Memory;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Speed;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Jump;                                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Battery;                                           // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rader;                                             // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Efficiency;                                        // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Discoverability;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRidingParam) == 0x000004, "Wrong alignment on FRidingParam");
static_assert(sizeof(FRidingParam) == 0x00001C, "Wrong size on FRidingParam");
static_assert(offsetof(FRidingParam, Memory) == 0x000000, "Member 'FRidingParam::Memory' has a wrong offset!");
static_assert(offsetof(FRidingParam, Speed) == 0x000004, "Member 'FRidingParam::Speed' has a wrong offset!");
static_assert(offsetof(FRidingParam, Jump) == 0x000008, "Member 'FRidingParam::Jump' has a wrong offset!");
static_assert(offsetof(FRidingParam, Battery) == 0x00000C, "Member 'FRidingParam::Battery' has a wrong offset!");
static_assert(offsetof(FRidingParam, Rader) == 0x000010, "Member 'FRidingParam::Rader' has a wrong offset!");
static_assert(offsetof(FRidingParam, Efficiency) == 0x000014, "Member 'FRidingParam::Efficiency' has a wrong offset!");
static_assert(offsetof(FRidingParam, Discoverability) == 0x000018, "Member 'FRidingParam::Discoverability' has a wrong offset!");

// ScriptStruct AT.MissionTargetData
// 0x0018 (0x0020 - 0x0008)
struct FMissionTargetData final : public FTableRowBase
{
public:
	EMissionType                                  MissionType;                                       // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECHARACTER_TYPE>                       TargetTypes;                                       // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionTargetData) == 0x000008, "Wrong alignment on FMissionTargetData");
static_assert(sizeof(FMissionTargetData) == 0x000020, "Wrong size on FMissionTargetData");
static_assert(offsetof(FMissionTargetData, MissionType) == 0x000008, "Member 'FMissionTargetData::MissionType' has a wrong offset!");
static_assert(offsetof(FMissionTargetData, TargetTypes) == 0x000010, "Member 'FMissionTargetData::TargetTypes' has a wrong offset!");

// ScriptStruct AT.MissionHermitRewardParameter
// 0x0028 (0x0030 - 0x0008)
struct FMissionHermitRewardParameter final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeedCount;                                         // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardTalkId;                                      // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RewardId;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMissionHermitRewardParameter) == 0x000008, "Wrong alignment on FMissionHermitRewardParameter");
static_assert(sizeof(FMissionHermitRewardParameter) == 0x000030, "Wrong size on FMissionHermitRewardParameter");
static_assert(offsetof(FMissionHermitRewardParameter, ID) == 0x000008, "Member 'FMissionHermitRewardParameter::ID' has a wrong offset!");
static_assert(offsetof(FMissionHermitRewardParameter, NeedCount) == 0x000010, "Member 'FMissionHermitRewardParameter::NeedCount' has a wrong offset!");
static_assert(offsetof(FMissionHermitRewardParameter, RewardTalkId) == 0x000018, "Member 'FMissionHermitRewardParameter::RewardTalkId' has a wrong offset!");
static_assert(offsetof(FMissionHermitRewardParameter, RewardId) == 0x000028, "Member 'FMissionHermitRewardParameter::RewardId' has a wrong offset!");

// ScriptStruct AT.MissionPhaseParameter
// 0x0050 (0x0058 - 0x0008)
struct FMissionPhaseParameter final : public FTableRowBase
{
public:
	class FName                                   MissionTitleId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupId;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DescriptionId;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TargetID;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        NeedValue;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RepeatFlag;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RewardId;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissionPhaseIdRequired;                            // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AggregatedAfterInProgress;                         // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OpenBeforeReportingPreviousMissionPhaseId;         // 0x0051(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMissionPhaseParameter) == 0x000008, "Wrong alignment on FMissionPhaseParameter");
static_assert(sizeof(FMissionPhaseParameter) == 0x000058, "Wrong size on FMissionPhaseParameter");
static_assert(offsetof(FMissionPhaseParameter, MissionTitleId) == 0x000008, "Member 'FMissionPhaseParameter::MissionTitleId' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, GroupId) == 0x000010, "Member 'FMissionPhaseParameter::GroupId' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, DescriptionId) == 0x000018, "Member 'FMissionPhaseParameter::DescriptionId' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, Level) == 0x000020, "Member 'FMissionPhaseParameter::Level' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, TargetID) == 0x000028, "Member 'FMissionPhaseParameter::TargetID' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, NeedValue) == 0x000030, "Member 'FMissionPhaseParameter::NeedValue' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, RepeatFlag) == 0x000038, "Member 'FMissionPhaseParameter::RepeatFlag' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, RewardId) == 0x000040, "Member 'FMissionPhaseParameter::RewardId' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, MissionPhaseIdRequired) == 0x000048, "Member 'FMissionPhaseParameter::MissionPhaseIdRequired' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, AggregatedAfterInProgress) == 0x000050, "Member 'FMissionPhaseParameter::AggregatedAfterInProgress' has a wrong offset!");
static_assert(offsetof(FMissionPhaseParameter, OpenBeforeReportingPreviousMissionPhaseId) == 0x000051, "Member 'FMissionPhaseParameter::OpenBeforeReportingPreviousMissionPhaseId' has a wrong offset!");

// ScriptStruct AT.NeedCharacterSubQuest
// 0x0010 (0x0018 - 0x0008)
struct FNeedCharacterSubQuest final : public FTableRowBase
{
public:
	class FName                                   Quest_id;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Necessary_character1;                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Necessary_character2;                              // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Necessary_character3;                              // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Necessary_character4;                              // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Necessary_character5;                              // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNeedCharacterSubQuest) == 0x000008, "Wrong alignment on FNeedCharacterSubQuest");
static_assert(sizeof(FNeedCharacterSubQuest) == 0x000018, "Wrong size on FNeedCharacterSubQuest");
static_assert(offsetof(FNeedCharacterSubQuest, Quest_id) == 0x000008, "Member 'FNeedCharacterSubQuest::Quest_id' has a wrong offset!");
static_assert(offsetof(FNeedCharacterSubQuest, Necessary_character1) == 0x000010, "Member 'FNeedCharacterSubQuest::Necessary_character1' has a wrong offset!");
static_assert(offsetof(FNeedCharacterSubQuest, Necessary_character2) == 0x000011, "Member 'FNeedCharacterSubQuest::Necessary_character2' has a wrong offset!");
static_assert(offsetof(FNeedCharacterSubQuest, Necessary_character3) == 0x000012, "Member 'FNeedCharacterSubQuest::Necessary_character3' has a wrong offset!");
static_assert(offsetof(FNeedCharacterSubQuest, Necessary_character4) == 0x000013, "Member 'FNeedCharacterSubQuest::Necessary_character4' has a wrong offset!");
static_assert(offsetof(FNeedCharacterSubQuest, Necessary_character5) == 0x000014, "Member 'FNeedCharacterSubQuest::Necessary_character5' has a wrong offset!");

// ScriptStruct AT.PlaceObjectPatternTableRow
// 0x0040 (0x0048 - 0x0008)
struct FPlaceObjectPatternTableRow final : public FTableRowBase
{
public:
	EPlaceObjectType                              PlaceObjectType;                                   // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             ItemDropTabl;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemTableId;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlaceObjectArrangement                       Arrangement;                                       // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Offset;                                            // 0x0024(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceNum;                                          // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaceInterval;                                     // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceNumPerCircle;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllGetBonus;                                      // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlaceObjectPatternTableRow) == 0x000008, "Wrong alignment on FPlaceObjectPatternTableRow");
static_assert(sizeof(FPlaceObjectPatternTableRow) == 0x000048, "Wrong size on FPlaceObjectPatternTableRow");
static_assert(offsetof(FPlaceObjectPatternTableRow, PlaceObjectType) == 0x000008, "Member 'FPlaceObjectPatternTableRow::PlaceObjectType' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, ItemDropTabl) == 0x000010, "Member 'FPlaceObjectPatternTableRow::ItemDropTabl' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, ItemTableId) == 0x000018, "Member 'FPlaceObjectPatternTableRow::ItemTableId' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, Arrangement) == 0x000020, "Member 'FPlaceObjectPatternTableRow::Arrangement' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, Offset) == 0x000024, "Member 'FPlaceObjectPatternTableRow::Offset' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, PlaceNum) == 0x000030, "Member 'FPlaceObjectPatternTableRow::PlaceNum' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, Radius) == 0x000034, "Member 'FPlaceObjectPatternTableRow::Radius' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, PlaceInterval) == 0x000038, "Member 'FPlaceObjectPatternTableRow::PlaceInterval' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, PlaceNumPerCircle) == 0x00003C, "Member 'FPlaceObjectPatternTableRow::PlaceNumPerCircle' has a wrong offset!");
static_assert(offsetof(FPlaceObjectPatternTableRow, bAllGetBonus) == 0x000040, "Member 'FPlaceObjectPatternTableRow::bAllGetBonus' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateEffectInfo
// 0x00E8 (0x00E8 - 0x0000)
struct alignas(0x08) FTerrainDecorateEffectInfo final
{
public:
	uint8                                         Pad_0[0xE8];                                       // 0x0000(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainDecorateEffectInfo) == 0x000008, "Wrong alignment on FTerrainDecorateEffectInfo");
static_assert(sizeof(FTerrainDecorateEffectInfo) == 0x0000E8, "Wrong size on FTerrainDecorateEffectInfo");

// ScriptStruct AT.OverrideAnimation
// 0x0070 (0x0070 - 0x0000)
struct FOverrideAnimation final
{
public:
	EOverrideAnimationTiming                      Timing;                                            // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          Sequence;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLoop;                                            // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0xF];                                       // 0x0011(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FATMeshAttachObject                    AttachedMesh;                                      // 0x0020(0x0040)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 TargetPoint;                                       // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOverrideAnimation) == 0x000010, "Wrong alignment on FOverrideAnimation");
static_assert(sizeof(FOverrideAnimation) == 0x000070, "Wrong size on FOverrideAnimation");
static_assert(offsetof(FOverrideAnimation, Timing) == 0x000000, "Member 'FOverrideAnimation::Timing' has a wrong offset!");
static_assert(offsetof(FOverrideAnimation, Sequence) == 0x000008, "Member 'FOverrideAnimation::Sequence' has a wrong offset!");
static_assert(offsetof(FOverrideAnimation, IsLoop) == 0x000010, "Member 'FOverrideAnimation::IsLoop' has a wrong offset!");
static_assert(offsetof(FOverrideAnimation, AttachedMesh) == 0x000020, "Member 'FOverrideAnimation::AttachedMesh' has a wrong offset!");
static_assert(offsetof(FOverrideAnimation, TargetPoint) == 0x000060, "Member 'FOverrideAnimation::TargetPoint' has a wrong offset!");

// ScriptStruct AT.FieldItemData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FFieldItemData final
{
public:
	class FName                                   FixedId;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NormalId;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldItemData) == 0x000008, "Wrong alignment on FFieldItemData");
static_assert(sizeof(FFieldItemData) == 0x000010, "Wrong size on FFieldItemData");
static_assert(offsetof(FFieldItemData, FixedId) == 0x000000, "Member 'FFieldItemData::FixedId' has a wrong offset!");
static_assert(offsetof(FFieldItemData, NormalId) == 0x000008, "Member 'FFieldItemData::NormalId' has a wrong offset!");

// ScriptStruct AT.ATParticleSystemData
// 0x0018 (0x0018 - 0x0000)
struct FATParticleSystemData final
{
public:
	class UParticleSystemComponent*               PSC;                                               // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATParticleSystemData) == 0x000008, "Wrong alignment on FATParticleSystemData");
static_assert(sizeof(FATParticleSystemData) == 0x000018, "Wrong size on FATParticleSystemData");
static_assert(offsetof(FATParticleSystemData, PSC) == 0x000000, "Member 'FATParticleSystemData::PSC' has a wrong offset!");

// ScriptStruct AT.AddExpOverWriteCharacterTypeInfoTable
// 0x0018 (0x0020 - 0x0008)
struct FAddExpOverWriteCharacterTypeInfoTable final : public FTableRowBase
{
public:
	class FName                                   DlcId;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAddExpOverwriteCharacterTypeInfo> AddExpOverwriteList;                               // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddExpOverWriteCharacterTypeInfoTable) == 0x000008, "Wrong alignment on FAddExpOverWriteCharacterTypeInfoTable");
static_assert(sizeof(FAddExpOverWriteCharacterTypeInfoTable) == 0x000020, "Wrong size on FAddExpOverWriteCharacterTypeInfoTable");
static_assert(offsetof(FAddExpOverWriteCharacterTypeInfoTable, DlcId) == 0x000008, "Member 'FAddExpOverWriteCharacterTypeInfoTable::DlcId' has a wrong offset!");
static_assert(offsetof(FAddExpOverWriteCharacterTypeInfoTable, AddExpOverwriteList) == 0x000010, "Member 'FAddExpOverWriteCharacterTypeInfoTable::AddExpOverwriteList' has a wrong offset!");

// ScriptStruct AT.QuestRewardParam
// 0x00C8 (0x00D0 - 0x0008)
struct FQuestRewardParam final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ExpId;                                             // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Money;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Quest_community_id;                                // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_id_01;                                        // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_01;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_02;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_02;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_03;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_03;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_04;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_04;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_05;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_05;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_06;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_06;                                       // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_07;                                        // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_07;                                       // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_08;                                        // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_08;                                       // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_09;                                        // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_09;                                       // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Item_id_10;                                        // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num_10;                                       // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestRewardParam) == 0x000008, "Wrong alignment on FQuestRewardParam");
static_assert(sizeof(FQuestRewardParam) == 0x0000D0, "Wrong size on FQuestRewardParam");
static_assert(offsetof(FQuestRewardParam, ID) == 0x000008, "Member 'FQuestRewardParam::ID' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Exp) == 0x000010, "Member 'FQuestRewardParam::Exp' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, ExpId) == 0x000018, "Member 'FQuestRewardParam::ExpId' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Money) == 0x000020, "Member 'FQuestRewardParam::Money' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Quest_community_id) == 0x000028, "Member 'FQuestRewardParam::Quest_community_id' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_01) == 0x000030, "Member 'FQuestRewardParam::Item_id_01' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_01) == 0x000038, "Member 'FQuestRewardParam::Item_num_01' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_02) == 0x000040, "Member 'FQuestRewardParam::Item_id_02' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_02) == 0x000048, "Member 'FQuestRewardParam::Item_num_02' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_03) == 0x000050, "Member 'FQuestRewardParam::Item_id_03' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_03) == 0x000058, "Member 'FQuestRewardParam::Item_num_03' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_04) == 0x000060, "Member 'FQuestRewardParam::Item_id_04' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_04) == 0x000068, "Member 'FQuestRewardParam::Item_num_04' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_05) == 0x000070, "Member 'FQuestRewardParam::Item_id_05' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_05) == 0x000078, "Member 'FQuestRewardParam::Item_num_05' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_06) == 0x000080, "Member 'FQuestRewardParam::Item_id_06' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_06) == 0x000088, "Member 'FQuestRewardParam::Item_num_06' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_07) == 0x000090, "Member 'FQuestRewardParam::Item_id_07' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_07) == 0x000098, "Member 'FQuestRewardParam::Item_num_07' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_08) == 0x0000A0, "Member 'FQuestRewardParam::Item_id_08' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_08) == 0x0000A8, "Member 'FQuestRewardParam::Item_num_08' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_09) == 0x0000B0, "Member 'FQuestRewardParam::Item_id_09' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_09) == 0x0000B8, "Member 'FQuestRewardParam::Item_num_09' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_id_10) == 0x0000C0, "Member 'FQuestRewardParam::Item_id_10' has a wrong offset!");
static_assert(offsetof(FQuestRewardParam, Item_num_10) == 0x0000C8, "Member 'FQuestRewardParam::Item_num_10' has a wrong offset!");

// ScriptStruct AT.AddExpDlcEventBattleInfo
// 0x0028 (0x0028 - 0x0000)
struct FAddExpDlcEventBattleInfo final
{
public:
	class FName                                   EventBattleID;                                     // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECHARACTER_TYPE>                       AddExpCharacterList;                               // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECHARACTER_TYPE>                       FixedAddExpCharacterList;                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddExpDlcEventBattleInfo) == 0x000008, "Wrong alignment on FAddExpDlcEventBattleInfo");
static_assert(sizeof(FAddExpDlcEventBattleInfo) == 0x000028, "Wrong size on FAddExpDlcEventBattleInfo");
static_assert(offsetof(FAddExpDlcEventBattleInfo, EventBattleID) == 0x000000, "Member 'FAddExpDlcEventBattleInfo::EventBattleID' has a wrong offset!");
static_assert(offsetof(FAddExpDlcEventBattleInfo, AddExpCharacterList) == 0x000008, "Member 'FAddExpDlcEventBattleInfo::AddExpCharacterList' has a wrong offset!");
static_assert(offsetof(FAddExpDlcEventBattleInfo, FixedAddExpCharacterList) == 0x000018, "Member 'FAddExpDlcEventBattleInfo::FixedAddExpCharacterList' has a wrong offset!");

// ScriptStruct AT.AddExpInfoTable
// 0x0028 (0x0030 - 0x0008)
struct FAddExpInfoTable final : public FTableRowBase
{
public:
	class FName                                   DlcId;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAddExpOverwriteCharacterTypeInfo> AddExpOverwriteCharacterTypeList;                  // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAddExpDlcEventBattleInfo>      AddExpEventBattleOverwriteList;                    // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAddExpInfoTable) == 0x000008, "Wrong alignment on FAddExpInfoTable");
static_assert(sizeof(FAddExpInfoTable) == 0x000030, "Wrong size on FAddExpInfoTable");
static_assert(offsetof(FAddExpInfoTable, DlcId) == 0x000008, "Member 'FAddExpInfoTable::DlcId' has a wrong offset!");
static_assert(offsetof(FAddExpInfoTable, AddExpOverwriteCharacterTypeList) == 0x000010, "Member 'FAddExpInfoTable::AddExpOverwriteCharacterTypeList' has a wrong offset!");
static_assert(offsetof(FAddExpInfoTable, AddExpEventBattleOverwriteList) == 0x000020, "Member 'FAddExpInfoTable::AddExpEventBattleOverwriteList' has a wrong offset!");

// ScriptStruct AT.IntBox
// 0x001C (0x001C - 0x0000)
struct alignas(0x04) FIntBox final
{
public:
	uint8                                         Pad_0[0x1C];                                       // 0x0000(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FIntBox) == 0x000004, "Wrong alignment on FIntBox");
static_assert(sizeof(FIntBox) == 0x00001C, "Wrong size on FIntBox");

// ScriptStruct AT.PhaseTalkParam
// 0x0018 (0x0018 - 0x0000)
struct FPhaseTalkParam final
{
public:
	int32                                         StartNo;                                           // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndNo;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TalkEventID;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPhaseTalkParam) == 0x000008, "Wrong alignment on FPhaseTalkParam");
static_assert(sizeof(FPhaseTalkParam) == 0x000018, "Wrong size on FPhaseTalkParam");
static_assert(offsetof(FPhaseTalkParam, StartNo) == 0x000000, "Member 'FPhaseTalkParam::StartNo' has a wrong offset!");
static_assert(offsetof(FPhaseTalkParam, EndNo) == 0x000004, "Member 'FPhaseTalkParam::EndNo' has a wrong offset!");
static_assert(offsetof(FPhaseTalkParam, TalkEventID) == 0x000008, "Member 'FPhaseTalkParam::TalkEventID' has a wrong offset!");

// ScriptStruct AT.ATControlInputInfo
// 0x0138 (0x0138 - 0x0000)
struct alignas(0x04) FATControlInputInfo final
{
public:
	uint8                                         Pad_0[0x138];                                      // 0x0000(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATControlInputInfo) == 0x000004, "Wrong alignment on FATControlInputInfo");
static_assert(sizeof(FATControlInputInfo) == 0x000138, "Wrong size on FATControlInputInfo");

// ScriptStruct AT.QuestPhasePair
// 0x0058 (0x0058 - 0x0000)
struct FQuestPhasePair final
{
public:
	class UDataTable*                             TargetDataTable;                                   // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, int32>                      PhaseNoMap;                                        // 0x0008(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FQuestPhasePair) == 0x000008, "Wrong alignment on FQuestPhasePair");
static_assert(sizeof(FQuestPhasePair) == 0x000058, "Wrong size on FQuestPhasePair");
static_assert(offsetof(FQuestPhasePair, TargetDataTable) == 0x000000, "Member 'FQuestPhasePair::TargetDataTable' has a wrong offset!");
static_assert(offsetof(FQuestPhasePair, PhaseNoMap) == 0x000008, "Member 'FQuestPhasePair::PhaseNoMap' has a wrong offset!");

// ScriptStruct AT.ItemPaletteSettingTable
// 0x0018 (0x0020 - 0x0008)
struct FItemPaletteSettingTable final : public FTableRowBase
{
public:
	EItemPaletteFace                              PaletteFace;                                       // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemPaletteSettingTable) == 0x000008, "Wrong alignment on FItemPaletteSettingTable");
static_assert(sizeof(FItemPaletteSettingTable) == 0x000020, "Wrong size on FItemPaletteSettingTable");
static_assert(offsetof(FItemPaletteSettingTable, PaletteFace) == 0x000008, "Member 'FItemPaletteSettingTable::PaletteFace' has a wrong offset!");
static_assert(offsetof(FItemPaletteSettingTable, ItemId) == 0x000010, "Member 'FItemPaletteSettingTable::ItemId' has a wrong offset!");
static_assert(offsetof(FItemPaletteSettingTable, Count) == 0x000018, "Member 'FItemPaletteSettingTable::Count' has a wrong offset!");

// ScriptStruct AT.QuestDirectionCoordinateParameter
// 0x0020 (0x0028 - 0x0008)
struct FQuestDirectionCoordinateParameter final : public FTableRowBase
{
public:
	TArray<class FName>                           EnabledCharacterFindListIds;                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisabledCharacterFindListIds;                      // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestDirectionCoordinateParameter) == 0x000008, "Wrong alignment on FQuestDirectionCoordinateParameter");
static_assert(sizeof(FQuestDirectionCoordinateParameter) == 0x000028, "Wrong size on FQuestDirectionCoordinateParameter");
static_assert(offsetof(FQuestDirectionCoordinateParameter, EnabledCharacterFindListIds) == 0x000008, "Member 'FQuestDirectionCoordinateParameter::EnabledCharacterFindListIds' has a wrong offset!");
static_assert(offsetof(FQuestDirectionCoordinateParameter, DisabledCharacterFindListIds) == 0x000018, "Member 'FQuestDirectionCoordinateParameter::DisabledCharacterFindListIds' has a wrong offset!");

// ScriptStruct AT.QuestDistanceObserverParameter
// 0x0010 (0x0018 - 0x0008)
struct FQuestDistanceObserverParameter final : public FTableRowBase
{
public:
	TArray<struct FObserverCondition>             ConditionList;                                     // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestDistanceObserverParameter) == 0x000008, "Wrong alignment on FQuestDistanceObserverParameter");
static_assert(sizeof(FQuestDistanceObserverParameter) == 0x000018, "Wrong size on FQuestDistanceObserverParameter");
static_assert(offsetof(FQuestDistanceObserverParameter, ConditionList) == 0x000008, "Member 'FQuestDistanceObserverParameter::ConditionList' has a wrong offset!");

// ScriptStruct AT.GeneralTalkEventArgment
// 0x0008 (0x0008 - 0x0000)
struct FGeneralTalkEventArgment final
{
public:
	EQUEST_GENERAL_TALK_TIMING                    Timing;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTerrainDamage;                                    // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWindRoad;                                         // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnemiesAI;                                        // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraShake;                                      // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMobCharacter;                                     // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLandmarkCharacter;                                // 0x0006(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCould;                                            // 0x0007(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralTalkEventArgment) == 0x000001, "Wrong alignment on FGeneralTalkEventArgment");
static_assert(sizeof(FGeneralTalkEventArgment) == 0x000008, "Wrong size on FGeneralTalkEventArgment");
static_assert(offsetof(FGeneralTalkEventArgment, Timing) == 0x000000, "Member 'FGeneralTalkEventArgment::Timing' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bTerrainDamage) == 0x000001, "Member 'FGeneralTalkEventArgment::bTerrainDamage' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bWindRoad) == 0x000002, "Member 'FGeneralTalkEventArgment::bWindRoad' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bEnemiesAI) == 0x000003, "Member 'FGeneralTalkEventArgment::bEnemiesAI' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bCameraShake) == 0x000004, "Member 'FGeneralTalkEventArgment::bCameraShake' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bMobCharacter) == 0x000005, "Member 'FGeneralTalkEventArgment::bMobCharacter' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bLandmarkCharacter) == 0x000006, "Member 'FGeneralTalkEventArgment::bLandmarkCharacter' has a wrong offset!");
static_assert(offsetof(FGeneralTalkEventArgment, bCould) == 0x000007, "Member 'FGeneralTalkEventArgment::bCould' has a wrong offset!");

// ScriptStruct AT.QuestNotificationParameter
// 0x0038 (0x0040 - 0x0008)
struct FQuestNotificationParameter final : public FTableRowBase
{
public:
	class FString                                 MessageId;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENotyfyTiming                                 Timing;                                            // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TypeId;                                            // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPun;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestNotificationParameter) == 0x000008, "Wrong alignment on FQuestNotificationParameter");
static_assert(sizeof(FQuestNotificationParameter) == 0x000040, "Wrong size on FQuestNotificationParameter");
static_assert(offsetof(FQuestNotificationParameter, MessageId) == 0x000008, "Member 'FQuestNotificationParameter::MessageId' has a wrong offset!");
static_assert(offsetof(FQuestNotificationParameter, Timing) == 0x000018, "Member 'FQuestNotificationParameter::Timing' has a wrong offset!");
static_assert(offsetof(FQuestNotificationParameter, TypeId) == 0x000020, "Member 'FQuestNotificationParameter::TypeId' has a wrong offset!");
static_assert(offsetof(FQuestNotificationParameter, Count) == 0x000030, "Member 'FQuestNotificationParameter::Count' has a wrong offset!");
static_assert(offsetof(FQuestNotificationParameter, Probability) == 0x000034, "Member 'FQuestNotificationParameter::Probability' has a wrong offset!");
static_assert(offsetof(FQuestNotificationParameter, IsPun) == 0x000038, "Member 'FQuestNotificationParameter::IsPun' has a wrong offset!");

// ScriptStruct AT.QuestSpawnParameter
// 0x0038 (0x0040 - 0x0008)
struct FQuestSpawnParameter final : public FTableRowBase
{
public:
	TSubclassOf<class AQuestCharacter>            QuestCharacter;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpawnLocation;                                     // 0x0010(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               SpawnRotation;                                     // 0x001C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ProgressBegin;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressEnd;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VisibleBegin;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestSpawnParameter) == 0x000008, "Wrong alignment on FQuestSpawnParameter");
static_assert(sizeof(FQuestSpawnParameter) == 0x000040, "Wrong size on FQuestSpawnParameter");
static_assert(offsetof(FQuestSpawnParameter, QuestCharacter) == 0x000008, "Member 'FQuestSpawnParameter::QuestCharacter' has a wrong offset!");
static_assert(offsetof(FQuestSpawnParameter, SpawnLocation) == 0x000010, "Member 'FQuestSpawnParameter::SpawnLocation' has a wrong offset!");
static_assert(offsetof(FQuestSpawnParameter, SpawnRotation) == 0x00001C, "Member 'FQuestSpawnParameter::SpawnRotation' has a wrong offset!");
static_assert(offsetof(FQuestSpawnParameter, ProgressBegin) == 0x000028, "Member 'FQuestSpawnParameter::ProgressBegin' has a wrong offset!");
static_assert(offsetof(FQuestSpawnParameter, ProgressEnd) == 0x000030, "Member 'FQuestSpawnParameter::ProgressEnd' has a wrong offset!");
static_assert(offsetof(FQuestSpawnParameter, VisibleBegin) == 0x000038, "Member 'FQuestSpawnParameter::VisibleBegin' has a wrong offset!");

// ScriptStruct AT.LandingShotOffsetParam
// 0x0018 (0x0018 - 0x0000)
struct FLandingShotOffsetParam final
{
public:
	struct FVector2D                              TargetOffset;                                      // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetOffsetZ;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandRadius;                                        // 0x000C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLandingShotOffsetParam) == 0x000004, "Wrong alignment on FLandingShotOffsetParam");
static_assert(sizeof(FLandingShotOffsetParam) == 0x000018, "Wrong size on FLandingShotOffsetParam");
static_assert(offsetof(FLandingShotOffsetParam, TargetOffset) == 0x000000, "Member 'FLandingShotOffsetParam::TargetOffset' has a wrong offset!");
static_assert(offsetof(FLandingShotOffsetParam, TargetOffsetZ) == 0x000008, "Member 'FLandingShotOffsetParam::TargetOffsetZ' has a wrong offset!");
static_assert(offsetof(FLandingShotOffsetParam, RandRadius) == 0x00000C, "Member 'FLandingShotOffsetParam::RandRadius' has a wrong offset!");

// ScriptStruct AT.QuestTimingObserveCondition
// 0x0010 (0x0018 - 0x0008)
struct FQuestTimingObserveCondition final : public FTableRowBase
{
public:
	class FName                                   QuestId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestTimingObserveCondition) == 0x000008, "Wrong alignment on FQuestTimingObserveCondition");
static_assert(sizeof(FQuestTimingObserveCondition) == 0x000018, "Wrong size on FQuestTimingObserveCondition");
static_assert(offsetof(FQuestTimingObserveCondition, QuestId) == 0x000008, "Member 'FQuestTimingObserveCondition::QuestId' has a wrong offset!");
static_assert(offsetof(FQuestTimingObserveCondition, Interval) == 0x000010, "Member 'FQuestTimingObserveCondition::Interval' has a wrong offset!");
static_assert(offsetof(FQuestTimingObserveCondition, Distance) == 0x000014, "Member 'FQuestTimingObserveCondition::Distance' has a wrong offset!");

// ScriptStruct AT.QuestCommunityParam
// 0x0020 (0x0028 - 0x0008)
struct FQuestCommunityParam final : public FTableRowBase
{
public:
	class FName                                   CommunityId;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SoulEmblemId;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommunityPhaseCondition                      EmblemEditCondition;                               // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOMMUNITY_CATEGORY                           CommunityCategory;                                 // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CommunityValue;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FavoriteValue;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLeader;                                          // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestCommunityParam) == 0x000008, "Wrong alignment on FQuestCommunityParam");
static_assert(sizeof(FQuestCommunityParam) == 0x000028, "Wrong size on FQuestCommunityParam");
static_assert(offsetof(FQuestCommunityParam, CommunityId) == 0x000008, "Member 'FQuestCommunityParam::CommunityId' has a wrong offset!");
static_assert(offsetof(FQuestCommunityParam, SoulEmblemId) == 0x000010, "Member 'FQuestCommunityParam::SoulEmblemId' has a wrong offset!");
static_assert(offsetof(FQuestCommunityParam, EmblemEditCondition) == 0x000018, "Member 'FQuestCommunityParam::EmblemEditCondition' has a wrong offset!");
static_assert(offsetof(FQuestCommunityParam, CommunityCategory) == 0x000019, "Member 'FQuestCommunityParam::CommunityCategory' has a wrong offset!");
static_assert(offsetof(FQuestCommunityParam, CommunityValue) == 0x00001C, "Member 'FQuestCommunityParam::CommunityValue' has a wrong offset!");
static_assert(offsetof(FQuestCommunityParam, FavoriteValue) == 0x000020, "Member 'FQuestCommunityParam::FavoriteValue' has a wrong offset!");
static_assert(offsetof(FQuestCommunityParam, IsLeader) == 0x000024, "Member 'FQuestCommunityParam::IsLeader' has a wrong offset!");

// ScriptStruct AT.QuestWorldMapLandmarkParameter
// 0x0010 (0x0018 - 0x0008)
struct FQuestWorldMapLandmarkParameter final : public FTableRowBase
{
public:
	int32                                         POS_X;                                             // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         POS_Y;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWorldStageId                                 WorldStageId;                                      // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestWorldMapLandmarkParameter) == 0x000008, "Wrong alignment on FQuestWorldMapLandmarkParameter");
static_assert(sizeof(FQuestWorldMapLandmarkParameter) == 0x000018, "Wrong size on FQuestWorldMapLandmarkParameter");
static_assert(offsetof(FQuestWorldMapLandmarkParameter, POS_X) == 0x000008, "Member 'FQuestWorldMapLandmarkParameter::POS_X' has a wrong offset!");
static_assert(offsetof(FQuestWorldMapLandmarkParameter, POS_Y) == 0x00000C, "Member 'FQuestWorldMapLandmarkParameter::POS_Y' has a wrong offset!");
static_assert(offsetof(FQuestWorldMapLandmarkParameter, WorldStageId) == 0x000010, "Member 'FQuestWorldMapLandmarkParameter::WorldStageId' has a wrong offset!");

// ScriptStruct AT.QuestWorldMapParameter
// 0x0020 (0x0028 - 0x0008)
struct FQuestWorldMapParameter final : public FTableRowBase
{
public:
	class FName                                   Quest_progress;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Map_name;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Phase_id_st;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Phase_id_ed;                                       // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestWorldMapParameter) == 0x000008, "Wrong alignment on FQuestWorldMapParameter");
static_assert(sizeof(FQuestWorldMapParameter) == 0x000028, "Wrong size on FQuestWorldMapParameter");
static_assert(offsetof(FQuestWorldMapParameter, Quest_progress) == 0x000008, "Member 'FQuestWorldMapParameter::Quest_progress' has a wrong offset!");
static_assert(offsetof(FQuestWorldMapParameter, Map_name) == 0x000010, "Member 'FQuestWorldMapParameter::Map_name' has a wrong offset!");
static_assert(offsetof(FQuestWorldMapParameter, Phase_id_st) == 0x000018, "Member 'FQuestWorldMapParameter::Phase_id_st' has a wrong offset!");
static_assert(offsetof(FQuestWorldMapParameter, Phase_id_ed) == 0x000020, "Member 'FQuestWorldMapParameter::Phase_id_ed' has a wrong offset!");

// ScriptStruct AT.SeIdManage
// 0x0008 (0x0008 - 0x0000)
struct FSeIdManage final
{
public:
	int32                                         ReqID;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SeManageNum;                                       // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeIdManage) == 0x000004, "Wrong alignment on FSeIdManage");
static_assert(sizeof(FSeIdManage) == 0x000008, "Wrong size on FSeIdManage");
static_assert(offsetof(FSeIdManage, ReqID) == 0x000000, "Member 'FSeIdManage::ReqID' has a wrong offset!");
static_assert(offsetof(FSeIdManage, SeManageNum) == 0x000004, "Member 'FSeIdManage::SeManageNum' has a wrong offset!");

// ScriptStruct AT.ATDataTableSoundTest
// 0x0028 (0x0030 - 0x0008)
struct FATDataTableSoundTest final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UManaTexture>            ManaTexture;                                       // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATDataTableSoundTest) == 0x000008, "Wrong alignment on FATDataTableSoundTest");
static_assert(sizeof(FATDataTableSoundTest) == 0x000030, "Wrong size on FATDataTableSoundTest");
static_assert(offsetof(FATDataTableSoundTest, ManaTexture) == 0x000008, "Member 'FATDataTableSoundTest::ManaTexture' has a wrong offset!");

// ScriptStruct AT.SndTestStruct
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FSndTestStruct final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSndTestStruct) == 0x000008, "Wrong alignment on FSndTestStruct");
static_assert(sizeof(FSndTestStruct) == 0x000038, "Wrong size on FSndTestStruct");

// ScriptStruct AT.Cpl003MakohoParam
// 0x0020 (0x0020 - 0x0000)
struct FCpl003MakohoParam final
{
public:
	struct FVector                                TransOffset;                                       // 0x0000(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotOffset;                                         // 0x000C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AProjectile>                ExplodeProjectile;                                 // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCpl003MakohoParam) == 0x000008, "Wrong alignment on FCpl003MakohoParam");
static_assert(sizeof(FCpl003MakohoParam) == 0x000020, "Wrong size on FCpl003MakohoParam");
static_assert(offsetof(FCpl003MakohoParam, TransOffset) == 0x000000, "Member 'FCpl003MakohoParam::TransOffset' has a wrong offset!");
static_assert(offsetof(FCpl003MakohoParam, RotOffset) == 0x00000C, "Member 'FCpl003MakohoParam::RotOffset' has a wrong offset!");
static_assert(offsetof(FCpl003MakohoParam, ExplodeProjectile) == 0x000018, "Member 'FCpl003MakohoParam::ExplodeProjectile' has a wrong offset!");

// ScriptStruct AT.SpawnCondition
// 0x0038 (0x0038 - 0x0000)
struct FSpawnCondition final
{
public:
	TSubclassOf<class ASpacePodTractor>           SpawnMachineClass;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SpawnTransportedMachineClass;                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     SpawnLastTransportedMachineClass;                  // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransportCount;                                    // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnLimit;                                        // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnInterval;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VehiclesDistance;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMustSpawnedAtStart;                               // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnIntervalDistanceMax;                          // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnIntervalDistanceMin;                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopSpawningPlayerDistance;                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnCondition) == 0x000008, "Wrong alignment on FSpawnCondition");
static_assert(sizeof(FSpawnCondition) == 0x000038, "Wrong size on FSpawnCondition");
static_assert(offsetof(FSpawnCondition, SpawnMachineClass) == 0x000000, "Member 'FSpawnCondition::SpawnMachineClass' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, SpawnTransportedMachineClass) == 0x000008, "Member 'FSpawnCondition::SpawnTransportedMachineClass' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, SpawnLastTransportedMachineClass) == 0x000010, "Member 'FSpawnCondition::SpawnLastTransportedMachineClass' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, TransportCount) == 0x000018, "Member 'FSpawnCondition::TransportCount' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, SpawnLimit) == 0x00001C, "Member 'FSpawnCondition::SpawnLimit' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, SpawnInterval) == 0x000020, "Member 'FSpawnCondition::SpawnInterval' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, VehiclesDistance) == 0x000024, "Member 'FSpawnCondition::VehiclesDistance' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, bMustSpawnedAtStart) == 0x000028, "Member 'FSpawnCondition::bMustSpawnedAtStart' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, SpawnIntervalDistanceMax) == 0x00002C, "Member 'FSpawnCondition::SpawnIntervalDistanceMax' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, SpawnIntervalDistanceMin) == 0x000030, "Member 'FSpawnCondition::SpawnIntervalDistanceMin' has a wrong offset!");
static_assert(offsetof(FSpawnCondition, StopSpawningPlayerDistance) == 0x000034, "Member 'FSpawnCondition::StopSpawningPlayerDistance' has a wrong offset!");

// ScriptStruct AT.SpawnableTimingSubjectParameter
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSpawnableTimingSubjectParameter final
{
public:
	class FName                                   CountName;                                         // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnableTimingSubjectParameter) == 0x000008, "Wrong alignment on FSpawnableTimingSubjectParameter");
static_assert(sizeof(FSpawnableTimingSubjectParameter) == 0x000008, "Wrong size on FSpawnableTimingSubjectParameter");
static_assert(offsetof(FSpawnableTimingSubjectParameter, CountName) == 0x000000, "Member 'FSpawnableTimingSubjectParameter::CountName' has a wrong offset!");

// ScriptStruct AT.ZCW_LightControl
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FZCW_LightControl final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCW_LightControl) == 0x000004, "Wrong alignment on FZCW_LightControl");
static_assert(sizeof(FZCW_LightControl) == 0x000010, "Wrong size on FZCW_LightControl");

// ScriptStruct AT.SubQuestBgmCondition
// 0x0010 (0x0018 - 0x0008)
struct FSubQuestBgmCondition final : public FTableRowBase
{
public:
	class FName                                   SubQuestId;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      BgmCode;                                           // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubQuestBgmCondition) == 0x000008, "Wrong alignment on FSubQuestBgmCondition");
static_assert(sizeof(FSubQuestBgmCondition) == 0x000018, "Wrong size on FSubQuestBgmCondition");
static_assert(offsetof(FSubQuestBgmCondition, SubQuestId) == 0x000008, "Member 'FSubQuestBgmCondition::SubQuestId' has a wrong offset!");
static_assert(offsetof(FSubQuestBgmCondition, BgmCode) == 0x000010, "Member 'FSubQuestBgmCondition::BgmCode' has a wrong offset!");

// ScriptStruct AT.DecorateEntitiesTouchedDestructibleMesh
// 0x0010 (0x0010 - 0x0000)
struct FDecorateEntitiesTouchedDestructibleMesh final
{
public:
	TArray<class UTerrainDecorateEntityBase*>     TouchedDecorateEntities;                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDecorateEntitiesTouchedDestructibleMesh) == 0x000008, "Wrong alignment on FDecorateEntitiesTouchedDestructibleMesh");
static_assert(sizeof(FDecorateEntitiesTouchedDestructibleMesh) == 0x000010, "Wrong size on FDecorateEntitiesTouchedDestructibleMesh");
static_assert(offsetof(FDecorateEntitiesTouchedDestructibleMesh, TouchedDecorateEntities) == 0x000000, "Member 'FDecorateEntitiesTouchedDestructibleMesh::TouchedDecorateEntities' has a wrong offset!");

// ScriptStruct AT.SubQuestStartCondition
// 0x0010 (0x0018 - 0x0008)
struct FSubQuestStartCondition final : public FTableRowBase
{
public:
	class FName                                   SubQuestId;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisableEncount;                                    // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      BgmCode;                                           // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubQuestStartCondition) == 0x000008, "Wrong alignment on FSubQuestStartCondition");
static_assert(sizeof(FSubQuestStartCondition) == 0x000018, "Wrong size on FSubQuestStartCondition");
static_assert(offsetof(FSubQuestStartCondition, SubQuestId) == 0x000008, "Member 'FSubQuestStartCondition::SubQuestId' has a wrong offset!");
static_assert(offsetof(FSubQuestStartCondition, DisableEncount) == 0x000010, "Member 'FSubQuestStartCondition::DisableEncount' has a wrong offset!");
static_assert(offsetof(FSubQuestStartCondition, BgmCode) == 0x000011, "Member 'FSubQuestStartCondition::BgmCode' has a wrong offset!");

// ScriptStruct AT.ATSupportCharacterTalkDataTable
// 0x0020 (0x0028 - 0x0008)
struct FATSupportCharacterTalkDataTable final : public FTableRowBase
{
public:
	class FName                                   Identifier;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Quest;                                             // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExtendQuestId;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Message;                                           // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATSupportCharacterTalkDataTable) == 0x000008, "Wrong alignment on FATSupportCharacterTalkDataTable");
static_assert(sizeof(FATSupportCharacterTalkDataTable) == 0x000028, "Wrong size on FATSupportCharacterTalkDataTable");
static_assert(offsetof(FATSupportCharacterTalkDataTable, Identifier) == 0x000008, "Member 'FATSupportCharacterTalkDataTable::Identifier' has a wrong offset!");
static_assert(offsetof(FATSupportCharacterTalkDataTable, Quest) == 0x000010, "Member 'FATSupportCharacterTalkDataTable::Quest' has a wrong offset!");
static_assert(offsetof(FATSupportCharacterTalkDataTable, ExtendQuestId) == 0x000018, "Member 'FATSupportCharacterTalkDataTable::ExtendQuestId' has a wrong offset!");
static_assert(offsetof(FATSupportCharacterTalkDataTable, Message) == 0x000020, "Member 'FATSupportCharacterTalkDataTable::Message' has a wrong offset!");

// ScriptStruct AT.ATSurfaceName
// 0x0050 (0x0050 - 0x0000)
struct FATSurfaceName final
{
public:
	TMap<EATSurfaceType, class FName>             SurfaceNames;                                      // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FATSurfaceName) == 0x000008, "Wrong alignment on FATSurfaceName");
static_assert(sizeof(FATSurfaceName) == 0x000050, "Wrong size on FATSurfaceName");
static_assert(offsetof(FATSurfaceName, SurfaceNames) == 0x000000, "Member 'FATSurfaceName::SurfaceNames' has a wrong offset!");

// ScriptStruct AT.ATVisionData
// 0x0058 (0x0058 - 0x0000)
struct FATVisionData final
{
public:
	TSoftObjectPtr<class UTexture2D>              PictureTexturePath;                                // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OmenMessageTable;                                  // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           StartFutureVisionMessageTable;                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           EndMessageTable;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATVisionData) == 0x000008, "Wrong alignment on FATVisionData");
static_assert(sizeof(FATVisionData) == 0x000058, "Wrong size on FATVisionData");
static_assert(offsetof(FATVisionData, PictureTexturePath) == 0x000000, "Member 'FATVisionData::PictureTexturePath' has a wrong offset!");
static_assert(offsetof(FATVisionData, OmenMessageTable) == 0x000028, "Member 'FATVisionData::OmenMessageTable' has a wrong offset!");
static_assert(offsetof(FATVisionData, StartFutureVisionMessageTable) == 0x000038, "Member 'FATVisionData::StartFutureVisionMessageTable' has a wrong offset!");
static_assert(offsetof(FATVisionData, EndMessageTable) == 0x000048, "Member 'FATVisionData::EndMessageTable' has a wrong offset!");

// ScriptStruct AT.AttackRangeEffectInfo
// 0x0050 (0x0050 - 0x0000)
struct FAttackRangeEffectInfo final
{
public:
	struct FAttackRangeEffectSetting              SettingParam;                                      // 0x0000(0x0048)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAttackRangeEffectInfo) == 0x000008, "Wrong alignment on FAttackRangeEffectInfo");
static_assert(sizeof(FAttackRangeEffectInfo) == 0x000050, "Wrong size on FAttackRangeEffectInfo");
static_assert(offsetof(FAttackRangeEffectInfo, SettingParam) == 0x000000, "Member 'FAttackRangeEffectInfo::SettingParam' has a wrong offset!");

// ScriptStruct AT.SimpleTalkParam
// 0x0088 (0x0090 - 0x0008)
struct FSimpleTalkParam final : public FTableRowBase
{
public:
	class FString                                 Talk_id;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message_id;                                        // 0x0018(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Message_parameter_ids;                             // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Delay_time;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Auto_subscribe_time;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Quest_id;                                          // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETalkWindowType                               Window_type;                                       // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Selection_item_id;                                 // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETalkEventType                                Talk_event;                                        // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Talk_event_parameter_id;                           // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 begin_action_command_id;                           // 0x0070(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 End_action_command_id;                             // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSimpleTalkParam) == 0x000008, "Wrong alignment on FSimpleTalkParam");
static_assert(sizeof(FSimpleTalkParam) == 0x000090, "Wrong size on FSimpleTalkParam");
static_assert(offsetof(FSimpleTalkParam, Talk_id) == 0x000008, "Member 'FSimpleTalkParam::Talk_id' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Message_id) == 0x000018, "Member 'FSimpleTalkParam::Message_id' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Message_parameter_ids) == 0x000028, "Member 'FSimpleTalkParam::Message_parameter_ids' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Delay_time) == 0x000038, "Member 'FSimpleTalkParam::Delay_time' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Auto_subscribe_time) == 0x00003C, "Member 'FSimpleTalkParam::Auto_subscribe_time' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Quest_id) == 0x000040, "Member 'FSimpleTalkParam::Quest_id' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Window_type) == 0x000048, "Member 'FSimpleTalkParam::Window_type' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Selection_item_id) == 0x000050, "Member 'FSimpleTalkParam::Selection_item_id' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Talk_event) == 0x000060, "Member 'FSimpleTalkParam::Talk_event' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, Talk_event_parameter_id) == 0x000068, "Member 'FSimpleTalkParam::Talk_event_parameter_id' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, begin_action_command_id) == 0x000070, "Member 'FSimpleTalkParam::begin_action_command_id' has a wrong offset!");
static_assert(offsetof(FSimpleTalkParam, End_action_command_id) == 0x000080, "Member 'FSimpleTalkParam::End_action_command_id' has a wrong offset!");

// ScriptStruct AT.SupportActionLotParam
// 0x0008 (0x0008 - 0x0000)
struct FSupportActionLotParam final
{
public:
	ECHARACTER_TYPE                               Chara;                                             // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSupportActionLotParam) == 0x000004, "Wrong alignment on FSupportActionLotParam");
static_assert(sizeof(FSupportActionLotParam) == 0x000008, "Wrong size on FSupportActionLotParam");
static_assert(offsetof(FSupportActionLotParam, Chara) == 0x000000, "Member 'FSupportActionLotParam::Chara' has a wrong offset!");
static_assert(offsetof(FSupportActionLotParam, Lot) == 0x000004, "Member 'FSupportActionLotParam::Lot' has a wrong offset!");

// ScriptStruct AT.SupportActionLotTableRow
// 0x0018 (0x0020 - 0x0008)
struct FSupportActionLotTableRow final : public FTableRowBase
{
public:
	TArray<struct FSupportActionLotParam>         List;                                              // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Allorrection;                                      // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSupportActionLotTableRow) == 0x000008, "Wrong alignment on FSupportActionLotTableRow");
static_assert(sizeof(FSupportActionLotTableRow) == 0x000020, "Wrong size on FSupportActionLotTableRow");
static_assert(offsetof(FSupportActionLotTableRow, List) == 0x000008, "Member 'FSupportActionLotTableRow::List' has a wrong offset!");
static_assert(offsetof(FSupportActionLotTableRow, Allorrection) == 0x000018, "Member 'FSupportActionLotTableRow::Allorrection' has a wrong offset!");

// ScriptStruct AT.SelectionItemParam
// 0x00B0 (0x00B8 - 0x0008)
struct FSelectionItemParam final : public FTableRowBase
{
public:
	class FString                                 Item_id;                                           // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESelectionEnableType                          Enable_condition;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Condition_variable;                                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_enable_cancel;                                  // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Window_title;                                      // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Window_title_parameter;                            // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Detail;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Detail_parameter;                                  // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Detail_int_parameter;                              // 0x0070(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Message_id;                                        // 0x0080(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Message_id_parameter;                              // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Action_command_id;                                 // 0x00A0(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_answer;                                         // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Is_default_cursor;                                 // 0x00B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSelectionItemParam) == 0x000008, "Wrong alignment on FSelectionItemParam");
static_assert(sizeof(FSelectionItemParam) == 0x0000B8, "Wrong size on FSelectionItemParam");
static_assert(offsetof(FSelectionItemParam, Item_id) == 0x000008, "Member 'FSelectionItemParam::Item_id' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Enable_condition) == 0x000018, "Member 'FSelectionItemParam::Enable_condition' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Condition_variable) == 0x000020, "Member 'FSelectionItemParam::Condition_variable' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Is_enable_cancel) == 0x000028, "Member 'FSelectionItemParam::Is_enable_cancel' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Window_title) == 0x000030, "Member 'FSelectionItemParam::Window_title' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Window_title_parameter) == 0x000040, "Member 'FSelectionItemParam::Window_title_parameter' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Detail) == 0x000050, "Member 'FSelectionItemParam::Detail' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Detail_parameter) == 0x000060, "Member 'FSelectionItemParam::Detail_parameter' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Detail_int_parameter) == 0x000070, "Member 'FSelectionItemParam::Detail_int_parameter' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Message_id) == 0x000080, "Member 'FSelectionItemParam::Message_id' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Message_id_parameter) == 0x000090, "Member 'FSelectionItemParam::Message_id_parameter' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Action_command_id) == 0x0000A0, "Member 'FSelectionItemParam::Action_command_id' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Is_answer) == 0x0000B0, "Member 'FSelectionItemParam::Is_answer' has a wrong offset!");
static_assert(offsetof(FSelectionItemParam, Is_default_cursor) == 0x0000B1, "Member 'FSelectionItemParam::Is_default_cursor' has a wrong offset!");

// ScriptStruct AT.NpcTalkMinigameParam
// 0x0040 (0x0048 - 0x0008)
struct FNpcTalkMinigameParam final : public FTableRowBase
{
public:
	class FString                                 Talk_minigame_id;                                  // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETALK_MINIGAME_TYPE                           MiniGame;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETALK_MINIGAME_LEVEL                          Level;                                             // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Area_name;                                         // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Play_count;                                        // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        best_score;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Just_meet_count;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcTalkMinigameParam) == 0x000008, "Wrong alignment on FNpcTalkMinigameParam");
static_assert(sizeof(FNpcTalkMinigameParam) == 0x000048, "Wrong size on FNpcTalkMinigameParam");
static_assert(offsetof(FNpcTalkMinigameParam, Talk_minigame_id) == 0x000008, "Member 'FNpcTalkMinigameParam::Talk_minigame_id' has a wrong offset!");
static_assert(offsetof(FNpcTalkMinigameParam, MiniGame) == 0x000018, "Member 'FNpcTalkMinigameParam::MiniGame' has a wrong offset!");
static_assert(offsetof(FNpcTalkMinigameParam, Level) == 0x000019, "Member 'FNpcTalkMinigameParam::Level' has a wrong offset!");
static_assert(offsetof(FNpcTalkMinigameParam, Area_name) == 0x000020, "Member 'FNpcTalkMinigameParam::Area_name' has a wrong offset!");
static_assert(offsetof(FNpcTalkMinigameParam, Play_count) == 0x000030, "Member 'FNpcTalkMinigameParam::Play_count' has a wrong offset!");
static_assert(offsetof(FNpcTalkMinigameParam, best_score) == 0x000038, "Member 'FNpcTalkMinigameParam::best_score' has a wrong offset!");
static_assert(offsetof(FNpcTalkMinigameParam, Just_meet_count) == 0x000040, "Member 'FNpcTalkMinigameParam::Just_meet_count' has a wrong offset!");

// ScriptStruct AT.CheckHitValid
// 0x0090 (0x0090 - 0x0000)
struct alignas(0x08) FCheckHitValid final
{
public:
	uint8                                         Pad_0[0x90];                                       // 0x0000(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCheckHitValid) == 0x000008, "Wrong alignment on FCheckHitValid");
static_assert(sizeof(FCheckHitValid) == 0x000090, "Wrong size on FCheckHitValid");

// ScriptStruct AT.TalkParticleParam
// 0x0040 (0x0048 - 0x0008)
struct FTalkParticleParam final : public FTableRowBase
{
public:
	class FName                                   ParticleId;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UParticleSystem>         RefParticle;                                       // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdBegin;                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdEnd;                              // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkParticleParam) == 0x000008, "Wrong alignment on FTalkParticleParam");
static_assert(sizeof(FTalkParticleParam) == 0x000048, "Wrong size on FTalkParticleParam");
static_assert(offsetof(FTalkParticleParam, ParticleId) == 0x000008, "Member 'FTalkParticleParam::ParticleId' has a wrong offset!");
static_assert(offsetof(FTalkParticleParam, RefParticle) == 0x000010, "Member 'FTalkParticleParam::RefParticle' has a wrong offset!");
static_assert(offsetof(FTalkParticleParam, LoadingProgressIdBegin) == 0x000038, "Member 'FTalkParticleParam::LoadingProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FTalkParticleParam, LoadingProgressIdEnd) == 0x000040, "Member 'FTalkParticleParam::LoadingProgressIdEnd' has a wrong offset!");

// ScriptStruct AT.FishDataTable
// 0x0070 (0x0078 - 0x0008)
struct FFishDataTable final : public FTableRowBase
{
public:
	class FName                                   FishID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FishName;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FishModelName;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID_01;                                         // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Num_01;                                            // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot_01;                                            // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID_02;                                         // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Num_02;                                            // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot_02;                                            // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID_03;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Num_03;                                            // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot_03;                                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID_04;                                         // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Num_04;                                            // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot_04;                                            // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID_05;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Num_05;                                            // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot_05;                                            // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFishID                                       CollectionId;                                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFishDataTable) == 0x000008, "Wrong alignment on FFishDataTable");
static_assert(sizeof(FFishDataTable) == 0x000078, "Wrong size on FFishDataTable");
static_assert(offsetof(FFishDataTable, FishID) == 0x000008, "Member 'FFishDataTable::FishID' has a wrong offset!");
static_assert(offsetof(FFishDataTable, FishName) == 0x000010, "Member 'FFishDataTable::FishName' has a wrong offset!");
static_assert(offsetof(FFishDataTable, FishModelName) == 0x000018, "Member 'FFishDataTable::FishModelName' has a wrong offset!");
static_assert(offsetof(FFishDataTable, ItemID_01) == 0x000020, "Member 'FFishDataTable::ItemID_01' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Num_01) == 0x000028, "Member 'FFishDataTable::Num_01' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Lot_01) == 0x00002C, "Member 'FFishDataTable::Lot_01' has a wrong offset!");
static_assert(offsetof(FFishDataTable, ItemID_02) == 0x000030, "Member 'FFishDataTable::ItemID_02' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Num_02) == 0x000038, "Member 'FFishDataTable::Num_02' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Lot_02) == 0x00003C, "Member 'FFishDataTable::Lot_02' has a wrong offset!");
static_assert(offsetof(FFishDataTable, ItemID_03) == 0x000040, "Member 'FFishDataTable::ItemID_03' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Num_03) == 0x000048, "Member 'FFishDataTable::Num_03' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Lot_03) == 0x00004C, "Member 'FFishDataTable::Lot_03' has a wrong offset!");
static_assert(offsetof(FFishDataTable, ItemID_04) == 0x000050, "Member 'FFishDataTable::ItemID_04' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Num_04) == 0x000058, "Member 'FFishDataTable::Num_04' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Lot_04) == 0x00005C, "Member 'FFishDataTable::Lot_04' has a wrong offset!");
static_assert(offsetof(FFishDataTable, ItemID_05) == 0x000060, "Member 'FFishDataTable::ItemID_05' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Num_05) == 0x000068, "Member 'FFishDataTable::Num_05' has a wrong offset!");
static_assert(offsetof(FFishDataTable, Lot_05) == 0x00006C, "Member 'FFishDataTable::Lot_05' has a wrong offset!");
static_assert(offsetof(FFishDataTable, CollectionId) == 0x000070, "Member 'FFishDataTable::CollectionId' has a wrong offset!");

// ScriptStruct AT.CharacterAbsenceParam
// 0x0008 (0x0010 - 0x0008)
struct FCharacterAbsenceParam final : public FTableRowBase
{
public:
	float                                         LightTowerDistance;                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterAbsenceParam) == 0x000008, "Wrong alignment on FCharacterAbsenceParam");
static_assert(sizeof(FCharacterAbsenceParam) == 0x000010, "Wrong size on FCharacterAbsenceParam");
static_assert(offsetof(FCharacterAbsenceParam, LightTowerDistance) == 0x000008, "Member 'FCharacterAbsenceParam::LightTowerDistance' has a wrong offset!");

// ScriptStruct AT.TalkMontageParam
// 0x0048 (0x0050 - 0x0008)
struct FTalkMontageParam final : public FTableRowBase
{
public:
	class FName                                   MontageId;                                         // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            RefMontage;                                        // 0x0010(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendSpaceType;                                    // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LoadingProgressIdBegin;                            // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdEnd;                              // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTalkMontageParam) == 0x000008, "Wrong alignment on FTalkMontageParam");
static_assert(sizeof(FTalkMontageParam) == 0x000050, "Wrong size on FTalkMontageParam");
static_assert(offsetof(FTalkMontageParam, MontageId) == 0x000008, "Member 'FTalkMontageParam::MontageId' has a wrong offset!");
static_assert(offsetof(FTalkMontageParam, RefMontage) == 0x000010, "Member 'FTalkMontageParam::RefMontage' has a wrong offset!");
static_assert(offsetof(FTalkMontageParam, BlendSpaceType) == 0x000038, "Member 'FTalkMontageParam::BlendSpaceType' has a wrong offset!");
static_assert(offsetof(FTalkMontageParam, LoadingProgressIdBegin) == 0x000040, "Member 'FTalkMontageParam::LoadingProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FTalkMontageParam, LoadingProgressIdEnd) == 0x000048, "Member 'FTalkMontageParam::LoadingProgressIdEnd' has a wrong offset!");

// ScriptStruct AT.BuyItemData
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FBuyItemData final
{
public:
	class FName                                   BuyItemId;                                         // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyItemNum;                                        // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BuyItemTotalMoney;                                 // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemMessageId;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuySuccessRequestCommand;                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBuyItemData) == 0x000008, "Wrong alignment on FBuyItemData");
static_assert(sizeof(FBuyItemData) == 0x000020, "Wrong size on FBuyItemData");
static_assert(offsetof(FBuyItemData, BuyItemId) == 0x000000, "Member 'FBuyItemData::BuyItemId' has a wrong offset!");
static_assert(offsetof(FBuyItemData, BuyItemNum) == 0x000008, "Member 'FBuyItemData::BuyItemNum' has a wrong offset!");
static_assert(offsetof(FBuyItemData, BuyItemTotalMoney) == 0x00000C, "Member 'FBuyItemData::BuyItemTotalMoney' has a wrong offset!");
static_assert(offsetof(FBuyItemData, ItemMessageId) == 0x000010, "Member 'FBuyItemData::ItemMessageId' has a wrong offset!");
static_assert(offsetof(FBuyItemData, BuySuccessRequestCommand) == 0x000018, "Member 'FBuyItemData::BuySuccessRequestCommand' has a wrong offset!");

// ScriptStruct AT.QuestTalkBuyItemParam
// 0x0038 (0x0040 - 0x0008)
struct FQuestTalkBuyItemParam final : public FTableRowBase
{
public:
	class FName                                   TitleMessageId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoActionMessageId;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBuyItemData>                   BuyItems;                                          // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   NoActionRequestCommand;                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuyFaildNoMoneyRequestCommand;                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BuyFaildMaxItemRequestCommand;                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestTalkBuyItemParam) == 0x000008, "Wrong alignment on FQuestTalkBuyItemParam");
static_assert(sizeof(FQuestTalkBuyItemParam) == 0x000040, "Wrong size on FQuestTalkBuyItemParam");
static_assert(offsetof(FQuestTalkBuyItemParam, TitleMessageId) == 0x000008, "Member 'FQuestTalkBuyItemParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FQuestTalkBuyItemParam, NoActionMessageId) == 0x000010, "Member 'FQuestTalkBuyItemParam::NoActionMessageId' has a wrong offset!");
static_assert(offsetof(FQuestTalkBuyItemParam, BuyItems) == 0x000018, "Member 'FQuestTalkBuyItemParam::BuyItems' has a wrong offset!");
static_assert(offsetof(FQuestTalkBuyItemParam, NoActionRequestCommand) == 0x000028, "Member 'FQuestTalkBuyItemParam::NoActionRequestCommand' has a wrong offset!");
static_assert(offsetof(FQuestTalkBuyItemParam, BuyFaildNoMoneyRequestCommand) == 0x000030, "Member 'FQuestTalkBuyItemParam::BuyFaildNoMoneyRequestCommand' has a wrong offset!");
static_assert(offsetof(FQuestTalkBuyItemParam, BuyFaildMaxItemRequestCommand) == 0x000038, "Member 'FQuestTalkBuyItemParam::BuyFaildMaxItemRequestCommand' has a wrong offset!");

// ScriptStruct AT.TickControllerInfo
// 0x0030 (0x0038 - 0x0008)
struct FTickControllerInfo final : public FTableRowBase
{
public:
	float                                         Interval_LOD0;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD1;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD1;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD2;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD2;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD3;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD3;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_Invisible;                                // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_Deactive;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_DeactiveOutView;                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time_DeactiveOutView;                              // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_Margin;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTickControllerInfo) == 0x000008, "Wrong alignment on FTickControllerInfo");
static_assert(sizeof(FTickControllerInfo) == 0x000038, "Wrong size on FTickControllerInfo");
static_assert(offsetof(FTickControllerInfo, Interval_LOD0) == 0x000008, "Member 'FTickControllerInfo::Interval_LOD0' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_LOD1) == 0x00000C, "Member 'FTickControllerInfo::Distance_LOD1' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Interval_LOD1) == 0x000010, "Member 'FTickControllerInfo::Interval_LOD1' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_LOD2) == 0x000014, "Member 'FTickControllerInfo::Distance_LOD2' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Interval_LOD2) == 0x000018, "Member 'FTickControllerInfo::Interval_LOD2' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_LOD3) == 0x00001C, "Member 'FTickControllerInfo::Distance_LOD3' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Interval_LOD3) == 0x000020, "Member 'FTickControllerInfo::Interval_LOD3' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_Invisible) == 0x000024, "Member 'FTickControllerInfo::Distance_Invisible' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_Deactive) == 0x000028, "Member 'FTickControllerInfo::Distance_Deactive' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_DeactiveOutView) == 0x00002C, "Member 'FTickControllerInfo::Distance_DeactiveOutView' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Time_DeactiveOutView) == 0x000030, "Member 'FTickControllerInfo::Time_DeactiveOutView' has a wrong offset!");
static_assert(offsetof(FTickControllerInfo, Distance_Margin) == 0x000034, "Member 'FTickControllerInfo::Distance_Margin' has a wrong offset!");

// ScriptStruct AT.FishShadowSpawnTable
// 0x0098 (0x00A0 - 0x0008)
struct FFishShadowSpawnTable final : public FTableRowBase
{
public:
	class FName                                   MngID;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FishShadow01_ID;                                   // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow01_Lot;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow02_ID;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow02_Lot;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow03_ID;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow03_Lot;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow04_ID;                                   // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow04_Lot;                                  // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow05_ID;                                   // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow05_Lot;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow06_ID;                                   // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow06_Lot;                                  // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow07_ID;                                   // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow07_Lot;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow08_ID;                                   // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow08_Lot;                                  // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadow09_ID;                                   // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadow09_Lot;                                  // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFishShadowSpawnTable) == 0x000008, "Wrong alignment on FFishShadowSpawnTable");
static_assert(sizeof(FFishShadowSpawnTable) == 0x0000A0, "Wrong size on FFishShadowSpawnTable");
static_assert(offsetof(FFishShadowSpawnTable, MngID) == 0x000008, "Member 'FFishShadowSpawnTable::MngID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow01_ID) == 0x000010, "Member 'FFishShadowSpawnTable::FishShadow01_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow01_Lot) == 0x000018, "Member 'FFishShadowSpawnTable::FishShadow01_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow02_ID) == 0x000020, "Member 'FFishShadowSpawnTable::FishShadow02_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow02_Lot) == 0x000028, "Member 'FFishShadowSpawnTable::FishShadow02_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow03_ID) == 0x000030, "Member 'FFishShadowSpawnTable::FishShadow03_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow03_Lot) == 0x000038, "Member 'FFishShadowSpawnTable::FishShadow03_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow04_ID) == 0x000040, "Member 'FFishShadowSpawnTable::FishShadow04_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow04_Lot) == 0x000048, "Member 'FFishShadowSpawnTable::FishShadow04_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow05_ID) == 0x000050, "Member 'FFishShadowSpawnTable::FishShadow05_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow05_Lot) == 0x000058, "Member 'FFishShadowSpawnTable::FishShadow05_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow06_ID) == 0x000060, "Member 'FFishShadowSpawnTable::FishShadow06_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow06_Lot) == 0x000068, "Member 'FFishShadowSpawnTable::FishShadow06_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow07_ID) == 0x000070, "Member 'FFishShadowSpawnTable::FishShadow07_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow07_Lot) == 0x000078, "Member 'FFishShadowSpawnTable::FishShadow07_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow08_ID) == 0x000080, "Member 'FFishShadowSpawnTable::FishShadow08_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow08_Lot) == 0x000088, "Member 'FFishShadowSpawnTable::FishShadow08_Lot' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow09_ID) == 0x000090, "Member 'FFishShadowSpawnTable::FishShadow09_ID' has a wrong offset!");
static_assert(offsetof(FFishShadowSpawnTable, FishShadow09_Lot) == 0x000098, "Member 'FFishShadowSpawnTable::FishShadow09_Lot' has a wrong offset!");

// ScriptStruct AT.ActiveStateInfo
// 0x0018 (0x0020 - 0x0008)
struct FActiveStateInfo final : public FTableRowBase
{
public:
	float                                         Distance_Invisible;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_Deactive;                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_DeactiveOutView;                          // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time_DeactiveOutView;                              // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_Margin;                                   // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FActiveStateInfo) == 0x000008, "Wrong alignment on FActiveStateInfo");
static_assert(sizeof(FActiveStateInfo) == 0x000020, "Wrong size on FActiveStateInfo");
static_assert(offsetof(FActiveStateInfo, Distance_Invisible) == 0x000008, "Member 'FActiveStateInfo::Distance_Invisible' has a wrong offset!");
static_assert(offsetof(FActiveStateInfo, Distance_Deactive) == 0x00000C, "Member 'FActiveStateInfo::Distance_Deactive' has a wrong offset!");
static_assert(offsetof(FActiveStateInfo, Distance_DeactiveOutView) == 0x000010, "Member 'FActiveStateInfo::Distance_DeactiveOutView' has a wrong offset!");
static_assert(offsetof(FActiveStateInfo, Time_DeactiveOutView) == 0x000014, "Member 'FActiveStateInfo::Time_DeactiveOutView' has a wrong offset!");
static_assert(offsetof(FActiveStateInfo, Distance_Margin) == 0x000018, "Member 'FActiveStateInfo::Distance_Margin' has a wrong offset!");

// ScriptStruct AT.TickLODInfo
// 0x0020 (0x0028 - 0x0008)
struct FTickLODInfo final : public FTableRowBase
{
public:
	float                                         Distance_LOD0;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD1;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD2;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD0;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD1;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD2;                                     // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD3;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTickLODInfo) == 0x000008, "Wrong alignment on FTickLODInfo");
static_assert(sizeof(FTickLODInfo) == 0x000028, "Wrong size on FTickLODInfo");
static_assert(offsetof(FTickLODInfo, Distance_LOD0) == 0x000008, "Member 'FTickLODInfo::Distance_LOD0' has a wrong offset!");
static_assert(offsetof(FTickLODInfo, Distance_LOD1) == 0x00000C, "Member 'FTickLODInfo::Distance_LOD1' has a wrong offset!");
static_assert(offsetof(FTickLODInfo, Distance_LOD2) == 0x000010, "Member 'FTickLODInfo::Distance_LOD2' has a wrong offset!");
static_assert(offsetof(FTickLODInfo, Interval_LOD0) == 0x000014, "Member 'FTickLODInfo::Interval_LOD0' has a wrong offset!");
static_assert(offsetof(FTickLODInfo, Interval_LOD1) == 0x000018, "Member 'FTickLODInfo::Interval_LOD1' has a wrong offset!");
static_assert(offsetof(FTickLODInfo, Interval_LOD2) == 0x00001C, "Member 'FTickLODInfo::Interval_LOD2' has a wrong offset!");
static_assert(offsetof(FTickLODInfo, Interval_LOD3) == 0x000020, "Member 'FTickLODInfo::Interval_LOD3' has a wrong offset!");

// ScriptStruct AT.ATCharacterInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FATCharacterInfo final
{
public:
	class FName                                   Unique_id;                                         // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Variation;                                         // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Form;                                              // 0x0009(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATCharacterInfo) == 0x000008, "Wrong alignment on FATCharacterInfo");
static_assert(sizeof(FATCharacterInfo) == 0x000010, "Wrong size on FATCharacterInfo");
static_assert(offsetof(FATCharacterInfo, Unique_id) == 0x000000, "Member 'FATCharacterInfo::Unique_id' has a wrong offset!");
static_assert(offsetof(FATCharacterInfo, Variation) == 0x000008, "Member 'FATCharacterInfo::Variation' has a wrong offset!");
static_assert(offsetof(FATCharacterInfo, Form) == 0x000009, "Member 'FATCharacterInfo::Form' has a wrong offset!");

// ScriptStruct AT.CreateCaptureSetParameter
// 0x00A0 (0x00A0 - 0x0000)
struct FCreateCaptureSetParameter final
{
public:
	struct FTransform                             CameraTransform;                                   // 0x0000(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             DirectionalLightTransform;                         // 0x0030(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             SkyLightTransform;                                 // 0x0060(0x0030)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FColor                                 DirectionalLightColor;                             // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 SkyLightColor;                                     // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESceneCaptureSource                           CaptureSource;                                     // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SkyLightIntensity;                                 // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreateCaptureSetParameter) == 0x000010, "Wrong alignment on FCreateCaptureSetParameter");
static_assert(sizeof(FCreateCaptureSetParameter) == 0x0000A0, "Wrong size on FCreateCaptureSetParameter");
static_assert(offsetof(FCreateCaptureSetParameter, CameraTransform) == 0x000000, "Member 'FCreateCaptureSetParameter::CameraTransform' has a wrong offset!");
static_assert(offsetof(FCreateCaptureSetParameter, DirectionalLightTransform) == 0x000030, "Member 'FCreateCaptureSetParameter::DirectionalLightTransform' has a wrong offset!");
static_assert(offsetof(FCreateCaptureSetParameter, SkyLightTransform) == 0x000060, "Member 'FCreateCaptureSetParameter::SkyLightTransform' has a wrong offset!");
static_assert(offsetof(FCreateCaptureSetParameter, DirectionalLightColor) == 0x000090, "Member 'FCreateCaptureSetParameter::DirectionalLightColor' has a wrong offset!");
static_assert(offsetof(FCreateCaptureSetParameter, SkyLightColor) == 0x000094, "Member 'FCreateCaptureSetParameter::SkyLightColor' has a wrong offset!");
static_assert(offsetof(FCreateCaptureSetParameter, CaptureSource) == 0x000098, "Member 'FCreateCaptureSetParameter::CaptureSource' has a wrong offset!");
static_assert(offsetof(FCreateCaptureSetParameter, SkyLightIntensity) == 0x00009C, "Member 'FCreateCaptureSetParameter::SkyLightIntensity' has a wrong offset!");

// ScriptStruct AT.RipOffSkillAndCharacter
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FRipOffSkillAndCharacter final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRipOffSkillAndCharacter) == 0x000008, "Wrong alignment on FRipOffSkillAndCharacter");
static_assert(sizeof(FRipOffSkillAndCharacter) == 0x000010, "Wrong size on FRipOffSkillAndCharacter");

// ScriptStruct AT.SubTitleInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FSubTitleInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubTitleInfo) == 0x000008, "Wrong alignment on FSubTitleInfo");
static_assert(sizeof(FSubTitleInfo) == 0x000020, "Wrong size on FSubTitleInfo");

// ScriptStruct AT.ItemTableImportant
// 0x0008 (0x0048 - 0x0040)
struct FItemTableImportant final : public FItemInfoParam
{
public:
	bool                                          bMemory;                                           // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTableImportant) == 0x000008, "Wrong alignment on FItemTableImportant");
static_assert(sizeof(FItemTableImportant) == 0x000048, "Wrong size on FItemTableImportant");
static_assert(offsetof(FItemTableImportant, bMemory) == 0x000040, "Member 'FItemTableImportant::bMemory' has a wrong offset!");

// ScriptStruct AT.ATWindRoadParam
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FATWindRoadParam final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATWindRoadParam) == 0x000008, "Wrong alignment on FATWindRoadParam");
static_assert(sizeof(FATWindRoadParam) == 0x000028, "Wrong size on FATWindRoadParam");

// ScriptStruct AT.ATWindRoadAppearanceInfo
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FATWindRoadAppearanceInfo final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATWindRoadAppearanceInfo) == 0x000008, "Wrong alignment on FATWindRoadAppearanceInfo");
static_assert(sizeof(FATWindRoadAppearanceInfo) == 0x000058, "Wrong size on FATWindRoadAppearanceInfo");

// ScriptStruct AT.ATWorldBlockingVolumes
// 0x0010 (0x0010 - 0x0000)
struct FATWorldBlockingVolumes final
{
public:
	TArray<class AActor*>                         List;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATWorldBlockingVolumes) == 0x000008, "Wrong alignment on FATWorldBlockingVolumes");
static_assert(sizeof(FATWorldBlockingVolumes) == 0x000010, "Wrong size on FATWorldBlockingVolumes");
static_assert(offsetof(FATWorldBlockingVolumes, List) == 0x000000, "Member 'FATWorldBlockingVolumes::List' has a wrong offset!");

// ScriptStruct AT.ATWorldMapMovementData
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FATWorldMapMovementData final
{
public:
	float                                         MoveTimeLimit;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CloudDataMasterId;                                 // 0x0008(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTimeLimit;                                     // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudDistance;                                     // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudEmmisiveMin;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudEmmisiveMax;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloudEmmisiveTimeLimit;                            // 0x0020(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UiFadeOutTimeLimit;                                // 0x0024(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BoostFlyingRotation;                               // 0x0028(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               LookAtRelativeRotation;                            // 0x0034(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRelativeRotation;                            // 0x0040(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LookAtLength;                                      // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLength;                                      // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraInterpolationDuration;                       // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FirstCutDuration;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Altitude;                                          // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DLC5StartPointOffsetLocation;                      // 0x0060(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FATWorldMapMovementData) == 0x000008, "Wrong alignment on FATWorldMapMovementData");
static_assert(sizeof(FATWorldMapMovementData) == 0x000070, "Wrong size on FATWorldMapMovementData");
static_assert(offsetof(FATWorldMapMovementData, MoveTimeLimit) == 0x000000, "Member 'FATWorldMapMovementData::MoveTimeLimit' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CloudDataMasterId) == 0x000008, "Member 'FATWorldMapMovementData::CloudDataMasterId' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, FadeTimeLimit) == 0x000010, "Member 'FATWorldMapMovementData::FadeTimeLimit' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CloudDistance) == 0x000014, "Member 'FATWorldMapMovementData::CloudDistance' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CloudEmmisiveMin) == 0x000018, "Member 'FATWorldMapMovementData::CloudEmmisiveMin' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CloudEmmisiveMax) == 0x00001C, "Member 'FATWorldMapMovementData::CloudEmmisiveMax' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CloudEmmisiveTimeLimit) == 0x000020, "Member 'FATWorldMapMovementData::CloudEmmisiveTimeLimit' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, UiFadeOutTimeLimit) == 0x000024, "Member 'FATWorldMapMovementData::UiFadeOutTimeLimit' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, BoostFlyingRotation) == 0x000028, "Member 'FATWorldMapMovementData::BoostFlyingRotation' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, LookAtRelativeRotation) == 0x000034, "Member 'FATWorldMapMovementData::LookAtRelativeRotation' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CameraRelativeRotation) == 0x000040, "Member 'FATWorldMapMovementData::CameraRelativeRotation' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, LookAtLength) == 0x00004C, "Member 'FATWorldMapMovementData::LookAtLength' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CameraLength) == 0x000050, "Member 'FATWorldMapMovementData::CameraLength' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, CameraInterpolationDuration) == 0x000054, "Member 'FATWorldMapMovementData::CameraInterpolationDuration' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, FirstCutDuration) == 0x000058, "Member 'FATWorldMapMovementData::FirstCutDuration' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, Altitude) == 0x00005C, "Member 'FATWorldMapMovementData::Altitude' has a wrong offset!");
static_assert(offsetof(FATWorldMapMovementData, DLC5StartPointOffsetLocation) == 0x000060, "Member 'FATWorldMapMovementData::DLC5StartPointOffsetLocation' has a wrong offset!");

// ScriptStruct AT.DLC3ProgressAreaMoveList
// 0x0018 (0x0020 - 0x0008)
struct FDLC3ProgressAreaMoveList final : public FTableRowBase
{
public:
	class FName                                   StartSubQuestId;                                   // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndSubQuestId;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EATAreaMoveState                              AreaMoveState;                                     // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDLC3ProgressAreaMoveList) == 0x000008, "Wrong alignment on FDLC3ProgressAreaMoveList");
static_assert(sizeof(FDLC3ProgressAreaMoveList) == 0x000020, "Wrong size on FDLC3ProgressAreaMoveList");
static_assert(offsetof(FDLC3ProgressAreaMoveList, StartSubQuestId) == 0x000008, "Member 'FDLC3ProgressAreaMoveList::StartSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC3ProgressAreaMoveList, EndSubQuestId) == 0x000010, "Member 'FDLC3ProgressAreaMoveList::EndSubQuestId' has a wrong offset!");
static_assert(offsetof(FDLC3ProgressAreaMoveList, AreaMoveState) == 0x000018, "Member 'FDLC3ProgressAreaMoveList::AreaMoveState' has a wrong offset!");

// ScriptStruct AT.BaseballGameCutinTable
// 0x0018 (0x0020 - 0x0008)
struct FBaseballGameCutinTable final : public FTableRowBase
{
public:
	EBaseballGameCutinType                        CutinType;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Distance;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageId;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseballGameCutinTable) == 0x000008, "Wrong alignment on FBaseballGameCutinTable");
static_assert(sizeof(FBaseballGameCutinTable) == 0x000020, "Wrong size on FBaseballGameCutinTable");
static_assert(offsetof(FBaseballGameCutinTable, CutinType) == 0x000008, "Member 'FBaseballGameCutinTable::CutinType' has a wrong offset!");
static_assert(offsetof(FBaseballGameCutinTable, Distance) == 0x00000C, "Member 'FBaseballGameCutinTable::Distance' has a wrong offset!");
static_assert(offsetof(FBaseballGameCutinTable, MessageId) == 0x000010, "Member 'FBaseballGameCutinTable::MessageId' has a wrong offset!");

// ScriptStruct AT.BaseballGameBallTypeTable
// 0x0048 (0x0050 - 0x0008)
struct FBaseballGameBallTypeTable final : public FTableRowBase
{
public:
	EBaseballGameBallType                         BallType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedMin;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedMax;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRangeMin;                                  // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VerticalRangeMax;                                  // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRangeMin;                                // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HorizontalRangeMax;                                // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertexPositionMin;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VertexPositionMax;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedEffectSmall;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedEffectLarge;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MessageId;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowBallSpeedUI;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseballGameBallTypeTable) == 0x000008, "Wrong alignment on FBaseballGameBallTypeTable");
static_assert(sizeof(FBaseballGameBallTypeTable) == 0x000050, "Wrong size on FBaseballGameBallTypeTable");
static_assert(offsetof(FBaseballGameBallTypeTable, BallType) == 0x000008, "Member 'FBaseballGameBallTypeTable::BallType' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, SpeedMin) == 0x00000C, "Member 'FBaseballGameBallTypeTable::SpeedMin' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, SpeedMax) == 0x000010, "Member 'FBaseballGameBallTypeTable::SpeedMax' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, VerticalRangeMin) == 0x000014, "Member 'FBaseballGameBallTypeTable::VerticalRangeMin' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, VerticalRangeMax) == 0x000018, "Member 'FBaseballGameBallTypeTable::VerticalRangeMax' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, HorizontalRangeMin) == 0x00001C, "Member 'FBaseballGameBallTypeTable::HorizontalRangeMin' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, HorizontalRangeMax) == 0x000020, "Member 'FBaseballGameBallTypeTable::HorizontalRangeMax' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, VertexPositionMin) == 0x000024, "Member 'FBaseballGameBallTypeTable::VertexPositionMin' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, VertexPositionMax) == 0x000028, "Member 'FBaseballGameBallTypeTable::VertexPositionMax' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, SpeedEffectSmall) == 0x00002C, "Member 'FBaseballGameBallTypeTable::SpeedEffectSmall' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, SpeedEffectLarge) == 0x000030, "Member 'FBaseballGameBallTypeTable::SpeedEffectLarge' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, MessageId) == 0x000038, "Member 'FBaseballGameBallTypeTable::MessageId' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTypeTable, bShowBallSpeedUI) == 0x000048, "Member 'FBaseballGameBallTypeTable::bShowBallSpeedUI' has a wrong offset!");

// ScriptStruct AT.BaseballGameBallTable
// 0x0010 (0x0018 - 0x0008)
struct FBaseballGameBallTable final : public FTableRowBase
{
public:
	EBaseballGameBallType                         BallType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedLow;                                          // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedHigh;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseballGameBallTable) == 0x000008, "Wrong alignment on FBaseballGameBallTable");
static_assert(sizeof(FBaseballGameBallTable) == 0x000018, "Wrong size on FBaseballGameBallTable");
static_assert(offsetof(FBaseballGameBallTable, BallType) == 0x000008, "Member 'FBaseballGameBallTable::BallType' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTable, SpeedLow) == 0x00000C, "Member 'FBaseballGameBallTable::SpeedLow' has a wrong offset!");
static_assert(offsetof(FBaseballGameBallTable, SpeedHigh) == 0x000010, "Member 'FBaseballGameBallTable::SpeedHigh' has a wrong offset!");

// ScriptStruct AT.BaseballGamePitcherTable
// 0x00C8 (0x00D0 - 0x0008)
struct FBaseballGamePitcherTable final : public FTableRowBase
{
public:
	class FName                                   MeshID;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageId;                                         // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingRate;                                        // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_01;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_01;                                    // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_02;                                         // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_02;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_03;                                         // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_03;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_04;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_04;                                    // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_05;                                         // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_05;                                    // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_06;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_06;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_07;                                         // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_07;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_08;                                         // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_08;                                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_09;                                         // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_09;                                    // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BallID_10;                                         // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability_10;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BallReleasePointOffsetX;                           // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BallReleasePointOffsetY;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BallReleasePointOffsetZ;                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseballGamePitcherTable) == 0x000008, "Wrong alignment on FBaseballGamePitcherTable");
static_assert(sizeof(FBaseballGamePitcherTable) == 0x0000D0, "Wrong size on FBaseballGamePitcherTable");
static_assert(offsetof(FBaseballGamePitcherTable, MeshID) == 0x000008, "Member 'FBaseballGamePitcherTable::MeshID' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, MessageId) == 0x000010, "Member 'FBaseballGamePitcherTable::MessageId' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, FlyingRate) == 0x000020, "Member 'FBaseballGamePitcherTable::FlyingRate' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_01) == 0x000028, "Member 'FBaseballGamePitcherTable::BallID_01' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_01) == 0x000030, "Member 'FBaseballGamePitcherTable::Probability_01' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_02) == 0x000038, "Member 'FBaseballGamePitcherTable::BallID_02' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_02) == 0x000040, "Member 'FBaseballGamePitcherTable::Probability_02' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_03) == 0x000048, "Member 'FBaseballGamePitcherTable::BallID_03' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_03) == 0x000050, "Member 'FBaseballGamePitcherTable::Probability_03' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_04) == 0x000058, "Member 'FBaseballGamePitcherTable::BallID_04' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_04) == 0x000060, "Member 'FBaseballGamePitcherTable::Probability_04' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_05) == 0x000068, "Member 'FBaseballGamePitcherTable::BallID_05' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_05) == 0x000070, "Member 'FBaseballGamePitcherTable::Probability_05' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_06) == 0x000078, "Member 'FBaseballGamePitcherTable::BallID_06' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_06) == 0x000080, "Member 'FBaseballGamePitcherTable::Probability_06' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_07) == 0x000088, "Member 'FBaseballGamePitcherTable::BallID_07' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_07) == 0x000090, "Member 'FBaseballGamePitcherTable::Probability_07' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_08) == 0x000098, "Member 'FBaseballGamePitcherTable::BallID_08' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_08) == 0x0000A0, "Member 'FBaseballGamePitcherTable::Probability_08' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_09) == 0x0000A8, "Member 'FBaseballGamePitcherTable::BallID_09' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_09) == 0x0000B0, "Member 'FBaseballGamePitcherTable::Probability_09' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallID_10) == 0x0000B8, "Member 'FBaseballGamePitcherTable::BallID_10' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, Probability_10) == 0x0000C0, "Member 'FBaseballGamePitcherTable::Probability_10' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallReleasePointOffsetX) == 0x0000C4, "Member 'FBaseballGamePitcherTable::BallReleasePointOffsetX' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallReleasePointOffsetY) == 0x0000C8, "Member 'FBaseballGamePitcherTable::BallReleasePointOffsetY' has a wrong offset!");
static_assert(offsetof(FBaseballGamePitcherTable, BallReleasePointOffsetZ) == 0x0000CC, "Member 'FBaseballGamePitcherTable::BallReleasePointOffsetZ' has a wrong offset!");

// ScriptStruct AT.BaseballGameHitTimingTable
// 0x0010 (0x0018 - 0x0008)
struct FBaseballGameHitTimingTable final : public FTableRowBase
{
public:
	EBaseballGameHitTiming                        Timing;                                            // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Range;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseballGameHitTimingTable) == 0x000008, "Wrong alignment on FBaseballGameHitTimingTable");
static_assert(sizeof(FBaseballGameHitTimingTable) == 0x000018, "Wrong size on FBaseballGameHitTimingTable");
static_assert(offsetof(FBaseballGameHitTimingTable, Timing) == 0x000008, "Member 'FBaseballGameHitTimingTable::Timing' has a wrong offset!");
static_assert(offsetof(FBaseballGameHitTimingTable, Range) == 0x00000C, "Member 'FBaseballGameHitTimingTable::Range' has a wrong offset!");
static_assert(offsetof(FBaseballGameHitTimingTable, Rate) == 0x000010, "Member 'FBaseballGameHitTimingTable::Rate' has a wrong offset!");

// ScriptStruct AT.BaseballGameBattlePowerTable
// 0x0008 (0x0010 - 0x0008)
struct FBaseballGameBattlePowerTable final : public FTableRowBase
{
public:
	float                                         BattlePower;                                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyingRate;                                        // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaseballGameBattlePowerTable) == 0x000008, "Wrong alignment on FBaseballGameBattlePowerTable");
static_assert(sizeof(FBaseballGameBattlePowerTable) == 0x000010, "Wrong size on FBaseballGameBattlePowerTable");
static_assert(offsetof(FBaseballGameBattlePowerTable, BattlePower) == 0x000008, "Member 'FBaseballGameBattlePowerTable::BattlePower' has a wrong offset!");
static_assert(offsetof(FBaseballGameBattlePowerTable, FlyingRate) == 0x00000C, "Member 'FBaseballGameBattlePowerTable::FlyingRate' has a wrong offset!");

// ScriptStruct AT.BaseballGameConstantTable
// 0x0008 (0x0010 - 0x0008)
struct FBaseballGameConstantTable final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBaseballGameConstantTable) == 0x000008, "Wrong alignment on FBaseballGameConstantTable");
static_assert(sizeof(FBaseballGameConstantTable) == 0x000010, "Wrong size on FBaseballGameConstantTable");
static_assert(offsetof(FBaseballGameConstantTable, Value) == 0x000008, "Member 'FBaseballGameConstantTable::Value' has a wrong offset!");

// ScriptStruct AT.BattleBarrierParamBox
// 0x0010 (0x0010 - 0x0000)
struct FBattleBarrierParamBox final
{
public:
	float                                         BarrierSizeFB;                                     // 0x0000(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierSizeLR;                                     // 0x0004(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierSizeUD;                                     // 0x0008(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BarrierLimitOffset;                                // 0x000C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattleBarrierParamBox) == 0x000004, "Wrong alignment on FBattleBarrierParamBox");
static_assert(sizeof(FBattleBarrierParamBox) == 0x000010, "Wrong size on FBattleBarrierParamBox");
static_assert(offsetof(FBattleBarrierParamBox, BarrierSizeFB) == 0x000000, "Member 'FBattleBarrierParamBox::BarrierSizeFB' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParamBox, BarrierSizeLR) == 0x000004, "Member 'FBattleBarrierParamBox::BarrierSizeLR' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParamBox, BarrierSizeUD) == 0x000008, "Member 'FBattleBarrierParamBox::BarrierSizeUD' has a wrong offset!");
static_assert(offsetof(FBattleBarrierParamBox, BarrierLimitOffset) == 0x00000C, "Member 'FBattleBarrierParamBox::BarrierLimitOffset' has a wrong offset!");

// ScriptStruct AT.DestroyedMeshData
// 0x0040 (0x0040 - 0x0000)
struct FDestroyedMeshData final
{
public:
	TSubclassOf<class ABreakableDestructibleActor> DestructibleClass;                                 // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            RootDebriMesh;                                     // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Transform;                                         // 0x0010(0x0030)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestroyedMeshData) == 0x000010, "Wrong alignment on FDestroyedMeshData");
static_assert(sizeof(FDestroyedMeshData) == 0x000040, "Wrong size on FDestroyedMeshData");
static_assert(offsetof(FDestroyedMeshData, DestructibleClass) == 0x000000, "Member 'FDestroyedMeshData::DestructibleClass' has a wrong offset!");
static_assert(offsetof(FDestroyedMeshData, RootDebriMesh) == 0x000008, "Member 'FDestroyedMeshData::RootDebriMesh' has a wrong offset!");
static_assert(offsetof(FDestroyedMeshData, Transform) == 0x000010, "Member 'FDestroyedMeshData::Transform' has a wrong offset!");

// ScriptStruct AT.RaceGameConstParam
// 0x0008 (0x0010 - 0x0008)
struct FRaceGameConstParam final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRaceGameConstParam) == 0x000008, "Wrong alignment on FRaceGameConstParam");
static_assert(sizeof(FRaceGameConstParam) == 0x000010, "Wrong size on FRaceGameConstParam");
static_assert(offsetof(FRaceGameConstParam, Value) == 0x000008, "Member 'FRaceGameConstParam::Value' has a wrong offset!");

// ScriptStruct AT.BuffTableRow
// 0x0048 (0x0050 - 0x0008)
struct FBuffTableRow final : public FTableRowBase
{
public:
	class FString                                 BuffName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBuffType                                     Type;                                              // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeEx;                                            // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakTime;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakTimeEx;                                       // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoverRate;                                       // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Attack;                                            // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Defense;                                           // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakAttack;                                       // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakDefense;                                      // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damage;                                            // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakDamage;                                       // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncBreak;                                        // 0x004C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FBuffTableRow) == 0x000008, "Wrong alignment on FBuffTableRow");
static_assert(sizeof(FBuffTableRow) == 0x000050, "Wrong size on FBuffTableRow");
static_assert(offsetof(FBuffTableRow, BuffName) == 0x000008, "Member 'FBuffTableRow::BuffName' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, Type) == 0x000018, "Member 'FBuffTableRow::Type' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, Time) == 0x00001C, "Member 'FBuffTableRow::Time' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, TimeEx) == 0x000020, "Member 'FBuffTableRow::TimeEx' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, BreakTime) == 0x000024, "Member 'FBuffTableRow::BreakTime' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, BreakTimeEx) == 0x000028, "Member 'FBuffTableRow::BreakTimeEx' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, RecoverRate) == 0x00002C, "Member 'FBuffTableRow::RecoverRate' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, Attack) == 0x000030, "Member 'FBuffTableRow::Attack' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, Defense) == 0x000034, "Member 'FBuffTableRow::Defense' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, BreakAttack) == 0x000038, "Member 'FBuffTableRow::BreakAttack' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, BreakDefense) == 0x00003C, "Member 'FBuffTableRow::BreakDefense' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, Damage) == 0x000040, "Member 'FBuffTableRow::Damage' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, BreakDamage) == 0x000044, "Member 'FBuffTableRow::BreakDamage' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, MoveSpeed) == 0x000048, "Member 'FBuffTableRow::MoveSpeed' has a wrong offset!");
static_assert(offsetof(FBuffTableRow, bSyncBreak) == 0x00004C, "Member 'FBuffTableRow::bSyncBreak' has a wrong offset!");

// ScriptStruct AT.CollectionSearchIndex
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FCollectionSearchIndex final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionSearchIndex) == 0x000008, "Wrong alignment on FCollectionSearchIndex");
static_assert(sizeof(FCollectionSearchIndex) == 0x000018, "Wrong size on FCollectionSearchIndex");

// ScriptStruct AT.CarParameterArea
// 0x0018 (0x0020 - 0x0008)
struct FCarParameterArea final : public FTableRowBase
{
public:
	class FName                                   CarGroupName;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DensityForSpawn;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarSpeedMin;                                       // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarSpeedMax;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCarParameterArea) == 0x000008, "Wrong alignment on FCarParameterArea");
static_assert(sizeof(FCarParameterArea) == 0x000020, "Wrong size on FCarParameterArea");
static_assert(offsetof(FCarParameterArea, CarGroupName) == 0x000008, "Member 'FCarParameterArea::CarGroupName' has a wrong offset!");
static_assert(offsetof(FCarParameterArea, DensityForSpawn) == 0x000010, "Member 'FCarParameterArea::DensityForSpawn' has a wrong offset!");
static_assert(offsetof(FCarParameterArea, CarSpeedMin) == 0x000014, "Member 'FCarParameterArea::CarSpeedMin' has a wrong offset!");
static_assert(offsetof(FCarParameterArea, CarSpeedMax) == 0x000018, "Member 'FCarParameterArea::CarSpeedMax' has a wrong offset!");

// ScriptStruct AT.CarParameterGlobal
// 0x00E0 (0x00E8 - 0x0008)
struct FCarParameterGlobal final : public FTableRowBase
{
public:
	float                                         SplineMinimalLengthForSpawn;                       // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarSpawnIntervalBias;                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineInvalidRotationCheckDistance;                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineInvalidRotationCheckAngle;                   // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineMinimalLengthForSplit;                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineSplitUnit;                                   // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineBoundsCheckDistanceInterval;                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineDistancePlayer;                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineDistanceLOD0;                                // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayedDistanceIntervalLOD0;                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineDistanceLOD1;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayedDistanceIntervalLOD1;                     // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SplineDistanceLOD2;                                // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayedDistanceIntervalLOD2;                     // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerDistanceForBlock;                            // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextSplineSearchDepth;                             // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextSplineDensityBias;                             // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerCongestTime;                                 // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CongestLODDistanceBias;                            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShotDetectionDistance;                             // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecretPathActiveInScreenDistance;                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecretPathActiveOutScreenDistance;                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CarGroupName;                                      // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DensityForSpawn;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarSpeedMin;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarSpeedMax;                                       // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarSpeedChangeTime;                                // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarBrakeCurveDistance;                             // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            CarBrakeCurve;                                     // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpCurve;                                         // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JumpRotationCurve;                                 // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShakeCurve;                                        // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            ShakeRotationCurve;                                // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RadiusForShot;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvulnerableTime;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ExplodeCarEffect;                                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCarExplodeCarEffectInfo>       ExplodeCarEffectInfos;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ExplodeCarEffectScale;                             // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrafficLightChangeTime;                            // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrafficLightYellowTime;                            // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CarEngineSoundPoolSize;                            // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarEngineSoundDistMin;                             // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarEngineSoundDistMax;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarKlaxonSoundIntervalMin;                         // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CarKlaxonSoundIntervalMax;                         // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCarParameterGlobal) == 0x000008, "Wrong alignment on FCarParameterGlobal");
static_assert(sizeof(FCarParameterGlobal) == 0x0000E8, "Wrong size on FCarParameterGlobal");
static_assert(offsetof(FCarParameterGlobal, SplineMinimalLengthForSpawn) == 0x000008, "Member 'FCarParameterGlobal::SplineMinimalLengthForSpawn' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarSpawnIntervalBias) == 0x00000C, "Member 'FCarParameterGlobal::CarSpawnIntervalBias' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineInvalidRotationCheckDistance) == 0x000010, "Member 'FCarParameterGlobal::SplineInvalidRotationCheckDistance' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineInvalidRotationCheckAngle) == 0x000014, "Member 'FCarParameterGlobal::SplineInvalidRotationCheckAngle' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineMinimalLengthForSplit) == 0x000018, "Member 'FCarParameterGlobal::SplineMinimalLengthForSplit' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineSplitUnit) == 0x00001C, "Member 'FCarParameterGlobal::SplineSplitUnit' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineBoundsCheckDistanceInterval) == 0x000020, "Member 'FCarParameterGlobal::SplineBoundsCheckDistanceInterval' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineDistancePlayer) == 0x000024, "Member 'FCarParameterGlobal::SplineDistancePlayer' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineDistanceLOD0) == 0x000028, "Member 'FCarParameterGlobal::SplineDistanceLOD0' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, DisplayedDistanceIntervalLOD0) == 0x00002C, "Member 'FCarParameterGlobal::DisplayedDistanceIntervalLOD0' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineDistanceLOD1) == 0x000030, "Member 'FCarParameterGlobal::SplineDistanceLOD1' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, DisplayedDistanceIntervalLOD1) == 0x000034, "Member 'FCarParameterGlobal::DisplayedDistanceIntervalLOD1' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SplineDistanceLOD2) == 0x000038, "Member 'FCarParameterGlobal::SplineDistanceLOD2' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, DisplayedDistanceIntervalLOD2) == 0x00003C, "Member 'FCarParameterGlobal::DisplayedDistanceIntervalLOD2' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, PlayerDistanceForBlock) == 0x000040, "Member 'FCarParameterGlobal::PlayerDistanceForBlock' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, NextSplineSearchDepth) == 0x000044, "Member 'FCarParameterGlobal::NextSplineSearchDepth' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, NextSplineDensityBias) == 0x000048, "Member 'FCarParameterGlobal::NextSplineDensityBias' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, PlayerCongestTime) == 0x00004C, "Member 'FCarParameterGlobal::PlayerCongestTime' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CongestLODDistanceBias) == 0x000050, "Member 'FCarParameterGlobal::CongestLODDistanceBias' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, ShotDetectionDistance) == 0x000054, "Member 'FCarParameterGlobal::ShotDetectionDistance' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SecretPathActiveInScreenDistance) == 0x000058, "Member 'FCarParameterGlobal::SecretPathActiveInScreenDistance' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, SecretPathActiveOutScreenDistance) == 0x00005C, "Member 'FCarParameterGlobal::SecretPathActiveOutScreenDistance' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarGroupName) == 0x000060, "Member 'FCarParameterGlobal::CarGroupName' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, DensityForSpawn) == 0x000068, "Member 'FCarParameterGlobal::DensityForSpawn' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarSpeedMin) == 0x00006C, "Member 'FCarParameterGlobal::CarSpeedMin' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarSpeedMax) == 0x000070, "Member 'FCarParameterGlobal::CarSpeedMax' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarSpeedChangeTime) == 0x000074, "Member 'FCarParameterGlobal::CarSpeedChangeTime' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarBrakeCurveDistance) == 0x000078, "Member 'FCarParameterGlobal::CarBrakeCurveDistance' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarBrakeCurve) == 0x000080, "Member 'FCarParameterGlobal::CarBrakeCurve' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, JumpCurve) == 0x000088, "Member 'FCarParameterGlobal::JumpCurve' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, JumpRotationCurve) == 0x000090, "Member 'FCarParameterGlobal::JumpRotationCurve' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, ShakeCurve) == 0x000098, "Member 'FCarParameterGlobal::ShakeCurve' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, ShakeRotationCurve) == 0x0000A0, "Member 'FCarParameterGlobal::ShakeRotationCurve' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, RadiusForShot) == 0x0000A8, "Member 'FCarParameterGlobal::RadiusForShot' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, InvulnerableTime) == 0x0000AC, "Member 'FCarParameterGlobal::InvulnerableTime' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, ExplodeCarEffect) == 0x0000B0, "Member 'FCarParameterGlobal::ExplodeCarEffect' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, ExplodeCarEffectInfos) == 0x0000B8, "Member 'FCarParameterGlobal::ExplodeCarEffectInfos' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, ExplodeCarEffectScale) == 0x0000C8, "Member 'FCarParameterGlobal::ExplodeCarEffectScale' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, TrafficLightChangeTime) == 0x0000CC, "Member 'FCarParameterGlobal::TrafficLightChangeTime' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, TrafficLightYellowTime) == 0x0000D0, "Member 'FCarParameterGlobal::TrafficLightYellowTime' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarEngineSoundPoolSize) == 0x0000D4, "Member 'FCarParameterGlobal::CarEngineSoundPoolSize' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarEngineSoundDistMin) == 0x0000D8, "Member 'FCarParameterGlobal::CarEngineSoundDistMin' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarEngineSoundDistMax) == 0x0000DC, "Member 'FCarParameterGlobal::CarEngineSoundDistMax' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarKlaxonSoundIntervalMin) == 0x0000E0, "Member 'FCarParameterGlobal::CarKlaxonSoundIntervalMin' has a wrong offset!");
static_assert(offsetof(FCarParameterGlobal, CarKlaxonSoundIntervalMax) == 0x0000E4, "Member 'FCarParameterGlobal::CarKlaxonSoundIntervalMax' has a wrong offset!");

// ScriptStruct AT.NpcVarietyInfo
// 0x002C (0x002C - 0x0000)
struct FNpcVarietyInfo final
{
public:
	float                                         ScaleHigh;                                         // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleLow;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionSpeedHigh;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MotionSpeedLow;                                    // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ValidityFlag_Fly;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FNpcVariety_Fly                        FlyVariety;                                        // 0x0014(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcVarietyInfo) == 0x000004, "Wrong alignment on FNpcVarietyInfo");
static_assert(sizeof(FNpcVarietyInfo) == 0x00002C, "Wrong size on FNpcVarietyInfo");
static_assert(offsetof(FNpcVarietyInfo, ScaleHigh) == 0x000000, "Member 'FNpcVarietyInfo::ScaleHigh' has a wrong offset!");
static_assert(offsetof(FNpcVarietyInfo, ScaleLow) == 0x000004, "Member 'FNpcVarietyInfo::ScaleLow' has a wrong offset!");
static_assert(offsetof(FNpcVarietyInfo, MotionSpeedHigh) == 0x000008, "Member 'FNpcVarietyInfo::MotionSpeedHigh' has a wrong offset!");
static_assert(offsetof(FNpcVarietyInfo, MotionSpeedLow) == 0x00000C, "Member 'FNpcVarietyInfo::MotionSpeedLow' has a wrong offset!");
static_assert(offsetof(FNpcVarietyInfo, ValidityFlag_Fly) == 0x000010, "Member 'FNpcVarietyInfo::ValidityFlag_Fly' has a wrong offset!");
static_assert(offsetof(FNpcVarietyInfo, FlyVariety) == 0x000014, "Member 'FNpcVarietyInfo::FlyVariety' has a wrong offset!");

// ScriptStruct AT.CharacterTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCharacterTableRow final : public FTableRowBase
{
public:
	TSubclassOf<class AAT_Character>              CharacterClass;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterTableRow) == 0x000008, "Wrong alignment on FCharacterTableRow");
static_assert(sizeof(FCharacterTableRow) == 0x000010, "Wrong size on FCharacterTableRow");
static_assert(offsetof(FCharacterTableRow, CharacterClass) == 0x000008, "Member 'FCharacterTableRow::CharacterClass' has a wrong offset!");

// ScriptStruct AT.CharaIconTableRow
// 0x0018 (0x0020 - 0x0008)
struct FCharaIconTableRow final : public FTableRowBase
{
public:
	class FString                                 IconCode;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Gradation;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaIconTableRow) == 0x000008, "Wrong alignment on FCharaIconTableRow");
static_assert(sizeof(FCharaIconTableRow) == 0x000020, "Wrong size on FCharaIconTableRow");
static_assert(offsetof(FCharaIconTableRow, IconCode) == 0x000008, "Member 'FCharaIconTableRow::IconCode' has a wrong offset!");
static_assert(offsetof(FCharaIconTableRow, Gradation) == 0x000018, "Member 'FCharaIconTableRow::Gradation' has a wrong offset!");

// ScriptStruct AT.RaceGameCamera
// 0x0010 (0x0010 - 0x0000)
struct FRaceGameCamera final
{
public:
	class UCurveVector*                           CameraMoveCurve;                                   // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveTime;                                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRelative;                                        // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRaceGameCamera) == 0x000008, "Wrong alignment on FRaceGameCamera");
static_assert(sizeof(FRaceGameCamera) == 0x000010, "Wrong size on FRaceGameCamera");
static_assert(offsetof(FRaceGameCamera, CameraMoveCurve) == 0x000000, "Member 'FRaceGameCamera::CameraMoveCurve' has a wrong offset!");
static_assert(offsetof(FRaceGameCamera, MoveTime) == 0x000008, "Member 'FRaceGameCamera::MoveTime' has a wrong offset!");
static_assert(offsetof(FRaceGameCamera, IsRelative) == 0x00000C, "Member 'FRaceGameCamera::IsRelative' has a wrong offset!");

// ScriptStruct AT.CollectionRewardNotice
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCollectionRewardNotice final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionRewardNotice) == 0x000008, "Wrong alignment on FCollectionRewardNotice");
static_assert(sizeof(FCollectionRewardNotice) == 0x000010, "Wrong size on FCollectionRewardNotice");

// ScriptStruct AT.CollectionInfomation
// 0x0038 (0x0038 - 0x0000)
struct alignas(0x08) FCollectionInfomation final
{
public:
	uint8                                         Pad_0[0x38];                                       // 0x0000(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionInfomation) == 0x000008, "Wrong alignment on FCollectionInfomation");
static_assert(sizeof(FCollectionInfomation) == 0x000038, "Wrong size on FCollectionInfomation");

// ScriptStruct AT.CollectionBgmIDTable
// 0x0008 (0x0010 - 0x0008)
struct FCollectionBgmIDTable final : public FTableRowBase
{
public:
	EBgmCode                                      ID;                                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionBgmIDTable) == 0x000008, "Wrong alignment on FCollectionBgmIDTable");
static_assert(sizeof(FCollectionBgmIDTable) == 0x000010, "Wrong size on FCollectionBgmIDTable");
static_assert(offsetof(FCollectionBgmIDTable, ID) == 0x000008, "Member 'FCollectionBgmIDTable::ID' has a wrong offset!");

// ScriptStruct AT.CollectionFishIDTable
// 0x0008 (0x0010 - 0x0008)
struct FCollectionFishIDTable final : public FTableRowBase
{
public:
	EFishID                                       ID;                                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionFishIDTable) == 0x000008, "Wrong alignment on FCollectionFishIDTable");
static_assert(sizeof(FCollectionFishIDTable) == 0x000010, "Wrong size on FCollectionFishIDTable");
static_assert(offsetof(FCollectionFishIDTable, ID) == 0x000008, "Member 'FCollectionFishIDTable::ID' has a wrong offset!");

// ScriptStruct AT.CollectionAnimalIDTable
// 0x0008 (0x0010 - 0x0008)
struct FCollectionAnimalIDTable final : public FTableRowBase
{
public:
	EAnimalID                                     ID;                                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCollectionAnimalIDTable) == 0x000008, "Wrong alignment on FCollectionAnimalIDTable");
static_assert(sizeof(FCollectionAnimalIDTable) == 0x000010, "Wrong size on FCollectionAnimalIDTable");
static_assert(offsetof(FCollectionAnimalIDTable, ID) == 0x000008, "Member 'FCollectionAnimalIDTable::ID' has a wrong offset!");

// ScriptStruct AT.NpcTickLODInfo
// 0x001C (0x001C - 0x0000)
struct FNpcTickLODInfo final
{
public:
	float                                         Distance_LOD0;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD1;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance_LOD2;                                     // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD0;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD1;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD2;                                     // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Interval_LOD3;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcTickLODInfo) == 0x000004, "Wrong alignment on FNpcTickLODInfo");
static_assert(sizeof(FNpcTickLODInfo) == 0x00001C, "Wrong size on FNpcTickLODInfo");
static_assert(offsetof(FNpcTickLODInfo, Distance_LOD0) == 0x000000, "Member 'FNpcTickLODInfo::Distance_LOD0' has a wrong offset!");
static_assert(offsetof(FNpcTickLODInfo, Distance_LOD1) == 0x000004, "Member 'FNpcTickLODInfo::Distance_LOD1' has a wrong offset!");
static_assert(offsetof(FNpcTickLODInfo, Distance_LOD2) == 0x000008, "Member 'FNpcTickLODInfo::Distance_LOD2' has a wrong offset!");
static_assert(offsetof(FNpcTickLODInfo, Interval_LOD0) == 0x00000C, "Member 'FNpcTickLODInfo::Interval_LOD0' has a wrong offset!");
static_assert(offsetof(FNpcTickLODInfo, Interval_LOD1) == 0x000010, "Member 'FNpcTickLODInfo::Interval_LOD1' has a wrong offset!");
static_assert(offsetof(FNpcTickLODInfo, Interval_LOD2) == 0x000014, "Member 'FNpcTickLODInfo::Interval_LOD2' has a wrong offset!");
static_assert(offsetof(FNpcTickLODInfo, Interval_LOD3) == 0x000018, "Member 'FNpcTickLODInfo::Interval_LOD3' has a wrong offset!");

// ScriptStruct AT.CollectionCharaTypeTable
// 0x0018 (0x0020 - 0x0008)
struct FCollectionCharaTypeTable final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               ID;                                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TextID;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionCharaTypeTable) == 0x000008, "Wrong alignment on FCollectionCharaTypeTable");
static_assert(sizeof(FCollectionCharaTypeTable) == 0x000020, "Wrong size on FCollectionCharaTypeTable");
static_assert(offsetof(FCollectionCharaTypeTable, ID) == 0x000008, "Member 'FCollectionCharaTypeTable::ID' has a wrong offset!");
static_assert(offsetof(FCollectionCharaTypeTable, TextID) == 0x000010, "Member 'FCollectionCharaTypeTable::TextID' has a wrong offset!");

// ScriptStruct AT.QuestParam
// 0x00B8 (0x00C0 - 0x0008)
struct FQuestParam final : public FTableRowBase
{
public:
	EEpisodeId                                    Chapter_id;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Episode_num;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Quest_id;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_GENRE_TYPE                             Quest_genre;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Event_subquest;                                    // 0x0019(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Recommended_level;                                 // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Quest_title;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOMMUNITY_CATEGORY                           Community_quest_type;                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Summary;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Client_name;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Require_character;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECHARACTER_TYPE>                       Need_character;                                    // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<ECHARACTER_TYPE>                       Need_character_progress;                           // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Sublv_name1;                                       // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Sublv_name2;                                       // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Sublv_name3;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Progress_id;                                       // 0x0098(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Reward_id;                                         // 0x00A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_result;                                     // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enable_achievement;                                // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Require_dlc_id;                                    // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDLC_QUEST_TYPE                               Dlc_quest_type;                                    // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Has_retry_condition;                               // 0x00B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BA[0x6];                                       // 0x00BA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestParam) == 0x000008, "Wrong alignment on FQuestParam");
static_assert(sizeof(FQuestParam) == 0x0000C0, "Wrong size on FQuestParam");
static_assert(offsetof(FQuestParam, Chapter_id) == 0x000008, "Member 'FQuestParam::Chapter_id' has a wrong offset!");
static_assert(offsetof(FQuestParam, Episode_num) == 0x00000C, "Member 'FQuestParam::Episode_num' has a wrong offset!");
static_assert(offsetof(FQuestParam, Quest_id) == 0x000010, "Member 'FQuestParam::Quest_id' has a wrong offset!");
static_assert(offsetof(FQuestParam, Quest_genre) == 0x000018, "Member 'FQuestParam::Quest_genre' has a wrong offset!");
static_assert(offsetof(FQuestParam, Event_subquest) == 0x000019, "Member 'FQuestParam::Event_subquest' has a wrong offset!");
static_assert(offsetof(FQuestParam, Recommended_level) == 0x00001C, "Member 'FQuestParam::Recommended_level' has a wrong offset!");
static_assert(offsetof(FQuestParam, Quest_title) == 0x000020, "Member 'FQuestParam::Quest_title' has a wrong offset!");
static_assert(offsetof(FQuestParam, Community_quest_type) == 0x000030, "Member 'FQuestParam::Community_quest_type' has a wrong offset!");
static_assert(offsetof(FQuestParam, Summary) == 0x000038, "Member 'FQuestParam::Summary' has a wrong offset!");
static_assert(offsetof(FQuestParam, Client_name) == 0x000048, "Member 'FQuestParam::Client_name' has a wrong offset!");
static_assert(offsetof(FQuestParam, Require_character) == 0x000058, "Member 'FQuestParam::Require_character' has a wrong offset!");
static_assert(offsetof(FQuestParam, Need_character) == 0x000060, "Member 'FQuestParam::Need_character' has a wrong offset!");
static_assert(offsetof(FQuestParam, Need_character_progress) == 0x000070, "Member 'FQuestParam::Need_character_progress' has a wrong offset!");
static_assert(offsetof(FQuestParam, Sublv_name1) == 0x000080, "Member 'FQuestParam::Sublv_name1' has a wrong offset!");
static_assert(offsetof(FQuestParam, Sublv_name2) == 0x000088, "Member 'FQuestParam::Sublv_name2' has a wrong offset!");
static_assert(offsetof(FQuestParam, Sublv_name3) == 0x000090, "Member 'FQuestParam::Sublv_name3' has a wrong offset!");
static_assert(offsetof(FQuestParam, Progress_id) == 0x000098, "Member 'FQuestParam::Progress_id' has a wrong offset!");
static_assert(offsetof(FQuestParam, Reward_id) == 0x0000A0, "Member 'FQuestParam::Reward_id' has a wrong offset!");
static_assert(offsetof(FQuestParam, Enable_result) == 0x0000A8, "Member 'FQuestParam::Enable_result' has a wrong offset!");
static_assert(offsetof(FQuestParam, Enable_achievement) == 0x0000A9, "Member 'FQuestParam::Enable_achievement' has a wrong offset!");
static_assert(offsetof(FQuestParam, Require_dlc_id) == 0x0000B0, "Member 'FQuestParam::Require_dlc_id' has a wrong offset!");
static_assert(offsetof(FQuestParam, Dlc_quest_type) == 0x0000B8, "Member 'FQuestParam::Dlc_quest_type' has a wrong offset!");
static_assert(offsetof(FQuestParam, Has_retry_condition) == 0x0000B9, "Member 'FQuestParam::Has_retry_condition' has a wrong offset!");

// ScriptStruct AT.CollectionOpenFlag
// 0x0002 (0x0002 - 0x0000)
struct FCollectionOpenFlag final
{
public:
	uint16                                        Flag;                                              // 0x0000(0x0002)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCollectionOpenFlag) == 0x000002, "Wrong alignment on FCollectionOpenFlag");
static_assert(sizeof(FCollectionOpenFlag) == 0x000002, "Wrong size on FCollectionOpenFlag");
static_assert(offsetof(FCollectionOpenFlag, Flag) == 0x000000, "Member 'FCollectionOpenFlag::Flag' has a wrong offset!");

// ScriptStruct AT.FullCourceItemParam
// 0x0078 (0x0080 - 0x0008)
struct FFullCourceItemParam final : public FTableRowBase
{
public:
	class FName                                   Main;                                              // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainGrab;                                          // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MainGrabSaiya;                                     // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainGrabScale;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MainFree;                                          // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Sub;                                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubGrab;                                           // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SubGrabSaiya;                                      // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SubGrabScale;                                      // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SubFree;                                           // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Leftover;                                          // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Attachment;                                        // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachmentSaiya;                                   // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LastDish;                                          // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IgnoreFreeSocket;                                  // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFullCourceItemParam) == 0x000008, "Wrong alignment on FFullCourceItemParam");
static_assert(sizeof(FFullCourceItemParam) == 0x000080, "Wrong size on FFullCourceItemParam");
static_assert(offsetof(FFullCourceItemParam, Main) == 0x000008, "Member 'FFullCourceItemParam::Main' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, MainGrab) == 0x000010, "Member 'FFullCourceItemParam::MainGrab' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, MainGrabSaiya) == 0x000018, "Member 'FFullCourceItemParam::MainGrabSaiya' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, MainGrabScale) == 0x000020, "Member 'FFullCourceItemParam::MainGrabScale' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, MainFree) == 0x000028, "Member 'FFullCourceItemParam::MainFree' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, Sub) == 0x000030, "Member 'FFullCourceItemParam::Sub' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, SubGrab) == 0x000038, "Member 'FFullCourceItemParam::SubGrab' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, SubGrabSaiya) == 0x000040, "Member 'FFullCourceItemParam::SubGrabSaiya' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, SubGrabScale) == 0x000048, "Member 'FFullCourceItemParam::SubGrabScale' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, SubFree) == 0x000050, "Member 'FFullCourceItemParam::SubFree' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, Leftover) == 0x000058, "Member 'FFullCourceItemParam::Leftover' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, Attachment) == 0x000060, "Member 'FFullCourceItemParam::Attachment' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, AttachmentSaiya) == 0x000068, "Member 'FFullCourceItemParam::AttachmentSaiya' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, LastDish) == 0x000070, "Member 'FFullCourceItemParam::LastDish' has a wrong offset!");
static_assert(offsetof(FFullCourceItemParam, IgnoreFreeSocket) == 0x000078, "Member 'FFullCourceItemParam::IgnoreFreeSocket' has a wrong offset!");

// ScriptStruct AT.MealTimeSideCharacterParameter
// 0x0020 (0x0028 - 0x0008)
struct FMealTimeSideCharacterParameter final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UATCharacterAnimInstance>   AnimInstance;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForcedPlacement;                                // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MeshOffset;                                        // 0x001C(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMealTimeSideCharacterParameter) == 0x000008, "Wrong alignment on FMealTimeSideCharacterParameter");
static_assert(sizeof(FMealTimeSideCharacterParameter) == 0x000028, "Wrong size on FMealTimeSideCharacterParameter");
static_assert(offsetof(FMealTimeSideCharacterParameter, CharacterType) == 0x000008, "Member 'FMealTimeSideCharacterParameter::CharacterType' has a wrong offset!");
static_assert(offsetof(FMealTimeSideCharacterParameter, AnimInstance) == 0x000010, "Member 'FMealTimeSideCharacterParameter::AnimInstance' has a wrong offset!");
static_assert(offsetof(FMealTimeSideCharacterParameter, bIsForcedPlacement) == 0x000018, "Member 'FMealTimeSideCharacterParameter::bIsForcedPlacement' has a wrong offset!");
static_assert(offsetof(FMealTimeSideCharacterParameter, MeshOffset) == 0x00001C, "Member 'FMealTimeSideCharacterParameter::MeshOffset' has a wrong offset!");

// ScriptStruct AT.BreakableObjectReactionVoiceParam
// 0x0010 (0x0018 - 0x0008)
struct FBreakableObjectReactionVoiceParam final : public FTableRowBase
{
public:
	class FName                                   SuccessVoiceID;                                    // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailureVoiceID;                                    // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBreakableObjectReactionVoiceParam) == 0x000008, "Wrong alignment on FBreakableObjectReactionVoiceParam");
static_assert(sizeof(FBreakableObjectReactionVoiceParam) == 0x000018, "Wrong size on FBreakableObjectReactionVoiceParam");
static_assert(offsetof(FBreakableObjectReactionVoiceParam, SuccessVoiceID) == 0x000008, "Member 'FBreakableObjectReactionVoiceParam::SuccessVoiceID' has a wrong offset!");
static_assert(offsetof(FBreakableObjectReactionVoiceParam, FailureVoiceID) == 0x000010, "Member 'FBreakableObjectReactionVoiceParam::FailureVoiceID' has a wrong offset!");

// ScriptStruct AT.HiddenActorWhenCookingParameter
// 0x0050 (0x0058 - 0x0008)
struct FHiddenActorWhenCookingParameter final : public FTableRowBase
{
public:
	TMap<class FName, struct FHiddenTarget>       HiddenTargets;                                     // 0x0008(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHiddenActorWhenCookingParameter) == 0x000008, "Wrong alignment on FHiddenActorWhenCookingParameter");
static_assert(sizeof(FHiddenActorWhenCookingParameter) == 0x000058, "Wrong size on FHiddenActorWhenCookingParameter");
static_assert(offsetof(FHiddenActorWhenCookingParameter, HiddenTargets) == 0x000008, "Member 'FHiddenActorWhenCookingParameter::HiddenTargets' has a wrong offset!");

// ScriptStruct AT.CookingConstParam
// 0x0020 (0x0028 - 0x0008)
struct FCookingConstParam final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainX;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MainY;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sub1X;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sub1Y;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sub2X;                                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Sub2Y;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCookingConstParam) == 0x000008, "Wrong alignment on FCookingConstParam");
static_assert(sizeof(FCookingConstParam) == 0x000028, "Wrong size on FCookingConstParam");
static_assert(offsetof(FCookingConstParam, Value) == 0x000008, "Member 'FCookingConstParam::Value' has a wrong offset!");
static_assert(offsetof(FCookingConstParam, MainX) == 0x00000C, "Member 'FCookingConstParam::MainX' has a wrong offset!");
static_assert(offsetof(FCookingConstParam, MainY) == 0x000010, "Member 'FCookingConstParam::MainY' has a wrong offset!");
static_assert(offsetof(FCookingConstParam, Sub1X) == 0x000014, "Member 'FCookingConstParam::Sub1X' has a wrong offset!");
static_assert(offsetof(FCookingConstParam, Sub1Y) == 0x000018, "Member 'FCookingConstParam::Sub1Y' has a wrong offset!");
static_assert(offsetof(FCookingConstParam, Sub2X) == 0x00001C, "Member 'FCookingConstParam::Sub2X' has a wrong offset!");
static_assert(offsetof(FCookingConstParam, Sub2Y) == 0x000020, "Member 'FCookingConstParam::Sub2Y' has a wrong offset!");

// ScriptStruct AT.CourseEatUpStatus
// 0x0028 (0x0030 - 0x0008)
struct FCourseEatUpStatus final : public FTableRowBase
{
public:
	float                                         HP;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Energy;                                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ATK;                                               // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DEF;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AGL;                                               // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SPD;                                               // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BREAK;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BREAK_ATK;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BREAK_DEF;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCourseEatUpStatus) == 0x000008, "Wrong alignment on FCourseEatUpStatus");
static_assert(sizeof(FCourseEatUpStatus) == 0x000030, "Wrong size on FCourseEatUpStatus");
static_assert(offsetof(FCourseEatUpStatus, HP) == 0x000008, "Member 'FCourseEatUpStatus::HP' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, Energy) == 0x00000C, "Member 'FCourseEatUpStatus::Energy' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, ATK) == 0x000010, "Member 'FCourseEatUpStatus::ATK' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, DEF) == 0x000014, "Member 'FCourseEatUpStatus::DEF' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, AGL) == 0x000018, "Member 'FCourseEatUpStatus::AGL' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, SPD) == 0x00001C, "Member 'FCourseEatUpStatus::SPD' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, BREAK) == 0x000020, "Member 'FCourseEatUpStatus::BREAK' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, BREAK_ATK) == 0x000024, "Member 'FCourseEatUpStatus::BREAK_ATK' has a wrong offset!");
static_assert(offsetof(FCourseEatUpStatus, BREAK_DEF) == 0x000028, "Member 'FCourseEatUpStatus::BREAK_DEF' has a wrong offset!");

// ScriptStruct AT.SkillSparkingVariationInfo
// 0x0004 (0x0004 - 0x0000)
struct FSkillSparkingVariationInfo final
{
public:
	uint8                                         Normal[0x2];                                       // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Sparking[0x2];                                     // 0x0002(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillSparkingVariationInfo) == 0x000001, "Wrong alignment on FSkillSparkingVariationInfo");
static_assert(sizeof(FSkillSparkingVariationInfo) == 0x000004, "Wrong size on FSkillSparkingVariationInfo");
static_assert(offsetof(FSkillSparkingVariationInfo, Normal) == 0x000000, "Member 'FSkillSparkingVariationInfo::Normal' has a wrong offset!");
static_assert(offsetof(FSkillSparkingVariationInfo, Sparking) == 0x000002, "Member 'FSkillSparkingVariationInfo::Sparking' has a wrong offset!");

// ScriptStruct AT.SkillSparkingDataTable
// 0x0078 (0x0080 - 0x0008)
struct FSkillSparkingDataTable final : public FTableRowBase
{
public:
	class FString                                 Discription;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AutoActivatePriority;                              // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFormChangeEndCondition                       EndCondition;                                      // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveBuffLv1[0x2];                                // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveBuffLv2[0x2];                                // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActiveBuffLv3[0x2];                                // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSkillSparkingVariationInfo>    Variation;                                         // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	ESndCodeBattle                                OffSeID;                                           // 0x0060(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AddBuffLv1;                                        // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AddBuffLv2;                                        // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AddBuffLv3;                                        // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillSparkingDataTable) == 0x000008, "Wrong alignment on FSkillSparkingDataTable");
static_assert(sizeof(FSkillSparkingDataTable) == 0x000080, "Wrong size on FSkillSparkingDataTable");
static_assert(offsetof(FSkillSparkingDataTable, Discription) == 0x000008, "Member 'FSkillSparkingDataTable::Discription' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, AutoActivatePriority) == 0x000018, "Member 'FSkillSparkingDataTable::AutoActivatePriority' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, EndCondition) == 0x00001C, "Member 'FSkillSparkingDataTable::EndCondition' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, ActiveBuffLv1) == 0x000020, "Member 'FSkillSparkingDataTable::ActiveBuffLv1' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, ActiveBuffLv2) == 0x000030, "Member 'FSkillSparkingDataTable::ActiveBuffLv2' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, ActiveBuffLv3) == 0x000040, "Member 'FSkillSparkingDataTable::ActiveBuffLv3' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, Variation) == 0x000050, "Member 'FSkillSparkingDataTable::Variation' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, OffSeID) == 0x000060, "Member 'FSkillSparkingDataTable::OffSeID' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, AddBuffLv1) == 0x000068, "Member 'FSkillSparkingDataTable::AddBuffLv1' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, AddBuffLv2) == 0x000070, "Member 'FSkillSparkingDataTable::AddBuffLv2' has a wrong offset!");
static_assert(offsetof(FSkillSparkingDataTable, AddBuffLv3) == 0x000078, "Member 'FSkillSparkingDataTable::AddBuffLv3' has a wrong offset!");

// ScriptStruct AT.CookingFoodInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FCookingFoodInfo final
{
public:
	class FName                                   ID;                                                // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Num;                                               // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCookingFoodInfo) == 0x000008, "Wrong alignment on FCookingFoodInfo");
static_assert(sizeof(FCookingFoodInfo) == 0x000010, "Wrong size on FCookingFoodInfo");
static_assert(offsetof(FCookingFoodInfo, ID) == 0x000000, "Member 'FCookingFoodInfo::ID' has a wrong offset!");
static_assert(offsetof(FCookingFoodInfo, Num) == 0x000008, "Member 'FCookingFoodInfo::Num' has a wrong offset!");

// ScriptStruct AT.QuestDemoParam
// 0x0040 (0x0048 - 0x0008)
struct FQuestDemoParam final : public FTableRowBase
{
public:
	EQUEST_XO                                     bEnable;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDEMO_TYPE                                    Demo_type;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Demo_name;                                         // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     Check_play_player;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Check_play_player_ctype;                           // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Fade_delay_time;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fade_time;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fade_wait_time;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFADE_COLOR                                   Color;                                             // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Not_fadein_in_demoskip;                            // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDemoBGMSeamlessType                          BGMSeamlessType;                                   // 0x003A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Phase_replay_fadein;                               // 0x003B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Phase_replay_delay_fadein;                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Check_loaded_resources;                            // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestDemoParam) == 0x000008, "Wrong alignment on FQuestDemoParam");
static_assert(sizeof(FQuestDemoParam) == 0x000048, "Wrong size on FQuestDemoParam");
static_assert(offsetof(FQuestDemoParam, bEnable) == 0x000008, "Member 'FQuestDemoParam::bEnable' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, ID) == 0x000010, "Member 'FQuestDemoParam::ID' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Demo_type) == 0x000018, "Member 'FQuestDemoParam::Demo_type' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Demo_name) == 0x000020, "Member 'FQuestDemoParam::Demo_name' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Check_play_player) == 0x000028, "Member 'FQuestDemoParam::Check_play_player' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Check_play_player_ctype) == 0x000029, "Member 'FQuestDemoParam::Check_play_player_ctype' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Fade_delay_time) == 0x00002C, "Member 'FQuestDemoParam::Fade_delay_time' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Fade_time) == 0x000030, "Member 'FQuestDemoParam::Fade_time' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Fade_wait_time) == 0x000034, "Member 'FQuestDemoParam::Fade_wait_time' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Color) == 0x000038, "Member 'FQuestDemoParam::Color' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Not_fadein_in_demoskip) == 0x000039, "Member 'FQuestDemoParam::Not_fadein_in_demoskip' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, BGMSeamlessType) == 0x00003A, "Member 'FQuestDemoParam::BGMSeamlessType' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Phase_replay_fadein) == 0x00003B, "Member 'FQuestDemoParam::Phase_replay_fadein' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Phase_replay_delay_fadein) == 0x00003C, "Member 'FQuestDemoParam::Phase_replay_delay_fadein' has a wrong offset!");
static_assert(offsetof(FQuestDemoParam, Check_loaded_resources) == 0x000040, "Member 'FQuestDemoParam::Check_loaded_resources' has a wrong offset!");

// ScriptStruct AT.CookingDecideInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCookingDecideInfo final
{
public:
	class FName                                   CookingRecipe;                                     // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BentoItemId;                                       // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlusBentoNum;                                      // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Grade;                                             // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CookRank;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOKING_FORMAT                               Format;                                            // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCookingDecideInfo) == 0x000008, "Wrong alignment on FCookingDecideInfo");
static_assert(sizeof(FCookingDecideInfo) == 0x000020, "Wrong size on FCookingDecideInfo");
static_assert(offsetof(FCookingDecideInfo, CookingRecipe) == 0x000000, "Member 'FCookingDecideInfo::CookingRecipe' has a wrong offset!");
static_assert(offsetof(FCookingDecideInfo, BentoItemId) == 0x000008, "Member 'FCookingDecideInfo::BentoItemId' has a wrong offset!");
static_assert(offsetof(FCookingDecideInfo, PlusBentoNum) == 0x000010, "Member 'FCookingDecideInfo::PlusBentoNum' has a wrong offset!");
static_assert(offsetof(FCookingDecideInfo, Grade) == 0x000014, "Member 'FCookingDecideInfo::Grade' has a wrong offset!");
static_assert(offsetof(FCookingDecideInfo, CookRank) == 0x000018, "Member 'FCookingDecideInfo::CookRank' has a wrong offset!");
static_assert(offsetof(FCookingDecideInfo, Format) == 0x00001C, "Member 'FCookingDecideInfo::Format' has a wrong offset!");

// ScriptStruct AT.SuccessProbabilityParam
// 0x0010 (0x0018 - 0x0008)
struct FSuccessProbabilityParam final : public FTableRowBase
{
public:
	int32                                         Base;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncPerPlus;                                        // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPer;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSuccessProbabilityParam) == 0x000008, "Wrong alignment on FSuccessProbabilityParam");
static_assert(sizeof(FSuccessProbabilityParam) == 0x000018, "Wrong size on FSuccessProbabilityParam");
static_assert(offsetof(FSuccessProbabilityParam, Base) == 0x000008, "Member 'FSuccessProbabilityParam::Base' has a wrong offset!");
static_assert(offsetof(FSuccessProbabilityParam, IncPerPlus) == 0x00000C, "Member 'FSuccessProbabilityParam::IncPerPlus' has a wrong offset!");
static_assert(offsetof(FSuccessProbabilityParam, MaxPer) == 0x000010, "Member 'FSuccessProbabilityParam::MaxPer' has a wrong offset!");

// ScriptStruct AT.RecipeParam
// 0x00D0 (0x00D8 - 0x0008)
struct FRecipeParam final : public FTableRowBase
{
public:
	class FName                                   JName;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DescId;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BentoItemId;                                       // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOKING_GENRE                                Genre;                                             // 0x002C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOKING_FORMAT                               Format;                                            // 0x002D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECOOKING_CONDITION                            Condition;                                         // 0x002E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F[0x1];                                       // 0x002F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ComuRnk;                                           // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   NormalBuffID;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SuperBuffID;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstBonusBuffID;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FoodID01;                                          // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Food01;                                            // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FoodID02;                                          // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Food02;                                            // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FoodID03;                                          // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Food03;                                            // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FoodID04;                                          // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Food04;                                            // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FoodID05;                                          // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Food05;                                            // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BentoItemID01;                                     // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BentoItemID02;                                     // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BentoItemID03;                                     // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BentoItemID04;                                     // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BentoItemID05;                                     // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextureName;                                       // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDLC3ShowOnly;                                     // 0x00D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDLC3Disable;                                      // 0x00D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2[0x6];                                       // 0x00D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRecipeParam) == 0x000008, "Wrong alignment on FRecipeParam");
static_assert(sizeof(FRecipeParam) == 0x0000D8, "Wrong size on FRecipeParam");
static_assert(offsetof(FRecipeParam, JName) == 0x000008, "Member 'FRecipeParam::JName' has a wrong offset!");
static_assert(offsetof(FRecipeParam, NameId) == 0x000010, "Member 'FRecipeParam::NameId' has a wrong offset!");
static_assert(offsetof(FRecipeParam, DescId) == 0x000018, "Member 'FRecipeParam::DescId' has a wrong offset!");
static_assert(offsetof(FRecipeParam, BentoItemId) == 0x000020, "Member 'FRecipeParam::BentoItemId' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Rarity) == 0x000028, "Member 'FRecipeParam::Rarity' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Genre) == 0x00002C, "Member 'FRecipeParam::Genre' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Format) == 0x00002D, "Member 'FRecipeParam::Format' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Condition) == 0x00002E, "Member 'FRecipeParam::Condition' has a wrong offset!");
static_assert(offsetof(FRecipeParam, ComuRnk) == 0x000030, "Member 'FRecipeParam::ComuRnk' has a wrong offset!");
static_assert(offsetof(FRecipeParam, NormalBuffID) == 0x000038, "Member 'FRecipeParam::NormalBuffID' has a wrong offset!");
static_assert(offsetof(FRecipeParam, SuperBuffID) == 0x000040, "Member 'FRecipeParam::SuperBuffID' has a wrong offset!");
static_assert(offsetof(FRecipeParam, FirstBonusBuffID) == 0x000048, "Member 'FRecipeParam::FirstBonusBuffID' has a wrong offset!");
static_assert(offsetof(FRecipeParam, FoodID01) == 0x000050, "Member 'FRecipeParam::FoodID01' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Food01) == 0x000058, "Member 'FRecipeParam::Food01' has a wrong offset!");
static_assert(offsetof(FRecipeParam, FoodID02) == 0x000060, "Member 'FRecipeParam::FoodID02' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Food02) == 0x000068, "Member 'FRecipeParam::Food02' has a wrong offset!");
static_assert(offsetof(FRecipeParam, FoodID03) == 0x000070, "Member 'FRecipeParam::FoodID03' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Food03) == 0x000078, "Member 'FRecipeParam::Food03' has a wrong offset!");
static_assert(offsetof(FRecipeParam, FoodID04) == 0x000080, "Member 'FRecipeParam::FoodID04' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Food04) == 0x000088, "Member 'FRecipeParam::Food04' has a wrong offset!");
static_assert(offsetof(FRecipeParam, FoodID05) == 0x000090, "Member 'FRecipeParam::FoodID05' has a wrong offset!");
static_assert(offsetof(FRecipeParam, Food05) == 0x000098, "Member 'FRecipeParam::Food05' has a wrong offset!");
static_assert(offsetof(FRecipeParam, BentoItemID01) == 0x0000A0, "Member 'FRecipeParam::BentoItemID01' has a wrong offset!");
static_assert(offsetof(FRecipeParam, BentoItemID02) == 0x0000A8, "Member 'FRecipeParam::BentoItemID02' has a wrong offset!");
static_assert(offsetof(FRecipeParam, BentoItemID03) == 0x0000B0, "Member 'FRecipeParam::BentoItemID03' has a wrong offset!");
static_assert(offsetof(FRecipeParam, BentoItemID04) == 0x0000B8, "Member 'FRecipeParam::BentoItemID04' has a wrong offset!");
static_assert(offsetof(FRecipeParam, BentoItemID05) == 0x0000C0, "Member 'FRecipeParam::BentoItemID05' has a wrong offset!");
static_assert(offsetof(FRecipeParam, TextureName) == 0x0000C8, "Member 'FRecipeParam::TextureName' has a wrong offset!");
static_assert(offsetof(FRecipeParam, bDLC3ShowOnly) == 0x0000D0, "Member 'FRecipeParam::bDLC3ShowOnly' has a wrong offset!");
static_assert(offsetof(FRecipeParam, bDLC3Disable) == 0x0000D1, "Member 'FRecipeParam::bDLC3Disable' has a wrong offset!");

// ScriptStruct AT.EnabledCrossTalkCondition
// 0x0010 (0x0018 - 0x0008)
struct FEnabledCrossTalkCondition final : public FTableRowBase
{
public:
	TArray<class FName>                           EnabledCrossTalkAssets;                            // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnabledCrossTalkCondition) == 0x000008, "Wrong alignment on FEnabledCrossTalkCondition");
static_assert(sizeof(FEnabledCrossTalkCondition) == 0x000018, "Wrong size on FEnabledCrossTalkCondition");
static_assert(offsetof(FEnabledCrossTalkCondition, EnabledCrossTalkAssets) == 0x000008, "Member 'FEnabledCrossTalkCondition::EnabledCrossTalkAssets' has a wrong offset!");

// ScriptStruct AT.IgnoreCrossTalkCompanionPoint
// 0x0010 (0x0018 - 0x0008)
struct FIgnoreCrossTalkCompanionPoint final : public FTableRowBase
{
public:
	TArray<class FName>                           IdentifierList;                                    // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FIgnoreCrossTalkCompanionPoint) == 0x000008, "Wrong alignment on FIgnoreCrossTalkCompanionPoint");
static_assert(sizeof(FIgnoreCrossTalkCompanionPoint) == 0x000018, "Wrong size on FIgnoreCrossTalkCompanionPoint");
static_assert(offsetof(FIgnoreCrossTalkCompanionPoint, IdentifierList) == 0x000008, "Member 'FIgnoreCrossTalkCompanionPoint::IdentifierList' has a wrong offset!");

// ScriptStruct AT.CrossTalkTableRow
// 0x0088 (0x0090 - 0x0008)
struct FCrossTalkTableRow final : public FTableRowBase
{
public:
	class FName                                   Identifier;                                        // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SaveId;                                            // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkBattleType                          BattleType;                                        // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventBattleID;                                     // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkSideCategory                        SideCategory;                                      // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkPlayerState                         PlayerState;                                       // 0x0029(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MessageId;                                         // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               PartnerCharacter;                                  // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkSideCategory                        PartnerSideCategory;                               // 0x0039(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkPriority                            Priority;                                          // 0x003A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Delay;                                             // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkCondition                           Condition;                                         // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IntProperty;                                       // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StringProperty;                                    // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               TargetCharacter;                                   // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkSideCategory                        TargetSideCategory;                                // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Request;                                           // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AlreadyTalk;                                       // 0x0068(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestPhaseBegin;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestPhaseEnd;                                     // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkInequalitySign                      InequalitySign;                                    // 0x0080(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECrossTalkInequalitySign                      InequalitySign_Section;                            // 0x0081(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x2];                                       // 0x0082(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InequalitySign_SectionValue;                       // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AnnounserPriority;                                 // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Probability;                                       // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCrossTalkTableRow) == 0x000008, "Wrong alignment on FCrossTalkTableRow");
static_assert(sizeof(FCrossTalkTableRow) == 0x000090, "Wrong size on FCrossTalkTableRow");
static_assert(offsetof(FCrossTalkTableRow, Identifier) == 0x000008, "Member 'FCrossTalkTableRow::Identifier' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, SaveId) == 0x000010, "Member 'FCrossTalkTableRow::SaveId' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, BattleType) == 0x000018, "Member 'FCrossTalkTableRow::BattleType' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, EventBattleID) == 0x000020, "Member 'FCrossTalkTableRow::EventBattleID' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, SideCategory) == 0x000028, "Member 'FCrossTalkTableRow::SideCategory' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, PlayerState) == 0x000029, "Member 'FCrossTalkTableRow::PlayerState' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, MessageId) == 0x000030, "Member 'FCrossTalkTableRow::MessageId' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, PartnerCharacter) == 0x000038, "Member 'FCrossTalkTableRow::PartnerCharacter' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, PartnerSideCategory) == 0x000039, "Member 'FCrossTalkTableRow::PartnerSideCategory' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, Priority) == 0x00003A, "Member 'FCrossTalkTableRow::Priority' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, Delay) == 0x000040, "Member 'FCrossTalkTableRow::Delay' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, Condition) == 0x000048, "Member 'FCrossTalkTableRow::Condition' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, IntProperty) == 0x00004C, "Member 'FCrossTalkTableRow::IntProperty' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, StringProperty) == 0x000050, "Member 'FCrossTalkTableRow::StringProperty' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, TargetCharacter) == 0x000058, "Member 'FCrossTalkTableRow::TargetCharacter' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, TargetSideCategory) == 0x000059, "Member 'FCrossTalkTableRow::TargetSideCategory' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, Request) == 0x000060, "Member 'FCrossTalkTableRow::Request' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, AlreadyTalk) == 0x000068, "Member 'FCrossTalkTableRow::AlreadyTalk' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, QuestPhaseBegin) == 0x000070, "Member 'FCrossTalkTableRow::QuestPhaseBegin' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, QuestPhaseEnd) == 0x000078, "Member 'FCrossTalkTableRow::QuestPhaseEnd' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, InequalitySign) == 0x000080, "Member 'FCrossTalkTableRow::InequalitySign' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, InequalitySign_Section) == 0x000081, "Member 'FCrossTalkTableRow::InequalitySign_Section' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, InequalitySign_SectionValue) == 0x000084, "Member 'FCrossTalkTableRow::InequalitySign_SectionValue' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, AnnounserPriority) == 0x000088, "Member 'FCrossTalkTableRow::AnnounserPriority' has a wrong offset!");
static_assert(offsetof(FCrossTalkTableRow, Probability) == 0x00008C, "Member 'FCrossTalkTableRow::Probability' has a wrong offset!");

// ScriptStruct AT.DamageTable
// 0x0020 (0x0028 - 0x0008)
struct FDamageTable final : public FTableRowBase
{
public:
	float                                         LifeDamage;                                        // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BreakDamage;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GuardBreakDamage;                                  // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalRate;                                      // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_HEALTH_ID                                   HealthId;                                          // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_Projectile;                                   // 0x0019(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_AttackAura;                                   // 0x001A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_NoDestruction;                                // 0x001B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_NoDead;                                       // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_NoBreak;                                      // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_SuperArmorPenetration;                        // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_Lock;                                         // 0x001F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_LongBlowOff;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_LongBlowOffSparking;                          // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_LongBlowOffNoAdjust;                          // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_InvGuard;                                     // 0x0023(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Attr_ComboFinish;                                  // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDamageTable) == 0x000008, "Wrong alignment on FDamageTable");
static_assert(sizeof(FDamageTable) == 0x000028, "Wrong size on FDamageTable");
static_assert(offsetof(FDamageTable, LifeDamage) == 0x000008, "Member 'FDamageTable::LifeDamage' has a wrong offset!");
static_assert(offsetof(FDamageTable, BreakDamage) == 0x00000C, "Member 'FDamageTable::BreakDamage' has a wrong offset!");
static_assert(offsetof(FDamageTable, GuardBreakDamage) == 0x000010, "Member 'FDamageTable::GuardBreakDamage' has a wrong offset!");
static_assert(offsetof(FDamageTable, CriticalRate) == 0x000014, "Member 'FDamageTable::CriticalRate' has a wrong offset!");
static_assert(offsetof(FDamageTable, HealthId) == 0x000018, "Member 'FDamageTable::HealthId' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_Projectile) == 0x000019, "Member 'FDamageTable::Attr_Projectile' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_AttackAura) == 0x00001A, "Member 'FDamageTable::Attr_AttackAura' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_NoDestruction) == 0x00001B, "Member 'FDamageTable::Attr_NoDestruction' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_NoDead) == 0x00001C, "Member 'FDamageTable::Attr_NoDead' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_NoBreak) == 0x00001D, "Member 'FDamageTable::Attr_NoBreak' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_SuperArmorPenetration) == 0x00001E, "Member 'FDamageTable::Attr_SuperArmorPenetration' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_Lock) == 0x00001F, "Member 'FDamageTable::Attr_Lock' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_LongBlowOff) == 0x000020, "Member 'FDamageTable::Attr_LongBlowOff' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_LongBlowOffSparking) == 0x000021, "Member 'FDamageTable::Attr_LongBlowOffSparking' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_LongBlowOffNoAdjust) == 0x000022, "Member 'FDamageTable::Attr_LongBlowOffNoAdjust' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_InvGuard) == 0x000023, "Member 'FDamageTable::Attr_InvGuard' has a wrong offset!");
static_assert(offsetof(FDamageTable, Attr_ComboFinish) == 0x000024, "Member 'FDamageTable::Attr_ComboFinish' has a wrong offset!");

// ScriptStruct AT.DestructParam
// 0x0028 (0x0030 - 0x0008)
struct FDestructParam final : public FTableRowBase
{
public:
	EDestructType                                 Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleX;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleY;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleZ;                                            // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Option00;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Option01;                                          // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Option02;                                          // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Option03;                                          // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UParticleSystem>            Particle;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestructParam) == 0x000008, "Wrong alignment on FDestructParam");
static_assert(sizeof(FDestructParam) == 0x000030, "Wrong size on FDestructParam");
static_assert(offsetof(FDestructParam, Type) == 0x000008, "Member 'FDestructParam::Type' has a wrong offset!");
static_assert(offsetof(FDestructParam, ScaleX) == 0x00000C, "Member 'FDestructParam::ScaleX' has a wrong offset!");
static_assert(offsetof(FDestructParam, ScaleY) == 0x000010, "Member 'FDestructParam::ScaleY' has a wrong offset!");
static_assert(offsetof(FDestructParam, ScaleZ) == 0x000014, "Member 'FDestructParam::ScaleZ' has a wrong offset!");
static_assert(offsetof(FDestructParam, Option00) == 0x000018, "Member 'FDestructParam::Option00' has a wrong offset!");
static_assert(offsetof(FDestructParam, Option01) == 0x00001C, "Member 'FDestructParam::Option01' has a wrong offset!");
static_assert(offsetof(FDestructParam, Option02) == 0x000020, "Member 'FDestructParam::Option02' has a wrong offset!");
static_assert(offsetof(FDestructParam, Option03) == 0x000024, "Member 'FDestructParam::Option03' has a wrong offset!");
static_assert(offsetof(FDestructParam, Particle) == 0x000028, "Member 'FDestructParam::Particle' has a wrong offset!");

// ScriptStruct AT.DragonBallResetTiming
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FDragonBallResetTiming final
{
public:
	class FName                                   QuestId;                                           // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PhaseNo;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowReUseMessage;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonBallResetTiming) == 0x000008, "Wrong alignment on FDragonBallResetTiming");
static_assert(sizeof(FDragonBallResetTiming) == 0x000010, "Wrong size on FDragonBallResetTiming");
static_assert(offsetof(FDragonBallResetTiming, QuestId) == 0x000000, "Member 'FDragonBallResetTiming::QuestId' has a wrong offset!");
static_assert(offsetof(FDragonBallResetTiming, PhaseNo) == 0x000008, "Member 'FDragonBallResetTiming::PhaseNo' has a wrong offset!");
static_assert(offsetof(FDragonBallResetTiming, bShowReUseMessage) == 0x00000C, "Member 'FDragonBallResetTiming::bShowReUseMessage' has a wrong offset!");

// ScriptStruct AT.WishResultInfoLog
// 0x0020 (0x0020 - 0x0000)
struct FWishResultInfoLog final
{
public:
	int32                                         WishId;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EWishType                                     WishType;                                          // 0x0004(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ItemName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemNum;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWishResultInfoLog) == 0x000008, "Wrong alignment on FWishResultInfoLog");
static_assert(sizeof(FWishResultInfoLog) == 0x000020, "Wrong size on FWishResultInfoLog");
static_assert(offsetof(FWishResultInfoLog, WishId) == 0x000000, "Member 'FWishResultInfoLog::WishId' has a wrong offset!");
static_assert(offsetof(FWishResultInfoLog, WishType) == 0x000004, "Member 'FWishResultInfoLog::WishType' has a wrong offset!");
static_assert(offsetof(FWishResultInfoLog, ItemName) == 0x000008, "Member 'FWishResultInfoLog::ItemName' has a wrong offset!");
static_assert(offsetof(FWishResultInfoLog, ItemNum) == 0x000018, "Member 'FWishResultInfoLog::ItemNum' has a wrong offset!");

// ScriptStruct AT.WishResultInfo
// 0x0028 (0x0028 - 0x0000)
struct FWishResultInfo final
{
public:
	EWishType                                     WishType;                                          // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResultMessage;                                     // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameWindowSetupItemInfo>       ResultItemList;                                    // 0x0018(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWishResultInfo) == 0x000008, "Wrong alignment on FWishResultInfo");
static_assert(sizeof(FWishResultInfo) == 0x000028, "Wrong size on FWishResultInfo");
static_assert(offsetof(FWishResultInfo, WishType) == 0x000000, "Member 'FWishResultInfo::WishType' has a wrong offset!");
static_assert(offsetof(FWishResultInfo, ResultMessage) == 0x000008, "Member 'FWishResultInfo::ResultMessage' has a wrong offset!");
static_assert(offsetof(FWishResultInfo, ResultItemList) == 0x000018, "Member 'FWishResultInfo::ResultItemList' has a wrong offset!");

// ScriptStruct AT.DragonBallSpawnAreaInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FDragonBallSpawnAreaInfo final
{
public:
	int32                                         UseNum;                                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Area;                                              // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x10];                                       // 0x0008(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDragonBallSpawnAreaInfo) == 0x000008, "Wrong alignment on FDragonBallSpawnAreaInfo");
static_assert(sizeof(FDragonBallSpawnAreaInfo) == 0x000018, "Wrong size on FDragonBallSpawnAreaInfo");
static_assert(offsetof(FDragonBallSpawnAreaInfo, UseNum) == 0x000000, "Member 'FDragonBallSpawnAreaInfo::UseNum' has a wrong offset!");
static_assert(offsetof(FDragonBallSpawnAreaInfo, Area) == 0x000004, "Member 'FDragonBallSpawnAreaInfo::Area' has a wrong offset!");

// ScriptStruct AT.DragonBallPlacementInfo
// 0x0028 (0x0028 - 0x0000)
struct FDragonBallPlacementInfo final
{
public:
	bool                                          bSelected;                                         // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlacemented;                                      // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDRAGONBALL_PLACEMENTTYPE                     Type;                                              // 0x0002(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediate;                                        // 0x0003(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ballNum;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AreaName;                                          // 0x0008(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PointNum;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Actor;                                             // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDragonBallPlacementInfo) == 0x000008, "Wrong alignment on FDragonBallPlacementInfo");
static_assert(sizeof(FDragonBallPlacementInfo) == 0x000028, "Wrong size on FDragonBallPlacementInfo");
static_assert(offsetof(FDragonBallPlacementInfo, bSelected) == 0x000000, "Member 'FDragonBallPlacementInfo::bSelected' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, bPlacemented) == 0x000001, "Member 'FDragonBallPlacementInfo::bPlacemented' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, Type) == 0x000002, "Member 'FDragonBallPlacementInfo::Type' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, bImmediate) == 0x000003, "Member 'FDragonBallPlacementInfo::bImmediate' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, ballNum) == 0x000004, "Member 'FDragonBallPlacementInfo::ballNum' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, AreaName) == 0x000008, "Member 'FDragonBallPlacementInfo::AreaName' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, PointNum) == 0x000018, "Member 'FDragonBallPlacementInfo::PointNum' has a wrong offset!");
static_assert(offsetof(FDragonBallPlacementInfo, Actor) == 0x000020, "Member 'FDragonBallPlacementInfo::Actor' has a wrong offset!");

// ScriptStruct AT.EncounterHeightAreaTableRow
// 0x0008 (0x0010 - 0x0008)
struct FEncounterHeightAreaTableRow final : public FTableRowBase
{
public:
	float                                         SeaHeight;                                         // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SkyHeight;                                         // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEncounterHeightAreaTableRow) == 0x000008, "Wrong alignment on FEncounterHeightAreaTableRow");
static_assert(sizeof(FEncounterHeightAreaTableRow) == 0x000010, "Wrong size on FEncounterHeightAreaTableRow");
static_assert(offsetof(FEncounterHeightAreaTableRow, SeaHeight) == 0x000008, "Member 'FEncounterHeightAreaTableRow::SeaHeight' has a wrong offset!");
static_assert(offsetof(FEncounterHeightAreaTableRow, SkyHeight) == 0x00000C, "Member 'FEncounterHeightAreaTableRow::SkyHeight' has a wrong offset!");

// ScriptStruct AT.EncounterMapTableRow
// 0x0040 (0x0048 - 0x0008)
struct FEncounterMapTableRow final : public FTableRowBase
{
public:
	int32                                         MapA;                                              // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapB;                                              // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapC;                                              // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapD;                                              // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapE;                                              // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapF;                                              // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapG;                                              // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapH;                                              // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapI;                                              // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapJ;                                              // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapK;                                              // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapL;                                              // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapM;                                              // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapN;                                              // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapO;                                              // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MapP;                                              // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEncounterMapTableRow) == 0x000008, "Wrong alignment on FEncounterMapTableRow");
static_assert(sizeof(FEncounterMapTableRow) == 0x000048, "Wrong size on FEncounterMapTableRow");
static_assert(offsetof(FEncounterMapTableRow, MapA) == 0x000008, "Member 'FEncounterMapTableRow::MapA' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapB) == 0x00000C, "Member 'FEncounterMapTableRow::MapB' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapC) == 0x000010, "Member 'FEncounterMapTableRow::MapC' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapD) == 0x000014, "Member 'FEncounterMapTableRow::MapD' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapE) == 0x000018, "Member 'FEncounterMapTableRow::MapE' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapF) == 0x00001C, "Member 'FEncounterMapTableRow::MapF' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapG) == 0x000020, "Member 'FEncounterMapTableRow::MapG' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapH) == 0x000024, "Member 'FEncounterMapTableRow::MapH' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapI) == 0x000028, "Member 'FEncounterMapTableRow::MapI' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapJ) == 0x00002C, "Member 'FEncounterMapTableRow::MapJ' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapK) == 0x000030, "Member 'FEncounterMapTableRow::MapK' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapL) == 0x000034, "Member 'FEncounterMapTableRow::MapL' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapM) == 0x000038, "Member 'FEncounterMapTableRow::MapM' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapN) == 0x00003C, "Member 'FEncounterMapTableRow::MapN' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapO) == 0x000040, "Member 'FEncounterMapTableRow::MapO' has a wrong offset!");
static_assert(offsetof(FEncounterMapTableRow, MapP) == 0x000044, "Member 'FEncounterMapTableRow::MapP' has a wrong offset!");

// ScriptStruct AT.VanishingBallAttackRangeParam
// 0x000C (0x000C - 0x0000)
struct FVanishingBallAttackRangeParam final
{
public:
	float                                         HPParsent;                                         // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Power;                                             // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttackEffectScaleUpSpeed;                          // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVanishingBallAttackRangeParam) == 0x000004, "Wrong alignment on FVanishingBallAttackRangeParam");
static_assert(sizeof(FVanishingBallAttackRangeParam) == 0x00000C, "Wrong size on FVanishingBallAttackRangeParam");
static_assert(offsetof(FVanishingBallAttackRangeParam, HPParsent) == 0x000000, "Member 'FVanishingBallAttackRangeParam::HPParsent' has a wrong offset!");
static_assert(offsetof(FVanishingBallAttackRangeParam, Power) == 0x000004, "Member 'FVanishingBallAttackRangeParam::Power' has a wrong offset!");
static_assert(offsetof(FVanishingBallAttackRangeParam, AttackEffectScaleUpSpeed) == 0x000008, "Member 'FVanishingBallAttackRangeParam::AttackEffectScaleUpSpeed' has a wrong offset!");

// ScriptStruct AT.EncountEnemyParamTable
// 0x0100 (0x0108 - 0x0008)
struct FEncountEnemyParamTable final : public FTableRowBase
{
public:
	float                                         LoiteringShortDist;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoiteringMiddleDist;                               // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoiteringLongDist;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoiteringMoveDist_Max;                             // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoiteringMoveDist_Min;                             // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoiteringMoveWait_Max;                             // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoiteringMoveWait_Min;                             // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningShortDist;                                  // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningMiddleDist;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningLongDist;                                   // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningMoveWait_Max;                               // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WarningMoveWait_Min;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitDeg;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchShortDist;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchShortDeg;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchLongDist;                                    // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchLongDeg;                                     // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchShortDistFly;                                // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchShortDegFly;                                 // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchLongDistFly;                                 // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchLongDegFly;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchShortDistBoost;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchShortDegBoost;                               // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchLongDistBoost;                               // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SearchLongDegBoost;                                // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousSearchShortDist;                          // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousSearchLongDist;                           // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousSearchShortDistFly;                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousSearchLongDistFly;                        // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousSearchShortDistBoost;                     // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousSearchLongDistBoost;                      // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemySpawnDist;                                    // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeleteSpawnDist;                                   // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecifiedEnemyRespawnDist;                         // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyReturnTime;                                   // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyReturnDist;                                   // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyDestroyDist;                                  // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncountBattleEscapeDist;                           // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EncountEnemyEscapeDist;                            // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnWaitTime;                                   // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnDistance;                                     // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SpawnMaxCount;                                     // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleEndCoolTime;                                 // 0x00B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIRestartCoolTime;                                 // 0x00B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaSpawnMaxCount;                                 // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DecreaseSpawnWeight;                               // 0x00BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AtrociousVolumeOutWaitTime;                        // 0x00C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDirectionCursorLimitDist;                     // 0x00C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldVillainDist;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleEncountSize;                           // 0x00CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleEnemySpawnDist;                        // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleEnemyDestroyDist;                      // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleFieldDirectionCursorLimitDist;         // 0x00D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleRespawnWaitTime;                       // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleBattleEndCoolTime;                     // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundBattleFieldAttackDist;                       // 0x00E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactLandingProjectileFieldNormal;                 // 0x00E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactLandingProjectileFieldNormalDistMin;          // 0x00EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactLandingProjectileFieldNormalDistMax;          // 0x00F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactLandingProjectileFieldFast;                   // 0x00F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactLandingProjectileFieldFastDistMin;            // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactLandingProjectileFieldFastDistMax;            // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitLandingProjectileField;                        // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DelayLandingProjectileField;                       // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEncountEnemyParamTable) == 0x000008, "Wrong alignment on FEncountEnemyParamTable");
static_assert(sizeof(FEncountEnemyParamTable) == 0x000108, "Wrong size on FEncountEnemyParamTable");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringShortDist) == 0x000008, "Member 'FEncountEnemyParamTable::LoiteringShortDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringMiddleDist) == 0x00000C, "Member 'FEncountEnemyParamTable::LoiteringMiddleDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringLongDist) == 0x000010, "Member 'FEncountEnemyParamTable::LoiteringLongDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringMoveDist_Max) == 0x000014, "Member 'FEncountEnemyParamTable::LoiteringMoveDist_Max' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringMoveDist_Min) == 0x000018, "Member 'FEncountEnemyParamTable::LoiteringMoveDist_Min' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringMoveWait_Max) == 0x00001C, "Member 'FEncountEnemyParamTable::LoiteringMoveWait_Max' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LoiteringMoveWait_Min) == 0x000020, "Member 'FEncountEnemyParamTable::LoiteringMoveWait_Min' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, WarningShortDist) == 0x000024, "Member 'FEncountEnemyParamTable::WarningShortDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, WarningMiddleDist) == 0x000028, "Member 'FEncountEnemyParamTable::WarningMiddleDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, WarningLongDist) == 0x00002C, "Member 'FEncountEnemyParamTable::WarningLongDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, WarningMoveWait_Max) == 0x000030, "Member 'FEncountEnemyParamTable::WarningMoveWait_Max' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, WarningMoveWait_Min) == 0x000034, "Member 'FEncountEnemyParamTable::WarningMoveWait_Min' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, LimitDeg) == 0x000038, "Member 'FEncountEnemyParamTable::LimitDeg' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchShortDist) == 0x00003C, "Member 'FEncountEnemyParamTable::SearchShortDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchShortDeg) == 0x000040, "Member 'FEncountEnemyParamTable::SearchShortDeg' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchLongDist) == 0x000044, "Member 'FEncountEnemyParamTable::SearchLongDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchLongDeg) == 0x000048, "Member 'FEncountEnemyParamTable::SearchLongDeg' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchShortDistFly) == 0x00004C, "Member 'FEncountEnemyParamTable::SearchShortDistFly' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchShortDegFly) == 0x000050, "Member 'FEncountEnemyParamTable::SearchShortDegFly' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchLongDistFly) == 0x000054, "Member 'FEncountEnemyParamTable::SearchLongDistFly' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchLongDegFly) == 0x000058, "Member 'FEncountEnemyParamTable::SearchLongDegFly' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchShortDistBoost) == 0x00005C, "Member 'FEncountEnemyParamTable::SearchShortDistBoost' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchShortDegBoost) == 0x000060, "Member 'FEncountEnemyParamTable::SearchShortDegBoost' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchLongDistBoost) == 0x000064, "Member 'FEncountEnemyParamTable::SearchLongDistBoost' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SearchLongDegBoost) == 0x000068, "Member 'FEncountEnemyParamTable::SearchLongDegBoost' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousSearchShortDist) == 0x00006C, "Member 'FEncountEnemyParamTable::AtrociousSearchShortDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousSearchLongDist) == 0x000070, "Member 'FEncountEnemyParamTable::AtrociousSearchLongDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousSearchShortDistFly) == 0x000074, "Member 'FEncountEnemyParamTable::AtrociousSearchShortDistFly' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousSearchLongDistFly) == 0x000078, "Member 'FEncountEnemyParamTable::AtrociousSearchLongDistFly' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousSearchShortDistBoost) == 0x00007C, "Member 'FEncountEnemyParamTable::AtrociousSearchShortDistBoost' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousSearchLongDistBoost) == 0x000080, "Member 'FEncountEnemyParamTable::AtrociousSearchLongDistBoost' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, EnemySpawnDist) == 0x000084, "Member 'FEncountEnemyParamTable::EnemySpawnDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, DeleteSpawnDist) == 0x000088, "Member 'FEncountEnemyParamTable::DeleteSpawnDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SpecifiedEnemyRespawnDist) == 0x00008C, "Member 'FEncountEnemyParamTable::SpecifiedEnemyRespawnDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, EnemyReturnTime) == 0x000090, "Member 'FEncountEnemyParamTable::EnemyReturnTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, EnemyReturnDist) == 0x000094, "Member 'FEncountEnemyParamTable::EnemyReturnDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, EnemyDestroyDist) == 0x000098, "Member 'FEncountEnemyParamTable::EnemyDestroyDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, EncountBattleEscapeDist) == 0x00009C, "Member 'FEncountEnemyParamTable::EncountBattleEscapeDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, EncountEnemyEscapeDist) == 0x0000A0, "Member 'FEncountEnemyParamTable::EncountEnemyEscapeDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, RespawnWaitTime) == 0x0000A4, "Member 'FEncountEnemyParamTable::RespawnWaitTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SpawnDistance) == 0x0000A8, "Member 'FEncountEnemyParamTable::SpawnDistance' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, SpawnMaxCount) == 0x0000AC, "Member 'FEncountEnemyParamTable::SpawnMaxCount' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, BattleEndCoolTime) == 0x0000B0, "Member 'FEncountEnemyParamTable::BattleEndCoolTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AIRestartCoolTime) == 0x0000B4, "Member 'FEncountEnemyParamTable::AIRestartCoolTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AreaSpawnMaxCount) == 0x0000B8, "Member 'FEncountEnemyParamTable::AreaSpawnMaxCount' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, DecreaseSpawnWeight) == 0x0000BC, "Member 'FEncountEnemyParamTable::DecreaseSpawnWeight' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, AtrociousVolumeOutWaitTime) == 0x0000C0, "Member 'FEncountEnemyParamTable::AtrociousVolumeOutWaitTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, FieldDirectionCursorLimitDist) == 0x0000C4, "Member 'FEncountEnemyParamTable::FieldDirectionCursorLimitDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, FieldVillainDist) == 0x0000C8, "Member 'FEncountEnemyParamTable::FieldVillainDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleEncountSize) == 0x0000CC, "Member 'FEncountEnemyParamTable::GroundBattleEncountSize' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleEnemySpawnDist) == 0x0000D0, "Member 'FEncountEnemyParamTable::GroundBattleEnemySpawnDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleEnemyDestroyDist) == 0x0000D4, "Member 'FEncountEnemyParamTable::GroundBattleEnemyDestroyDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleFieldDirectionCursorLimitDist) == 0x0000D8, "Member 'FEncountEnemyParamTable::GroundBattleFieldDirectionCursorLimitDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleRespawnWaitTime) == 0x0000DC, "Member 'FEncountEnemyParamTable::GroundBattleRespawnWaitTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleBattleEndCoolTime) == 0x0000E0, "Member 'FEncountEnemyParamTable::GroundBattleBattleEndCoolTime' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, GroundBattleFieldAttackDist) == 0x0000E4, "Member 'FEncountEnemyParamTable::GroundBattleFieldAttackDist' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, ReactLandingProjectileFieldNormal) == 0x0000E8, "Member 'FEncountEnemyParamTable::ReactLandingProjectileFieldNormal' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, ReactLandingProjectileFieldNormalDistMin) == 0x0000EC, "Member 'FEncountEnemyParamTable::ReactLandingProjectileFieldNormalDistMin' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, ReactLandingProjectileFieldNormalDistMax) == 0x0000F0, "Member 'FEncountEnemyParamTable::ReactLandingProjectileFieldNormalDistMax' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, ReactLandingProjectileFieldFast) == 0x0000F4, "Member 'FEncountEnemyParamTable::ReactLandingProjectileFieldFast' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, ReactLandingProjectileFieldFastDistMin) == 0x0000F8, "Member 'FEncountEnemyParamTable::ReactLandingProjectileFieldFastDistMin' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, ReactLandingProjectileFieldFastDistMax) == 0x0000FC, "Member 'FEncountEnemyParamTable::ReactLandingProjectileFieldFastDistMax' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, WaitLandingProjectileField) == 0x000100, "Member 'FEncountEnemyParamTable::WaitLandingProjectileField' has a wrong offset!");
static_assert(offsetof(FEncountEnemyParamTable, DelayLandingProjectileField) == 0x000104, "Member 'FEncountEnemyParamTable::DelayLandingProjectileField' has a wrong offset!");

// ScriptStruct AT.DropGroupTable
// 0x0080 (0x0088 - 0x0008)
struct FDropGroupTable final : public FTableRowBase
{
public:
	class FName                                   DropGroupID;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId_1;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount_1;                                       // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropRate_1;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemResultRank_1;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropLevel_1;                                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId_2;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount_2;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropRate_2;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemResultRank_2;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropLevel_2;                                   // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId_3;                                          // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount_3;                                       // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropRate_3;                                    // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemResultRank_3;                                  // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropLevel_3;                                   // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId_4;                                          // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount_4;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropRate_4;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemResultRank_4;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropLevel_4;                                   // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemId_5;                                          // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount_5;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropRate_5;                                    // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemResultRank_5;                                  // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemDropLevel_5;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDropGroupTable) == 0x000008, "Wrong alignment on FDropGroupTable");
static_assert(sizeof(FDropGroupTable) == 0x000088, "Wrong size on FDropGroupTable");
static_assert(offsetof(FDropGroupTable, DropGroupID) == 0x000008, "Member 'FDropGroupTable::DropGroupID' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemId_1) == 0x000010, "Member 'FDropGroupTable::ItemId_1' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemCount_1) == 0x000018, "Member 'FDropGroupTable::ItemCount_1' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropRate_1) == 0x00001C, "Member 'FDropGroupTable::ItemDropRate_1' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemResultRank_1) == 0x000020, "Member 'FDropGroupTable::ItemResultRank_1' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropLevel_1) == 0x000024, "Member 'FDropGroupTable::ItemDropLevel_1' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemId_2) == 0x000028, "Member 'FDropGroupTable::ItemId_2' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemCount_2) == 0x000030, "Member 'FDropGroupTable::ItemCount_2' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropRate_2) == 0x000034, "Member 'FDropGroupTable::ItemDropRate_2' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemResultRank_2) == 0x000038, "Member 'FDropGroupTable::ItemResultRank_2' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropLevel_2) == 0x00003C, "Member 'FDropGroupTable::ItemDropLevel_2' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemId_3) == 0x000040, "Member 'FDropGroupTable::ItemId_3' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemCount_3) == 0x000048, "Member 'FDropGroupTable::ItemCount_3' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropRate_3) == 0x00004C, "Member 'FDropGroupTable::ItemDropRate_3' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemResultRank_3) == 0x000050, "Member 'FDropGroupTable::ItemResultRank_3' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropLevel_3) == 0x000054, "Member 'FDropGroupTable::ItemDropLevel_3' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemId_4) == 0x000058, "Member 'FDropGroupTable::ItemId_4' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemCount_4) == 0x000060, "Member 'FDropGroupTable::ItemCount_4' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropRate_4) == 0x000064, "Member 'FDropGroupTable::ItemDropRate_4' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemResultRank_4) == 0x000068, "Member 'FDropGroupTable::ItemResultRank_4' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropLevel_4) == 0x00006C, "Member 'FDropGroupTable::ItemDropLevel_4' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemId_5) == 0x000070, "Member 'FDropGroupTable::ItemId_5' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemCount_5) == 0x000078, "Member 'FDropGroupTable::ItemCount_5' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropRate_5) == 0x00007C, "Member 'FDropGroupTable::ItemDropRate_5' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemResultRank_5) == 0x000080, "Member 'FDropGroupTable::ItemResultRank_5' has a wrong offset!");
static_assert(offsetof(FDropGroupTable, ItemDropLevel_5) == 0x000084, "Member 'FDropGroupTable::ItemDropLevel_5' has a wrong offset!");

// ScriptStruct AT.CharaStatusSetting
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FCharaStatusSetting final
{
public:
	ECHARACTER_TYPE                               Charatype;                                         // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Variation;                                         // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Form;                                              // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StatusTableSuffix;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleAISuffix;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SearchFlg;                                         // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharaStatusSetting) == 0x000008, "Wrong alignment on FCharaStatusSetting");
static_assert(sizeof(FCharaStatusSetting) == 0x000020, "Wrong size on FCharaStatusSetting");
static_assert(offsetof(FCharaStatusSetting, Charatype) == 0x000000, "Member 'FCharaStatusSetting::Charatype' has a wrong offset!");
static_assert(offsetof(FCharaStatusSetting, Variation) == 0x000001, "Member 'FCharaStatusSetting::Variation' has a wrong offset!");
static_assert(offsetof(FCharaStatusSetting, Form) == 0x000002, "Member 'FCharaStatusSetting::Form' has a wrong offset!");
static_assert(offsetof(FCharaStatusSetting, StatusTableSuffix) == 0x000008, "Member 'FCharaStatusSetting::StatusTableSuffix' has a wrong offset!");
static_assert(offsetof(FCharaStatusSetting, BattleAISuffix) == 0x000010, "Member 'FCharaStatusSetting::BattleAISuffix' has a wrong offset!");
static_assert(offsetof(FCharaStatusSetting, SearchFlg) == 0x000018, "Member 'FCharaStatusSetting::SearchFlg' has a wrong offset!");

// ScriptStruct AT.EncounterTableRow
// 0x0038 (0x0040 - 0x0008)
struct FEncounterTableRow final : public FTableRowBase
{
public:
	float                                         Distance;                                          // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height00;                                          // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height01;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height02;                                          // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height03;                                          // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height04;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height05;                                          // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent00;                                         // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent01;                                         // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent02;                                         // 0x002C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent03;                                         // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent04;                                         // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Percent05;                                         // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEncounterTableRow) == 0x000008, "Wrong alignment on FEncounterTableRow");
static_assert(sizeof(FEncounterTableRow) == 0x000040, "Wrong size on FEncounterTableRow");
static_assert(offsetof(FEncounterTableRow, Distance) == 0x000008, "Member 'FEncounterTableRow::Distance' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Height00) == 0x00000C, "Member 'FEncounterTableRow::Height00' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Height01) == 0x000010, "Member 'FEncounterTableRow::Height01' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Height02) == 0x000014, "Member 'FEncounterTableRow::Height02' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Height03) == 0x000018, "Member 'FEncounterTableRow::Height03' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Height04) == 0x00001C, "Member 'FEncounterTableRow::Height04' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Height05) == 0x000020, "Member 'FEncounterTableRow::Height05' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Percent00) == 0x000024, "Member 'FEncounterTableRow::Percent00' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Percent01) == 0x000028, "Member 'FEncounterTableRow::Percent01' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Percent02) == 0x00002C, "Member 'FEncounterTableRow::Percent02' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Percent03) == 0x000030, "Member 'FEncounterTableRow::Percent03' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Percent04) == 0x000034, "Member 'FEncounterTableRow::Percent04' has a wrong offset!");
static_assert(offsetof(FEncounterTableRow, Percent05) == 0x000038, "Member 'FEncounterTableRow::Percent05' has a wrong offset!");

// ScriptStruct AT.FieldBattleBgmTableRow
// 0x0008 (0x0010 - 0x0008)
struct FFieldBattleBgmTableRow final : public FTableRowBase
{
public:
	int32                                         Chapter;                                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      NormalEnemyBGM;                                    // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      MiddleBossBGM;                                     // 0x000D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      BigBossBGM;                                        // 0x000E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      StrongEnemyBGM;                                    // 0x000F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldBattleBgmTableRow) == 0x000008, "Wrong alignment on FFieldBattleBgmTableRow");
static_assert(sizeof(FFieldBattleBgmTableRow) == 0x000010, "Wrong size on FFieldBattleBgmTableRow");
static_assert(offsetof(FFieldBattleBgmTableRow, Chapter) == 0x000008, "Member 'FFieldBattleBgmTableRow::Chapter' has a wrong offset!");
static_assert(offsetof(FFieldBattleBgmTableRow, NormalEnemyBGM) == 0x00000C, "Member 'FFieldBattleBgmTableRow::NormalEnemyBGM' has a wrong offset!");
static_assert(offsetof(FFieldBattleBgmTableRow, MiddleBossBGM) == 0x00000D, "Member 'FFieldBattleBgmTableRow::MiddleBossBGM' has a wrong offset!");
static_assert(offsetof(FFieldBattleBgmTableRow, BigBossBGM) == 0x00000E, "Member 'FFieldBattleBgmTableRow::BigBossBGM' has a wrong offset!");
static_assert(offsetof(FFieldBattleBgmTableRow, StrongEnemyBGM) == 0x00000F, "Member 'FFieldBattleBgmTableRow::StrongEnemyBGM' has a wrong offset!");

// ScriptStruct AT.PhaseFieldBgmParam
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FPhaseFieldBgmParam final
{
public:
	class FName                                   DlcId;                                             // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartPhaseId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndPhaseId;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      PhaseBGM;                                          // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPhaseFieldBgmParam) == 0x000008, "Wrong alignment on FPhaseFieldBgmParam");
static_assert(sizeof(FPhaseFieldBgmParam) == 0x000020, "Wrong size on FPhaseFieldBgmParam");
static_assert(offsetof(FPhaseFieldBgmParam, DlcId) == 0x000000, "Member 'FPhaseFieldBgmParam::DlcId' has a wrong offset!");
static_assert(offsetof(FPhaseFieldBgmParam, StartPhaseId) == 0x000008, "Member 'FPhaseFieldBgmParam::StartPhaseId' has a wrong offset!");
static_assert(offsetof(FPhaseFieldBgmParam, EndPhaseId) == 0x000010, "Member 'FPhaseFieldBgmParam::EndPhaseId' has a wrong offset!");
static_assert(offsetof(FPhaseFieldBgmParam, PhaseBGM) == 0x000018, "Member 'FPhaseFieldBgmParam::PhaseBGM' has a wrong offset!");

// ScriptStruct AT.FieldDefaultBgmTableRow
// 0x0028 (0x0030 - 0x0008)
struct FFieldDefaultBgmTableRow final : public FTableRowBase
{
public:
	EBgmCode                                      StartBGM;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPhaseFieldBgmParam                    PhaseFieldBgmParam;                                // 0x0010(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFieldDefaultBgmTableRow) == 0x000008, "Wrong alignment on FFieldDefaultBgmTableRow");
static_assert(sizeof(FFieldDefaultBgmTableRow) == 0x000030, "Wrong size on FFieldDefaultBgmTableRow");
static_assert(offsetof(FFieldDefaultBgmTableRow, StartBGM) == 0x000008, "Member 'FFieldDefaultBgmTableRow::StartBGM' has a wrong offset!");
static_assert(offsetof(FFieldDefaultBgmTableRow, PhaseFieldBgmParam) == 0x000010, "Member 'FFieldDefaultBgmTableRow::PhaseFieldBgmParam' has a wrong offset!");

// ScriptStruct AT.FieldDropItemTableRow
// 0x0090 (0x0098 - 0x0008)
struct FFieldDropItemTableRow final : public FTableRowBase
{
public:
	class FName                                   ItemTableId;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CondEpisode;                                       // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMin;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMax;                                          // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_1;                                      // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_1;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_1;                                  // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_1;                                  // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_2;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_2;                                   // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_2;                                  // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_2;                                  // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_3;                                      // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_3;                                   // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_3;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_3;                                  // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_4;                                      // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_4;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_4;                                  // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_4;                                  // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_5;                                      // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_5;                                   // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_5;                                  // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_5;                                  // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFieldDropItemTableRow) == 0x000008, "Wrong alignment on FFieldDropItemTableRow");
static_assert(sizeof(FFieldDropItemTableRow) == 0x000098, "Wrong size on FFieldDropItemTableRow");
static_assert(offsetof(FFieldDropItemTableRow, ItemTableId) == 0x000008, "Member 'FFieldDropItemTableRow::ItemTableId' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, CondEpisode) == 0x000010, "Member 'FFieldDropItemTableRow::CondEpisode' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, CountMin) == 0x000014, "Member 'FFieldDropItemTableRow::CountMin' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, CountMax) == 0x000018, "Member 'FFieldDropItemTableRow::CountMax' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemId_1) == 0x000020, "Member 'FFieldDropItemTableRow::DropItemId_1' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemCount_1) == 0x000028, "Member 'FFieldDropItemTableRow::DropItemCount_1' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemWeight_1) == 0x00002C, "Member 'FFieldDropItemTableRow::DropItemWeight_1' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemIsRare_1) == 0x000030, "Member 'FFieldDropItemTableRow::DropItemIsRare_1' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemId_2) == 0x000038, "Member 'FFieldDropItemTableRow::DropItemId_2' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemCount_2) == 0x000040, "Member 'FFieldDropItemTableRow::DropItemCount_2' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemWeight_2) == 0x000044, "Member 'FFieldDropItemTableRow::DropItemWeight_2' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemIsRare_2) == 0x000048, "Member 'FFieldDropItemTableRow::DropItemIsRare_2' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemId_3) == 0x000050, "Member 'FFieldDropItemTableRow::DropItemId_3' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemCount_3) == 0x000058, "Member 'FFieldDropItemTableRow::DropItemCount_3' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemWeight_3) == 0x00005C, "Member 'FFieldDropItemTableRow::DropItemWeight_3' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemIsRare_3) == 0x000060, "Member 'FFieldDropItemTableRow::DropItemIsRare_3' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemId_4) == 0x000068, "Member 'FFieldDropItemTableRow::DropItemId_4' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemCount_4) == 0x000070, "Member 'FFieldDropItemTableRow::DropItemCount_4' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemWeight_4) == 0x000074, "Member 'FFieldDropItemTableRow::DropItemWeight_4' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemIsRare_4) == 0x000078, "Member 'FFieldDropItemTableRow::DropItemIsRare_4' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemId_5) == 0x000080, "Member 'FFieldDropItemTableRow::DropItemId_5' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemCount_5) == 0x000088, "Member 'FFieldDropItemTableRow::DropItemCount_5' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemWeight_5) == 0x00008C, "Member 'FFieldDropItemTableRow::DropItemWeight_5' has a wrong offset!");
static_assert(offsetof(FFieldDropItemTableRow, DropItemIsRare_5) == 0x000090, "Member 'FFieldDropItemTableRow::DropItemIsRare_5' has a wrong offset!");

// ScriptStruct AT.FieldItemTableRow
// 0x0080 (0x0088 - 0x0008)
struct FFieldItemTableRow final : public FTableRowBase
{
public:
	class FName                                   ItemTableId;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DropItemId_1;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_1;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_1;                                  // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_1;                                  // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_2;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_2;                                   // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_2;                                  // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_2;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_3;                                      // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_3;                                   // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_3;                                  // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_3;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_4;                                      // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_4;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_4;                                  // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_4;                                  // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DropItemId_5;                                      // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemCount_5;                                   // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropItemWeight_5;                                  // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     DropItemIsRare_5;                                  // 0x0080(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFieldItemTableRow) == 0x000008, "Wrong alignment on FFieldItemTableRow");
static_assert(sizeof(FFieldItemTableRow) == 0x000088, "Wrong size on FFieldItemTableRow");
static_assert(offsetof(FFieldItemTableRow, ItemTableId) == 0x000008, "Member 'FFieldItemTableRow::ItemTableId' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemId_1) == 0x000010, "Member 'FFieldItemTableRow::DropItemId_1' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemCount_1) == 0x000018, "Member 'FFieldItemTableRow::DropItemCount_1' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemWeight_1) == 0x00001C, "Member 'FFieldItemTableRow::DropItemWeight_1' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemIsRare_1) == 0x000020, "Member 'FFieldItemTableRow::DropItemIsRare_1' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemId_2) == 0x000028, "Member 'FFieldItemTableRow::DropItemId_2' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemCount_2) == 0x000030, "Member 'FFieldItemTableRow::DropItemCount_2' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemWeight_2) == 0x000034, "Member 'FFieldItemTableRow::DropItemWeight_2' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemIsRare_2) == 0x000038, "Member 'FFieldItemTableRow::DropItemIsRare_2' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemId_3) == 0x000040, "Member 'FFieldItemTableRow::DropItemId_3' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemCount_3) == 0x000048, "Member 'FFieldItemTableRow::DropItemCount_3' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemWeight_3) == 0x00004C, "Member 'FFieldItemTableRow::DropItemWeight_3' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemIsRare_3) == 0x000050, "Member 'FFieldItemTableRow::DropItemIsRare_3' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemId_4) == 0x000058, "Member 'FFieldItemTableRow::DropItemId_4' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemCount_4) == 0x000060, "Member 'FFieldItemTableRow::DropItemCount_4' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemWeight_4) == 0x000064, "Member 'FFieldItemTableRow::DropItemWeight_4' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemIsRare_4) == 0x000068, "Member 'FFieldItemTableRow::DropItemIsRare_4' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemId_5) == 0x000070, "Member 'FFieldItemTableRow::DropItemId_5' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemCount_5) == 0x000078, "Member 'FFieldItemTableRow::DropItemCount_5' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemWeight_5) == 0x00007C, "Member 'FFieldItemTableRow::DropItemWeight_5' has a wrong offset!");
static_assert(offsetof(FFieldItemTableRow, DropItemIsRare_5) == 0x000080, "Member 'FFieldItemTableRow::DropItemIsRare_5' has a wrong offset!");

// ScriptStruct AT.FishAreaSettingParam
// 0x0070 (0x0070 - 0x0000)
struct FFishAreaSettingParam final
{
public:
	float                                         Lot;                                               // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ChallengeCount;                                    // 0x0004(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadowID;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ATriggerBox*                            MoveAreaBox;                                       // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FishShadowMinNum;                                  // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FishShadowMaxNum;                                  // 0x0019(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReSpawnTime;                                       // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishNormalQTE_Gauge;                               // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishRareQTE_Gauge;                                 // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeQTE_Gauge;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishNormalQTE_Ring;                                // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishRareQTE_Ring;                                  // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateFishNormalQTE_Ring;                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RateFishRareQTE_Ring;                              // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeQTE_Ring;                                      // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemFrameNum_C;                                    // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemFrameNum_A;                                    // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DiscoverParam;                                     // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoverWaitTime_Min;                              // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoverWaitTime_Max;                              // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoverDist_Min;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiscoverDist_Max;                                  // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ChallengeInfinity;                                 // 0x0060(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetWithRod;                                     // 0x0064(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishAreaSettingParam) == 0x000008, "Wrong alignment on FFishAreaSettingParam");
static_assert(sizeof(FFishAreaSettingParam) == 0x000070, "Wrong size on FFishAreaSettingParam");
static_assert(offsetof(FFishAreaSettingParam, Lot) == 0x000000, "Member 'FFishAreaSettingParam::Lot' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, ChallengeCount) == 0x000004, "Member 'FFishAreaSettingParam::ChallengeCount' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishShadowID) == 0x000008, "Member 'FFishAreaSettingParam::FishShadowID' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, MoveAreaBox) == 0x000010, "Member 'FFishAreaSettingParam::MoveAreaBox' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishShadowMinNum) == 0x000018, "Member 'FFishAreaSettingParam::FishShadowMinNum' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishShadowMaxNum) == 0x000019, "Member 'FFishAreaSettingParam::FishShadowMaxNum' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, ReSpawnTime) == 0x00001C, "Member 'FFishAreaSettingParam::ReSpawnTime' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishNormalQTE_Gauge) == 0x000020, "Member 'FFishAreaSettingParam::FishNormalQTE_Gauge' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishRareQTE_Gauge) == 0x000024, "Member 'FFishAreaSettingParam::FishRareQTE_Gauge' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, TimeQTE_Gauge) == 0x000028, "Member 'FFishAreaSettingParam::TimeQTE_Gauge' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishNormalQTE_Ring) == 0x00002C, "Member 'FFishAreaSettingParam::FishNormalQTE_Ring' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, FishRareQTE_Ring) == 0x000030, "Member 'FFishAreaSettingParam::FishRareQTE_Ring' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, RateFishNormalQTE_Ring) == 0x000034, "Member 'FFishAreaSettingParam::RateFishNormalQTE_Ring' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, RateFishRareQTE_Ring) == 0x000038, "Member 'FFishAreaSettingParam::RateFishRareQTE_Ring' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, TimeQTE_Ring) == 0x00003C, "Member 'FFishAreaSettingParam::TimeQTE_Ring' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, ItemFrameNum_C) == 0x000040, "Member 'FFishAreaSettingParam::ItemFrameNum_C' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, ItemFrameNum_A) == 0x000044, "Member 'FFishAreaSettingParam::ItemFrameNum_A' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, DiscoverParam) == 0x000048, "Member 'FFishAreaSettingParam::DiscoverParam' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, DiscoverWaitTime_Min) == 0x000050, "Member 'FFishAreaSettingParam::DiscoverWaitTime_Min' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, DiscoverWaitTime_Max) == 0x000054, "Member 'FFishAreaSettingParam::DiscoverWaitTime_Max' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, DiscoverDist_Min) == 0x000058, "Member 'FFishAreaSettingParam::DiscoverDist_Min' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, DiscoverDist_Max) == 0x00005C, "Member 'FFishAreaSettingParam::DiscoverDist_Max' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, ChallengeInfinity) == 0x000060, "Member 'FFishAreaSettingParam::ChallengeInfinity' has a wrong offset!");
static_assert(offsetof(FFishAreaSettingParam, OffsetWithRod) == 0x000064, "Member 'FFishAreaSettingParam::OffsetWithRod' has a wrong offset!");

// ScriptStruct AT.FishInfo
// 0x0020 (0x0028 - 0x0008)
struct FFishInfo final : public FTableRowBase
{
public:
	EITEM_ID                                      ItemId;                                            // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SizeMin;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeMax;                                           // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightMin;                                         // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WeightMax;                                         // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFISH_FORM_TYPE                               FormID;                                            // 0x001C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFISH_GROUP                                   Group;                                             // 0x001D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFISH_COLOR_TYPE                              ColorType;                                         // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          QTEFlag;                                           // 0x001F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFISH_RARITY_TYPE                             RarityType;                                        // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFishInfo) == 0x000008, "Wrong alignment on FFishInfo");
static_assert(sizeof(FFishInfo) == 0x000028, "Wrong size on FFishInfo");
static_assert(offsetof(FFishInfo, ItemId) == 0x000008, "Member 'FFishInfo::ItemId' has a wrong offset!");
static_assert(offsetof(FFishInfo, SizeMin) == 0x00000C, "Member 'FFishInfo::SizeMin' has a wrong offset!");
static_assert(offsetof(FFishInfo, SizeMax) == 0x000010, "Member 'FFishInfo::SizeMax' has a wrong offset!");
static_assert(offsetof(FFishInfo, WeightMin) == 0x000014, "Member 'FFishInfo::WeightMin' has a wrong offset!");
static_assert(offsetof(FFishInfo, WeightMax) == 0x000018, "Member 'FFishInfo::WeightMax' has a wrong offset!");
static_assert(offsetof(FFishInfo, FormID) == 0x00001C, "Member 'FFishInfo::FormID' has a wrong offset!");
static_assert(offsetof(FFishInfo, Group) == 0x00001D, "Member 'FFishInfo::Group' has a wrong offset!");
static_assert(offsetof(FFishInfo, ColorType) == 0x00001E, "Member 'FFishInfo::ColorType' has a wrong offset!");
static_assert(offsetof(FFishInfo, QTEFlag) == 0x00001F, "Member 'FFishInfo::QTEFlag' has a wrong offset!");
static_assert(offsetof(FFishInfo, RarityType) == 0x000020, "Member 'FFishInfo::RarityType' has a wrong offset!");

// ScriptStruct AT.FishGetItemTable
// 0x0010 (0x0018 - 0x0008)
struct FFishGetItemTable final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Num;                                               // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Lot;                                               // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishGetItemTable) == 0x000008, "Wrong alignment on FFishGetItemTable");
static_assert(sizeof(FFishGetItemTable) == 0x000018, "Wrong size on FFishGetItemTable");
static_assert(offsetof(FFishGetItemTable, ItemId) == 0x000008, "Member 'FFishGetItemTable::ItemId' has a wrong offset!");
static_assert(offsetof(FFishGetItemTable, Num) == 0x000010, "Member 'FFishGetItemTable::Num' has a wrong offset!");
static_assert(offsetof(FFishGetItemTable, Lot) == 0x000014, "Member 'FFishGetItemTable::Lot' has a wrong offset!");

// ScriptStruct AT.FishShadowTable
// 0x0048 (0x0050 - 0x0008)
struct FFishShadowTable final : public FTableRowBase
{
public:
	class FName                                   MngID;                                             // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FishID;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDeg;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDegCorrection;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDist;                                          // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewDistCorrection;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Reaction;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReactionCorrection;                                // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Escape;                                            // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeCorrection;                                  // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FishShadowModelName;                               // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FishShadowModelSize;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FishShadowRare;                                    // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFishShadowTable) == 0x000008, "Wrong alignment on FFishShadowTable");
static_assert(sizeof(FFishShadowTable) == 0x000050, "Wrong size on FFishShadowTable");
static_assert(offsetof(FFishShadowTable, MngID) == 0x000008, "Member 'FFishShadowTable::MngID' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, FishID) == 0x000010, "Member 'FFishShadowTable::FishID' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, ViewDeg) == 0x000018, "Member 'FFishShadowTable::ViewDeg' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, ViewDegCorrection) == 0x00001C, "Member 'FFishShadowTable::ViewDegCorrection' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, ViewDist) == 0x000020, "Member 'FFishShadowTable::ViewDist' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, ViewDistCorrection) == 0x000024, "Member 'FFishShadowTable::ViewDistCorrection' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, Speed) == 0x000028, "Member 'FFishShadowTable::Speed' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, Reaction) == 0x00002C, "Member 'FFishShadowTable::Reaction' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, ReactionCorrection) == 0x000030, "Member 'FFishShadowTable::ReactionCorrection' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, Escape) == 0x000034, "Member 'FFishShadowTable::Escape' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, EscapeCorrection) == 0x000038, "Member 'FFishShadowTable::EscapeCorrection' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, FishShadowModelName) == 0x000040, "Member 'FFishShadowTable::FishShadowModelName' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, FishShadowModelSize) == 0x000048, "Member 'FFishShadowTable::FishShadowModelSize' has a wrong offset!");
static_assert(offsetof(FFishShadowTable, FishShadowRare) == 0x00004C, "Member 'FFishShadowTable::FishShadowRare' has a wrong offset!");

// ScriptStruct AT.BaitParam
// 0x0030 (0x0038 - 0x0008)
struct FBaitParam final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BAIT_TYPE                                   BaitType;                                          // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Amount;                                            // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BAIT_TYPE                                   BaitType2;                                         // 0x0018(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Amount2;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BAIT_TYPE                                   BaitType3;                                         // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Amount3;                                           // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	E_BAIT_EFFECT_TYPE                            BaitEffectType;                                    // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Count;                                             // 0x0029(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BaitWindowMsgID;                                   // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBaitParam) == 0x000008, "Wrong alignment on FBaitParam");
static_assert(sizeof(FBaitParam) == 0x000038, "Wrong size on FBaitParam");
static_assert(offsetof(FBaitParam, ItemId) == 0x000008, "Member 'FBaitParam::ItemId' has a wrong offset!");
static_assert(offsetof(FBaitParam, BaitType) == 0x000010, "Member 'FBaitParam::BaitType' has a wrong offset!");
static_assert(offsetof(FBaitParam, Amount) == 0x000014, "Member 'FBaitParam::Amount' has a wrong offset!");
static_assert(offsetof(FBaitParam, BaitType2) == 0x000018, "Member 'FBaitParam::BaitType2' has a wrong offset!");
static_assert(offsetof(FBaitParam, Amount2) == 0x00001C, "Member 'FBaitParam::Amount2' has a wrong offset!");
static_assert(offsetof(FBaitParam, BaitType3) == 0x000020, "Member 'FBaitParam::BaitType3' has a wrong offset!");
static_assert(offsetof(FBaitParam, Amount3) == 0x000024, "Member 'FBaitParam::Amount3' has a wrong offset!");
static_assert(offsetof(FBaitParam, BaitEffectType) == 0x000028, "Member 'FBaitParam::BaitEffectType' has a wrong offset!");
static_assert(offsetof(FBaitParam, Count) == 0x000029, "Member 'FBaitParam::Count' has a wrong offset!");
static_assert(offsetof(FBaitParam, BaitWindowMsgID) == 0x000030, "Member 'FBaitParam::BaitWindowMsgID' has a wrong offset!");

// ScriptStruct AT.GrassTransform
// 0x0040 (0x0048 - 0x0008)
struct FGrassTransform final : public FTableRowBase
{
public:
	uint32                                        ID;                                                // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPosX;                                             // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPosY;                                             // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FPosZ;                                             // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSclX;                                             // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSclY;                                             // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FSclZ;                                             // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexX0;                                         // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexY0;                                         // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexZ0;                                         // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexX1;                                         // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexY1;                                         // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexZ1;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexX2;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexY2;                                         // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FVertexZ2;                                         // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGrassTransform) == 0x000008, "Wrong alignment on FGrassTransform");
static_assert(sizeof(FGrassTransform) == 0x000048, "Wrong size on FGrassTransform");
static_assert(offsetof(FGrassTransform, ID) == 0x000008, "Member 'FGrassTransform::ID' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FPosX) == 0x00000C, "Member 'FGrassTransform::FPosX' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FPosY) == 0x000010, "Member 'FGrassTransform::FPosY' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FPosZ) == 0x000014, "Member 'FGrassTransform::FPosZ' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FSclX) == 0x000018, "Member 'FGrassTransform::FSclX' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FSclY) == 0x00001C, "Member 'FGrassTransform::FSclY' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FSclZ) == 0x000020, "Member 'FGrassTransform::FSclZ' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexX0) == 0x000024, "Member 'FGrassTransform::FVertexX0' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexY0) == 0x000028, "Member 'FGrassTransform::FVertexY0' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexZ0) == 0x00002C, "Member 'FGrassTransform::FVertexZ0' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexX1) == 0x000030, "Member 'FGrassTransform::FVertexX1' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexY1) == 0x000034, "Member 'FGrassTransform::FVertexY1' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexZ1) == 0x000038, "Member 'FGrassTransform::FVertexZ1' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexX2) == 0x00003C, "Member 'FGrassTransform::FVertexX2' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexY2) == 0x000040, "Member 'FGrassTransform::FVertexY2' has a wrong offset!");
static_assert(offsetof(FGrassTransform, FVertexZ2) == 0x000044, "Member 'FGrassTransform::FVertexZ2' has a wrong offset!");

// ScriptStruct AT.AnimClassInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAnimClassInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAnimClassInfo) == 0x000008, "Wrong alignment on FAnimClassInfo");
static_assert(sizeof(FAnimClassInfo) == 0x000018, "Wrong size on FAnimClassInfo");

// ScriptStruct AT.InventoryItem
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FInventoryItem final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInventoryItem) == 0x000008, "Wrong alignment on FInventoryItem");
static_assert(sizeof(FInventoryItem) == 0x000010, "Wrong size on FInventoryItem");

// ScriptStruct AT.UniqueItemInventory
// 0x0001 (0x0001 - 0x0000)
struct FUniqueItemInventory final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUniqueItemInventory) == 0x000001, "Wrong alignment on FUniqueItemInventory");
static_assert(sizeof(FUniqueItemInventory) == 0x000001, "Wrong size on FUniqueItemInventory");

// ScriptStruct AT.GrassWeightBackupControl2
// 0x0010 (0x0010 - 0x0000)
struct FGrassWeightBackupControl2
{
public:
	TArray<class UGrassWeightBackupArrayWrite*>   GrassWeightBackupArrayList;                        // 0x0000(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGrassWeightBackupControl2) == 0x000008, "Wrong alignment on FGrassWeightBackupControl2");
static_assert(sizeof(FGrassWeightBackupControl2) == 0x000010, "Wrong size on FGrassWeightBackupControl2");
static_assert(offsetof(FGrassWeightBackupControl2, GrassWeightBackupArrayList) == 0x000000, "Member 'FGrassWeightBackupControl2::GrassWeightBackupArrayList' has a wrong offset!");

// ScriptStruct AT.GrassWeightBackupControlWrite2
// 0x0000 (0x0010 - 0x0010)
struct FGrassWeightBackupControlWrite2 final : public FGrassWeightBackupControl2
{
};
static_assert(alignof(FGrassWeightBackupControlWrite2) == 0x000008, "Wrong alignment on FGrassWeightBackupControlWrite2");
static_assert(sizeof(FGrassWeightBackupControlWrite2) == 0x000010, "Wrong size on FGrassWeightBackupControlWrite2");

// ScriptStruct AT.ItemUsageRestrictionDataTableType
// 0x0028 (0x0030 - 0x0008)
struct FItemUsageRestrictionDataTableType final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartQuestId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartQuestPhase;                                   // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndQuestId;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndQuestPhase;                                     // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemUsageRestrictionDataTableType) == 0x000008, "Wrong alignment on FItemUsageRestrictionDataTableType");
static_assert(sizeof(FItemUsageRestrictionDataTableType) == 0x000030, "Wrong size on FItemUsageRestrictionDataTableType");
static_assert(offsetof(FItemUsageRestrictionDataTableType, ItemId) == 0x000008, "Member 'FItemUsageRestrictionDataTableType::ItemId' has a wrong offset!");
static_assert(offsetof(FItemUsageRestrictionDataTableType, StartQuestId) == 0x000010, "Member 'FItemUsageRestrictionDataTableType::StartQuestId' has a wrong offset!");
static_assert(offsetof(FItemUsageRestrictionDataTableType, StartQuestPhase) == 0x000018, "Member 'FItemUsageRestrictionDataTableType::StartQuestPhase' has a wrong offset!");
static_assert(offsetof(FItemUsageRestrictionDataTableType, EndQuestId) == 0x000020, "Member 'FItemUsageRestrictionDataTableType::EndQuestId' has a wrong offset!");
static_assert(offsetof(FItemUsageRestrictionDataTableType, EndQuestPhase) == 0x000028, "Member 'FItemUsageRestrictionDataTableType::EndQuestPhase' has a wrong offset!");

// ScriptStruct AT.RewardBonusTable
// 0x0020 (0x0028 - 0x0008)
struct FRewardBonusTable final : public FTableRowBase
{
public:
	int32                                         AtkBlow;                                           // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AtkShot;                                           // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AtkSpeed;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefBlow;                                           // 0x0014(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefShot;                                           // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefSpeed;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HpMax;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KiMax;                                             // 0x0024(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardBonusTable) == 0x000008, "Wrong alignment on FRewardBonusTable");
static_assert(sizeof(FRewardBonusTable) == 0x000028, "Wrong size on FRewardBonusTable");
static_assert(offsetof(FRewardBonusTable, AtkBlow) == 0x000008, "Member 'FRewardBonusTable::AtkBlow' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, AtkShot) == 0x00000C, "Member 'FRewardBonusTable::AtkShot' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, AtkSpeed) == 0x000010, "Member 'FRewardBonusTable::AtkSpeed' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, DefBlow) == 0x000014, "Member 'FRewardBonusTable::DefBlow' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, DefShot) == 0x000018, "Member 'FRewardBonusTable::DefShot' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, DefSpeed) == 0x00001C, "Member 'FRewardBonusTable::DefSpeed' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, HpMax) == 0x000020, "Member 'FRewardBonusTable::HpMax' has a wrong offset!");
static_assert(offsetof(FRewardBonusTable, KiMax) == 0x000024, "Member 'FRewardBonusTable::KiMax' has a wrong offset!");

// ScriptStruct AT.ItemTableHeal
// 0x0018 (0x0058 - 0x0040)
struct FItemTableHeal final : public FItemInfoParam
{
public:
	int32                                         ItemPaletteMaximum;                                // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemEffectType                               EffectType;                                        // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EITEM_EFF_TARGET                              EffectTarget;                                      // 0x0045(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectValue;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectTime;                                        // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUseItemParticle                              UseParticle;                                       // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUseItemParticleColor                         UseParticleColor;                                  // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTableHeal) == 0x000008, "Wrong alignment on FItemTableHeal");
static_assert(sizeof(FItemTableHeal) == 0x000058, "Wrong size on FItemTableHeal");
static_assert(offsetof(FItemTableHeal, ItemPaletteMaximum) == 0x000040, "Member 'FItemTableHeal::ItemPaletteMaximum' has a wrong offset!");
static_assert(offsetof(FItemTableHeal, EffectType) == 0x000044, "Member 'FItemTableHeal::EffectType' has a wrong offset!");
static_assert(offsetof(FItemTableHeal, EffectTarget) == 0x000045, "Member 'FItemTableHeal::EffectTarget' has a wrong offset!");
static_assert(offsetof(FItemTableHeal, EffectValue) == 0x000048, "Member 'FItemTableHeal::EffectValue' has a wrong offset!");
static_assert(offsetof(FItemTableHeal, EffectTime) == 0x00004C, "Member 'FItemTableHeal::EffectTime' has a wrong offset!");
static_assert(offsetof(FItemTableHeal, UseParticle) == 0x000050, "Member 'FItemTableHeal::UseParticle' has a wrong offset!");
static_assert(offsetof(FItemTableHeal, UseParticleColor) == 0x000051, "Member 'FItemTableHeal::UseParticleColor' has a wrong offset!");

// ScriptStruct AT.ItemTableDevelop
// 0x0008 (0x0048 - 0x0040)
struct FItemTableDevelop final : public FItemInfoParam
{
public:
	int32                                         DevelopExp;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTableDevelop) == 0x000008, "Wrong alignment on FItemTableDevelop");
static_assert(sizeof(FItemTableDevelop) == 0x000048, "Wrong size on FItemTableDevelop");
static_assert(offsetof(FItemTableDevelop, DevelopExp) == 0x000040, "Member 'FItemTableDevelop::DevelopExp' has a wrong offset!");

// ScriptStruct AT.ItemTableBait
// 0x0010 (0x0050 - 0x0040)
struct FItemTableBait final : public FItemInfoParam
{
public:
	int32                                         BaitUpRate;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RareFishUpRate;                                    // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropUpRate;                                        // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemTableBait) == 0x000008, "Wrong alignment on FItemTableBait");
static_assert(sizeof(FItemTableBait) == 0x000050, "Wrong size on FItemTableBait");
static_assert(offsetof(FItemTableBait, BaitUpRate) == 0x000040, "Member 'FItemTableBait::BaitUpRate' has a wrong offset!");
static_assert(offsetof(FItemTableBait, RareFishUpRate) == 0x000044, "Member 'FItemTableBait::RareFishUpRate' has a wrong offset!");
static_assert(offsetof(FItemTableBait, DropUpRate) == 0x000048, "Member 'FItemTableBait::DropUpRate' has a wrong offset!");

// ScriptStruct AT.ItemEffectTable
// 0x0010 (0x0018 - 0x0008)
struct FItemEffectTable final : public FTableRowBase
{
public:
	EItemEffectType                               EffectType;                                        // 0x0008(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EffectValue;                                       // 0x000C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EffectTime;                                        // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemEffectTable) == 0x000008, "Wrong alignment on FItemEffectTable");
static_assert(sizeof(FItemEffectTable) == 0x000018, "Wrong size on FItemEffectTable");
static_assert(offsetof(FItemEffectTable, EffectType) == 0x000008, "Member 'FItemEffectTable::EffectType' has a wrong offset!");
static_assert(offsetof(FItemEffectTable, EffectValue) == 0x00000C, "Member 'FItemEffectTable::EffectValue' has a wrong offset!");
static_assert(offsetof(FItemEffectTable, EffectTime) == 0x000010, "Member 'FItemEffectTable::EffectTime' has a wrong offset!");

// ScriptStruct AT.LandscapeParams
// 0x0040 (0x0040 - 0x0000)
struct FLandscapeParams final
{
public:
	EDestructType                                 M_Type;                                            // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                M_ClashPos;                                        // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                M_Vec;                                             // 0x0010(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_ScaleZ;                                          // 0x001C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOption00;                                       // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOption01;                                       // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOption02;                                       // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M_fOption03;                                       // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleSmk;                                       // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMassDestruction;                                 // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLandscapeParams) == 0x000008, "Wrong alignment on FLandscapeParams");
static_assert(sizeof(FLandscapeParams) == 0x000040, "Wrong size on FLandscapeParams");
static_assert(offsetof(FLandscapeParams, M_Type) == 0x000000, "Member 'FLandscapeParams::M_Type' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_ClashPos) == 0x000004, "Member 'FLandscapeParams::M_ClashPos' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_Vec) == 0x000010, "Member 'FLandscapeParams::M_Vec' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_ScaleZ) == 0x00001C, "Member 'FLandscapeParams::M_ScaleZ' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_fOption00) == 0x000020, "Member 'FLandscapeParams::M_fOption00' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_fOption01) == 0x000024, "Member 'FLandscapeParams::M_fOption01' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_fOption02) == 0x000028, "Member 'FLandscapeParams::M_fOption02' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, M_fOption03) == 0x00002C, "Member 'FLandscapeParams::M_fOption03' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, ParticleSmk) == 0x000030, "Member 'FLandscapeParams::ParticleSmk' has a wrong offset!");
static_assert(offsetof(FLandscapeParams, IsMassDestruction) == 0x000038, "Member 'FLandscapeParams::IsMassDestruction' has a wrong offset!");

// ScriptStruct AT.LeafTreeVolume
// 0x0020 (0x0020 - 0x0000)
struct FLeafTreeVolume final
{
public:
	class UParticleSystem*                        Effect;                                            // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x18];                                       // 0x0008(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLeafTreeVolume) == 0x000008, "Wrong alignment on FLeafTreeVolume");
static_assert(sizeof(FLeafTreeVolume) == 0x000020, "Wrong size on FLeafTreeVolume");
static_assert(offsetof(FLeafTreeVolume, Effect) == 0x000000, "Member 'FLeafTreeVolume::Effect' has a wrong offset!");

// ScriptStruct AT.LipSyncAreaData
// 0x0010 (0x0018 - 0x0008)
struct FLipSyncAreaData final : public FTableRowBase
{
public:
	float                                         Start_s;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLipSyncAreaData) == 0x000008, "Wrong alignment on FLipSyncAreaData");
static_assert(sizeof(FLipSyncAreaData) == 0x000018, "Wrong size on FLipSyncAreaData");
static_assert(offsetof(FLipSyncAreaData, Start_s) == 0x000008, "Member 'FLipSyncAreaData::Start_s' has a wrong offset!");
static_assert(offsetof(FLipSyncAreaData, X) == 0x00000C, "Member 'FLipSyncAreaData::X' has a wrong offset!");
static_assert(offsetof(FLipSyncAreaData, Y) == 0x000010, "Member 'FLipSyncAreaData::Y' has a wrong offset!");

// ScriptStruct AT.TimerTalkParam
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FTimerTalkParam final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTimerTalkParam) == 0x000008, "Wrong alignment on FTimerTalkParam");
static_assert(sizeof(FTimerTalkParam) == 0x000020, "Wrong size on FTimerTalkParam");

// ScriptStruct AT.MiniGameFinishParam
// 0x0008 (0x0010 - 0x0008)
struct FMiniGameFinishParam final : public FTableRowBase
{
public:
	EMiniGameFinishType                           MiniGameFinishType;                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FinishValue;                                       // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniGameFinishParam) == 0x000008, "Wrong alignment on FMiniGameFinishParam");
static_assert(sizeof(FMiniGameFinishParam) == 0x000010, "Wrong size on FMiniGameFinishParam");
static_assert(offsetof(FMiniGameFinishParam, MiniGameFinishType) == 0x000008, "Member 'FMiniGameFinishParam::MiniGameFinishType' has a wrong offset!");
static_assert(offsetof(FMiniGameFinishParam, FinishValue) == 0x00000C, "Member 'FMiniGameFinishParam::FinishValue' has a wrong offset!");

// ScriptStruct AT.MiniGameFishingSaveInfo
// 0x00A0 (0x00A0 - 0x0000)
struct FMiniGameFishingSaveInfo final
{
public:
	TMap<EFISH_RARITY_TYPE, int32>                StartFishingCountMap;                              // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<EFISH_RARITY_TYPE, int32>                SucceseFishingCountMap;                            // 0x0050(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniGameFishingSaveInfo) == 0x000008, "Wrong alignment on FMiniGameFishingSaveInfo");
static_assert(sizeof(FMiniGameFishingSaveInfo) == 0x0000A0, "Wrong size on FMiniGameFishingSaveInfo");
static_assert(offsetof(FMiniGameFishingSaveInfo, StartFishingCountMap) == 0x000000, "Member 'FMiniGameFishingSaveInfo::StartFishingCountMap' has a wrong offset!");
static_assert(offsetof(FMiniGameFishingSaveInfo, SucceseFishingCountMap) == 0x000050, "Member 'FMiniGameFishingSaveInfo::SucceseFishingCountMap' has a wrong offset!");

// ScriptStruct AT.SubQuestCompleteUITableRow
// 0x0068 (0x0070 - 0x0008)
struct FSubQuestCompleteUITableRow final : public FTableRowBase
{
public:
	class FName                                   ClientName;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mc_reward_win;                                     // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mc_name;                                           // 0x0020(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mc_title;                                          // 0x0030(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mc_detail;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mc_exp;                                            // 0x0050(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mc_reward;                                         // 0x0060(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubQuestCompleteUITableRow) == 0x000008, "Wrong alignment on FSubQuestCompleteUITableRow");
static_assert(sizeof(FSubQuestCompleteUITableRow) == 0x000070, "Wrong size on FSubQuestCompleteUITableRow");
static_assert(offsetof(FSubQuestCompleteUITableRow, ClientName) == 0x000008, "Member 'FSubQuestCompleteUITableRow::ClientName' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteUITableRow, Mc_reward_win) == 0x000010, "Member 'FSubQuestCompleteUITableRow::Mc_reward_win' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteUITableRow, Mc_name) == 0x000020, "Member 'FSubQuestCompleteUITableRow::Mc_name' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteUITableRow, Mc_title) == 0x000030, "Member 'FSubQuestCompleteUITableRow::Mc_title' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteUITableRow, Mc_detail) == 0x000040, "Member 'FSubQuestCompleteUITableRow::Mc_detail' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteUITableRow, Mc_exp) == 0x000050, "Member 'FSubQuestCompleteUITableRow::Mc_exp' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteUITableRow, Mc_reward) == 0x000060, "Member 'FSubQuestCompleteUITableRow::Mc_reward' has a wrong offset!");

// ScriptStruct AT.MiniGameRaceSaveInfo
// 0x0060 (0x0060 - 0x0000)
struct FMiniGameRaceSaveInfo final
{
public:
	TMap<class FString, struct FMiniGameRaceSaveOutline> Records;                                           // 0x0000(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMiniGameAcquiredReward>        AcquiredRewardList;                                // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMiniGameRaceSaveInfo) == 0x000008, "Wrong alignment on FMiniGameRaceSaveInfo");
static_assert(sizeof(FMiniGameRaceSaveInfo) == 0x000060, "Wrong size on FMiniGameRaceSaveInfo");
static_assert(offsetof(FMiniGameRaceSaveInfo, Records) == 0x000000, "Member 'FMiniGameRaceSaveInfo::Records' has a wrong offset!");
static_assert(offsetof(FMiniGameRaceSaveInfo, AcquiredRewardList) == 0x000050, "Member 'FMiniGameRaceSaveInfo::AcquiredRewardList' has a wrong offset!");

// ScriptStruct AT.MobLookGroup
// 0x0018 (0x0020 - 0x0008)
struct FMobLookGroup final : public FTableRowBase
{
public:
	class FName                                   GroupName;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           PresetName;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMobLookGroup) == 0x000008, "Wrong alignment on FMobLookGroup");
static_assert(sizeof(FMobLookGroup) == 0x000020, "Wrong size on FMobLookGroup");
static_assert(offsetof(FMobLookGroup, GroupName) == 0x000008, "Member 'FMobLookGroup::GroupName' has a wrong offset!");
static_assert(offsetof(FMobLookGroup, PresetName) == 0x000010, "Member 'FMobLookGroup::PresetName' has a wrong offset!");

// ScriptStruct AT.AnimalParameterTable
// 0x00A8 (0x00B0 - 0x0008)
struct FAnimalParameterTable final : public FTableRowBase
{
public:
	EAnimalID                                     ID;                                                // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 VariationName;                                     // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeStartRange;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeEndRange;                                    // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EscapeRandom;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CautionStartRange;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CautionEndRange;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionPlayTime;                                    // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnDistance;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkSpeed;                                         // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAcceleration;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkDeceleration;                                  // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunSpeed;                                          // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunAcceleration;                                   // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunDeceleration;                                   // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySpeed;                                          // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyAcceleration;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyDeceleration;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlideSpeed;                                        // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlideAcceleration;                                 // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlideDeceleration;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveSpeed;                                         // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveAcceleration;                                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveDeceleration;                                  // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlyTime;                                           // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlideTime;                                         // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveStartAngle;                                    // 0x0080(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiveEndAngle;                                      // 0x0084(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RandamTime;                                        // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HP;                                                // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownPower;                                         // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownTime;                                          // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FalterDamage;                                      // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropDistanceMin;                                   // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropDistanceMax;                                   // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropHeight;                                        // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropAngle;                                         // 0x00A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnRatio;                                        // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnimalParameterTable) == 0x000008, "Wrong alignment on FAnimalParameterTable");
static_assert(sizeof(FAnimalParameterTable) == 0x0000B0, "Wrong size on FAnimalParameterTable");
static_assert(offsetof(FAnimalParameterTable, ID) == 0x000008, "Member 'FAnimalParameterTable::ID' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, VariationName) == 0x000010, "Member 'FAnimalParameterTable::VariationName' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, EscapeStartRange) == 0x000020, "Member 'FAnimalParameterTable::EscapeStartRange' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, EscapeEndRange) == 0x000024, "Member 'FAnimalParameterTable::EscapeEndRange' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, EscapeRandom) == 0x000028, "Member 'FAnimalParameterTable::EscapeRandom' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, CautionStartRange) == 0x00002C, "Member 'FAnimalParameterTable::CautionStartRange' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, CautionEndRange) == 0x000030, "Member 'FAnimalParameterTable::CautionEndRange' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, ActionPlayTime) == 0x000034, "Member 'FAnimalParameterTable::ActionPlayTime' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, RespawnDistance) == 0x000038, "Member 'FAnimalParameterTable::RespawnDistance' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, WalkSpeed) == 0x00003C, "Member 'FAnimalParameterTable::WalkSpeed' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, WalkAcceleration) == 0x000040, "Member 'FAnimalParameterTable::WalkAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, WalkDeceleration) == 0x000044, "Member 'FAnimalParameterTable::WalkDeceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, RunSpeed) == 0x000048, "Member 'FAnimalParameterTable::RunSpeed' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, RunAcceleration) == 0x00004C, "Member 'FAnimalParameterTable::RunAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, RunDeceleration) == 0x000050, "Member 'FAnimalParameterTable::RunDeceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, FlySpeed) == 0x000054, "Member 'FAnimalParameterTable::FlySpeed' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, FlyAcceleration) == 0x000058, "Member 'FAnimalParameterTable::FlyAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, FlyDeceleration) == 0x00005C, "Member 'FAnimalParameterTable::FlyDeceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, GlideSpeed) == 0x000060, "Member 'FAnimalParameterTable::GlideSpeed' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, GlideAcceleration) == 0x000064, "Member 'FAnimalParameterTable::GlideAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, GlideDeceleration) == 0x000068, "Member 'FAnimalParameterTable::GlideDeceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DiveSpeed) == 0x00006C, "Member 'FAnimalParameterTable::DiveSpeed' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DiveAcceleration) == 0x000070, "Member 'FAnimalParameterTable::DiveAcceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DiveDeceleration) == 0x000074, "Member 'FAnimalParameterTable::DiveDeceleration' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, FlyTime) == 0x000078, "Member 'FAnimalParameterTable::FlyTime' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, GlideTime) == 0x00007C, "Member 'FAnimalParameterTable::GlideTime' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DiveStartAngle) == 0x000080, "Member 'FAnimalParameterTable::DiveStartAngle' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DiveEndAngle) == 0x000084, "Member 'FAnimalParameterTable::DiveEndAngle' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, RandamTime) == 0x000088, "Member 'FAnimalParameterTable::RandamTime' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, HP) == 0x00008C, "Member 'FAnimalParameterTable::HP' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DownPower) == 0x000090, "Member 'FAnimalParameterTable::DownPower' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DownTime) == 0x000094, "Member 'FAnimalParameterTable::DownTime' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, FalterDamage) == 0x000098, "Member 'FAnimalParameterTable::FalterDamage' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DropDistanceMin) == 0x00009C, "Member 'FAnimalParameterTable::DropDistanceMin' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DropDistanceMax) == 0x0000A0, "Member 'FAnimalParameterTable::DropDistanceMax' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DropHeight) == 0x0000A4, "Member 'FAnimalParameterTable::DropHeight' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, DropAngle) == 0x0000A8, "Member 'FAnimalParameterTable::DropAngle' has a wrong offset!");
static_assert(offsetof(FAnimalParameterTable, SpawnRatio) == 0x0000AC, "Member 'FAnimalParameterTable::SpawnRatio' has a wrong offset!");

// ScriptStruct AT.NpcMontageInfo
// 0x0170 (0x0170 - 0x0000)
struct FNpcMontageInfo final
{
public:
	ENpcMobType                                   MobType;                                           // 0x0000(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UAnimMontage>            Greeting;                                          // 0x0008(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Sit;                                               // 0x0030(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Surprise1;                                         // 0x0058(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Surprise2;                                         // 0x0080(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StaggerFront;                                      // 0x00A8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StaggerBack;                                       // 0x00D0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            Surprise3;                                         // 0x00F8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SitStaggerFront;                                   // 0x0120(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            SitStaggerBack;                                    // 0x0148(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcMontageInfo) == 0x000008, "Wrong alignment on FNpcMontageInfo");
static_assert(sizeof(FNpcMontageInfo) == 0x000170, "Wrong size on FNpcMontageInfo");
static_assert(offsetof(FNpcMontageInfo, MobType) == 0x000000, "Member 'FNpcMontageInfo::MobType' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, Greeting) == 0x000008, "Member 'FNpcMontageInfo::Greeting' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, Sit) == 0x000030, "Member 'FNpcMontageInfo::Sit' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, Surprise1) == 0x000058, "Member 'FNpcMontageInfo::Surprise1' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, Surprise2) == 0x000080, "Member 'FNpcMontageInfo::Surprise2' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, StaggerFront) == 0x0000A8, "Member 'FNpcMontageInfo::StaggerFront' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, StaggerBack) == 0x0000D0, "Member 'FNpcMontageInfo::StaggerBack' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, Surprise3) == 0x0000F8, "Member 'FNpcMontageInfo::Surprise3' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, SitStaggerFront) == 0x000120, "Member 'FNpcMontageInfo::SitStaggerFront' has a wrong offset!");
static_assert(offsetof(FNpcMontageInfo, SitStaggerBack) == 0x000148, "Member 'FNpcMontageInfo::SitStaggerBack' has a wrong offset!");

// ScriptStruct AT.NpcLoadMontageTable
// 0x0010 (0x0018 - 0x0008)
struct FNpcLoadMontageTable final : public FTableRowBase
{
public:
	TArray<struct FNpcMontageInfo>                LoadInfo;                                          // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNpcLoadMontageTable) == 0x000008, "Wrong alignment on FNpcLoadMontageTable");
static_assert(sizeof(FNpcLoadMontageTable) == 0x000018, "Wrong size on FNpcLoadMontageTable");
static_assert(offsetof(FNpcLoadMontageTable, LoadInfo) == 0x000008, "Member 'FNpcLoadMontageTable::LoadInfo' has a wrong offset!");

// ScriptStruct AT.NpcAreaSetInfo
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FNpcAreaSetInfo final
{
public:
	class FName                                   GroupId;                                           // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Proportion;                                        // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcAreaSetInfo) == 0x000008, "Wrong alignment on FNpcAreaSetInfo");
static_assert(sizeof(FNpcAreaSetInfo) == 0x000010, "Wrong size on FNpcAreaSetInfo");
static_assert(offsetof(FNpcAreaSetInfo, GroupId) == 0x000000, "Member 'FNpcAreaSetInfo::GroupId' has a wrong offset!");
static_assert(offsetof(FNpcAreaSetInfo, Proportion) == 0x000008, "Member 'FNpcAreaSetInfo::Proportion' has a wrong offset!");

// ScriptStruct AT.NpcAreaPreset
// 0x0018 (0x0020 - 0x0008)
struct FNpcAreaPreset final : public FTableRowBase
{
public:
	TArray<struct FNpcAreaSetInfo>                GroupList;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcAreaPreset) == 0x000008, "Wrong alignment on FNpcAreaPreset");
static_assert(sizeof(FNpcAreaPreset) == 0x000020, "Wrong size on FNpcAreaPreset");
static_assert(offsetof(FNpcAreaPreset, GroupList) == 0x000008, "Member 'FNpcAreaPreset::GroupList' has a wrong offset!");

// ScriptStruct AT.NpcPreset
// 0x0020 (0x0028 - 0x0008)
struct FNpcPreset final : public FTableRowBase
{
public:
	ENpcMobType                                   MobType;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FNpcParts>                      PartsList;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDisableOverridedAnimation;                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcPreset) == 0x000008, "Wrong alignment on FNpcPreset");
static_assert(sizeof(FNpcPreset) == 0x000028, "Wrong size on FNpcPreset");
static_assert(offsetof(FNpcPreset, MobType) == 0x000008, "Member 'FNpcPreset::MobType' has a wrong offset!");
static_assert(offsetof(FNpcPreset, PartsList) == 0x000010, "Member 'FNpcPreset::PartsList' has a wrong offset!");
static_assert(offsetof(FNpcPreset, bDisableOverridedAnimation) == 0x000020, "Member 'FNpcPreset::bDisableOverridedAnimation' has a wrong offset!");

// ScriptStruct AT.NpcActionEventInfo
// 0x0014 (0x0014 - 0x0000)
struct alignas(0x04) FNpcActionEventInfo final
{
public:
	uint8                                         Pad_0[0x14];                                       // 0x0000(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcActionEventInfo) == 0x000004, "Wrong alignment on FNpcActionEventInfo");
static_assert(sizeof(FNpcActionEventInfo) == 0x000014, "Wrong size on FNpcActionEventInfo");

// ScriptStruct AT.MobActionTbl
// 0x0008 (0x0010 - 0x0008)
struct FMobActionTbl final : public FTableRowBase
{
public:
	int32                                         ActionPriority;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitTime;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMobActionTbl) == 0x000008, "Wrong alignment on FMobActionTbl");
static_assert(sizeof(FMobActionTbl) == 0x000010, "Wrong size on FMobActionTbl");
static_assert(offsetof(FMobActionTbl, ActionPriority) == 0x000008, "Member 'FMobActionTbl::ActionPriority' has a wrong offset!");
static_assert(offsetof(FMobActionTbl, WaitTime) == 0x00000C, "Member 'FMobActionTbl::WaitTime' has a wrong offset!");

// ScriptStruct AT.MobProgressParam
// 0x0028 (0x0030 - 0x0008)
struct FMobProgressParam final : public FTableRowBase
{
public:
	class FName                                   DlcId;                                             // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressBegin;                                     // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressEnd;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HumanSpawnMax;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMobProgressParam) == 0x000008, "Wrong alignment on FMobProgressParam");
static_assert(sizeof(FMobProgressParam) == 0x000030, "Wrong size on FMobProgressParam");
static_assert(offsetof(FMobProgressParam, DlcId) == 0x000008, "Member 'FMobProgressParam::DlcId' has a wrong offset!");
static_assert(offsetof(FMobProgressParam, ProgressBegin) == 0x000010, "Member 'FMobProgressParam::ProgressBegin' has a wrong offset!");
static_assert(offsetof(FMobProgressParam, ProgressEnd) == 0x000018, "Member 'FMobProgressParam::ProgressEnd' has a wrong offset!");
static_assert(offsetof(FMobProgressParam, AreaName) == 0x000020, "Member 'FMobProgressParam::AreaName' has a wrong offset!");
static_assert(offsetof(FMobProgressParam, HumanSpawnMax) == 0x000028, "Member 'FMobProgressParam::HumanSpawnMax' has a wrong offset!");

// ScriptStruct AT.NpcSplineInfo
// 0x0010 (0x0010 - 0x0000)
struct FNpcSplineInfo final
{
public:
	TWeakObjectPtr<class ANpcSplineActor>         Spline;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Probability;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SecretPath;                                        // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNpcSplineInfo) == 0x000004, "Wrong alignment on FNpcSplineInfo");
static_assert(sizeof(FNpcSplineInfo) == 0x000010, "Wrong size on FNpcSplineInfo");
static_assert(offsetof(FNpcSplineInfo, Spline) == 0x000000, "Member 'FNpcSplineInfo::Spline' has a wrong offset!");
static_assert(offsetof(FNpcSplineInfo, Probability) == 0x000008, "Member 'FNpcSplineInfo::Probability' has a wrong offset!");
static_assert(offsetof(FNpcSplineInfo, SecretPath) == 0x00000C, "Member 'FNpcSplineInfo::SecretPath' has a wrong offset!");

// ScriptStruct AT.OptionSampleSoundData
// 0x0008 (0x0010 - 0x0008)
struct FOptionSampleSoundData final : public FTableRowBase
{
public:
	ELanguageType                                 LangType;                                          // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBgmCode                                      bgm_code;                                          // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlBattleVoice_ID                             Voice_code;                                        // 0x000A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Voice_chara;                                       // 0x000B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlBattleVoice_ID                             Voice_code_demo;                                   // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Voice_chara_demo;                                  // 0x000D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlBattleVoice_ID                             Voice_code_controller;                             // 0x000E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Voice_chara_controller;                            // 0x000F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOptionSampleSoundData) == 0x000008, "Wrong alignment on FOptionSampleSoundData");
static_assert(sizeof(FOptionSampleSoundData) == 0x000010, "Wrong size on FOptionSampleSoundData");
static_assert(offsetof(FOptionSampleSoundData, LangType) == 0x000008, "Member 'FOptionSampleSoundData::LangType' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, bgm_code) == 0x000009, "Member 'FOptionSampleSoundData::bgm_code' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, Voice_code) == 0x00000A, "Member 'FOptionSampleSoundData::Voice_code' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, Voice_chara) == 0x00000B, "Member 'FOptionSampleSoundData::Voice_chara' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, Voice_code_demo) == 0x00000C, "Member 'FOptionSampleSoundData::Voice_code_demo' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, Voice_chara_demo) == 0x00000D, "Member 'FOptionSampleSoundData::Voice_chara_demo' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, Voice_code_controller) == 0x00000E, "Member 'FOptionSampleSoundData::Voice_code_controller' has a wrong offset!");
static_assert(offsetof(FOptionSampleSoundData, Voice_chara_controller) == 0x00000F, "Member 'FOptionSampleSoundData::Voice_chara_controller' has a wrong offset!");

// ScriptStruct AT.PassiveSkillSlotReleaseTable
// 0x0010 (0x0018 - 0x0008)
struct FPassiveSkillSlotReleaseTable final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               Character;                                         // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Slot;                                              // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ConditionsId;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassiveSkillSlotReleaseTable) == 0x000008, "Wrong alignment on FPassiveSkillSlotReleaseTable");
static_assert(sizeof(FPassiveSkillSlotReleaseTable) == 0x000018, "Wrong size on FPassiveSkillSlotReleaseTable");
static_assert(offsetof(FPassiveSkillSlotReleaseTable, Character) == 0x000008, "Member 'FPassiveSkillSlotReleaseTable::Character' has a wrong offset!");
static_assert(offsetof(FPassiveSkillSlotReleaseTable, Slot) == 0x00000C, "Member 'FPassiveSkillSlotReleaseTable::Slot' has a wrong offset!");
static_assert(offsetof(FPassiveSkillSlotReleaseTable, ConditionsId) == 0x000010, "Member 'FPassiveSkillSlotReleaseTable::ConditionsId' has a wrong offset!");

// ScriptStruct AT.ProceduralData
// 0x0028 (0x0028 - 0x0000)
struct FProceduralData final
{
public:
	class UStaticMesh*                            ProceduralMesh;                                    // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCollision;                                  // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CullDistance;                                      // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCastShadow;                                       // 0x0010(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EProceduralDataMeshDestructType               DestructType;                                      // 0x0011(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeSpan;                                          // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ParentClass;                                       // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CollisionProfileName;                              // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProceduralData) == 0x000008, "Wrong alignment on FProceduralData");
static_assert(sizeof(FProceduralData) == 0x000028, "Wrong size on FProceduralData");
static_assert(offsetof(FProceduralData, ProceduralMesh) == 0x000000, "Member 'FProceduralData::ProceduralMesh' has a wrong offset!");
static_assert(offsetof(FProceduralData, bEnableCollision) == 0x000008, "Member 'FProceduralData::bEnableCollision' has a wrong offset!");
static_assert(offsetof(FProceduralData, CullDistance) == 0x00000C, "Member 'FProceduralData::CullDistance' has a wrong offset!");
static_assert(offsetof(FProceduralData, bCastShadow) == 0x000010, "Member 'FProceduralData::bCastShadow' has a wrong offset!");
static_assert(offsetof(FProceduralData, DestructType) == 0x000011, "Member 'FProceduralData::DestructType' has a wrong offset!");
static_assert(offsetof(FProceduralData, LifeSpan) == 0x000014, "Member 'FProceduralData::LifeSpan' has a wrong offset!");
static_assert(offsetof(FProceduralData, ParentClass) == 0x000018, "Member 'FProceduralData::ParentClass' has a wrong offset!");
static_assert(offsetof(FProceduralData, CollisionProfileName) == 0x000020, "Member 'FProceduralData::CollisionProfileName' has a wrong offset!");

// ScriptStruct AT.ProcedualLinkedActorData
// 0x0018 (0x0018 - 0x0000)
struct FProcedualLinkedActorData final
{
public:
	class UPrimitiveComponent*                    RenderedMeshComponent;                             // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ABreakableDestructibleActor*            ResourceDestructibleActor;                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FProcedualLinkedActorData) == 0x000008, "Wrong alignment on FProcedualLinkedActorData");
static_assert(sizeof(FProcedualLinkedActorData) == 0x000018, "Wrong size on FProcedualLinkedActorData");
static_assert(offsetof(FProcedualLinkedActorData, RenderedMeshComponent) == 0x000000, "Member 'FProcedualLinkedActorData::RenderedMeshComponent' has a wrong offset!");
static_assert(offsetof(FProcedualLinkedActorData, ResourceDestructibleActor) == 0x000008, "Member 'FProcedualLinkedActorData::ResourceDestructibleActor' has a wrong offset!");

// ScriptStruct AT.ProjectileCpl034SkillPunishStormExplosionData
// 0x0018 (0x0018 - 0x0000)
struct FProjectileCpl034SkillPunishStormExplosionData final
{
public:
	struct FVector                                ExplodeOffsetPosition;                             // 0x0000(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUpdatePosition;                                 // 0x000C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetPosReferenceFrame;                           // 0x0010(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetHeightOffset;                                // 0x0014(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectileCpl034SkillPunishStormExplosionData) == 0x000004, "Wrong alignment on FProjectileCpl034SkillPunishStormExplosionData");
static_assert(sizeof(FProjectileCpl034SkillPunishStormExplosionData) == 0x000018, "Wrong size on FProjectileCpl034SkillPunishStormExplosionData");
static_assert(offsetof(FProjectileCpl034SkillPunishStormExplosionData, ExplodeOffsetPosition) == 0x000000, "Member 'FProjectileCpl034SkillPunishStormExplosionData::ExplodeOffsetPosition' has a wrong offset!");
static_assert(offsetof(FProjectileCpl034SkillPunishStormExplosionData, bIsUpdatePosition) == 0x00000C, "Member 'FProjectileCpl034SkillPunishStormExplosionData::bIsUpdatePosition' has a wrong offset!");
static_assert(offsetof(FProjectileCpl034SkillPunishStormExplosionData, TargetPosReferenceFrame) == 0x000010, "Member 'FProjectileCpl034SkillPunishStormExplosionData::TargetPosReferenceFrame' has a wrong offset!");
static_assert(offsetof(FProjectileCpl034SkillPunishStormExplosionData, TargetHeightOffset) == 0x000014, "Member 'FProjectileCpl034SkillPunishStormExplosionData::TargetHeightOffset' has a wrong offset!");

// ScriptStruct AT.EnemyKidan_Param
// 0x0018 (0x0018 - 0x0000)
struct FEnemyKidan_Param final
{
public:
	float                                         Force;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrontForce;                                        // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SideFrontForce;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnRoute;                                           // 0x000C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DiffusionLenght;                                   // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomingTime;                                        // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnemyKidan_Param) == 0x000004, "Wrong alignment on FEnemyKidan_Param");
static_assert(sizeof(FEnemyKidan_Param) == 0x000018, "Wrong size on FEnemyKidan_Param");
static_assert(offsetof(FEnemyKidan_Param, Force) == 0x000000, "Member 'FEnemyKidan_Param::Force' has a wrong offset!");
static_assert(offsetof(FEnemyKidan_Param, FrontForce) == 0x000004, "Member 'FEnemyKidan_Param::FrontForce' has a wrong offset!");
static_assert(offsetof(FEnemyKidan_Param, SideFrontForce) == 0x000008, "Member 'FEnemyKidan_Param::SideFrontForce' has a wrong offset!");
static_assert(offsetof(FEnemyKidan_Param, EnRoute) == 0x00000C, "Member 'FEnemyKidan_Param::EnRoute' has a wrong offset!");
static_assert(offsetof(FEnemyKidan_Param, DiffusionLenght) == 0x000010, "Member 'FEnemyKidan_Param::DiffusionLenght' has a wrong offset!");
static_assert(offsetof(FEnemyKidan_Param, HomingTime) == 0x000014, "Member 'FEnemyKidan_Param::HomingTime' has a wrong offset!");

// ScriptStruct AT.GhostTrailInfo
// 0x0018 (0x0018 - 0x0000)
struct FGhostTrailInfo final
{
public:
	class UParticleSystem*                        TrailParticle;                                     // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstSocket;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SecondSocket;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGhostTrailInfo) == 0x000008, "Wrong alignment on FGhostTrailInfo");
static_assert(sizeof(FGhostTrailInfo) == 0x000018, "Wrong size on FGhostTrailInfo");
static_assert(offsetof(FGhostTrailInfo, TrailParticle) == 0x000000, "Member 'FGhostTrailInfo::TrailParticle' has a wrong offset!");
static_assert(offsetof(FGhostTrailInfo, FirstSocket) == 0x000008, "Member 'FGhostTrailInfo::FirstSocket' has a wrong offset!");
static_assert(offsetof(FGhostTrailInfo, SecondSocket) == 0x000010, "Member 'FGhostTrailInfo::SecondSocket' has a wrong offset!");

// ScriptStruct AT.ZigZagShotProjectileParam
// 0x0028 (0x0028 - 0x0000)
struct FZigZagShotProjectileParam final
{
public:
	class UParticleSystem*                        ParticleProjectile;                                // 0x0000(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ParticleFire;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        HitEffect;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        VanishEffect;                                      // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Speed;                                             // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZigZagShotProjectileParam) == 0x000008, "Wrong alignment on FZigZagShotProjectileParam");
static_assert(sizeof(FZigZagShotProjectileParam) == 0x000028, "Wrong size on FZigZagShotProjectileParam");
static_assert(offsetof(FZigZagShotProjectileParam, ParticleProjectile) == 0x000000, "Member 'FZigZagShotProjectileParam::ParticleProjectile' has a wrong offset!");
static_assert(offsetof(FZigZagShotProjectileParam, ParticleFire) == 0x000008, "Member 'FZigZagShotProjectileParam::ParticleFire' has a wrong offset!");
static_assert(offsetof(FZigZagShotProjectileParam, HitEffect) == 0x000010, "Member 'FZigZagShotProjectileParam::HitEffect' has a wrong offset!");
static_assert(offsetof(FZigZagShotProjectileParam, VanishEffect) == 0x000018, "Member 'FZigZagShotProjectileParam::VanishEffect' has a wrong offset!");
static_assert(offsetof(FZigZagShotProjectileParam, SphereRadius) == 0x000020, "Member 'FZigZagShotProjectileParam::SphereRadius' has a wrong offset!");
static_assert(offsetof(FZigZagShotProjectileParam, Speed) == 0x000024, "Member 'FZigZagShotProjectileParam::Speed' has a wrong offset!");

// ScriptStruct AT.AnotherMessageIdForTitleCall
// 0x0010 (0x0018 - 0x0008)
struct FAnotherMessageIdForTitleCall final : public FTableRowBase
{
public:
	class FString                                 Title_id;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAnotherMessageIdForTitleCall) == 0x000008, "Wrong alignment on FAnotherMessageIdForTitleCall");
static_assert(sizeof(FAnotherMessageIdForTitleCall) == 0x000018, "Wrong size on FAnotherMessageIdForTitleCall");
static_assert(offsetof(FAnotherMessageIdForTitleCall, Title_id) == 0x000008, "Member 'FAnotherMessageIdForTitleCall::Title_id' has a wrong offset!");

// ScriptStruct AT.QuestTalkExchangeItemParam
// 0x0040 (0x0048 - 0x0008)
struct FQuestTalkExchangeItemParam final : public FTableRowBase
{
public:
	class FName                                   TitleMessageId;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemMessageId;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NoActionMessageId;                                 // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FExchangeItemData>              ExchangeItems;                                     // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   NoActionRequestCommand;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExchangeFaildNoBeforeItemRequestCommand;           // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExchangeFaildMaxAfterItemRequestCommand;           // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestTalkExchangeItemParam) == 0x000008, "Wrong alignment on FQuestTalkExchangeItemParam");
static_assert(sizeof(FQuestTalkExchangeItemParam) == 0x000048, "Wrong size on FQuestTalkExchangeItemParam");
static_assert(offsetof(FQuestTalkExchangeItemParam, TitleMessageId) == 0x000008, "Member 'FQuestTalkExchangeItemParam::TitleMessageId' has a wrong offset!");
static_assert(offsetof(FQuestTalkExchangeItemParam, ItemMessageId) == 0x000010, "Member 'FQuestTalkExchangeItemParam::ItemMessageId' has a wrong offset!");
static_assert(offsetof(FQuestTalkExchangeItemParam, NoActionMessageId) == 0x000018, "Member 'FQuestTalkExchangeItemParam::NoActionMessageId' has a wrong offset!");
static_assert(offsetof(FQuestTalkExchangeItemParam, ExchangeItems) == 0x000020, "Member 'FQuestTalkExchangeItemParam::ExchangeItems' has a wrong offset!");
static_assert(offsetof(FQuestTalkExchangeItemParam, NoActionRequestCommand) == 0x000030, "Member 'FQuestTalkExchangeItemParam::NoActionRequestCommand' has a wrong offset!");
static_assert(offsetof(FQuestTalkExchangeItemParam, ExchangeFaildNoBeforeItemRequestCommand) == 0x000038, "Member 'FQuestTalkExchangeItemParam::ExchangeFaildNoBeforeItemRequestCommand' has a wrong offset!");
static_assert(offsetof(FQuestTalkExchangeItemParam, ExchangeFaildMaxAfterItemRequestCommand) == 0x000040, "Member 'FQuestTalkExchangeItemParam::ExchangeFaildMaxAfterItemRequestCommand' has a wrong offset!");

// ScriptStruct AT.QuestPhaseAutoSaveRestriction
// 0x0010 (0x0018 - 0x0008)
struct FQuestPhaseAutoSaveRestriction final : public FTableRowBase
{
public:
	TArray<class FName>                           BannedAreaNameList;                                // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestPhaseAutoSaveRestriction) == 0x000008, "Wrong alignment on FQuestPhaseAutoSaveRestriction");
static_assert(sizeof(FQuestPhaseAutoSaveRestriction) == 0x000018, "Wrong size on FQuestPhaseAutoSaveRestriction");
static_assert(offsetof(FQuestPhaseAutoSaveRestriction, BannedAreaNameList) == 0x000008, "Member 'FQuestPhaseAutoSaveRestriction::BannedAreaNameList' has a wrong offset!");

// ScriptStruct AT.SoundDebugStruct
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSoundDebugStruct final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSoundDebugStruct) == 0x000008, "Wrong alignment on FSoundDebugStruct");
static_assert(sizeof(FSoundDebugStruct) == 0x000018, "Wrong size on FSoundDebugStruct");

// ScriptStruct AT.QuestEventBattleSequence
// 0x0018 (0x0020 - 0x0008)
struct FQuestEventBattleSequence final : public FTableRowBase
{
public:
	class FName                                   RequiredId;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredCount;                                     // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EventBattleID;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestEventBattleSequence) == 0x000008, "Wrong alignment on FQuestEventBattleSequence");
static_assert(sizeof(FQuestEventBattleSequence) == 0x000020, "Wrong size on FQuestEventBattleSequence");
static_assert(offsetof(FQuestEventBattleSequence, RequiredId) == 0x000008, "Member 'FQuestEventBattleSequence::RequiredId' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleSequence, RequiredCount) == 0x000010, "Member 'FQuestEventBattleSequence::RequiredCount' has a wrong offset!");
static_assert(offsetof(FQuestEventBattleSequence, EventBattleID) == 0x000018, "Member 'FQuestEventBattleSequence::EventBattleID' has a wrong offset!");

// ScriptStruct AT.TimemachineMenu
// 0x0090 (0x0098 - 0x0008)
struct FTimemachineMenu final : public FTableRowBase
{
public:
	int32                                         Episode_num;                                       // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Quest_id;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Quest_id_end;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Chapter_id;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Summary;                                           // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<ECHARACTER_TYPE>                       CharacterList;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bSubquest;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Start_area;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsStartSubQuest;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Sub_quest_id;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Start_main_quest_phase_no;                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Start_sub_quest_phase_no;                          // 0x007C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Draw_quest_id;                                     // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TexturePath;                                       // 0x0088(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTimemachineMenu) == 0x000008, "Wrong alignment on FTimemachineMenu");
static_assert(sizeof(FTimemachineMenu) == 0x000098, "Wrong size on FTimemachineMenu");
static_assert(offsetof(FTimemachineMenu, Episode_num) == 0x000008, "Member 'FTimemachineMenu::Episode_num' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Quest_id) == 0x000010, "Member 'FTimemachineMenu::Quest_id' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Quest_id_end) == 0x000018, "Member 'FTimemachineMenu::Quest_id_end' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Chapter_id) == 0x000020, "Member 'FTimemachineMenu::Chapter_id' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Title) == 0x000028, "Member 'FTimemachineMenu::Title' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Summary) == 0x000038, "Member 'FTimemachineMenu::Summary' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, CharacterList) == 0x000048, "Member 'FTimemachineMenu::CharacterList' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, bSubquest) == 0x000058, "Member 'FTimemachineMenu::bSubquest' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Start_area) == 0x000060, "Member 'FTimemachineMenu::Start_area' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, bIsStartSubQuest) == 0x000068, "Member 'FTimemachineMenu::bIsStartSubQuest' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Sub_quest_id) == 0x000070, "Member 'FTimemachineMenu::Sub_quest_id' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Start_main_quest_phase_no) == 0x000078, "Member 'FTimemachineMenu::Start_main_quest_phase_no' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Start_sub_quest_phase_no) == 0x00007C, "Member 'FTimemachineMenu::Start_sub_quest_phase_no' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, Draw_quest_id) == 0x000080, "Member 'FTimemachineMenu::Draw_quest_id' has a wrong offset!");
static_assert(offsetof(FTimemachineMenu, TexturePath) == 0x000088, "Member 'FTimemachineMenu::TexturePath' has a wrong offset!");

// ScriptStruct AT.ArrivalPhaseCondition
// 0x0008 (0x0010 - 0x0008)
struct FArrivalPhaseCondition final : public FTableRowBase
{
public:
	class FName                                   UniqueId;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FArrivalPhaseCondition) == 0x000008, "Wrong alignment on FArrivalPhaseCondition");
static_assert(sizeof(FArrivalPhaseCondition) == 0x000010, "Wrong size on FArrivalPhaseCondition");
static_assert(offsetof(FArrivalPhaseCondition, UniqueId) == 0x000008, "Member 'FArrivalPhaseCondition::UniqueId' has a wrong offset!");

// ScriptStruct AT.CharacterTypeProgressSet
// 0x0020 (0x0028 - 0x0008)
struct FCharacterTypeProgressSet final : public FTableRowBase
{
public:
	class FName                                   UniqueId;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressIdStart;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProgressIdEnd;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               ResultType;                                        // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterTypeProgressSet) == 0x000008, "Wrong alignment on FCharacterTypeProgressSet");
static_assert(sizeof(FCharacterTypeProgressSet) == 0x000028, "Wrong size on FCharacterTypeProgressSet");
static_assert(offsetof(FCharacterTypeProgressSet, UniqueId) == 0x000008, "Member 'FCharacterTypeProgressSet::UniqueId' has a wrong offset!");
static_assert(offsetof(FCharacterTypeProgressSet, ProgressIdStart) == 0x000010, "Member 'FCharacterTypeProgressSet::ProgressIdStart' has a wrong offset!");
static_assert(offsetof(FCharacterTypeProgressSet, ProgressIdEnd) == 0x000018, "Member 'FCharacterTypeProgressSet::ProgressIdEnd' has a wrong offset!");
static_assert(offsetof(FCharacterTypeProgressSet, ResultType) == 0x000020, "Member 'FCharacterTypeProgressSet::ResultType' has a wrong offset!");

// ScriptStruct AT.CharacterPriority
// 0x0008 (0x0010 - 0x0008)
struct FCharacterPriority final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               CharacterType;                                     // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Order;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterPriority) == 0x000008, "Wrong alignment on FCharacterPriority");
static_assert(sizeof(FCharacterPriority) == 0x000010, "Wrong size on FCharacterPriority");
static_assert(offsetof(FCharacterPriority, CharacterType) == 0x000008, "Member 'FCharacterPriority::CharacterType' has a wrong offset!");
static_assert(offsetof(FCharacterPriority, Order) == 0x00000C, "Member 'FCharacterPriority::Order' has a wrong offset!");

// ScriptStruct AT.QuestPartyOrganizeCondition
// 0x0038 (0x0040 - 0x0008)
struct FQuestPartyOrganizeCondition final : public FTableRowBase
{
public:
	class FName                                   QuestStartID;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseStartId;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestEndID;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseEndId;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLockPlayer;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLockSupport1;                                    // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLockSupport2;                                    // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B[0x5];                                       // 0x002B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECHARACTER_TYPE>                       OrganizeCharacter;                                 // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestPartyOrganizeCondition) == 0x000008, "Wrong alignment on FQuestPartyOrganizeCondition");
static_assert(sizeof(FQuestPartyOrganizeCondition) == 0x000040, "Wrong size on FQuestPartyOrganizeCondition");
static_assert(offsetof(FQuestPartyOrganizeCondition, QuestStartID) == 0x000008, "Member 'FQuestPartyOrganizeCondition::QuestStartID' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, PhaseStartId) == 0x000010, "Member 'FQuestPartyOrganizeCondition::PhaseStartId' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, QuestEndID) == 0x000018, "Member 'FQuestPartyOrganizeCondition::QuestEndID' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, PhaseEndId) == 0x000020, "Member 'FQuestPartyOrganizeCondition::PhaseEndId' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, IsLockPlayer) == 0x000028, "Member 'FQuestPartyOrganizeCondition::IsLockPlayer' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, IsLockSupport1) == 0x000029, "Member 'FQuestPartyOrganizeCondition::IsLockSupport1' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, IsLockSupport2) == 0x00002A, "Member 'FQuestPartyOrganizeCondition::IsLockSupport2' has a wrong offset!");
static_assert(offsetof(FQuestPartyOrganizeCondition, OrganizeCharacter) == 0x000030, "Member 'FQuestPartyOrganizeCondition::OrganizeCharacter' has a wrong offset!");

// ScriptStruct AT.QuestPartyCondition
// 0x0008 (0x0010 - 0x0008)
struct FQuestPartyCondition final : public FTableRowBase
{
public:
	ECHARACTER_TYPE                               SupportCharacter_1;                                // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SupportCharacter_2;                                // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestPartyCondition) == 0x000008, "Wrong alignment on FQuestPartyCondition");
static_assert(sizeof(FQuestPartyCondition) == 0x000010, "Wrong size on FQuestPartyCondition");
static_assert(offsetof(FQuestPartyCondition, SupportCharacter_1) == 0x000008, "Member 'FQuestPartyCondition::SupportCharacter_1' has a wrong offset!");
static_assert(offsetof(FQuestPartyCondition, SupportCharacter_2) == 0x000009, "Member 'FQuestPartyCondition::SupportCharacter_2' has a wrong offset!");

// ScriptStruct AT.QuestInstanceMap
// 0x0058 (0x0060 - 0x0008)
struct FQuestInstanceMap final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   QuestInstance;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdBegin;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingProgressIdEnd;                              // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingExtendProgressIdBegin;                      // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LoadingExtendProgressIdEnd;                        // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RequiredDlcId;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnabledWaitForDynamicLoading;                     // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestInstanceMap) == 0x000008, "Wrong alignment on FQuestInstanceMap");
static_assert(sizeof(FQuestInstanceMap) == 0x000060, "Wrong size on FQuestInstanceMap");
static_assert(offsetof(FQuestInstanceMap, QuestInstance) == 0x000008, "Member 'FQuestInstanceMap::QuestInstance' has a wrong offset!");
static_assert(offsetof(FQuestInstanceMap, LoadingProgressIdBegin) == 0x000030, "Member 'FQuestInstanceMap::LoadingProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FQuestInstanceMap, LoadingProgressIdEnd) == 0x000038, "Member 'FQuestInstanceMap::LoadingProgressIdEnd' has a wrong offset!");
static_assert(offsetof(FQuestInstanceMap, LoadingExtendProgressIdBegin) == 0x000040, "Member 'FQuestInstanceMap::LoadingExtendProgressIdBegin' has a wrong offset!");
static_assert(offsetof(FQuestInstanceMap, LoadingExtendProgressIdEnd) == 0x000048, "Member 'FQuestInstanceMap::LoadingExtendProgressIdEnd' has a wrong offset!");
static_assert(offsetof(FQuestInstanceMap, RequiredDlcId) == 0x000050, "Member 'FQuestInstanceMap::RequiredDlcId' has a wrong offset!");
static_assert(offsetof(FQuestInstanceMap, bEnabledWaitForDynamicLoading) == 0x000058, "Member 'FQuestInstanceMap::bEnabledWaitForDynamicLoading' has a wrong offset!");

// ScriptStruct AT.QuestFormChangeDisableParam
// 0x0010 (0x0018 - 0x0008)
struct FQuestFormChangeDisableParam final : public FTableRowBase
{
public:
	TArray<class FName>                           Sparking;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestFormChangeDisableParam) == 0x000008, "Wrong alignment on FQuestFormChangeDisableParam");
static_assert(sizeof(FQuestFormChangeDisableParam) == 0x000018, "Wrong size on FQuestFormChangeDisableParam");
static_assert(offsetof(FQuestFormChangeDisableParam, Sparking) == 0x000008, "Member 'FQuestFormChangeDisableParam::Sparking' has a wrong offset!");

// ScriptStruct AT.ExtendQuestCostumeOverride
// 0x0038 (0x0040 - 0x0008)
struct FExtendQuestCostumeOverride final : public FTableRowBase
{
public:
	class FName                                   UniqueId;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaName;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Progress_id;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Phase_id;                                          // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   End_progress_id;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   End_phase_id;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         FormID;                                            // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         VariationId;                                       // 0x0039(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FExtendQuestCostumeOverride) == 0x000008, "Wrong alignment on FExtendQuestCostumeOverride");
static_assert(sizeof(FExtendQuestCostumeOverride) == 0x000040, "Wrong size on FExtendQuestCostumeOverride");
static_assert(offsetof(FExtendQuestCostumeOverride, UniqueId) == 0x000008, "Member 'FExtendQuestCostumeOverride::UniqueId' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, AreaName) == 0x000010, "Member 'FExtendQuestCostumeOverride::AreaName' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, Progress_id) == 0x000018, "Member 'FExtendQuestCostumeOverride::Progress_id' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, Phase_id) == 0x000020, "Member 'FExtendQuestCostumeOverride::Phase_id' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, End_progress_id) == 0x000028, "Member 'FExtendQuestCostumeOverride::End_progress_id' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, End_phase_id) == 0x000030, "Member 'FExtendQuestCostumeOverride::End_phase_id' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, FormID) == 0x000038, "Member 'FExtendQuestCostumeOverride::FormID' has a wrong offset!");
static_assert(offsetof(FExtendQuestCostumeOverride, VariationId) == 0x000039, "Member 'FExtendQuestCostumeOverride::VariationId' has a wrong offset!");

// ScriptStruct AT.QuestCostume
// 0x0048 (0x0050 - 0x0008)
struct FQuestCostume final : public FTableRowBase
{
public:
	class FName                                   Progress_id;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Phase_id;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   End_progress_id;                                   // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   End_phase_id;                                      // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Required_content_id;                               // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UniqueId;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Character_code;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Variation_id;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Form_id;                                           // 0x0041(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Facial_id;                                         // 0x0042(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Auto_form_change_id;                               // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestCostume) == 0x000008, "Wrong alignment on FQuestCostume");
static_assert(sizeof(FQuestCostume) == 0x000050, "Wrong size on FQuestCostume");
static_assert(offsetof(FQuestCostume, Progress_id) == 0x000008, "Member 'FQuestCostume::Progress_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Phase_id) == 0x000010, "Member 'FQuestCostume::Phase_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, End_progress_id) == 0x000018, "Member 'FQuestCostume::End_progress_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, End_phase_id) == 0x000020, "Member 'FQuestCostume::End_phase_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Required_content_id) == 0x000028, "Member 'FQuestCostume::Required_content_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, UniqueId) == 0x000030, "Member 'FQuestCostume::UniqueId' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Character_code) == 0x000038, "Member 'FQuestCostume::Character_code' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Variation_id) == 0x000040, "Member 'FQuestCostume::Variation_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Form_id) == 0x000041, "Member 'FQuestCostume::Form_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Facial_id) == 0x000042, "Member 'FQuestCostume::Facial_id' has a wrong offset!");
static_assert(offsetof(FQuestCostume, Auto_form_change_id) == 0x000048, "Member 'FQuestCostume::Auto_form_change_id' has a wrong offset!");

// ScriptStruct AT.QuestMessagePhaseParameter
// 0x0030 (0x0038 - 0x0008)
struct FQuestMessagePhaseParameter final : public FTableRowBase
{
public:
	class FString                                 MessageId;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         VariableIds;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IsSelectWindow;                                    // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   QuestItemId;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestMessagePhaseParameter) == 0x000008, "Wrong alignment on FQuestMessagePhaseParameter");
static_assert(sizeof(FQuestMessagePhaseParameter) == 0x000038, "Wrong size on FQuestMessagePhaseParameter");
static_assert(offsetof(FQuestMessagePhaseParameter, MessageId) == 0x000008, "Member 'FQuestMessagePhaseParameter::MessageId' has a wrong offset!");
static_assert(offsetof(FQuestMessagePhaseParameter, VariableIds) == 0x000018, "Member 'FQuestMessagePhaseParameter::VariableIds' has a wrong offset!");
static_assert(offsetof(FQuestMessagePhaseParameter, IsSelectWindow) == 0x000028, "Member 'FQuestMessagePhaseParameter::IsSelectWindow' has a wrong offset!");
static_assert(offsetof(FQuestMessagePhaseParameter, QuestItemId) == 0x000030, "Member 'FQuestMessagePhaseParameter::QuestItemId' has a wrong offset!");

// ScriptStruct AT.QuestRewardParamSet
// 0x0010 (0x0018 - 0x0008)
struct FQuestRewardParamSet final : public FTableRowBase
{
public:
	class FName                                   QuestRewardParam;                                  // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestRewardParamReplaying;                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestRewardParamSet) == 0x000008, "Wrong alignment on FQuestRewardParamSet");
static_assert(sizeof(FQuestRewardParamSet) == 0x000018, "Wrong size on FQuestRewardParamSet");
static_assert(offsetof(FQuestRewardParamSet, QuestRewardParam) == 0x000008, "Member 'FQuestRewardParamSet::QuestRewardParam' has a wrong offset!");
static_assert(offsetof(FQuestRewardParamSet, QuestRewardParamReplaying) == 0x000010, "Member 'FQuestRewardParamSet::QuestRewardParamReplaying' has a wrong offset!");

// ScriptStruct AT.QuestLiveTalkParam
// 0x0028 (0x0030 - 0x0008)
struct FQuestLiveTalkParam final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mes_id;                                            // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Disp_time;                                         // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Delay_time;                                        // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQUEST_XO                                     Check_play_player;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               Check_play_player_ctype;                           // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestLiveTalkParam) == 0x000008, "Wrong alignment on FQuestLiveTalkParam");
static_assert(sizeof(FQuestLiveTalkParam) == 0x000030, "Wrong size on FQuestLiveTalkParam");
static_assert(offsetof(FQuestLiveTalkParam, ID) == 0x000008, "Member 'FQuestLiveTalkParam::ID' has a wrong offset!");
static_assert(offsetof(FQuestLiveTalkParam, Mes_id) == 0x000010, "Member 'FQuestLiveTalkParam::Mes_id' has a wrong offset!");
static_assert(offsetof(FQuestLiveTalkParam, Disp_time) == 0x000020, "Member 'FQuestLiveTalkParam::Disp_time' has a wrong offset!");
static_assert(offsetof(FQuestLiveTalkParam, Delay_time) == 0x000024, "Member 'FQuestLiveTalkParam::Delay_time' has a wrong offset!");
static_assert(offsetof(FQuestLiveTalkParam, Check_play_player) == 0x000028, "Member 'FQuestLiveTalkParam::Check_play_player' has a wrong offset!");
static_assert(offsetof(FQuestLiveTalkParam, Check_play_player_ctype) == 0x000029, "Member 'FQuestLiveTalkParam::Check_play_player_ctype' has a wrong offset!");

// ScriptStruct AT.WindowClosedPhaseCondition
// 0x0018 (0x0020 - 0x0008)
struct FWindowClosedPhaseCondition final : public FTableRowBase
{
public:
	EQUEST_WINDOW_TYPE                            WindowType;                                        // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TutorialSimpleTalkId;                              // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ArgmentId;                                         // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FWindowClosedPhaseCondition) == 0x000008, "Wrong alignment on FWindowClosedPhaseCondition");
static_assert(sizeof(FWindowClosedPhaseCondition) == 0x000020, "Wrong size on FWindowClosedPhaseCondition");
static_assert(offsetof(FWindowClosedPhaseCondition, WindowType) == 0x000008, "Member 'FWindowClosedPhaseCondition::WindowType' has a wrong offset!");
static_assert(offsetof(FWindowClosedPhaseCondition, TutorialSimpleTalkId) == 0x000010, "Member 'FWindowClosedPhaseCondition::TutorialSimpleTalkId' has a wrong offset!");
static_assert(offsetof(FWindowClosedPhaseCondition, ArgmentId) == 0x000018, "Member 'FWindowClosedPhaseCondition::ArgmentId' has a wrong offset!");

// ScriptStruct AT.QuestRewardPhaseCondition
// 0x0020 (0x0028 - 0x0008)
struct FQuestRewardPhaseCondition final : public FTableRowBase
{
public:
	class FName                                   QuestRewardId;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDisplayDialog;                              // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DialogTitleMessageId;                              // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESndCodeCmn                                   RewardSE;                                          // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestRewardPhaseCondition) == 0x000008, "Wrong alignment on FQuestRewardPhaseCondition");
static_assert(sizeof(FQuestRewardPhaseCondition) == 0x000028, "Wrong size on FQuestRewardPhaseCondition");
static_assert(offsetof(FQuestRewardPhaseCondition, QuestRewardId) == 0x000008, "Member 'FQuestRewardPhaseCondition::QuestRewardId' has a wrong offset!");
static_assert(offsetof(FQuestRewardPhaseCondition, bEnableDisplayDialog) == 0x000010, "Member 'FQuestRewardPhaseCondition::bEnableDisplayDialog' has a wrong offset!");
static_assert(offsetof(FQuestRewardPhaseCondition, DialogTitleMessageId) == 0x000018, "Member 'FQuestRewardPhaseCondition::DialogTitleMessageId' has a wrong offset!");
static_assert(offsetof(FQuestRewardPhaseCondition, RewardSE) == 0x000020, "Member 'FQuestRewardPhaseCondition::RewardSE' has a wrong offset!");

// ScriptStruct AT.QuestItemParam
// 0x0038 (0x0040 - 0x0008)
struct FQuestItemParam final : public FTableRowBase
{
public:
	class FName                                   ID;                                                // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Item_id;                                           // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item_num;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Clear_force_end_phase;                             // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Clear_remove_quest_actor_group;                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Clear_live_talk_id;                                // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Not_navigation;                                    // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestItemParam) == 0x000008, "Wrong alignment on FQuestItemParam");
static_assert(sizeof(FQuestItemParam) == 0x000040, "Wrong size on FQuestItemParam");
static_assert(offsetof(FQuestItemParam, ID) == 0x000008, "Member 'FQuestItemParam::ID' has a wrong offset!");
static_assert(offsetof(FQuestItemParam, Item_id) == 0x000010, "Member 'FQuestItemParam::Item_id' has a wrong offset!");
static_assert(offsetof(FQuestItemParam, Item_num) == 0x000018, "Member 'FQuestItemParam::Item_num' has a wrong offset!");
static_assert(offsetof(FQuestItemParam, Clear_force_end_phase) == 0x000020, "Member 'FQuestItemParam::Clear_force_end_phase' has a wrong offset!");
static_assert(offsetof(FQuestItemParam, Clear_remove_quest_actor_group) == 0x000028, "Member 'FQuestItemParam::Clear_remove_quest_actor_group' has a wrong offset!");
static_assert(offsetof(FQuestItemParam, Clear_live_talk_id) == 0x000030, "Member 'FQuestItemParam::Clear_live_talk_id' has a wrong offset!");
static_assert(offsetof(FQuestItemParam, Not_navigation) == 0x000038, "Member 'FQuestItemParam::Not_navigation' has a wrong offset!");

// ScriptStruct AT.ConditionalSimpleTalkSet
// 0x0028 (0x0030 - 0x0008)
struct FConditionalSimpleTalkSet final : public FTableRowBase
{
public:
	class FName                                   ConditionalId;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SimpleTalkId;                                      // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   QuestId;                                           // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PhaseID;                                           // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               PlayerType;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               FirstSupportType;                                  // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               SecondSupportType;                                 // 0x002A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotUsingTimeMachine;                               // 0x002B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FConditionalSimpleTalkSet) == 0x000008, "Wrong alignment on FConditionalSimpleTalkSet");
static_assert(sizeof(FConditionalSimpleTalkSet) == 0x000030, "Wrong size on FConditionalSimpleTalkSet");
static_assert(offsetof(FConditionalSimpleTalkSet, ConditionalId) == 0x000008, "Member 'FConditionalSimpleTalkSet::ConditionalId' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, SimpleTalkId) == 0x000010, "Member 'FConditionalSimpleTalkSet::SimpleTalkId' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, QuestId) == 0x000018, "Member 'FConditionalSimpleTalkSet::QuestId' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, PhaseID) == 0x000020, "Member 'FConditionalSimpleTalkSet::PhaseID' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, PlayerType) == 0x000028, "Member 'FConditionalSimpleTalkSet::PlayerType' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, FirstSupportType) == 0x000029, "Member 'FConditionalSimpleTalkSet::FirstSupportType' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, SecondSupportType) == 0x00002A, "Member 'FConditionalSimpleTalkSet::SecondSupportType' has a wrong offset!");
static_assert(offsetof(FConditionalSimpleTalkSet, NotUsingTimeMachine) == 0x00002B, "Member 'FConditionalSimpleTalkSet::NotUsingTimeMachine' has a wrong offset!");

// ScriptStruct AT.SpawnDragonball
// 0x0030 (0x0038 - 0x0008)
struct FSpawnDragonball final : public FTableRowBase
{
public:
	int32                                         DragonballType;                                    // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SpawnPointList;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpawnProgress;                                     // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DespawnProgress;                                   // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSpawnDragonball) == 0x000008, "Wrong alignment on FSpawnDragonball");
static_assert(sizeof(FSpawnDragonball) == 0x000038, "Wrong size on FSpawnDragonball");
static_assert(offsetof(FSpawnDragonball, DragonballType) == 0x000008, "Member 'FSpawnDragonball::DragonballType' has a wrong offset!");
static_assert(offsetof(FSpawnDragonball, SpawnPointList) == 0x000010, "Member 'FSpawnDragonball::SpawnPointList' has a wrong offset!");
static_assert(offsetof(FSpawnDragonball, Rate) == 0x000020, "Member 'FSpawnDragonball::Rate' has a wrong offset!");
static_assert(offsetof(FSpawnDragonball, SpawnProgress) == 0x000028, "Member 'FSpawnDragonball::SpawnProgress' has a wrong offset!");
static_assert(offsetof(FSpawnDragonball, DespawnProgress) == 0x000030, "Member 'FSpawnDragonball::DespawnProgress' has a wrong offset!");

// ScriptStruct AT.QuestBGM
// 0x0018 (0x0020 - 0x0008)
struct FQuestBGM final : public FTableRowBase
{
public:
	EBgmCode                                      BgmCode;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StateName;                                         // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LayerOption;                                       // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestBGM) == 0x000008, "Wrong alignment on FQuestBGM");
static_assert(sizeof(FQuestBGM) == 0x000020, "Wrong size on FQuestBGM");
static_assert(offsetof(FQuestBGM, BgmCode) == 0x000008, "Member 'FQuestBGM::BgmCode' has a wrong offset!");
static_assert(offsetof(FQuestBGM, StateName) == 0x000010, "Member 'FQuestBGM::StateName' has a wrong offset!");
static_assert(offsetof(FQuestBGM, LayerOption) == 0x000018, "Member 'FQuestBGM::LayerOption' has a wrong offset!");

// ScriptStruct AT.QuestPurposeInfo
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FQuestPurposeInfo final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FQuestPurposeInfo) == 0x000008, "Wrong alignment on FQuestPurposeInfo");
static_assert(sizeof(FQuestPurposeInfo) == 0x000028, "Wrong size on FQuestPurposeInfo");

// ScriptStruct AT.MinigamePhaseCondition
// 0x0010 (0x0018 - 0x0008)
struct FMinigamePhaseCondition final : public FTableRowBase
{
public:
	class FName                                   MinigameName;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetActorName;                                   // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMinigamePhaseCondition) == 0x000008, "Wrong alignment on FMinigamePhaseCondition");
static_assert(sizeof(FMinigamePhaseCondition) == 0x000018, "Wrong size on FMinigamePhaseCondition");
static_assert(offsetof(FMinigamePhaseCondition, MinigameName) == 0x000008, "Member 'FMinigamePhaseCondition::MinigameName' has a wrong offset!");
static_assert(offsetof(FMinigamePhaseCondition, TargetActorName) == 0x000010, "Member 'FMinigamePhaseCondition::TargetActorName' has a wrong offset!");

// ScriptStruct AT.TalkPhaseCondition
// 0x0028 (0x0030 - 0x0008)
struct FTalkPhaseCondition final : public FTableRowBase
{
public:
	class FName                                   ConditionId;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECHARACTER_TYPE                               PlayerCondition;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           FindActorsName;                                    // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          IfSomeoneTalked;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTalkPhaseCondition) == 0x000008, "Wrong alignment on FTalkPhaseCondition");
static_assert(sizeof(FTalkPhaseCondition) == 0x000030, "Wrong size on FTalkPhaseCondition");
static_assert(offsetof(FTalkPhaseCondition, ConditionId) == 0x000008, "Member 'FTalkPhaseCondition::ConditionId' has a wrong offset!");
static_assert(offsetof(FTalkPhaseCondition, PlayerCondition) == 0x000010, "Member 'FTalkPhaseCondition::PlayerCondition' has a wrong offset!");
static_assert(offsetof(FTalkPhaseCondition, FindActorsName) == 0x000018, "Member 'FTalkPhaseCondition::FindActorsName' has a wrong offset!");
static_assert(offsetof(FTalkPhaseCondition, IfSomeoneTalked) == 0x000028, "Member 'FTalkPhaseCondition::IfSomeoneTalked' has a wrong offset!");

// ScriptStruct AT.QuestWishCondition
// 0x0008 (0x0010 - 0x0008)
struct FQuestWishCondition final : public FTableRowBase
{
public:
	int32                                         OrderNo;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuestWishCondition) == 0x000008, "Wrong alignment on FQuestWishCondition");
static_assert(sizeof(FQuestWishCondition) == 0x000010, "Wrong size on FQuestWishCondition");
static_assert(offsetof(FQuestWishCondition, OrderNo) == 0x000008, "Member 'FQuestWishCondition::OrderNo' has a wrong offset!");
static_assert(offsetof(FQuestWishCondition, Count) == 0x00000C, "Member 'FQuestWishCondition::Count' has a wrong offset!");

// ScriptStruct AT.SubQuestRetryCondition
// 0x0040 (0x0048 - 0x0008)
struct FSubQuestRetryCondition final : public FTableRowBase
{
public:
	TArray<struct FSubQuestPeriod>                Period;                                            // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AreaID;                                            // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AreaNameId;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientIconId;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ClearSubQuestId;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         WishDragonBall;                                    // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowInTimemachineMenu;                            // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsQuestClearCounted;                              // 0x0045(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46[0x2];                                       // 0x0046(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSubQuestRetryCondition) == 0x000008, "Wrong alignment on FSubQuestRetryCondition");
static_assert(sizeof(FSubQuestRetryCondition) == 0x000048, "Wrong size on FSubQuestRetryCondition");
static_assert(offsetof(FSubQuestRetryCondition, Period) == 0x000008, "Member 'FSubQuestRetryCondition::Period' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, AreaID) == 0x000018, "Member 'FSubQuestRetryCondition::AreaID' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, AreaNameId) == 0x000020, "Member 'FSubQuestRetryCondition::AreaNameId' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, ClientIconId) == 0x000028, "Member 'FSubQuestRetryCondition::ClientIconId' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, ClearSubQuestId) == 0x000030, "Member 'FSubQuestRetryCondition::ClearSubQuestId' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, WishDragonBall) == 0x000040, "Member 'FSubQuestRetryCondition::WishDragonBall' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, bShowInTimemachineMenu) == 0x000044, "Member 'FSubQuestRetryCondition::bShowInTimemachineMenu' has a wrong offset!");
static_assert(offsetof(FSubQuestRetryCondition, bIsQuestClearCounted) == 0x000045, "Member 'FSubQuestRetryCondition::bIsQuestClearCounted' has a wrong offset!");

// ScriptStruct AT.FishingReactionVoiceParam
// 0x0028 (0x0030 - 0x0008)
struct FFishingReactionVoiceParam final : public FTableRowBase
{
public:
	class FName                                   DemoStartVoiceID;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartVoiceID;                                      // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FailedVoiceID;                                     // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResultCoolVoiceID;                                 // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ResultAmazingVoiceID;                              // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFishingReactionVoiceParam) == 0x000008, "Wrong alignment on FFishingReactionVoiceParam");
static_assert(sizeof(FFishingReactionVoiceParam) == 0x000030, "Wrong size on FFishingReactionVoiceParam");
static_assert(offsetof(FFishingReactionVoiceParam, DemoStartVoiceID) == 0x000008, "Member 'FFishingReactionVoiceParam::DemoStartVoiceID' has a wrong offset!");
static_assert(offsetof(FFishingReactionVoiceParam, StartVoiceID) == 0x000010, "Member 'FFishingReactionVoiceParam::StartVoiceID' has a wrong offset!");
static_assert(offsetof(FFishingReactionVoiceParam, FailedVoiceID) == 0x000018, "Member 'FFishingReactionVoiceParam::FailedVoiceID' has a wrong offset!");
static_assert(offsetof(FFishingReactionVoiceParam, ResultCoolVoiceID) == 0x000020, "Member 'FFishingReactionVoiceParam::ResultCoolVoiceID' has a wrong offset!");
static_assert(offsetof(FFishingReactionVoiceParam, ResultAmazingVoiceID) == 0x000028, "Member 'FFishingReactionVoiceParam::ResultAmazingVoiceID' has a wrong offset!");

// ScriptStruct AT.ReactionVoiceParam
// 0x0010 (0x0018 - 0x0008)
struct FReactionVoiceParam final : public FTableRowBase
{
public:
	class FName                                   StringID;                                          // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VoiceType;                                         // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReactionVoiceParam) == 0x000008, "Wrong alignment on FReactionVoiceParam");
static_assert(sizeof(FReactionVoiceParam) == 0x000018, "Wrong size on FReactionVoiceParam");
static_assert(offsetof(FReactionVoiceParam, StringID) == 0x000008, "Member 'FReactionVoiceParam::StringID' has a wrong offset!");
static_assert(offsetof(FReactionVoiceParam, VoiceType) == 0x000010, "Member 'FReactionVoiceParam::VoiceType' has a wrong offset!");

// ScriptStruct AT.EvaluationNum
// 0x0018 (0x0018 - 0x0000)
struct FEvaluationNum final
{
public:
	float                                         Conditions_S;                                      // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Add_S;                                             // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Conditions_A;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Add_A;                                             // 0x000C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Conditions_B;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Add_B;                                             // 0x0014(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEvaluationNum) == 0x000004, "Wrong alignment on FEvaluationNum");
static_assert(sizeof(FEvaluationNum) == 0x000018, "Wrong size on FEvaluationNum");
static_assert(offsetof(FEvaluationNum, Conditions_S) == 0x000000, "Member 'FEvaluationNum::Conditions_S' has a wrong offset!");
static_assert(offsetof(FEvaluationNum, Add_S) == 0x000004, "Member 'FEvaluationNum::Add_S' has a wrong offset!");
static_assert(offsetof(FEvaluationNum, Conditions_A) == 0x000008, "Member 'FEvaluationNum::Conditions_A' has a wrong offset!");
static_assert(offsetof(FEvaluationNum, Add_A) == 0x00000C, "Member 'FEvaluationNum::Add_A' has a wrong offset!");
static_assert(offsetof(FEvaluationNum, Conditions_B) == 0x000010, "Member 'FEvaluationNum::Conditions_B' has a wrong offset!");
static_assert(offsetof(FEvaluationNum, Add_B) == 0x000014, "Member 'FEvaluationNum::Add_B' has a wrong offset!");

// ScriptStruct AT.RankConditions
// 0x0006 (0x0006 - 0x0000)
struct FRankConditions final
{
public:
	uint8                                         Rank_S;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Add_S;                                             // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Rank_A;                                            // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Add_A;                                             // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Rank_B;                                            // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Add_B;                                             // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRankConditions) == 0x000001, "Wrong alignment on FRankConditions");
static_assert(sizeof(FRankConditions) == 0x000006, "Wrong size on FRankConditions");
static_assert(offsetof(FRankConditions, Rank_S) == 0x000000, "Member 'FRankConditions::Rank_S' has a wrong offset!");
static_assert(offsetof(FRankConditions, Add_S) == 0x000001, "Member 'FRankConditions::Add_S' has a wrong offset!");
static_assert(offsetof(FRankConditions, Rank_A) == 0x000002, "Member 'FRankConditions::Rank_A' has a wrong offset!");
static_assert(offsetof(FRankConditions, Add_A) == 0x000003, "Member 'FRankConditions::Add_A' has a wrong offset!");
static_assert(offsetof(FRankConditions, Rank_B) == 0x000004, "Member 'FRankConditions::Rank_B' has a wrong offset!");
static_assert(offsetof(FRankConditions, Add_B) == 0x000005, "Member 'FRankConditions::Add_B' has a wrong offset!");

// ScriptStruct AT.GBResultBonusDataTable
// 0x0068 (0x0070 - 0x0008)
struct FGBResultBonusDataTable final : public FTableRowBase
{
public:
	struct FEvaluationNum                         ClearTime;                                         // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         SurvivalTime;                                      // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         DamageTaken;                                       // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         DefeatEnemy;                                       // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRankConditions                        Rank;                                              // 0x0068(0x0006)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E[0x2];                                       // 0x006E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGBResultBonusDataTable) == 0x000008, "Wrong alignment on FGBResultBonusDataTable");
static_assert(sizeof(FGBResultBonusDataTable) == 0x000070, "Wrong size on FGBResultBonusDataTable");
static_assert(offsetof(FGBResultBonusDataTable, ClearTime) == 0x000008, "Member 'FGBResultBonusDataTable::ClearTime' has a wrong offset!");
static_assert(offsetof(FGBResultBonusDataTable, SurvivalTime) == 0x000020, "Member 'FGBResultBonusDataTable::SurvivalTime' has a wrong offset!");
static_assert(offsetof(FGBResultBonusDataTable, DamageTaken) == 0x000038, "Member 'FGBResultBonusDataTable::DamageTaken' has a wrong offset!");
static_assert(offsetof(FGBResultBonusDataTable, DefeatEnemy) == 0x000050, "Member 'FGBResultBonusDataTable::DefeatEnemy' has a wrong offset!");
static_assert(offsetof(FGBResultBonusDataTable, Rank) == 0x000068, "Member 'FGBResultBonusDataTable::Rank' has a wrong offset!");

// ScriptStruct AT.ResultBonusDataTable
// 0x00C0 (0x00C8 - 0x0008)
struct FResultBonusDataTable final : public FTableRowBase
{
public:
	struct FEvaluationNum                         NormalBattleClearTime;                             // 0x0008(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         NormalBattleMaxCombo;                              // 0x0020(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         NormalBattleDamageTaken;                           // 0x0038(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         BossBattleClearTime;                               // 0x0050(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         BossBattleMaxCombo;                                // 0x0068(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FEvaluationNum                         BossBattleDamageTaken;                             // 0x0080(0x0018)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRankConditions                        Rank;                                              // 0x0098(0x0006)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E[0x2];                                       // 0x009E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExperienceBonus                       ExperienceBonus;                                   // 0x00A0(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRankConditions                        TotalRank;                                         // 0x00AC(0x0006)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_B2[0x6];                                       // 0x00B2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExperienceReplay                      ExperienceReplay;                                  // 0x00B8(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResultBonusDataTable) == 0x000008, "Wrong alignment on FResultBonusDataTable");
static_assert(sizeof(FResultBonusDataTable) == 0x0000C8, "Wrong size on FResultBonusDataTable");
static_assert(offsetof(FResultBonusDataTable, NormalBattleClearTime) == 0x000008, "Member 'FResultBonusDataTable::NormalBattleClearTime' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, NormalBattleMaxCombo) == 0x000020, "Member 'FResultBonusDataTable::NormalBattleMaxCombo' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, NormalBattleDamageTaken) == 0x000038, "Member 'FResultBonusDataTable::NormalBattleDamageTaken' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, BossBattleClearTime) == 0x000050, "Member 'FResultBonusDataTable::BossBattleClearTime' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, BossBattleMaxCombo) == 0x000068, "Member 'FResultBonusDataTable::BossBattleMaxCombo' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, BossBattleDamageTaken) == 0x000080, "Member 'FResultBonusDataTable::BossBattleDamageTaken' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, Rank) == 0x000098, "Member 'FResultBonusDataTable::Rank' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, ExperienceBonus) == 0x0000A0, "Member 'FResultBonusDataTable::ExperienceBonus' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, TotalRank) == 0x0000AC, "Member 'FResultBonusDataTable::TotalRank' has a wrong offset!");
static_assert(offsetof(FResultBonusDataTable, ExperienceReplay) == 0x0000B8, "Member 'FResultBonusDataTable::ExperienceReplay' has a wrong offset!");

// ScriptStruct AT.RideConstParam
// 0x0008 (0x0010 - 0x0008)
struct FRideConstParam final : public FTableRowBase
{
public:
	float                                         Value;                                             // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRideConstParam) == 0x000008, "Wrong alignment on FRideConstParam");
static_assert(sizeof(FRideConstParam) == 0x000010, "Wrong size on FRideConstParam");
static_assert(offsetof(FRideConstParam, Value) == 0x000008, "Member 'FRideConstParam::Value' has a wrong offset!");

// ScriptStruct AT.RideExclusion
// 0x0028 (0x0030 - 0x0008)
struct FRideExclusion final : public FTableRowBase
{
public:
	ERideType                                     RideType;                                          // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERideAction                                   Action;                                            // 0x0009(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERideExclusionType                            ExclusionType;                                     // 0x000A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x5];                                        // 0x000B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ID;                                                // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Param;                                             // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERideMessageWindow                            Window;                                            // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Message;                                           // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRideExclusion) == 0x000008, "Wrong alignment on FRideExclusion");
static_assert(sizeof(FRideExclusion) == 0x000030, "Wrong size on FRideExclusion");
static_assert(offsetof(FRideExclusion, RideType) == 0x000008, "Member 'FRideExclusion::RideType' has a wrong offset!");
static_assert(offsetof(FRideExclusion, Action) == 0x000009, "Member 'FRideExclusion::Action' has a wrong offset!");
static_assert(offsetof(FRideExclusion, ExclusionType) == 0x00000A, "Member 'FRideExclusion::ExclusionType' has a wrong offset!");
static_assert(offsetof(FRideExclusion, ID) == 0x000010, "Member 'FRideExclusion::ID' has a wrong offset!");
static_assert(offsetof(FRideExclusion, Param) == 0x000018, "Member 'FRideExclusion::Param' has a wrong offset!");
static_assert(offsetof(FRideExclusion, Window) == 0x000020, "Member 'FRideExclusion::Window' has a wrong offset!");
static_assert(offsetof(FRideExclusion, Message) == 0x000028, "Member 'FRideExclusion::Message' has a wrong offset!");

// ScriptStruct AT.ShopInfoSaveData
// 0x0023 (0x0023 - 0x0000)
struct FShopInfoSaveData final
{
public:
	EFoundFieldPointStatus                        FoundFishingArea[0xF];                             // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFoundFieldPointStatus                        FoundHuntingPoint[0xF];                            // 0x000F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuyFishingSpot;                                   // 0x001E(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuyHuntingSpot;                                   // 0x001F(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuyCollectionSpotInfo;                            // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuyMiningSpot;                                    // 0x0021(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBuyCarRaceInfo;                                   // 0x0022(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopInfoSaveData) == 0x000001, "Wrong alignment on FShopInfoSaveData");
static_assert(sizeof(FShopInfoSaveData) == 0x000023, "Wrong size on FShopInfoSaveData");
static_assert(offsetof(FShopInfoSaveData, FoundFishingArea) == 0x000000, "Member 'FShopInfoSaveData::FoundFishingArea' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, FoundHuntingPoint) == 0x00000F, "Member 'FShopInfoSaveData::FoundHuntingPoint' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, bBuyFishingSpot) == 0x00001E, "Member 'FShopInfoSaveData::bBuyFishingSpot' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, bBuyHuntingSpot) == 0x00001F, "Member 'FShopInfoSaveData::bBuyHuntingSpot' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, bBuyCollectionSpotInfo) == 0x000020, "Member 'FShopInfoSaveData::bBuyCollectionSpotInfo' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, bBuyMiningSpot) == 0x000021, "Member 'FShopInfoSaveData::bBuyMiningSpot' has a wrong offset!");
static_assert(offsetof(FShopInfoSaveData, bBuyCarRaceInfo) == 0x000022, "Member 'FShopInfoSaveData::bBuyCarRaceInfo' has a wrong offset!");

// ScriptStruct AT.SkillPaletteDataTable
// 0x0120 (0x0128 - 0x0008)
struct FSkillPaletteDataTable final : public FTableRowBase
{
public:
	class FString                                 Discription;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RRight;                                            // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RUp;                                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RLeft;                                             // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RDown;                                             // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LRight;                                            // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LUp;                                               // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LLeft;                                             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LDown;                                             // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot01;                                            // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot02;                                            // 0x0060(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot03;                                            // 0x0068(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot04;                                            // 0x0070(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot05;                                            // 0x0078(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot06;                                            // 0x0080(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot07;                                            // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot08;                                            // 0x0090(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot09;                                            // 0x0098(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot10;                                            // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot11;                                            // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot12;                                            // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot13;                                            // 0x00B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot14;                                            // 0x00C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot15;                                            // 0x00C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot16;                                            // 0x00D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot17;                                            // 0x00D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot18;                                            // 0x00E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot19;                                            // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Slot20;                                            // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Support[0x2];                                      // 0x00F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Sparking[0x4];                                     // 0x0108(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSkillPaletteDataTable) == 0x000008, "Wrong alignment on FSkillPaletteDataTable");
static_assert(sizeof(FSkillPaletteDataTable) == 0x000128, "Wrong size on FSkillPaletteDataTable");
static_assert(offsetof(FSkillPaletteDataTable, Discription) == 0x000008, "Member 'FSkillPaletteDataTable::Discription' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, RRight) == 0x000018, "Member 'FSkillPaletteDataTable::RRight' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, RUp) == 0x000020, "Member 'FSkillPaletteDataTable::RUp' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, RLeft) == 0x000028, "Member 'FSkillPaletteDataTable::RLeft' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, RDown) == 0x000030, "Member 'FSkillPaletteDataTable::RDown' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, LRight) == 0x000038, "Member 'FSkillPaletteDataTable::LRight' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, LUp) == 0x000040, "Member 'FSkillPaletteDataTable::LUp' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, LLeft) == 0x000048, "Member 'FSkillPaletteDataTable::LLeft' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, LDown) == 0x000050, "Member 'FSkillPaletteDataTable::LDown' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot01) == 0x000058, "Member 'FSkillPaletteDataTable::Slot01' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot02) == 0x000060, "Member 'FSkillPaletteDataTable::Slot02' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot03) == 0x000068, "Member 'FSkillPaletteDataTable::Slot03' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot04) == 0x000070, "Member 'FSkillPaletteDataTable::Slot04' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot05) == 0x000078, "Member 'FSkillPaletteDataTable::Slot05' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot06) == 0x000080, "Member 'FSkillPaletteDataTable::Slot06' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot07) == 0x000088, "Member 'FSkillPaletteDataTable::Slot07' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot08) == 0x000090, "Member 'FSkillPaletteDataTable::Slot08' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot09) == 0x000098, "Member 'FSkillPaletteDataTable::Slot09' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot10) == 0x0000A0, "Member 'FSkillPaletteDataTable::Slot10' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot11) == 0x0000A8, "Member 'FSkillPaletteDataTable::Slot11' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot12) == 0x0000B0, "Member 'FSkillPaletteDataTable::Slot12' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot13) == 0x0000B8, "Member 'FSkillPaletteDataTable::Slot13' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot14) == 0x0000C0, "Member 'FSkillPaletteDataTable::Slot14' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot15) == 0x0000C8, "Member 'FSkillPaletteDataTable::Slot15' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot16) == 0x0000D0, "Member 'FSkillPaletteDataTable::Slot16' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot17) == 0x0000D8, "Member 'FSkillPaletteDataTable::Slot17' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot18) == 0x0000E0, "Member 'FSkillPaletteDataTable::Slot18' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot19) == 0x0000E8, "Member 'FSkillPaletteDataTable::Slot19' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Slot20) == 0x0000F0, "Member 'FSkillPaletteDataTable::Slot20' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Support) == 0x0000F8, "Member 'FSkillPaletteDataTable::Support' has a wrong offset!");
static_assert(offsetof(FSkillPaletteDataTable, Sparking) == 0x000108, "Member 'FSkillPaletteDataTable::Sparking' has a wrong offset!");

// ScriptStruct AT.SpawnerFruitParamTableRow
// 0x0010 (0x0018 - 0x0008)
struct FSpawnerFruitParamTableRow final : public FTableRowBase
{
public:
	int32                                         RespawnTimeMin;                                    // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespawnTimeMax;                                    // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ItemPSCMaxDrawDist;                                // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnerFruitParamTableRow) == 0x000008, "Wrong alignment on FSpawnerFruitParamTableRow");
static_assert(sizeof(FSpawnerFruitParamTableRow) == 0x000018, "Wrong size on FSpawnerFruitParamTableRow");
static_assert(offsetof(FSpawnerFruitParamTableRow, RespawnTimeMin) == 0x000008, "Member 'FSpawnerFruitParamTableRow::RespawnTimeMin' has a wrong offset!");
static_assert(offsetof(FSpawnerFruitParamTableRow, RespawnTimeMax) == 0x00000C, "Member 'FSpawnerFruitParamTableRow::RespawnTimeMax' has a wrong offset!");
static_assert(offsetof(FSpawnerFruitParamTableRow, ItemPSCMaxDrawDist) == 0x000010, "Member 'FSpawnerFruitParamTableRow::ItemPSCMaxDrawDist' has a wrong offset!");

// ScriptStruct AT.SpawnerItemData
// 0x0050 (0x0050 - 0x0000)
struct FSpawnerItemData final
{
public:
	class UParticleSystem*                        EffectIdle;                                        // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectGet;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectGet_000_003_01;                              // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectHit;                                         // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectIdle_Rare;                                   // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectGet_Rare;                                    // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectHit_Rare;                                    // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EffectFruitTreeBlade;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSpawnerItemData) == 0x000008, "Wrong alignment on FSpawnerItemData");
static_assert(sizeof(FSpawnerItemData) == 0x000050, "Wrong size on FSpawnerItemData");
static_assert(offsetof(FSpawnerItemData, EffectIdle) == 0x000000, "Member 'FSpawnerItemData::EffectIdle' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectGet) == 0x000008, "Member 'FSpawnerItemData::EffectGet' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectGet_000_003_01) == 0x000010, "Member 'FSpawnerItemData::EffectGet_000_003_01' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectHit) == 0x000018, "Member 'FSpawnerItemData::EffectHit' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectIdle_Rare) == 0x000020, "Member 'FSpawnerItemData::EffectIdle_Rare' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectGet_Rare) == 0x000028, "Member 'FSpawnerItemData::EffectGet_Rare' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectHit_Rare) == 0x000030, "Member 'FSpawnerItemData::EffectHit_Rare' has a wrong offset!");
static_assert(offsetof(FSpawnerItemData, EffectFruitTreeBlade) == 0x000038, "Member 'FSpawnerItemData::EffectFruitTreeBlade' has a wrong offset!");

// ScriptStruct AT.MineralSpawnItemRateTableRow
// 0x0010 (0x0018 - 0x0008)
struct FMineralSpawnItemRateTableRow final : public FTableRowBase
{
public:
	class FName                                   ItemId;                                            // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMineralSpawnItemRateTableRow) == 0x000008, "Wrong alignment on FMineralSpawnItemRateTableRow");
static_assert(sizeof(FMineralSpawnItemRateTableRow) == 0x000018, "Wrong size on FMineralSpawnItemRateTableRow");
static_assert(offsetof(FMineralSpawnItemRateTableRow, ItemId) == 0x000008, "Member 'FMineralSpawnItemRateTableRow::ItemId' has a wrong offset!");
static_assert(offsetof(FMineralSpawnItemRateTableRow, Rate) == 0x000010, "Member 'FMineralSpawnItemRateTableRow::Rate' has a wrong offset!");

// ScriptStruct AT.MineralSpawnNumLotTableRow
// 0x0008 (0x0010 - 0x0008)
struct FMineralSpawnNumLotTableRow final : public FTableRowBase
{
public:
	int32                                         Num;                                               // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMineralSpawnNumLotTableRow) == 0x000008, "Wrong alignment on FMineralSpawnNumLotTableRow");
static_assert(sizeof(FMineralSpawnNumLotTableRow) == 0x000010, "Wrong size on FMineralSpawnNumLotTableRow");
static_assert(offsetof(FMineralSpawnNumLotTableRow, Num) == 0x000008, "Member 'FMineralSpawnNumLotTableRow::Num' has a wrong offset!");
static_assert(offsetof(FMineralSpawnNumLotTableRow, Rate) == 0x00000C, "Member 'FMineralSpawnNumLotTableRow::Rate' has a wrong offset!");

// ScriptStruct AT.SubQuestCompleteMontageTableRow
// 0x0010 (0x0018 - 0x0008)
struct FSubQuestCompleteMontageTableRow final : public FTableRowBase
{
public:
	class UAnimMontage*                           CompleteMontage;                                   // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           FacialMontage;                                     // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSubQuestCompleteMontageTableRow) == 0x000008, "Wrong alignment on FSubQuestCompleteMontageTableRow");
static_assert(sizeof(FSubQuestCompleteMontageTableRow) == 0x000018, "Wrong size on FSubQuestCompleteMontageTableRow");
static_assert(offsetof(FSubQuestCompleteMontageTableRow, CompleteMontage) == 0x000008, "Member 'FSubQuestCompleteMontageTableRow::CompleteMontage' has a wrong offset!");
static_assert(offsetof(FSubQuestCompleteMontageTableRow, FacialMontage) == 0x000010, "Member 'FSubQuestCompleteMontageTableRow::FacialMontage' has a wrong offset!");

// ScriptStruct AT.HitProceduralComponent
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FHitProceduralComponent final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FHitProceduralComponent) == 0x000008, "Wrong alignment on FHitProceduralComponent");
static_assert(sizeof(FHitProceduralComponent) == 0x000018, "Wrong size on FHitProceduralComponent");

// ScriptStruct AT.TerrainDecoratePhotonInfo
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FTerrainDecoratePhotonInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTerrainDecoratePhotonInfo) == 0x000008, "Wrong alignment on FTerrainDecoratePhotonInfo");
static_assert(sizeof(FTerrainDecoratePhotonInfo) == 0x000008, "Wrong size on FTerrainDecoratePhotonInfo");

// ScriptStruct AT.GeneralTerrainDecorateResourcesRow
// 0x0180 (0x0180 - 0x0000)
struct FGeneralTerrainDecorateResourcesRow final
{
public:
	TMap<EATSurfaceType, struct FTerrainDecorateResourcesLoadManualy> DecorateResources;                                 // 0x0000(0x0050)(Edit, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FTerrainDecorateParameters             DecorateParameters;                                // 0x0050(0x0130)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGeneralTerrainDecorateResourcesRow) == 0x000008, "Wrong alignment on FGeneralTerrainDecorateResourcesRow");
static_assert(sizeof(FGeneralTerrainDecorateResourcesRow) == 0x000180, "Wrong size on FGeneralTerrainDecorateResourcesRow");
static_assert(offsetof(FGeneralTerrainDecorateResourcesRow, DecorateResources) == 0x000000, "Member 'FGeneralTerrainDecorateResourcesRow::DecorateResources' has a wrong offset!");
static_assert(offsetof(FGeneralTerrainDecorateResourcesRow, DecorateParameters) == 0x000050, "Member 'FGeneralTerrainDecorateResourcesRow::DecorateParameters' has a wrong offset!");

// ScriptStruct AT.TerrainDecorateEffectColorMultiByAreaTebleRow
// 0x0010 (0x0010 - 0x0000)
struct FTerrainDecorateEffectColorMultiByAreaTebleRow final
{
public:
	TArray<struct FTerrainDecorateEffectColorMultiByArea> MultiplyColorData;                                 // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTerrainDecorateEffectColorMultiByAreaTebleRow) == 0x000008, "Wrong alignment on FTerrainDecorateEffectColorMultiByAreaTebleRow");
static_assert(sizeof(FTerrainDecorateEffectColorMultiByAreaTebleRow) == 0x000010, "Wrong size on FTerrainDecorateEffectColorMultiByAreaTebleRow");
static_assert(offsetof(FTerrainDecorateEffectColorMultiByAreaTebleRow, MultiplyColorData) == 0x000000, "Member 'FTerrainDecorateEffectColorMultiByAreaTebleRow::MultiplyColorData' has a wrong offset!");

// ScriptStruct AT.AreaSurfacesData
// 0x0010 (0x0010 - 0x0000)
struct FAreaSurfacesData final
{
public:
	TArray<EATSurfaceType>                        SurfaceTypes;                                      // 0x0000(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAreaSurfacesData) == 0x000008, "Wrong alignment on FAreaSurfacesData");
static_assert(sizeof(FAreaSurfacesData) == 0x000010, "Wrong size on FAreaSurfacesData");
static_assert(offsetof(FAreaSurfacesData, SurfaceTypes) == 0x000000, "Member 'FAreaSurfacesData::SurfaceTypes' has a wrong offset!");

// ScriptStruct AT.TPSSkillViewCancelDataTable
// 0x0010 (0x0018 - 0x0008)
struct FTPSSkillViewCancelDataTable final : public FTableRowBase
{
public:
	class FString                                 Discription;                                       // 0x0008(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTPSSkillViewCancelDataTable) == 0x000008, "Wrong alignment on FTPSSkillViewCancelDataTable");
static_assert(sizeof(FTPSSkillViewCancelDataTable) == 0x000018, "Wrong size on FTPSSkillViewCancelDataTable");
static_assert(offsetof(FTPSSkillViewCancelDataTable, Discription) == 0x000008, "Member 'FTPSSkillViewCancelDataTable::Discription' has a wrong offset!");

// ScriptStruct AT.TreasureAccessPointSaveTable
// 0x0028 (0x0030 - 0x0008)
struct FTreasureAccessPointSaveTable final : public FTableRowBase
{
public:
	int32                                         SaveIndex;                                         // 0x0008(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAreaIndex                                    AreaIndex;                                         // 0x000C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartValidQuestId;                                 // 0x0010(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartValidPhaseNo;                                 // 0x0018(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   EndValidQuestId;                                   // 0x0020(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndValidPhaseNo;                                   // 0x0028(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTreasureAccessPointSaveTable) == 0x000008, "Wrong alignment on FTreasureAccessPointSaveTable");
static_assert(sizeof(FTreasureAccessPointSaveTable) == 0x000030, "Wrong size on FTreasureAccessPointSaveTable");
static_assert(offsetof(FTreasureAccessPointSaveTable, SaveIndex) == 0x000008, "Member 'FTreasureAccessPointSaveTable::SaveIndex' has a wrong offset!");
static_assert(offsetof(FTreasureAccessPointSaveTable, AreaIndex) == 0x00000C, "Member 'FTreasureAccessPointSaveTable::AreaIndex' has a wrong offset!");
static_assert(offsetof(FTreasureAccessPointSaveTable, StartValidQuestId) == 0x000010, "Member 'FTreasureAccessPointSaveTable::StartValidQuestId' has a wrong offset!");
static_assert(offsetof(FTreasureAccessPointSaveTable, StartValidPhaseNo) == 0x000018, "Member 'FTreasureAccessPointSaveTable::StartValidPhaseNo' has a wrong offset!");
static_assert(offsetof(FTreasureAccessPointSaveTable, EndValidQuestId) == 0x000020, "Member 'FTreasureAccessPointSaveTable::EndValidQuestId' has a wrong offset!");
static_assert(offsetof(FTreasureAccessPointSaveTable, EndValidPhaseNo) == 0x000028, "Member 'FTreasureAccessPointSaveTable::EndValidPhaseNo' has a wrong offset!");

// ScriptStruct AT.DMedalTakenData
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FDMedalTakenData final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FDMedalTakenData) == 0x000004, "Wrong alignment on FDMedalTakenData");
static_assert(sizeof(FDMedalTakenData) == 0x000008, "Wrong size on FDMedalTakenData");

// ScriptStruct AT.ATRenderingPage
// 0x0018 (0x0018 - 0x0000)
struct FATRenderingPage final
{
public:
	ERenderingPageState                           State;                                             // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AssetId;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAT_UICompZPageBase*                    AssetPtr;                                          // 0x0010(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FATRenderingPage) == 0x000008, "Wrong alignment on FATRenderingPage");
static_assert(sizeof(FATRenderingPage) == 0x000018, "Wrong size on FATRenderingPage");
static_assert(offsetof(FATRenderingPage, State) == 0x000000, "Member 'FATRenderingPage::State' has a wrong offset!");
static_assert(offsetof(FATRenderingPage, AssetId) == 0x000008, "Member 'FATRenderingPage::AssetId' has a wrong offset!");
static_assert(offsetof(FATRenderingPage, AssetPtr) == 0x000010, "Member 'FATRenderingPage::AssetPtr' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamDiaLine
// 0x0028 (0x0030 - 0x0008)
struct FZCompworksParamDiaLine final : public FTableRowBase
{
public:
	class FName                                   DiagramId1;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DiagramId2;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WedgetNameLine;                                    // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WedgetNameRelevance;                               // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RelevanceId;                                       // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksParamDiaLine) == 0x000008, "Wrong alignment on FZCompworksParamDiaLine");
static_assert(sizeof(FZCompworksParamDiaLine) == 0x000030, "Wrong size on FZCompworksParamDiaLine");
static_assert(offsetof(FZCompworksParamDiaLine, DiagramId1) == 0x000008, "Member 'FZCompworksParamDiaLine::DiagramId1' has a wrong offset!");
static_assert(offsetof(FZCompworksParamDiaLine, DiagramId2) == 0x000010, "Member 'FZCompworksParamDiaLine::DiagramId2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamDiaLine, WedgetNameLine) == 0x000018, "Member 'FZCompworksParamDiaLine::WedgetNameLine' has a wrong offset!");
static_assert(offsetof(FZCompworksParamDiaLine, WedgetNameRelevance) == 0x000020, "Member 'FZCompworksParamDiaLine::WedgetNameRelevance' has a wrong offset!");
static_assert(offsetof(FZCompworksParamDiaLine, RelevanceId) == 0x000028, "Member 'FZCompworksParamDiaLine::RelevanceId' has a wrong offset!");

// ScriptStruct AT.WMapProgress
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FWMapProgress final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWMapProgress) == 0x000004, "Wrong alignment on FWMapProgress");
static_assert(sizeof(FWMapProgress) == 0x00000C, "Wrong size on FWMapProgress");

// ScriptStruct AT.ZCompworksReward
// 0x0018 (0x0020 - 0x0008)
struct FZCompworksReward final : public FTableRowBase
{
public:
	EZCompworksMajorId                            MajorId;                                           // 0x0008(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x1];                                        // 0x0009(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	uint16                                        Count;                                             // 0x000A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemId;                                            // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ItemCount;                                         // 0x0018(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksReward) == 0x000008, "Wrong alignment on FZCompworksReward");
static_assert(sizeof(FZCompworksReward) == 0x000020, "Wrong size on FZCompworksReward");
static_assert(offsetof(FZCompworksReward, MajorId) == 0x000008, "Member 'FZCompworksReward::MajorId' has a wrong offset!");
static_assert(offsetof(FZCompworksReward, Count) == 0x00000A, "Member 'FZCompworksReward::Count' has a wrong offset!");
static_assert(offsetof(FZCompworksReward, ItemId) == 0x000010, "Member 'FZCompworksReward::ItemId' has a wrong offset!");
static_assert(offsetof(FZCompworksReward, ItemCount) == 0x000018, "Member 'FZCompworksReward::ItemCount' has a wrong offset!");

// ScriptStruct AT.ZCompworksAreaNavRate
// 0x0020 (0x0028 - 0x0008)
struct FZCompworksAreaNavRate final : public FTableRowBase
{
public:
	uint16                                        MAINQUEST;                                         // 0x0008(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        SUBQUEST;                                          // 0x000A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        MISSION;                                           // 0x000C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        NPCTALK;                                           // 0x000E(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Favorability;                                      // 0x0010(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        TOWN;                                              // 0x0012(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ANIMAL;                                            // 0x0014(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        FISH;                                              // 0x0016(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        MiniGame;                                          // 0x0018(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Victory;                                           // 0x001A(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Enemy;                                             // 0x001C(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Skill;                                             // 0x001E(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        Item;                                              // 0x0020(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        BGM;                                               // 0x0022(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint16                                        ZCOMPWORKS;                                        // 0x0024(0x0002)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksAreaNavRate) == 0x000008, "Wrong alignment on FZCompworksAreaNavRate");
static_assert(sizeof(FZCompworksAreaNavRate) == 0x000028, "Wrong size on FZCompworksAreaNavRate");
static_assert(offsetof(FZCompworksAreaNavRate, MAINQUEST) == 0x000008, "Member 'FZCompworksAreaNavRate::MAINQUEST' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, SUBQUEST) == 0x00000A, "Member 'FZCompworksAreaNavRate::SUBQUEST' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, MISSION) == 0x00000C, "Member 'FZCompworksAreaNavRate::MISSION' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, NPCTALK) == 0x00000E, "Member 'FZCompworksAreaNavRate::NPCTALK' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, Favorability) == 0x000010, "Member 'FZCompworksAreaNavRate::Favorability' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, TOWN) == 0x000012, "Member 'FZCompworksAreaNavRate::TOWN' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, ANIMAL) == 0x000014, "Member 'FZCompworksAreaNavRate::ANIMAL' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, FISH) == 0x000016, "Member 'FZCompworksAreaNavRate::FISH' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, MiniGame) == 0x000018, "Member 'FZCompworksAreaNavRate::MiniGame' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, Victory) == 0x00001A, "Member 'FZCompworksAreaNavRate::Victory' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, Enemy) == 0x00001C, "Member 'FZCompworksAreaNavRate::Enemy' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, Skill) == 0x00001E, "Member 'FZCompworksAreaNavRate::Skill' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, Item) == 0x000020, "Member 'FZCompworksAreaNavRate::Item' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, BGM) == 0x000022, "Member 'FZCompworksAreaNavRate::BGM' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNavRate, ZCOMPWORKS) == 0x000024, "Member 'FZCompworksAreaNavRate::ZCOMPWORKS' has a wrong offset!");

// ScriptStruct AT.ZCompworksAreaNav
// 0x0020 (0x0028 - 0x0008)
struct FZCompworksAreaNav final : public FTableRowBase
{
public:
	class FName                                   ZCompworksId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint64                                        AreaFlag;                                          // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SublevelId;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Exclude;                                           // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksAreaNav) == 0x000008, "Wrong alignment on FZCompworksAreaNav");
static_assert(sizeof(FZCompworksAreaNav) == 0x000028, "Wrong size on FZCompworksAreaNav");
static_assert(offsetof(FZCompworksAreaNav, ZCompworksId) == 0x000008, "Member 'FZCompworksAreaNav::ZCompworksId' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNav, AreaFlag) == 0x000010, "Member 'FZCompworksAreaNav::AreaFlag' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNav, SublevelId) == 0x000018, "Member 'FZCompworksAreaNav::SublevelId' has a wrong offset!");
static_assert(offsetof(FZCompworksAreaNav, Exclude) == 0x000020, "Member 'FZCompworksAreaNav::Exclude' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataFieldMemoryText
// 0x0058 (0x0060 - 0x0008)
struct FZCompworksUIDataFieldMemoryText final : public FTableRowBase
{
public:
	class FName                                   MemoryTitleMsdId;                                  // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId1;                                  // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId2;                                  // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId3;                                  // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId4;                                  // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId5;                                  // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId6;                                  // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId7;                                  // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId8;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId9;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MemoryTextMsgId10;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataFieldMemoryText) == 0x000008, "Wrong alignment on FZCompworksUIDataFieldMemoryText");
static_assert(sizeof(FZCompworksUIDataFieldMemoryText) == 0x000060, "Wrong size on FZCompworksUIDataFieldMemoryText");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTitleMsdId) == 0x000008, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTitleMsdId' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId1) == 0x000010, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId1' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId2) == 0x000018, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId2' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId3) == 0x000020, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId3' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId4) == 0x000028, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId4' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId5) == 0x000030, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId5' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId6) == 0x000038, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId6' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId7) == 0x000040, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId7' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId8) == 0x000048, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId8' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId9) == 0x000050, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId9' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataFieldMemoryText, MemoryTextMsgId10) == 0x000058, "Member 'FZCompworksUIDataFieldMemoryText::MemoryTextMsgId10' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataVoice
// 0x0028 (0x0030 - 0x0008)
struct FZCompworksUIDataVoice final : public FTableRowBase
{
public:
	class FName                                   MessageId1;                                        // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageId2;                                        // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageId3;                                        // 0x0018(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageId4;                                        // 0x0020(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageId5;                                        // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksUIDataVoice) == 0x000008, "Wrong alignment on FZCompworksUIDataVoice");
static_assert(sizeof(FZCompworksUIDataVoice) == 0x000030, "Wrong size on FZCompworksUIDataVoice");
static_assert(offsetof(FZCompworksUIDataVoice, MessageId1) == 0x000008, "Member 'FZCompworksUIDataVoice::MessageId1' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataVoice, MessageId2) == 0x000010, "Member 'FZCompworksUIDataVoice::MessageId2' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataVoice, MessageId3) == 0x000018, "Member 'FZCompworksUIDataVoice::MessageId3' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataVoice, MessageId4) == 0x000020, "Member 'FZCompworksUIDataVoice::MessageId4' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataVoice, MessageId5) == 0x000028, "Member 'FZCompworksUIDataVoice::MessageId5' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataModelOptional
// 0x0030 (0x0038 - 0x0008)
struct FZCompworksUIDataModelOptional final : public FTableRowBase
{
public:
	class FName                                   ZCompworksId;                                      // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ModelPath;                                         // 0x0010(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetX;                                           // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetY;                                           // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffsetZ;                                           // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksUIDataModelOptional) == 0x000008, "Wrong alignment on FZCompworksUIDataModelOptional");
static_assert(sizeof(FZCompworksUIDataModelOptional) == 0x000038, "Wrong size on FZCompworksUIDataModelOptional");
static_assert(offsetof(FZCompworksUIDataModelOptional, ZCompworksId) == 0x000008, "Member 'FZCompworksUIDataModelOptional::ZCompworksId' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, ModelPath) == 0x000010, "Member 'FZCompworksUIDataModelOptional::ModelPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, OffsetX) == 0x000018, "Member 'FZCompworksUIDataModelOptional::OffsetX' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, OffsetY) == 0x00001C, "Member 'FZCompworksUIDataModelOptional::OffsetY' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, OffsetZ) == 0x000020, "Member 'FZCompworksUIDataModelOptional::OffsetZ' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, Roll) == 0x000024, "Member 'FZCompworksUIDataModelOptional::Roll' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, Pitch) == 0x000028, "Member 'FZCompworksUIDataModelOptional::Pitch' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, Yaw) == 0x00002C, "Member 'FZCompworksUIDataModelOptional::Yaw' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelOptional, Scale) == 0x000030, "Member 'FZCompworksUIDataModelOptional::Scale' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataModelNormal
// 0x0028 (0x0050 - 0x0028)
struct FZCompworksUIDataModelNormal final : public FZCompworksUIDataModel
{
public:
	class FName                                   ModelPath;                                         // 0x0028(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimationPath;                                     // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AnimBPPath;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MontagePath;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateOffset;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksUIDataModelNormal) == 0x000008, "Wrong alignment on FZCompworksUIDataModelNormal");
static_assert(sizeof(FZCompworksUIDataModelNormal) == 0x000050, "Wrong size on FZCompworksUIDataModelNormal");
static_assert(offsetof(FZCompworksUIDataModelNormal, ModelPath) == 0x000028, "Member 'FZCompworksUIDataModelNormal::ModelPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelNormal, AnimationPath) == 0x000030, "Member 'FZCompworksUIDataModelNormal::AnimationPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelNormal, AnimBPPath) == 0x000038, "Member 'FZCompworksUIDataModelNormal::AnimBPPath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelNormal, MontagePath) == 0x000040, "Member 'FZCompworksUIDataModelNormal::MontagePath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataModelNormal, RotateOffset) == 0x000048, "Member 'FZCompworksUIDataModelNormal::RotateOffset' has a wrong offset!");

// ScriptStruct AT.ZCompworksUIDataPicture
// 0x0010 (0x0018 - 0x0008)
struct FZCompworksUIDataPicture final : public FTableRowBase
{
public:
	class FName                                   PicturePath;                                       // 0x0008(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Appendix;                                          // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksUIDataPicture) == 0x000008, "Wrong alignment on FZCompworksUIDataPicture");
static_assert(sizeof(FZCompworksUIDataPicture) == 0x000018, "Wrong size on FZCompworksUIDataPicture");
static_assert(offsetof(FZCompworksUIDataPicture, PicturePath) == 0x000008, "Member 'FZCompworksUIDataPicture::PicturePath' has a wrong offset!");
static_assert(offsetof(FZCompworksUIDataPicture, Appendix) == 0x000010, "Member 'FZCompworksUIDataPicture::Appendix' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamText
// 0x0028 (0x0050 - 0x0028)
struct FZCompworksParamText final : public FZCompworksParamDlc
{
public:
	EZCompworksOpenType                           OpenType2;                                         // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OpenId2;                                           // 0x0030(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenCount2;                                        // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddCondition2;                                     // 0x003C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideOpenId2;                                      // 0x003D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAddCondition2;                                // 0x003E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZCompworksOpenType                           OpenType3;                                         // 0x003F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OpenId3;                                           // 0x0040(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OpenCount3;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AddCondition3;                                     // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHideOpenId3;                                      // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAddCondition3;                                // 0x004E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZCompworksUIDataType                         UIDataType;                                        // 0x004F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCompworksParamText) == 0x000008, "Wrong alignment on FZCompworksParamText");
static_assert(sizeof(FZCompworksParamText) == 0x000050, "Wrong size on FZCompworksParamText");
static_assert(offsetof(FZCompworksParamText, OpenType2) == 0x000028, "Member 'FZCompworksParamText::OpenType2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, OpenId2) == 0x000030, "Member 'FZCompworksParamText::OpenId2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, OpenCount2) == 0x000038, "Member 'FZCompworksParamText::OpenCount2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, AddCondition2) == 0x00003C, "Member 'FZCompworksParamText::AddCondition2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, bHideOpenId2) == 0x00003D, "Member 'FZCompworksParamText::bHideOpenId2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, bShowAddCondition2) == 0x00003E, "Member 'FZCompworksParamText::bShowAddCondition2' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, OpenType3) == 0x00003F, "Member 'FZCompworksParamText::OpenType3' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, OpenId3) == 0x000040, "Member 'FZCompworksParamText::OpenId3' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, OpenCount3) == 0x000048, "Member 'FZCompworksParamText::OpenCount3' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, AddCondition3) == 0x00004C, "Member 'FZCompworksParamText::AddCondition3' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, bHideOpenId3) == 0x00004D, "Member 'FZCompworksParamText::bHideOpenId3' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, bShowAddCondition3) == 0x00004E, "Member 'FZCompworksParamText::bShowAddCondition3' has a wrong offset!");
static_assert(offsetof(FZCompworksParamText, UIDataType) == 0x00004F, "Member 'FZCompworksParamText::UIDataType' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamBGM
// 0x0010 (0x0038 - 0x0028)
struct FZCompworksParamBGM final : public FZCompworksParamDlc
{
public:
	int32                                         bgmID;                                             // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Appendix;                                          // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRidePlay;                                         // 0x0030(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksParamBGM) == 0x000008, "Wrong alignment on FZCompworksParamBGM");
static_assert(sizeof(FZCompworksParamBGM) == 0x000038, "Wrong size on FZCompworksParamBGM");
static_assert(offsetof(FZCompworksParamBGM, bgmID) == 0x000028, "Member 'FZCompworksParamBGM::bgmID' has a wrong offset!");
static_assert(offsetof(FZCompworksParamBGM, Appendix) == 0x00002C, "Member 'FZCompworksParamBGM::Appendix' has a wrong offset!");
static_assert(offsetof(FZCompworksParamBGM, bRidePlay) == 0x000030, "Member 'FZCompworksParamBGM::bRidePlay' has a wrong offset!");

// ScriptStruct AT.ZCompworksParamDemo
// 0x0008 (0x0028 - 0x0020)
struct FZCompworksParamDemo final : public FZCompworksParamBase
{
public:
	EZCompworksUIDataType                         UIDataType;                                        // 0x0020(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FZCompworksParamDemo) == 0x000008, "Wrong alignment on FZCompworksParamDemo");
static_assert(sizeof(FZCompworksParamDemo) == 0x000028, "Wrong size on FZCompworksParamDemo");
static_assert(offsetof(FZCompworksParamDemo, UIDataType) == 0x000020, "Member 'FZCompworksParamDemo::UIDataType' has a wrong offset!");

// ScriptStruct AT.ZCW_MeshMaterial
// 0x0018 (0x0018 - 0x0000)
struct FZCW_MeshMaterial final
{
public:
	class USkeletalMeshComponent*                 Mesh;                                              // 0x0000(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MaterialLeft;                                      // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MaterialRight;                                     // 0x0010(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZCW_MeshMaterial) == 0x000008, "Wrong alignment on FZCW_MeshMaterial");
static_assert(sizeof(FZCW_MeshMaterial) == 0x000018, "Wrong size on FZCW_MeshMaterial");
static_assert(offsetof(FZCW_MeshMaterial, Mesh) == 0x000000, "Member 'FZCW_MeshMaterial::Mesh' has a wrong offset!");
static_assert(offsetof(FZCW_MeshMaterial, MaterialLeft) == 0x000008, "Member 'FZCW_MeshMaterial::MaterialLeft' has a wrong offset!");
static_assert(offsetof(FZCW_MeshMaterial, MaterialRight) == 0x000010, "Member 'FZCW_MeshMaterial::MaterialRight' has a wrong offset!");

// ScriptStruct AT.ZOrbInitializeParam
// 0x002C (0x002C - 0x0000)
struct FZOrbInitializeParam final
{
public:
	EZOrbType                                     ZOrbEffectType;                                    // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EZOrbPlaceType                                ZorbPlaceType;                                     // 0x0001(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                SplineOffset;                                      // 0x0004(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaceStartOffset;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlaceNum;                                          // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlaceInterval;                                     // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CirclePlaceNum;                                    // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CircleRadius;                                      // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SortPriority;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveDataIndex;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZOrbInitializeParam) == 0x000004, "Wrong alignment on FZOrbInitializeParam");
static_assert(sizeof(FZOrbInitializeParam) == 0x00002C, "Wrong size on FZOrbInitializeParam");
static_assert(offsetof(FZOrbInitializeParam, ZOrbEffectType) == 0x000000, "Member 'FZOrbInitializeParam::ZOrbEffectType' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, ZorbPlaceType) == 0x000001, "Member 'FZOrbInitializeParam::ZorbPlaceType' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, SplineOffset) == 0x000004, "Member 'FZOrbInitializeParam::SplineOffset' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, PlaceStartOffset) == 0x000010, "Member 'FZOrbInitializeParam::PlaceStartOffset' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, PlaceNum) == 0x000014, "Member 'FZOrbInitializeParam::PlaceNum' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, PlaceInterval) == 0x000018, "Member 'FZOrbInitializeParam::PlaceInterval' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, CirclePlaceNum) == 0x00001C, "Member 'FZOrbInitializeParam::CirclePlaceNum' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, CircleRadius) == 0x000020, "Member 'FZOrbInitializeParam::CircleRadius' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, SortPriority) == 0x000024, "Member 'FZOrbInitializeParam::SortPriority' has a wrong offset!");
static_assert(offsetof(FZOrbInitializeParam, SaveDataIndex) == 0x000028, "Member 'FZOrbInitializeParam::SaveDataIndex' has a wrong offset!");

// ScriptStruct AT.ZOrbSettingParam
// 0x0088 (0x0090 - 0x0008)
struct FZOrbSettingParam final : public FTableRowBase
{
public:
	float                                         AutoGetAddRadiusLanding;                           // 0x0008(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoGetAddRadiusAerial;                            // 0x000C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOrbAutoGetAddRadiusLanding;                    // 0x0010(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeOrbAutoGetAddRadiusAerial;                     // 0x0014(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDrawDist;                                       // 0x0018(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LODEffectMeshDist;                                 // 0x001C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecRed;                                 // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecBlue;                                // 0x0024(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecSizeM;                               // 0x0028(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecSizeL;                               // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecRainbow;                             // 0x0030(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecWhite;                               // 0x0034(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RespwanTimeSecPureWhite;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleYellow;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleRed;                                  // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleBlue;                                 // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleRed_S;                                // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleRed_M;                                // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleRed_L;                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleBlue_S;                               // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleBlue_M;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleBlue_L;                               // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleGreen_S;                              // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleGreen_M;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleGreen_L;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleRainbow;                              // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScaleWhite;                                // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshBaseScalePureWhite;                            // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GetNum_S;                                          // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GetNum_M;                                          // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GetNum_L;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRasius_S;                                 // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRasius_M;                                 // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CollisionRasius_L;                                 // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FZOrbSettingParam) == 0x000008, "Wrong alignment on FZOrbSettingParam");
static_assert(sizeof(FZOrbSettingParam) == 0x000090, "Wrong size on FZOrbSettingParam");
static_assert(offsetof(FZOrbSettingParam, AutoGetAddRadiusLanding) == 0x000008, "Member 'FZOrbSettingParam::AutoGetAddRadiusLanding' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, AutoGetAddRadiusAerial) == 0x00000C, "Member 'FZOrbSettingParam::AutoGetAddRadiusAerial' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, TimeOrbAutoGetAddRadiusLanding) == 0x000010, "Member 'FZOrbSettingParam::TimeOrbAutoGetAddRadiusLanding' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, TimeOrbAutoGetAddRadiusAerial) == 0x000014, "Member 'FZOrbSettingParam::TimeOrbAutoGetAddRadiusAerial' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MaxDrawDist) == 0x000018, "Member 'FZOrbSettingParam::MaxDrawDist' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, LODEffectMeshDist) == 0x00001C, "Member 'FZOrbSettingParam::LODEffectMeshDist' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecRed) == 0x000020, "Member 'FZOrbSettingParam::RespwanTimeSecRed' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecBlue) == 0x000024, "Member 'FZOrbSettingParam::RespwanTimeSecBlue' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecSizeM) == 0x000028, "Member 'FZOrbSettingParam::RespwanTimeSecSizeM' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecSizeL) == 0x00002C, "Member 'FZOrbSettingParam::RespwanTimeSecSizeL' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecRainbow) == 0x000030, "Member 'FZOrbSettingParam::RespwanTimeSecRainbow' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecWhite) == 0x000034, "Member 'FZOrbSettingParam::RespwanTimeSecWhite' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, RespwanTimeSecPureWhite) == 0x000038, "Member 'FZOrbSettingParam::RespwanTimeSecPureWhite' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleYellow) == 0x00003C, "Member 'FZOrbSettingParam::MeshBaseScaleYellow' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleRed) == 0x000040, "Member 'FZOrbSettingParam::MeshBaseScaleRed' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleBlue) == 0x000044, "Member 'FZOrbSettingParam::MeshBaseScaleBlue' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleRed_S) == 0x000048, "Member 'FZOrbSettingParam::MeshBaseScaleRed_S' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleRed_M) == 0x00004C, "Member 'FZOrbSettingParam::MeshBaseScaleRed_M' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleRed_L) == 0x000050, "Member 'FZOrbSettingParam::MeshBaseScaleRed_L' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleBlue_S) == 0x000054, "Member 'FZOrbSettingParam::MeshBaseScaleBlue_S' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleBlue_M) == 0x000058, "Member 'FZOrbSettingParam::MeshBaseScaleBlue_M' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleBlue_L) == 0x00005C, "Member 'FZOrbSettingParam::MeshBaseScaleBlue_L' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleGreen_S) == 0x000060, "Member 'FZOrbSettingParam::MeshBaseScaleGreen_S' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleGreen_M) == 0x000064, "Member 'FZOrbSettingParam::MeshBaseScaleGreen_M' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleGreen_L) == 0x000068, "Member 'FZOrbSettingParam::MeshBaseScaleGreen_L' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleRainbow) == 0x00006C, "Member 'FZOrbSettingParam::MeshBaseScaleRainbow' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScaleWhite) == 0x000070, "Member 'FZOrbSettingParam::MeshBaseScaleWhite' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, MeshBaseScalePureWhite) == 0x000074, "Member 'FZOrbSettingParam::MeshBaseScalePureWhite' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, GetNum_S) == 0x000078, "Member 'FZOrbSettingParam::GetNum_S' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, GetNum_M) == 0x00007C, "Member 'FZOrbSettingParam::GetNum_M' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, GetNum_L) == 0x000080, "Member 'FZOrbSettingParam::GetNum_L' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, CollisionRasius_S) == 0x000084, "Member 'FZOrbSettingParam::CollisionRasius_S' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, CollisionRasius_M) == 0x000088, "Member 'FZOrbSettingParam::CollisionRasius_M' has a wrong offset!");
static_assert(offsetof(FZOrbSettingParam, CollisionRasius_L) == 0x00008C, "Member 'FZOrbSettingParam::CollisionRasius_L' has a wrong offset!");

// ScriptStruct AT.SplineZOrbObject
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FSplineZOrbObject final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSplineZOrbObject) == 0x000008, "Wrong alignment on FSplineZOrbObject");
static_assert(sizeof(FSplineZOrbObject) == 0x000018, "Wrong size on FSplineZOrbObject");

}

